[![W3C](https://www.w3.org/StyleSheets/TR/2021/logos/W3C)](https://www.w3.org/)

WebAssembly Core Specification
==============================

[Editor’s Draft](https://www.w3.org/standards/types/#ED), 21 January 2026

More details about this document

This version:

[https://webassembly.github.io/spec/core/bikeshed/](https://webassembly.github.io/spec/core/bikeshed/)

Latest published version:

[https://www.w3.org/TR/wasm-core-2/](https://www.w3.org/TR/wasm-core-2/)

Implementation Report:

[https://webassembly.org/features/](https://webassembly.org/features/)

Feedback:

[GitHub](https://github.com/WebAssembly/spec/issues)

Editor:

Andreas Rossberg

Issue Tracking:

[GitHub Issues](https://github.com/WebAssembly/spec/labels/wasm-core-2)

[Copyright](https://www.w3.org/policies/#copyright) © 2026 [World Wide Web Consortium](https://www.w3.org/). W3C® [liability](https://www.w3.org/policies/#Legal_Disclaimer), [trademark](https://www.w3.org/policies/#W3C_Trademarks) and [permissive document license](https://www.w3.org/copyright/software-license/ "W3C Software and Document License") rules apply.

* * *

Abstract
--------

This document describes release 3.0 of the core WebAssembly standard, a safe, portable, low-level code format designed for efficient execution and compact representation.

This is part of a collection of related documents: the [Core WebAssembly Specification](https://www.w3.org/TR/wasm-core/), the [WebAssembly JS Interface](https://www.w3.org/TR/wasm-js-api/), and the [WebAssembly Web API](https://www.w3.org/TR/wasm-web-api/).

Status of this document
-----------------------

_This section describes the status of this document at the time of its publication. A list of current W3C publications and the latest revision of this technical report can be found in the [W3C technical reports index.](https://www.w3.org/TR/)_

This is a public copy of the editors’ draft. It is provided for discussion only and may change at any moment. Its publication here does not imply endorsement of its contents by W3C. Don’t cite this document other than as work in progress.

[GitHub Issues](https://github.com/WebAssembly/spec/issues) are preferred for discussion of this specification. All issues and comments are [archived](https://github.com/WebAssembly/spec/issues?utf8=%E2%9C%93&q=is%3Aissue++).

This document was produced by the [WebAssembly Working Group](https://www.w3.org/groups/wg/wasm).

This document was produced by a group operating under the [W3C Patent Policy](https://www.w3.org/policies/patent-policy/). W3C maintains a [public list of any patent disclosures](https://www.w3.org/2004/01/pp-impl/101196/status) made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent that the individual believes contains [Essential Claim(s)](https://www.w3.org/policies/patent-policy/#def-essential) must disclose the information in accordance with [section 6 of the W3C Patent Policy](https://www.w3.org/policies/patent-policy/#sec-Disclosure).

This document is governed by the [18 August 2025 W3C Process Document](https://www.w3.org/policies/process/20250818/).

Table of Contents
-----------------

1.  [1 Introduction](#introduction①)
    1.  [1.1 Introduction](#introduction③)
        1.  [1.1.1 Design Goals](#design-goals①)
        2.  [1.1.2 Scope](#scope①)
        3.  [1.1.3 Security Considerations](#security-considerations①)
        4.  [1.1.4 Dependencies](#dependencies①)
    2.  [1.2 Overview](#overview①)
        1.  [1.2.1 Concepts](#concepts①)
        2.  [1.2.2 Semantic Phases](#semantic-phases①)
2.  [2 Structure](#structure①)
    1.  [2.1 Conventions](#conventions①)
        1.  [2.1.1 Grammar Notation](#grammar-notation①)
        2.  [2.1.2 Auxiliary Notation](#auxiliary-notation①)
        3.  [2.1.3 Lists](#lists①)
    2.  [2.2 Values](#values①)
        1.  [2.2.1 Bytes](#bytes①)
        2.  [2.2.2 Integers](#integers①)
        3.  [2.2.3 Floating-Point](#floating-point①)
        4.  [2.2.4 Vectors](#vectors①)
        5.  [2.2.5 Names](#names①)
    3.  [2.3 Types](#types①)
        1.  [2.3.1 Number Types](#number-types①)
        2.  [2.3.2 Vector Types](#vector-types①)
        3.  [2.3.3 Type Uses](#type-uses①)
        4.  [2.3.4 Heap Types](#heap-types①)
        5.  [2.3.5 Reference Types](#reference-types①)
        6.  [2.3.6 Value Types](#value-types①)
        7.  [2.3.7 Result Types](#result-types①)
        8.  [2.3.8 Block Types](#block-types①)
        9.  [2.3.9 Composite Types](#composite-types①)
        10.  [2.3.10 Recursive Types](#recursive-types①)
        11.  [2.3.11 Address Types](#address-types①)
        12.  [2.3.12 Limits](#limits①)
        13.  [2.3.13 Tag Types](#tag-types①)
        14.  [2.3.14 Global Types](#global-types①)
        15.  [2.3.15 Memory Types](#memory-types①)
        16.  [2.3.16 Table Types](#table-types①)
        17.  [2.3.17 Data Types](#data-types①)
        18.  [2.3.18 Element Types](#element-types①)
        19.  [2.3.19 External Types](#external-types①)
    4.  [2.4 Instructions](#instructions①)
        1.  [2.4.1 Parametric Instructions](#parametric-instructions①)
        2.  [2.4.2 Control Instructions](#control-instructions①)
        3.  [2.4.3 Variable Instructions](#variable-instructions①)
        4.  [2.4.4 Table Instructions](#table-instructions①)
        5.  [2.4.5 Memory Instructions](#memory-instructions①)
        6.  [2.4.6 Reference Instructions](#reference-instructions①)
        7.  [2.4.7 Aggregate Instructions](#aggregate-instructions①)
        8.  [2.4.8 Numeric Instructions](#numeric-instructions①)
        9.  [2.4.9 Vector Instructions](#vector-instructions①)
        10.  [2.4.10 Expressions](#expressions①)
    5.  [2.5 Modules](#modules①)
        1.  [2.5.1 Indices](#indices①)
        2.  [2.5.2 Types](#types③)
        3.  [2.5.3 Tags](#tags①)
        4.  [2.5.4 Globals](#globals①)
        5.  [2.5.5 Memories](#memories①)
        6.  [2.5.6 Tables](#tables①)
        7.  [2.5.7 Functions](#functions①)
        8.  [2.5.8 Data Segments](#data-segments①)
        9.  [2.5.9 Element Segments](#element-segments①)
        10.  [2.5.10 Start Function](#start-function①)
        11.  [2.5.11 Imports](#imports①)
        12.  [2.5.12 Exports](#exports①)
3.  [3 Validation](#validation②)
    1.  [3.1 Conventions](#conventions②⓪)
        1.  [3.1.1 Types](#types⑤)
        2.  [3.1.2 Defined Types](#defined-types①)
        3.  [3.1.3 Rolling and Unrolling](#rolling-and-unrolling①)
        4.  [3.1.4 Instruction Types](#instruction-types①)
        5.  [3.1.5 Local Types](#local-types①)
        6.  [3.1.6 Contexts](#contexts①)
        7.  [3.1.7 Prose Notation](#prose-notation①)
        8.  [3.1.8 Formal Notation](#formal-notation①)
    2.  [3.2 Types](#types⑦)
        1.  [3.2.1 Number Types](#number-types③)
        2.  [3.2.2 Vector Types](#vector-types③)
        3.  [3.2.3 Type Uses](#type-uses③)
        4.  [3.2.4 Heap Types](#heap-types③)
        5.  [3.2.5 Reference Types](#reference-types③)
        6.  [3.2.6 Value Types](#value-types③)
        7.  [3.2.7 Result Types](#result-types③)
        8.  [3.2.8 Block Types](#block-types③)
        9.  [3.2.9 Instruction Types](#instruction-types③)
        10.  [3.2.10 Composite Types](#composite-types③)
        11.  [3.2.11 Recursive Types](#recursive-types③)
        12.  [3.2.12 Limits](#limits③)
        13.  [3.2.13 Tag Types](#tag-types③)
        14.  [3.2.14 Global Types](#global-types③)
        15.  [3.2.15 Memory Types](#memory-types③)
        16.  [3.2.16 Table Types](#table-types③)
        17.  [3.2.17 External Types](#external-types③)
    3.  [3.3 Matching](#matching①)
        1.  [3.3.1 Number Types](#number-types⑤)
        2.  [3.3.2 Vector Types](#vector-types⑤)
        3.  [3.3.3 Heap Types](#heap-types⑤)
        4.  [3.3.4 Reference Types](#reference-types⑤)
        5.  [3.3.5 Value Types](#value-types⑤)
        6.  [3.3.6 Result Types](#result-types⑤)
        7.  [3.3.7 Instruction Types](#instruction-types⑤)
        8.  [3.3.8 Composite Types](#composite-types⑤)
        9.  [3.3.9 Field Types](#field-types①)
        10.  [3.3.10 Defined Types](#defined-types③)
        11.  [3.3.11 Limits](#limits⑤)
        12.  [3.3.12 Tag Types](#tag-types⑤)
        13.  [3.3.13 Global Types](#global-types⑤)
        14.  [3.3.14 Memory Types](#memory-types⑤)
        15.  [3.3.15 Table Types](#table-types⑤)
        16.  [3.3.16 External Types](#external-types⑤)
    4.  [3.4 Instructions](#instructions③)
        1.  [3.4.1 Parametric Instructions](#parametric-instructions③)
        2.  [3.4.2 Control Instructions](#control-instructions③)
        3.  [3.4.3 Variable Instructions](#variable-instructions③)
        4.  [3.4.4 Table Instructions](#table-instructions③)
        5.  [3.4.5 Memory Instructions](#memory-instructions③)
        6.  [3.4.6 Reference Instructions](#reference-instructions③)
        7.  [3.4.7 Aggregate Reference Instructions](#aggregate-reference-instructions①)
        8.  [3.4.8 Scalar Reference Instructions](#scalar-reference-instructions①)
        9.  [3.4.9 External Reference Instructions](#external-reference-instructions①)
        10.  [3.4.10 Numeric Instructions](#numeric-instructions③)
        11.  [3.4.11 Vector Instructions](#vector-instructions③)
        12.  [3.4.12 Instruction Sequences](#instruction-sequences①)
        13.  [3.4.13 Expressions](#expressions③)
    5.  [3.5 Modules](#modules③)
        1.  [3.5.1 Types](#types⑨)
        2.  [3.5.2 Tags](#tags③)
        3.  [3.5.3 Globals](#globals③)
        4.  [3.5.4 Memories](#memories③)
        5.  [3.5.5 Tables](#tables③)
        6.  [3.5.6 Functions](#functions③)
        7.  [3.5.7 Locals](#locals①)
        8.  [3.5.8 Data Segments](#data-segments③)
        9.  [3.5.9 Element Segments](#element-segments③)
        10.  [3.5.10 Start Function](#start-function③)
        11.  [3.5.11 Imports](#imports③)
        12.  [3.5.12 Exports](#exports③)
        13.  [3.5.13 Modules](#modules④)
4.  [4 Execution](#execution②)
    1.  [4.1 Conventions](#conventions②③)
        1.  [4.1.1 Prose Notation](#prose-notation③)
        2.  [4.1.2 Formal Notation](#formal-notation③)
    2.  [4.2 Runtime Structure](#runtime-structure①)
        1.  [4.2.1 Values](#values③)
        2.  [4.2.2 Results](#results①)
        3.  [4.2.3 Store](#store①)
        4.  [4.2.4 Addresses](#addresses①)
        5.  [4.2.5 External Addresses](#external-addresses①)
        6.  [4.2.6 Module Instances](#module-instances①)
        7.  [4.2.7 Function Instances](#function-instances①)
        8.  [4.2.8 Table Instances](#table-instances①)
        9.  [4.2.9 Memory Instances](#memory-instances①)
        10.  [4.2.10 Global Instances](#global-instances①)
        11.  [4.2.11 Tag Instances](#tag-instances①)
        12.  [4.2.12 Element Instances](#element-instances①)
        13.  [4.2.13 Data Instances](#data-instances①)
        14.  [4.2.14 Export Instances](#export-instances①)
        15.  [4.2.15 Aggregate Instances](#aggregate-instances①)
        16.  [4.2.16 Exception Instances](#exception-instances①)
        17.  [4.2.17 Stack](#stack①)
        18.  [4.2.18 Administrative Instructions](#administrative-instructions①)
        19.  [4.2.19 Configurations](#configurations①)
    3.  [4.3 Numerics](#numerics①)
        1.  [4.3.1 Representations](#representations①)
        2.  [4.3.2 Integer Operations](#integer-operations①)
        3.  [4.3.3 Floating-Point Operations](#floating-point-operations①)
        4.  [4.3.4 Conversions](#conversions①)
        5.  [4.3.5 Vector Operations](#vector-operations①)
        6.  [4.3.6 Relaxed Operations](#relaxed-operations①)
    4.  [4.4 Types](#types①①)
        1.  [4.4.1 Instantiation](#instantiation②)
    5.  [4.5 Values](#values⑥)
        1.  [4.5.1 Value Typing](#value-typing①)
        2.  [4.5.2 External Typing](#external-typing①)
    6.  [4.6 Instructions](#instructions⑤)
        1.  [4.6.1 Parametric Instructions](#parametric-instructions⑤)
        2.  [4.6.2 Control Instructions](#control-instructions⑤)
        3.  [4.6.3 Blocks](#blocks①)
        4.  [4.6.4 Exception Handling](#exception-handling①)
        5.  [4.6.5 Function Calls](#function-calls①)
        6.  [4.6.6 Variable Instructions](#variable-instructions⑤)
        7.  [4.6.7 Table Instructions](#table-instructions⑤)
        8.  [4.6.8 Memory Instructions](#memory-instructions⑤)
        9.  [4.6.9 Reference Instructions](#reference-instructions⑤)
        10.  [4.6.10 Numeric Instructions](#numeric-instructions⑤)
        11.  [4.6.11 Vector Instructions](#vector-instructions⑤)
        12.  [4.6.12 Expressions](#expressions⑤)
    7.  [4.7 Modules](#modules⑥)
        1.  [4.7.1 Allocation](#allocation①)
        2.  [4.7.2 Instantiation](#instantiation④)
        3.  [4.7.3 Invocation](#invocation②)
5.  [5 Binary Format](#binary-format①)
    1.  [5.1 Conventions](#conventions③①)
        1.  [5.1.1 Grammar](#grammar②)
        2.  [5.1.2 Auxiliary Notation](#auxiliary-notation③)
        3.  [5.1.3 Lists](#lists③)
    2.  [5.2 Values](#values⑧)
        1.  [5.2.1 Bytes](#bytes③)
        2.  [5.2.2 Integers](#integers⑤)
        3.  [5.2.3 Floating-Point](#floating-point⑤)
        4.  [5.2.4 Names](#names③)
    3.  [5.3 Types](#types①③)
        1.  [5.3.1 Number Types](#number-types⑦)
        2.  [5.3.2 Vector Types](#vector-types⑦)
        3.  [5.3.3 Heap Types](#heap-types⑦)
        4.  [5.3.4 Reference Types](#reference-types⑦)
        5.  [5.3.5 Value Types](#value-types⑦)
        6.  [5.3.6 Result Types](#result-types⑦)
        7.  [5.3.7 Composite Types](#composite-types⑦)
        8.  [5.3.8 Recursive Types](#recursive-types⑤)
        9.  [5.3.9 Limits](#limits⑦)
        10.  [5.3.10 Tag Types](#tag-types⑦)
        11.  [5.3.11 Global Types](#global-types⑦)
        12.  [5.3.12 Memory Types](#memory-types⑦)
        13.  [5.3.13 Table Types](#table-types⑦)
        14.  [5.3.14 External Types](#external-types⑦)
    4.  [5.4 Instructions](#instructions⑦)
        1.  [5.4.1 Parametric Instructions](#parametric-instructions⑦)
        2.  [5.4.2 Control Instructions](#control-instructions⑦)
        3.  [5.4.3 Variable Instructions](#variable-instructions⑦)
        4.  [5.4.4 Table Instructions](#table-instructions⑦)
        5.  [5.4.5 Memory Instructions](#memory-instructions⑦)
        6.  [5.4.6 Reference Instructions](#reference-instructions⑦)
        7.  [5.4.7 Aggregate Instructions](#aggregate-instructions③)
        8.  [5.4.8 Numeric Instructions](#numeric-instructions⑦)
        9.  [5.4.9 Vector Instructions](#vector-instructions⑦)
        10.  [5.4.10 Expressions](#expressions⑦)
    5.  [5.5 Modules](#modules⑨)
        1.  [5.5.1 Indices](#indices③)
        2.  [5.5.2 Sections](#sections①)
        3.  [5.5.3 Custom Section](#custom-section①)
        4.  [5.5.4 Type Section](#type-section①)
        5.  [5.5.5 Import Section](#import-section①)
        6.  [5.5.6 Function Section](#function-section①)
        7.  [5.5.7 Table Section](#table-section①)
        8.  [5.5.8 Memory Section](#memory-section①)
        9.  [5.5.9 Global Section](#global-section①)
        10.  [5.5.10 Export Section](#export-section①)
        11.  [5.5.11 Start Section](#start-section①)
        12.  [5.5.12 Element Section](#element-section①)
        13.  [5.5.13 Code Section](#code-section①)
        14.  [5.5.14 Data Section](#data-section①)
        15.  [5.5.15 Data Count Section](#data-count-section①)
        16.  [5.5.16 Tag Section](#tag-section①)
        17.  [5.5.17 Modules](#modules①⓪)
6.  [6 Text Format](#text-format①)
    1.  [6.1 Conventions](#conventions③③)
        1.  [6.1.1 Grammar](#grammar④)
        2.  [6.1.2 Abbreviations](#abbreviations①)
        3.  [6.1.3 Contexts](#contexts③)
        4.  [6.1.4 Lists](#lists⑤)
    2.  [6.2 Lexical Format](#lexical-format①)
        1.  [6.2.1 Characters](#characters①)
        2.  [6.2.2 Tokens](#tokens①)
        3.  [6.2.3 White Space](#white-space①)
        4.  [6.2.4 Comments](#comments①)
        5.  [6.2.5 Annotations](#annotations①)
    3.  [6.3 Values](#values①⓪)
        1.  [6.3.1 Integers](#integers⑦)
        2.  [6.3.2 Floating-Point](#floating-point⑦)
        3.  [6.3.3 Strings](#strings①)
        4.  [6.3.4 Names](#names⑤)
        5.  [6.3.5 Identifiers](#identifiers①)
    4.  [6.4 Types](#types①⑤)
        1.  [6.4.1 Number Types](#number-types⑨)
        2.  [6.4.2 Vector Types](#vector-types⑨)
        3.  [6.4.3 Heap Types](#heap-types⑨)
        4.  [6.4.4 Reference Types](#reference-types⑨)
        5.  [6.4.5 Value Types](#value-types⑨)
        6.  [6.4.6 Composite Types](#composite-types⑨)
        7.  [6.4.7 Recursive Types](#recursive-types⑦)
        8.  [6.4.8 Address Types](#address-types③)
        9.  [6.4.9 Limits](#limits⑨)
        10.  [6.4.10 Tag Types](#tag-types⑨)
        11.  [6.4.11 Global Types](#global-types⑨)
        12.  [6.4.12 Memory Types](#memory-types⑨)
        13.  [6.4.13 Table Types](#table-types⑨)
        14.  [6.4.14 External Types](#external-types⑨)
        15.  [6.4.15 Type Uses](#type-uses⑤)
    5.  [6.5 Instructions](#instructions⑨)
        1.  [6.5.1 Labels](#labels③)
        2.  [6.5.2 Parametric Instructions](#parametric-instructions⑨)
        3.  [6.5.3 Control Instructions](#control-instructions⑨)
        4.  [6.5.4 Variable Instructions](#variable-instructions⑨)
        5.  [6.5.5 Table Instructions](#table-instructions⑨)
        6.  [6.5.6 Memory Instructions](#memory-instructions⑨)
        7.  [6.5.7 Reference Instructions](#reference-instructions⑨)
        8.  [6.5.8 Aggregate Instructions](#aggregate-instructions⑤)
        9.  [6.5.9 Numeric Instructions](#numeric-instructions⑨)
        10.  [6.5.10 Vector Instructions](#vector-instructions⑨)
        11.  [6.5.11 Folded Instructions](#folded-instructions①)
        12.  [6.5.12 Expressions](#expressions⑨)
    6.  [6.6 Modules](#modules①②)
        1.  [6.6.1 Indices](#indices⑤)
        2.  [6.6.2 Types](#types①⑦)
        3.  [6.6.3 Tags](#tags⑨)
        4.  [6.6.4 Globals](#globals⑨)
        5.  [6.6.5 Memories](#memories⑨)
        6.  [6.6.6 Tables](#tables⑨)
        7.  [6.6.7 Functions](#functions⑨)
        8.  [6.6.8 Data Segments](#data-segments⑦)
        9.  [6.6.9 Element Segments](#element-segments⑦)
        10.  [6.6.10 Start Function](#start-function⑤)
        11.  [6.6.11 Imports](#imports⑤)
        12.  [6.6.12 Exports](#exports⑤)
        13.  [6.6.13 Modules](#modules①③)
7.  [A Appendix](#a-appendix)
    1.  [A.1 Embedding](#a1-embedding)
        1.  [Types](#types①⑨)
        2.  [Booleans](#booleans①)
        3.  [Exceptions and Errors](#exceptions-and-errors①)
        4.  [Pre- and Post-Conditions](#pre--and-post-conditions)
        5.  [Store](#store③)
        6.  [Modules](#modules①⑤)
        7.  [Module Instances](#module-instances③)
        8.  [Functions](#functions①①)
        9.  [Tables](#tables①①)
        10.  [Memories](#memories①①)
        11.  [Tags](#tags①①)
        12.  [Exceptions](#exceptions①)
        13.  [Globals](#globals①①)
        14.  [Values](#values①②)
        15.  [Matching](#matching③)
    2.  [A.2 Profiles](#a2-profiles)
        1.  [Conventions](#conventions③⑧)
        2.  [Defined Profiles](#defined-profiles①)
    3.  [A.3 Implementation Limitations](#a3-implementation-limitations)
        1.  [Syntactic Limits](#syntactic-limits①)
        2.  [Validation](#validation④)
        3.  [Execution](#execution④)
    4.  [Type Soundness](#type-soundness①)
        1.  [Contexts](#contexts⑤)
        2.  [Types](#types②①)
        3.  [Subtyping](#subtyping②)
        4.  [Results](#results③)
        5.  [Store Validity](#store-validity①)
        6.  [Configuration Validity](#configuration-validity①)
        7.  [Administrative Instructions](#administrative-instructions③)
        8.  [Store Extension](#store-extension①)
        9.  [Theorems](#theorems①)
    5.  [A.7 Type System Properties](#a7-type-system-properties)
        1.  [Principal Types](#principal-types①)
        2.  [Type Lattice](#type-lattice①)
        3.  [Compositionality](#compositionality①)
    6.  [A.4 Validation Algorithm](#a4-validation-algorithm)
        1.  [Data Structures](#data-structures①)
        2.  [Validation of Opcode Sequences](#validation-of-opcode-sequences①)
    7.  [Custom Sections and Annotations](#custom-sections-and-annotations①)
        1.  [Name Section](#name-section①)
        2.  [Name Annotations](#name-annotations①)
        3.  [Custom Annotations](#custom-annotations①)
    8.  [A.8 Change History](#a8-change-history)
        1.  [Release 2.0](#release-20)
        2.  [Release 3.0](#release-30)
    9.  [A.9 Index of Types](#a9-index-of-types)
    10.  [A.10 Index of Instructions](#a10-index-of-instructions)
    11.  [A.11 Index of Semantic Rules](#a11-index-of-semantic-rules)
        1.  [Well-formedness of Types](#well-formedness-of-types①)
        2.  [Typing of Static Constructs](#typing-of-static-constructs①)
        3.  [Typing of Runtime Constructs](#typing-of-runtime-constructs①)
        4.  [Constantness](#constantness①)
        5.  [Matching](#matching⑤)
        6.  [Store Extension](#store-extension③)
        7.  [Execution](#execution⑥)
8.  [Conformance](#w3c-conformance)
    1.  [Document conventions](#w3c-conventions)
    2.  [Conformant Algorithms](#w3c-conformant-algorithms)
9.  [References](#references)
    1.  [Normative References](#normative)

1\. Introduction[](#introduction①)
----------------------------------

### 1.1. Introduction[](#introduction③)

WebAssembly (abbreviated Wasm [\[1\]](#wasm)) is a _safe, portable, low-level code format_ designed for efficient execution and compact representation. Its main goal is to enable high performance applications on the Web, but it does not make any Web-specific assumptions or provide Web-specific features, so it can be employed in other environments as well.

WebAssembly is an open standard developed by a [W3C Community Group](https://www.w3.org/community/webassembly/).

This document describes version 3.0 (2026-01-21) of the [core](#scope) WebAssembly standard. It is intended that it will be superseded by new incremental releases with additional features in the future.

#### 1.1.1. Design Goals[](#design-goals①)

The design goals of WebAssembly are the following:

*   Fast, safe, and portable _semantics_:
    
    *   **Fast**: executes with near native code performance, taking advantage of capabilities common to all contemporary hardware.
        
    *   **Safe**: code is validated and executes in a memory-safe [\[2\]](#memorysafe), sandboxed environment preventing data corruption or security breaches.
        
    *   **Well-defined**: fully and precisely defines valid programs and their behavior in a way that is easy to reason about informally and formally.
        
    *   **Hardware-independent**: can be compiled on all modern architectures, desktop or mobile devices and embedded systems alike.
        
    *   **Language-independent**: does not privilege any particular language, programming model, or object model.
        
    *   **Platform-independent**: can be embedded in browsers, run as a stand-alone VM, or integrated in other environments.
        
    *   **Open**: programs can interoperate with their environment in a simple and universal manner.
        
*   Efficient and portable _representation_:
    
    *   **Compact**: has a binary format that is fast to transmit by being smaller than typical text or native code formats.
        
    *   **Modular**: programs can be split up in smaller parts that can be transmitted, cached, and consumed separately.
        
    *   **Efficient**: can be decoded, validated, and compiled in a fast single pass, equally with either just-in-time (JIT) or ahead-of-time (AOT) compilation.
        
    *   **Streamable**: allows decoding, validation, and compilation to begin as soon as possible, before all data has been seen.
        
    *   **Parallelizable**: allows decoding, validation, and compilation to be split into many independent parallel tasks.
        
    *   **Portable**: makes no architectural assumptions that are not broadly supported across modern hardware.
        

WebAssembly code is also intended to be easy to inspect and debug, especially in environments like web browsers, but such features are beyond the scope of this specification.

\[[1](#id1)\]

A contraction of “WebAssembly”, not an acronym, hence not using all-caps.

\[[2](#id2)\]

No program can break WebAssembly’s memory model. Of course, it cannot guarantee that an unsafe language compiling to WebAssembly does not corrupt its own memory layout, e.g. inside WebAssembly’s linear memory.

#### 1.1.2. Scope[](#scope①)

At its core, WebAssembly is a _virtual instruction set architecture (virtual ISA)_. As such, it has many use cases and can be embedded in many different environments. To encompass their variety and enable maximum reuse, the WebAssembly specification is split and layered into several documents.

This document is concerned with the core ISA layer of WebAssembly. It defines the instruction set, binary encoding, validation, and execution semantics, as well as a textual representation. It does not, however, define how WebAssembly programs can interact with a specific environment they execute in, nor how they are invoked from such an environment.

Instead, this specification is complemented by additional documents defining interfaces to specific embedding environments such as the Web. These will each define a WebAssembly _application programming interface (API)_ suitable for a given environment.

#### 1.1.3. Security Considerations[](#security-considerations①)

WebAssembly provides no ambient access to the computing environment in which code is executed. Any interaction with the environment, such as I/O, access to resources, or operating system calls, can only be performed by invoking [functions](#function) provided by the [embedder](#embedder) and imported into a WebAssembly [module](#module). An embedder can establish security policies suitable for a respective environment by controlling or limiting which functional capabilities it makes available for import. Such considerations are an embedder’s responsibility and the subject of [API definitions](#scope) for a specific environment.

Because WebAssembly is designed to be translated into machine code running directly on the host’s hardware, it is potentially vulnerable to side channel attacks on the hardware level. In environments where this is a concern, an embedder may have to put suitable mitigations into place to isolate WebAssembly computations.

#### 1.1.4. Dependencies[](#dependencies①)

WebAssembly depends on two existing standards:

*   [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic"), for the representation of [floating-point data](#syntax-float) and the semantics of respective [numeric operations](#float-ops).
    
*   [\[UNICODE\]](#biblio-unicode "The Unicode Standard"), for the representation of import/export [names](#syntax-name) and the [text format](#text).
    

However, to make this specification self-contained, relevant aspects of the aforementioned standards are defined and formalized as part of this specification, such as the [binary representation](#aux-fbits) and [rounding](#aux-ieee) of floating-point values, and the [value range](#syntax-char) and [UTF-8 encoding](#binary-utf8) of Unicode characters.

Note

The aforementioned standards are the authoritative source of all respective definitions. Formalizations given in this specification are intended to match these definitions. Any discrepancy in the syntax or semantics described is to be considered an error.

### 1.2. Overview[](#overview①)

#### 1.2.1. Concepts[](#concepts①)

WebAssembly encodes a low-level, assembly-like programming language. This language is structured around the following concepts.

**Values**

WebAssembly provides only four basic _number types_. These are integers and [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") numbers, each in 32 and 64 bit width. 32-bit integers also serve as Booleans and as memory addresses. The usual operations on these types are available, including the full matrix of conversions between them. There is no distinction between signed and unsigned integer types. Instead, integers are interpreted by respective operations as either unsigned or signed in two’s complement representation.

In addition to these basic number types, there is a single 128 bit wide vector type representing different types of packed data. The supported representations are four 32-bit, or two 64-bit [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") numbers, or different widths of packed integer values, specifically two 64-bit integers, four 32-bit integers, eight 16-bit integers, or sixteen 8-bit integers.

Finally, values can consist of opaque _references_ that represent pointers towards different sorts of entities. Unlike with other types, their size or representation is not observable.

**Instructions**

The computational model of WebAssembly is based on a _stack machine_. Code consists of sequences of _instructions_ that are executed in order. Instructions manipulate values on an implicit _operand stack_ [\[1\]](#stackmachine) and fall into two main categories. _Simple_ instructions perform basic operations on data. They pop arguments from the operand stack and push results back to it. _Control_ instructions alter control flow. Control flow is _structured_, meaning it is expressed with well-nested constructs such as blocks, loops, and conditionals. Branches can only target such constructs.

**Traps**

Under some conditions, certain instructions may produce a _trap_, which immediately aborts execution. Traps cannot be handled by WebAssembly code, but are reported to the outside environment, where they typically can be caught.

**Functions**

Code is organized into separate _functions_. Each function takes a sequence of values as parameters and returns a sequence of values as results. Functions can call each other, including recursively, resulting in an implicit call stack that cannot be accessed directly. Functions may also declare mutable _local variables_ that are usable as virtual registers.

**Tables**

A _table_ is an array of opaque values of a particular _reference type_. It allows programs to select such values indirectly through a dynamic index operand. Thereby, for example, a program can call functions indirectly through a dynamic index into a table. This allows emulating function pointers by way of table indices.

**Linear Memory**

A _linear memory_ is a contiguous, mutable array of raw bytes. Such a memory is created with an initial size but can be grown dynamically. A program can load and store values from/to a linear memory at any byte address (including unaligned). Integer loads and stores can specify a _storage size_ which is smaller than the size of the respective value type. A trap occurs if an access is not within the bounds of the current memory size.

**Modules**

A WebAssembly binary takes the form of a _module_ that contains definitions for functions, tables, and linear memories, as well as mutable or immutable _global variables_. Definitions can also be _imported_, specifying a module/name pair and a suitable type. Each definition can optionally be _exported_ under one or more names. In addition to definitions, modules can define initialization data for their memories or tables that takes the form of _segments_ copied to given offsets. They can also define a _start function_ that is automatically executed.

**Embedder**

A WebAssembly implementation will typically be _embedded_ into a _host_ environment. This environment defines how loading of modules is initiated, how imports are provided (including host-side definitions), and how exports can be accessed. However, the details of any particular embedding are beyond the scope of this specification, and will instead be provided by complementary, environment-specific API definitions.

\[[1](#id2)\]

In practice, implementations need not maintain an actual operand stack. Instead, the stack can be viewed as a set of anonymous registers that are implicitly referenced by instructions. The [type system](#validation) ensures that the stack height, and thus any referenced register, is always known statically.

#### 1.2.2. Semantic Phases[](#semantic-phases①)

Conceptually, the semantics of WebAssembly is divided into three phases. For each part of the language, the specification specifies each of them.

**Decoding**

WebAssembly modules are distributed in a _binary format_. _Decoding_ processes that format and converts it into an internal representation of a module. In this specification, this representation is modelled by _abstract syntax_, but a real implementation could compile directly to machine code instead.

**Validation**

A decoded module has to be _valid_. Validation checks a number of well-formedness conditions to guarantee that the module is meaningful and safe. In particular, it performs _type checking_ of functions and the instruction sequences in their bodies, ensuring for example that the operand stack is used consistently.

**Execution**

Finally, a valid module can be _executed_. Execution can be further divided into two phases:

**Instantiation**. A module _instance_ is the dynamic representation of a module, complete with its own state and execution stack. Instantiation executes the module body itself, given definitions for all its imports. It initializes globals, memories and tables and invokes the module’s start function if defined. It returns the instances of the module’s exports.

**Invocation**. Once instantiated, further WebAssembly computations can be initiated by _invoking_ an exported function on a module instance. Given the required arguments, that executes the respective function and returns its results.

Instantiation and invocation are operations within the embedding environment.

2\. Structure[](#structure①)
----------------------------

### 2.1. Conventions[](#conventions①)

WebAssembly is a programming language that has multiple concrete representations (its [binary format](#binary) and the [text format](#text)). Both map to a common structure. For conciseness, this structure is described in the form of an _abstract syntax_. All parts of this specification are defined in terms of this abstract syntax.

#### 2.1.1. Grammar Notation[](#grammar-notation①)

The following conventions are adopted in defining grammar rules for abstract syntax.

*   Terminal symbols (atoms) are written in sans-serif font or in symbolic form: i32, nop, →, \[,\].
    
*   Nonterminal symbols are written in italic font: [valtype](#syntax-valtype), [instr](#syntax-instr).
    
*   An is a sequence of n≥0 iterations of A.
    
*   A∗ is a possibly empty sequence of iterations of A. (This is a shorthand for An used where n is not relevant.)
    
*   A+ is a non-empty sequence of iterations of A. (This is a shorthand for An where n≥1.)
    
*   A? is an optional occurrence of A. (This is a shorthand for An where n≤1.)
    
*   Productions are written ​sym​::=​A1​ ∣ … ∣ An​​.
    
*   Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, ​sym​::=​A1​​, and starting continuations with ellipses, ​sym​::=​… ∣ A2​​.
    
*   Some productions are augmented with side conditions, “ifcondition”, that provide a shorthand for a combinatorial expansion of the production into many separate cases.
    
*   If the same meta variable or non-terminal symbol appears multiple times in a production, then all those occurrences must have the same instantiation. (This is a shorthand for a side condition requiring multiple different variables to be equal.)
    

#### 2.1.2. Auxiliary Notation[](#auxiliary-notation①)

When dealing with syntactic constructs the following notation is also used:

*   ϵ denotes the empty sequence.
    
*   ∣s∣ denotes the length of a sequence s.
    
*   s\[i\] denotes the i\-th element of a sequence s, starting from 0.
    
*   s\[i:n\] denotes the sub-sequence s\[i\]…s\[i+n−1\] of a sequence s.
    
*   s\[\[i\]\=A\] denotes the same sequence as s, except that the i\-th element is replaced with A.
    
*   s\[\[i:n\]\=An\] denotes the same sequence as s, except that the sub-sequence s\[i:n\] is replaced with An.
    
*   s1​⊕s2​ denotes the sequence s1​ concatenated with s2​; this is equivalent to s1​ s2​, but used for clarity.
    
*   ⨁s∗ denotes the flattened sequence, formed by concatenating all sequences si​ in s∗.
    
*   A∈s denotes that A is a member of the sequence s, that is, s is of the form s1​ A s2​ for some sequences s1​, s2​.
    

Moreover, the following conventions are employed:

*   The notation xn, where x is a non-terminal symbol, is treated as a meta variable ranging over respective sequences of x (similarly for x∗, x+, x?).
    
*   When given a sequence xn, then the occurrences of x in an iterated sequence (…x…)n are assumed to denote the individual elements of xn, respectively (similarly for x∗, x+, x?). This implicitly expresses a form of mapping syntactic constructions over a sequence.
    
*   ei<n denotes the same sequence as en, but implicitly also defines in to be the sequence of values 0 to (n−1).
    

Note

For example, if xn is the sequence a b c, then (f(x)+1)n denotes the sequence (f(a)+1) (f(b)+1) (f(c)+1).

The form ei<n additionally gives access to an index variable inside the iteration. For example, (f(x)+i)i<n denotes the sequence (f(a)+0) (f(b)+1) (f(c)+2).

Productions of the following form are interpreted as _records_ that map a fixed set of fields fieldi​ to “values” Ai​, respectively:

​r​::=​{field1​ A1​,field2​ A2​,… }​​​

The following notation is adopted for manipulating such records:

*   Where the type of a record is clear from context, empty fields with value ϵ are often omitted.
    
*   r.field denotes the contents of the field component of r.
    
*   r\[.field\=A\] denotes the same record as r, except that the value of the field component is replaced with A.
    
*   r\[.field\=⊕A∗\] denotes the same record as r, except that A∗ is appended to the sequence value of the field component, that is, it is short for r\[.field\=r.field⊕A∗\].
    
*   r1​⊕r2​ denotes the composition of two identically shaped records by concatenating each field of sequences point-wise:
    
    {field1​A1∗​,field2​A2∗​,…}⊕{field1​B1∗​,field2​B2∗​,…}\={field1​(A1∗​⊕B1∗​),field2​(A2∗​⊕B2∗​),…}
    
*   ⨁r∗ denotes the composition of a sequence of records, respectively; if the sequence is empty, then all fields of the resulting record are empty.
    

The update notation for sequences and records generalizes recursively to nested components accessed by “paths” ​pth​::=​(\[i\] ∣ .field)+​:

*   s\[\[i\]pth\=A\] is short for s\[\[i\]\=s\[i\]\[pth\=A\]\],
    
*   r\[.field pth\=A\] is short for r\[.field\=r.field\[pth\=A\]\].
    

#### 2.1.3. Lists[](#lists①)

_Lists_ are bounded sequences of the form An (or A∗), where the A can either be values or complex constructions. A list can have at most 232−1 elements.

​[list](#syntax-list)(X)​::=​X∗​if ∣X∗∣<232​​

### 2.2. Values[](#values①)

WebAssembly programs operate on primitive numeric _values_. Moreover, in the definition of programs, immutable sequences of values occur to represent more complex data, such as text strings or other vectors.

#### 2.2.1. Bytes[](#bytes①)

The simplest form of value are raw uninterpreted _bytes_. In the abstract syntax they are represented as hexadecimal literals.

​[byte](#syntax-byte)​::=​0x00 ∣ … ∣ 0xFF​​

##### 2.2.1.1. Conventions[](#conventions③)

*   The meta variable b ranges over bytes.
    
*   Bytes are sometimes interpreted as natural numbers n<256.
    

#### 2.2.2. Integers[](#integers①)

Different classes of _integers_ with different value ranges are distinguished by their _bit width_ N and by whether they are _unsigned_ or _signed_.

​[u](#syntax-int)N[s](#syntax-int)N[i](#syntax-int)N​::=::=::=​0 ∣ … ∣ 2N−1−2N−1 ∣ … ∣ −1 ∣ 0 ∣ +1 ∣ … ∣ +2N−1−1[u](#syntax-int)N​​

The class [i](#syntax-int) defines _uninterpreted_ integers, whose signedness interpretation can vary depending on context. In the abstract syntax, they are represented as unsigned values. However, some operations [convert](#aux-signed) them to signed based on a two’s complement interpretation.

Note

The main integer types occurring in this specification are [u8](#syntax-int), [u32](#syntax-int), [u64](#syntax-int), and u128. However, other sizes occur as auxiliary constructions, e.g., in the definition of [floating-point](#syntax-float) numbers.

##### 2.2.2.1. Conventions[](#conventions④)

*   The meta variables m, n, i, j range over integers.
    
*   Numbers may be denoted by simple arithmetics, as in the grammar above. In order to distinguish arithmetics like 2N from sequences like (1)N, the latter is distinguished with parentheses.
    

#### 2.2.3. Floating-Point[](#floating-point①)

_Floating-point_ data represents 32 or 64 bit values that correspond to the respective binary formats of the [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") standard (Section 3.3).

Every value has a _sign_ and a _magnitude_. Magnitudes can either be expressed as _normal_ numbers of the form m0​ . m1​ m2​ … mm​⋅2e, where e is the exponent and m is the _significand_ whose most significant bit m0​ is 1, or as a _subnormal_ number where the exponent is fixed to the smallest possible value and m0​ is 0; among the subnormals are positive and negative zero values. Since the significands are binary values, normals are represented in the form (1+m⋅2−M)⋅2e in the abstract syntax, where M is the bit width of m; similarly for subnormals.

Possible magnitudes also include the special values ∞ (infinity) and nan (_NaN_, not a number). NaN values have a _payload_ that describes the mantissa bits in the underlying [binary representation](#aux-fbits). No distinction is made between signalling and quiet NaNs.

​[f](#syntax-float)N[fmagN](#syntax-float)​::=::=∣∣∣​+[fmagN](#syntax-float) ∣ −[fmagN](#syntax-float)(1+m⋅2−M)⋅2e(0+m⋅2−M)⋅2e∞[nan](#syntax-float)(m)​if m<2M∧2−2E−1≤e≤2E−1−1if m<2M∧2−2E−1\=eif 1≤m<2M​​

where M​\=​[signif](#aux-signif)(N)​ and E​\=​[expon](#aux-expon)(N)​ with

[signif](#aux-signif)(32)[signif](#aux-signif)(64)[expon](#aux-expon)(64)​\=\=\=​23520.8ex\][expon](#aux-expon)(32)11​\=​8​​

A _canonical NaN_ is a floating-point value ±nan([canon](#aux-canon)N​) where [canon](#aux-canon)N​ is a payload whose most significant bit is 1 while all others are 0:

[canon](#aux-canon)N​​\=​2[signif](#aux-signif)(N)−1​​

An _arithmetic NaN_ is a floating-point value ±nan(m) with m≥[canon](#aux-canon)N​, such that the most significant bit is 1 while all others are arbitrary.

Note

In the abstract syntax, subnormals are distinguished by the leading 0 of the significand. The exponent of subnormals has the same value as the smallest possible exponent of a normal number. Only in the [binary representation](#binary-float) the exponent of a subnormal is encoded differently than the exponent of any normal number.

The notion of canonical NaN defined here is unrelated to the notion of canonical NaN that the [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") standard (Section 3.5.2) defines for decimal interchange formats.

##### 2.2.3.1. Conventions[](#conventions⑤)

*   The meta variable z ranges over floating-point values where clear from context.
    
*   Where clear from context, shorthands like +1 denote floating point values like +(1+0⋅2−M)⋅20.
    

#### 2.2.4. Vectors[](#vectors①)

_Numeric vectors_ are 128-bit values that are processed by vector instructions (also known as _SIMD_ instructions, single instruction multiple data). They are represented in the abstract syntax using u128. The interpretation of lane types ([integer](#syntax-int) or [floating-point](#syntax-float) numbers) and lane sizes are determined by the specific instruction operating on them.

#### 2.2.5. Names[](#names①)

_Names_ are sequences of _characters_, which are _scalar values_ as defined by [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 2.4).

​[name](#syntax-name)[char](#syntax-name)​::=::=​[char](#syntax-name)∗U+00 ∣ … ∣ U+D7FF ∣ U+E000 ∣ … ∣ U+10FFFF​if ∣[utf8](#binary-utf8)([char](#syntax-name)∗)∣<232​

Due to the limitations of the [binary format](#binary-name), the length of a name is bounded by the length of its [UTF-8](#binary-utf8) encoding.

##### 2.2.5.1. Convention[](#convention①)

*   Characters (Unicode scalar values) are sometimes used interchangeably with natural numbers n<1114112.
    

### 2.3. Types[](#types①)

Various entities in WebAssembly are classified by types. Types are checked during [validation](#valid), [instantiation](#exec-instantiation), and possibly [execution](#syntax-call-indirect).

#### 2.3.1. Number Types[](#number-types①)

_Number types_ classify numeric values.

​[numtype](#syntax-numtype)​::=​[i32](#syntax-numtype) ∣ [i64](#syntax-numtype) ∣ [f32](#syntax-numtype) ∣ [f64](#syntax-numtype)​​

The types i32 and i64 classify 32 and 64 bit integers, respectively. Integers are not inherently signed or unsigned, their interpretation is determined by individual operations.

The types f32 and f64 classify 32 and 64 bit floating-point data, respectively. They correspond to the respective binary floating-point representations, also known as _single_ and _double_ precision, as defined by the [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") standard (Section 3.3).

Number types are _transparent_, meaning that their bit patterns can be observed. Values of number type can be stored in [memories](#syntax-mem).

##### 2.3.1.1. Conventions[](#conventions⑦)

*   The notation ∣t∣ denotes the _bit width_ of a number type t. That is, ∣i32∣\=∣f32∣\=32 and ∣i64∣\=∣f64∣\=64.
    

#### 2.3.2. Vector Types[](#vector-types①)

_Vector types_ classify vectors of [numeric](#syntax-numtype) values processed by vector instructions (also known as _SIMD_ instructions, single instruction multiple data).

​[vectype](#syntax-vectype)​::=​[v128](#syntax-vectype)​​

The type v128 corresponds to a 128 bit vector of packed integer or floating-point data. The packed data can be interpreted as signed or unsigned integers, single or double precision floating-point values, or a single 128 bit type. The interpretation is determined by individual operations.

Vector types, like [number types](#syntax-numtype) are _transparent_, meaning that their bit patterns can be observed. Values of vector type can be stored in [memories](#syntax-mem).

##### 2.3.2.1. Conventions[](#conventions⑧)

*   The notation ∣t∣ for [bit width](#bitwidth-numtype) extends to vector types as well, that is, ∣v128∣\=128.
    

#### 2.3.3. Type Uses[](#type-uses①)

A _type use_ is the use site of a [type index](#syntax-typeidx) referencing a [composite type](#syntax-comptype) [defined](#syntax-type) in a [module](#syntax-module). It classifies objects of the respective type.

​[typeuse](#syntax-typeuse)​::=​[typeidx](#syntax-typeidx)​​

The syntax of type uses is [extended](#syntax-typeuse-ext) with additional forms for the purpose of specifying [validation](#valid) and [execution](#exec).

#### 2.3.4. Heap Types[](#heap-types①)

_Heap types_ classify objects in the runtime [store](#store). There are three disjoint hierarchies of heap types:

*   _function types_ classify [functions](#syntax-func),
    
*   _aggregate types_ classify dynamically allocated _managed_ data, such as _structures_, _arrays_, or _unboxed scalars_,
    
*   _external types_ classify _external_ references possibly owned by the [embedder](#embedder).
    

The values from the latter two hierarchies are interconvertible by ways of the [extern.convert\_any](#syntax-instr-extern) and [any.convert\_extern](#syntax-instr-extern) instructions. That is, both type hierarchies are inhabited by an isomorphic set of values, but may have different, incompatible representations in practice.

​[absheaptype](#syntax-absheaptype)[heaptype](#syntax-heaptype)​::=∣∣∣::=​[any](#syntax-heaptype) ∣ [eq](#syntax-heaptype) ∣ [i31](#syntax-heaptype) ∣ [struct](#syntax-heaptype) ∣ [array](#syntax-heaptype) ∣ [none](#syntax-heaptype)[func](#syntax-heaptype) ∣ [nofunc](#syntax-heaptype)[exn](#syntax-heaptype) ∣ [noexn](#syntax-heaptype)[extern](#syntax-heaptype) ∣ [noextern](#syntax-heaptype)[absheaptype](#syntax-absheaptype) ∣ [typeuse](#syntax-typeuse)​​

A heap type is either _abstract_ or _concrete_. A concrete heap type consists of a [type use](#syntax-typeuse) that classifies an object of the respective [type](#syntax-type) defined in a module. Abstract types are denoted by individual keywords.

The type func denotes the common supertype of all [function types](#syntax-functype), regardless of their concrete definition. Dually, the type nofunc denotes the common subtype of all [function types](#syntax-functype), regardless of their concrete definition. This type has no values.

The type exn denotes the common supertype of all [exception references](#syntax-ref-exn). This type has no concrete subtypes. Dually, the type noexn denotes the common subtype of all forms of exception references. This type has no values.

The type extern denotes the common supertype of all external references received through the [embedder](#embedder). This type has no concrete subtypes. Dually, the type noextern denotes the common subtype of all forms of external references. This type has no values.

The type any denotes the common supertype of all aggregate types, as well as possibly abstract values produced by _internalizing_ an external reference of type extern. Dually, the type none denotes the common subtype of all forms of aggregate types. This type has no values.

The type eq is a subtype of any that includes all types for which references can be compared, i.e., aggregate values and i31.

The types struct and array denote the common supertypes of all [structure](#syntax-structtype) and [array](#syntax-arraytype) aggregates, respectively.

The type i31 denotes _unboxed scalars_, that is, integers injected into references. Their observable value range is limited to 31 bits.

Note

Values of type i31 are not actually allocated in the store, but represented in a way that allows them to be mixed with actual references into the store without ambiguity. Engines need to perform some form of _pointer tagging_ to achieve this, which is why one bit is reserved. Since this type is to be reliably unboxed on all hardware platforms supported by WebAssembly, it cannot be wider than 32 bits minus the tag bit.

Although the types none, nofunc, noexn, and noextern are not inhabited by any values, they can be used to form the types of all null [references](#syntax-reftype) in their respective hierarchy. For example, (ref null nofunc) is the generic type of a null reference compatible with all function reference types.

The syntax of abstract heap types is [extended](#syntax-heaptype-ext) with additional forms for the purpose of specifying [validation](#valid) and [execution](#exec).

#### 2.3.5. Reference Types[](#reference-types①)

_Reference types_ classify [values](#syntax-value) that are first-class references to objects in the runtime [store](#store).

​[reftype](#syntax-reftype)​::=​[ref](#syntax-reftype) [null](#syntax-reftype)? [heaptype](#syntax-heaptype)​​

A reference type is characterised by the [heap type](#syntax-heaptype) it points to.

In addition, a reference type of the form ref null ht is _nullable_, meaning that it can either be a proper reference to ht or [null](#syntax-null). Other references are _non-null_.

Reference types are _opaque_, meaning that neither their size nor their bit pattern can be observed. Values of reference type can be stored in [tables](#syntax-table) but not in [memories](#syntax-mem).

##### 2.3.5.1. Conventions[](#conventions⑨)

*   The reference type [anyref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [any](#syntax-heaptype)).
    
*   The reference type [eqref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [eq](#syntax-heaptype)).
    
*   The reference type [i31ref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [i31](#syntax-heaptype)).
    
*   The reference type [structref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [struct](#syntax-heaptype)).
    
*   The reference type [arrayref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [array](#syntax-heaptype)).
    
*   The reference type [funcref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)).
    
*   The reference type [exnref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [exn](#syntax-heaptype)).
    
*   The reference type [externref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [extern](#syntax-heaptype)).
    
*   The reference type [nullref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [none](#syntax-heaptype)).
    
*   The reference type [nullfuncref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [nofunc](#syntax-heaptype)).
    
*   The reference type [nullexnref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [noexn](#syntax-heaptype)).
    
*   The reference type [nullexternref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [noextern](#syntax-heaptype)).
    

#### 2.3.6. Value Types[](#value-types①)

_Value types_ classify the individual values that WebAssembly code can compute with and the values that a variable accepts. They are either [number types](#syntax-numtype), [vector types](#syntax-vectype), or [reference types](#syntax-reftype).

​[consttype](#syntax-consttype)[valtype](#syntax-valtype)​::=::=​[numtype](#syntax-numtype) ∣ [vectype](#syntax-vectype)[numtype](#syntax-numtype) ∣ [vectype](#syntax-vectype) ∣ [reftype](#syntax-reftype)​​

The syntax of value types is [extended](#syntax-valtype-ext) with additional forms for the purpose of specifying [validation](#valid).

##### 2.3.6.1. Conventions[](#conventions①⓪)

*   The meta variable t ranges over value types or subclasses thereof where clear from context.
    

#### 2.3.7. Result Types[](#result-types①)

_Result types_ classify the result of [executing](#exec-instr) [instructions](#syntax-instr) or [functions](#syntax-func), which is a sequence of values, written with brackets.

​[resulttype](#syntax-resulttype)​::=​[list](#syntax-list)([valtype](#syntax-valtype))​​

#### 2.3.8. Block Types[](#block-types①)

_Block types_ classify the _input_ and _output_ of structured [control instructions](#syntax-instr-control) delimiting [blocks](#syntax-block) of instructions.

​[blocktype](#syntax-blocktype)​::=∣​[valtype](#syntax-valtype)?[typeidx](#syntax-typeidx)​​

They are given either as a [type index](#syntax-funcidx) that refers to a suitable [function type](#syntax-functype) reinterpreted as an [instruction type](#syntax-instrtype), or as an optional [value type](#syntax-valtype) inline, which is a shorthand for the instruction type ϵ→[valtype](#syntax-valtype)?.

#### 2.3.9. Composite Types[](#composite-types①)

_Composite types_ are all types composed from simpler types, including _function types_, _structure types_ and _array types_.

​[comptype](#syntax-comptype)[storagetype](#syntax-storagetype)[packtype](#syntax-packtype)​::=∣∣::=::=​[struct](#syntax-comptype) [list](#syntax-list)([fieldtype](#syntax-fieldtype))[array](#syntax-comptype) [fieldtype](#syntax-fieldtype)[func](#syntax-comptype) [resulttype](#syntax-resulttype)[→](#syntax-comptype)[resulttype](#syntax-resulttype)0.8ex\][valtype](#syntax-valtype) ∣ [packtype](#syntax-packtype)[i8](#syntax-storagetype) ∣ [i16](#syntax-storagetype)​[fieldtype](#syntax-fieldtype)​::=​[mut](#syntax-mut)? [storagetype](#syntax-storagetype)​​

Function types classify the signature of [functions](#syntax-func), mapping a list of parameters to a list of results. They are also used to classify the inputs and outputs of [instructions](#syntax-instr).

_Aggregate types_ like structure or array types consist of a list of possibly mutable, possibly packed _field types_ describing their components. Structures are heterogeneous, but require static indexing, while arrays need to be homogeneous, but allow dynamic indexing.

##### 2.3.9.1. Conventions[](#conventions①①)

*   The notation ∣t∣ for the [bit width](#bitwidth-valtype) of a [value type](#syntax-valtype) t extends to packed types as well, that is, ∣i8∣\=8 and ∣i16∣\=16.
    
*   The auxiliary function [unpack](#aux-unpack) maps a storage type to the [value type](#syntax-valtype) obtained when accessing a field:
    

[unpack](#aux-unpack)([valtype](#syntax-valtype))[unpack](#aux-unpack)([packtype](#syntax-packtype))​\=\=​[valtype](#syntax-valtype)[i32](#syntax-numtype)​​

#### 2.3.10. Recursive Types[](#recursive-types①)

_Recursive types_ denote a group of mutually recursive [composite types](#syntax-comptype), each of which can optionally declare a list of [type uses](#syntax-typeuse) of supertypes that it [matches](#match-comptype). Each type can also be declared _final_, preventing further subtyping.

​[rectype](#syntax-rectype)[subtype](#syntax-subtype)​::=::=​[rec](#syntax-rectype) [list](#syntax-list)([subtype](#syntax-subtype))[sub](#syntax-subtype) [final](#syntax-subtype)? [typeuse](#syntax-typeuse)∗ [comptype](#syntax-comptype)​​

In a [module](#syntax-module), each member of a recursive type is assigned a separate [type index](#syntax-typeidx).

#### 2.3.11. Address Types[](#address-types①)

_Address types_ are a subset of [number types](#syntax-numtype) that classify the values that can be used as offsets into [memories](#syntax-mem) and [tables](#syntax-table).

​[addrtype](#syntax-addrtype)​::=​[i32](#syntax-numtype) ∣ [i64](#syntax-numtype)​​

##### 2.3.11.1. Conventions[](#conventions①②)

The _minimum_ of two address types is defined as the address type whose [bit width](#bitwidth-numtype) is the minimum of the two.

[min](#aux-addrtype-min)(at1​,at2​)[min](#aux-addrtype-min)(at1​,at2​)​\=\=​at1​at2​​if ∣at1​∣≤∣at2​∣otherwise​​

#### 2.3.12. Limits[](#limits①)

_Limits_ classify the size range of resizeable storage associated with [memory types](#syntax-memtype) and [table types](#syntax-tabletype).

​[limits](#syntax-limits)​::=​\[[u64](#syntax-int)[..](#syntax-limits)[u64](#syntax-int)?\]​​

If no maximum is present, then the respective storage can grow to any valid size.

#### 2.3.13. Tag Types[](#tag-types①)

_Tag types_ classify the signature [tags](#syntax-tag) with a [type use](#syntax-typeuse) referring to the definition of a [function type](#syntax-functype) that declares the types of parameter and result values associated with the tag. The result type is empty for exception tags.

​[tagtype](#syntax-tagtype)​::=​[typeuse](#syntax-typeuse)​​

#### 2.3.14. Global Types[](#global-types①)

_Global types_ classify [global](#syntax-global) variables, which hold a value and can either be mutable or immutable.

​[globaltype](#syntax-globaltype)​::=​[mut](#syntax-mut)? [valtype](#syntax-valtype)​​

#### 2.3.15. Memory Types[](#memory-types①)

_Memory types_ classify linear [memories](#syntax-mem) and their size range.

​[memtype](#syntax-memtype)​::=​[addrtype](#syntax-addrtype) [limits](#syntax-limits) [page](#syntax-memtype)​​

The limits constrain the minimum and optionally the maximum size of a memory. The limits are given in units of [page size](#page-size).

#### 2.3.16. Table Types[](#table-types①)

_Table types_ classify [tables](#syntax-table) over elements of [reference type](#syntax-reftype) within a size range.

​[tabletype](#syntax-tabletype)​::=​[addrtype](#syntax-addrtype) [limits](#syntax-limits) [reftype](#syntax-reftype)​​

Like memories, tables are constrained by limits for their minimum and optionally maximum size. The limits are given in numbers of entries.

#### 2.3.17. Data Types[](#data-types①)

_Data types_ classify [data segments](#syntax-elem). Since the contents of a data segment requires no further classification, they merely consist of a universal marker ok indicating well-formedness.

​[datatype](#syntax-datatype)​::=​[ok](#valid-data)​​

#### 2.3.18. Element Types[](#element-types①)

_Element types_ classify [element segments](#syntax-elem) by the [reference type](#syntax-reftype) of its elements.

​[elemtype](#syntax-elemtype)​::=​[reftype](#syntax-reftype)​​

#### 2.3.19. External Types[](#external-types①)

_External types_ classify [imports](#syntax-import) and [external addresses](#syntax-externaddr) with their respective types.

​[externtype](#syntax-externtype)​::=​[tag](#syntax-externtype) [tagtype](#syntax-tagtype) ∣ [global](#syntax-externtype) [globaltype](#syntax-globaltype) ∣ [mem](#syntax-externtype) [memtype](#syntax-memtype) ∣ [table](#syntax-externtype) [tabletype](#syntax-tabletype) ∣ [func](#syntax-externtype) [typeuse](#syntax-typeuse)​​

For functions, the [type use](#syntax-typeuse) has to refer to the definition of a [function type](#syntax-functype).

Note

Future versions of WebAssembly may have additional uses for tags, and may allow non-empty result types in the function types of tags.

##### 2.3.19.1. Conventions[](#conventions①③)

The following auxiliary notation is defined for sequences of external types. It filters out entries of a specific kind in an order-preserving fashion:

[funcs](#syntax-externtype)(ϵ)[funcs](#syntax-externtype)(([func](#syntax-externtype) dt) xt∗)[funcs](#syntax-externtype)([externtype](#syntax-externtype) xt∗)[tables](#syntax-externtype)(([table](#syntax-externtype) tt) xt∗)[tables](#syntax-externtype)([externtype](#syntax-externtype) xt∗)[mems](#syntax-externtype)(([mem](#syntax-externtype) mt) xt∗)[mems](#syntax-externtype)([externtype](#syntax-externtype) xt∗)[globals](#syntax-externtype)(([global](#syntax-externtype) gt) xt∗)[globals](#syntax-externtype)([externtype](#syntax-externtype) xt∗)[tags](#syntax-externtype)(([tag](#syntax-externtype) jt) xt∗)[tags](#syntax-externtype)([externtype](#syntax-externtype) xt∗)​\=\=\=\=\=\=\=\=\=\=\=​ϵdt [funcs](#syntax-externtype)(xt∗)[funcs](#syntax-externtype)(xt∗)tt [tables](#syntax-externtype)(xt∗)[tables](#syntax-externtype)(xt∗)mt [mems](#syntax-externtype)(xt∗)[mems](#syntax-externtype)(xt∗)gt [globals](#syntax-externtype)(xt∗)[globals](#syntax-externtype)(xt∗)jt [tags](#syntax-externtype)(xt∗)[tags](#syntax-externtype)(xt∗)​otherwise0.8ex\][tables](#syntax-externtype)(ϵ)otherwise0.8ex\][mems](#syntax-externtype)(ϵ)otherwise0.8ex\][globals](#syntax-externtype)(ϵ)otherwise0.8ex\][tags](#syntax-externtype)(ϵ)otherwise​\=\=\=\=​ϵϵϵϵ​​

### 2.4. Instructions[](#instructions①)

WebAssembly code consists of sequences of _instructions_. Its computational model is based on a _stack machine_ in that instructions manipulate values on an implicit _operand stack_, consuming (popping) argument values and producing or returning (pushing) result values.

In addition to dynamic operands from the stack, some instructions also have static _immediate_ arguments, typically [indices](#syntax-index) or type annotations, which are part of the instruction itself.

Some instructions are [structured](#syntax-instr-control) in that they contain nested sequences of instructions.

The following sections group instructions into a number of different categories.

The syntax of instruction is further [extended](#syntax-instr-admin) with additional forms for the purpose of specifying [execution](#exec).

#### 2.4.1. Parametric Instructions[](#parametric-instructions①)

Instructions in this group can operate on operands of any [value type](#syntax-valtype).

​[instr](#syntax-instr)​::=∣∣∣​[nop](#syntax-instr-control)[unreachable](#syntax-instr-control)[drop](#syntax-instr-parametric)[select](#syntax-instr-parametric) ([valtype](#syntax-valtype)∗)?​​

The nop instruction does nothing.

The unreachable instruction causes an unconditional [trap](#trap).

The drop instruction simply throws away a single operand.

The select instruction selects one of its first two operands based on whether its third operand is zero or not. It may include a [value type](#syntax-valtype) determining the type of these operands. If missing, the operands must be of [numeric](#syntax-numtype) or [vector](#syntax-vectype) type.

Note

In future versions of WebAssembly, the type annotation on select may allow for more than a single value being selected at the same time.

#### 2.4.2. Control Instructions[](#control-instructions①)

Instructions in this group affect the flow of control.

​[instr](#syntax-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…[block](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗[loop](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗[if](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗ [else](#syntax-instr-control) [instr](#syntax-instr)∗[br](#syntax-instr-control) [labelidx](#syntax-labelidx)[br\_if](#syntax-instr-control) [labelidx](#syntax-labelidx)[br\_table](#syntax-instr-control) [labelidx](#syntax-labelidx)∗ [labelidx](#syntax-labelidx)[br\_on\_null](#syntax-instr-control) [labelidx](#syntax-labelidx)[br\_on\_non\_null](#syntax-instr-control) [labelidx](#syntax-labelidx)[br\_on\_cast](#syntax-instr-control) [labelidx](#syntax-labelidx) [reftype](#syntax-reftype) [reftype](#syntax-reftype)[br\_on\_cast\_fail](#syntax-instr-control) [labelidx](#syntax-labelidx) [reftype](#syntax-reftype) [reftype](#syntax-reftype)[call](#syntax-instr-control) [funcidx](#syntax-funcidx)[call\_ref](#syntax-instr-control) [typeuse](#syntax-typeuse)[call\_indirect](#syntax-instr-control) [tableidx](#syntax-tableidx) [typeuse](#syntax-typeuse)[return](#syntax-instr-control)[return\_call](#syntax-instr-control) [funcidx](#syntax-funcidx)[return\_call\_ref](#syntax-instr-control) [typeuse](#syntax-typeuse)[return\_call\_indirect](#syntax-instr-control) [tableidx](#syntax-tableidx) [typeuse](#syntax-typeuse)[throw](#syntax-instr-control) [tagidx](#syntax-tagidx)[throw\_ref](#syntax-instr-control)[try\_table](#syntax-instr-control) [blocktype](#syntax-blocktype) [list](#syntax-list)([catch](#syntax-catch)) [instr](#syntax-instr)∗0.8ex\][catch\_ref](#syntax-instr-control) [tagidx](#syntax-tagidx) [labelidx](#syntax-labelidx)[catch\_all](#syntax-instr-control) [labelidx](#syntax-labelidx)[catch\_all\_ref](#syntax-instr-control) [labelidx](#syntax-labelidx)​[catch](#syntax-catch)​::=​[catch](#syntax-instr-control) [tagidx](#syntax-tagidx) [labelidx](#syntax-labelidx)​​

The block, loop, if and try\_table instructions are _structured_ instructions. They bracket nested sequences of instructions, called _blocks_. As the grammar prescribes, they must be well-nested.

A structured instruction can consume _input_ and produce _output_ on the operand stack according to its annotated [block type](#syntax-blocktype).

Each structured control instruction introduces an implicit _label_. Labels are targets for branch instructions that reference them with [label indices](#syntax-labelidx). Unlike with other [index spaces](#syntax-index), indexing of labels is relative by nesting depth, that is, label 0 refers to the innermost structured control instruction enclosing the referring branch instruction, while increasing indices refer to those farther out. Consequently, labels can only be referenced from _within_ the associated structured control instruction. This also implies that branches can only be directed outwards, “breaking” from the block of the control construct they target. The exact effect depends on that control construct. In case of block or if it is a _forward jump_, resuming execution after the end of the block. In case of loop it is a _backward jump_ to the beginning of the loop.

Note

This enforces _structured control flow_. Intuitively, a branch targeting a block or if behaves like a break statement in most C-like languages, while a branch targeting a loop behaves like a continue statement.

Branch instructions come in several flavors: br performs an unconditional branch, br\_if performs a conditional branch, and br\_table performs an indirect branch through an operand indexing into the label list that is an immediate to the instruction, or to a default target if the operand is out of bounds. The br\_on\_null and br\_on\_non\_null instructions check whether a reference operand is [null](#syntax-nullref) and branch if that is the case or not the case, respectively. Similarly, br\_on\_cast and br\_on\_cast\_fail attempt a downcast on a reference operand and branch if that succeeds, or fails, respectively.

The return instruction is a shortcut for an unconditional branch to the outermost block, which implicitly is the body of the current function. Taking a branch _unwinds_ the operand stack up to the height where the targeted structured control instruction was entered. However, branches may additionally consume operands themselves, which they push back on the operand stack after unwinding. Forward branches require operands according to the output of the targeted block’s type, i.e., represent the values produced by the terminated block. Backward branches require operands according to the input of the targeted block’s type, i.e., represent the values consumed by the restarted block.

The call instruction invokes another [function](#syntax-func), consuming the necessary arguments from the stack and returning the result values of the call. The call\_ref instruction invokes a function indirectly through a [function reference](#syntax-reftype) operand. The call\_indirect instruction calls a function indirectly through an operand indexing into a [table](#syntax-table) that is denoted by a [table index](#syntax-tableidx) and must contain [function references](#syntax-reftype). Since it may contain functions of heterogeneous type, the callee is dynamically checked against the [function type](#syntax-functype) indexed by the instruction’s second immediate, and the call is aborted with a [trap](#trap) if it does not match.

The return\_call, return\_call\_ref, and return\_call\_indirect instructions are _tail-call_ variants of the previous ones. That is, they first return from the current function before actually performing the respective call. It is guaranteed that no sequence of nested calls using only these instructions can cause resource exhaustion due to hitting an [implementation’s limit](#impl-exec) on the number of active calls.

The instructions throw, throw\_ref, and try\_table are concerned with _exceptions_. The throw and throw\_ref instructions raise and reraise an exception, respectively, and transfers control to the innermost enclosing exception handler that has a matching catch clause. The try\_table instruction installs an exception _handler_ that handles exceptions as specified by its catch clauses.

#### 2.4.3. Variable Instructions[](#variable-instructions①)

Variable instructions are concerned with access to [local](#syntax-local) or [global](#syntax-global) variables.

​[instr](#syntax-instr)​::=∣∣∣∣∣​…[local.get](#syntax-instr-variable) [localidx](#syntax-localidx)[local.set](#syntax-instr-variable) [localidx](#syntax-localidx)[local.tee](#syntax-instr-variable) [localidx](#syntax-localidx)[global.get](#syntax-instr-variable) [globalidx](#syntax-globalidx)[global.set](#syntax-instr-variable) [globalidx](#syntax-globalidx)​​

These instructions get or set the values of respective variables. The local.tee instruction is like local.set but also returns its argument.

#### 2.4.4. Table Instructions[](#table-instructions①)

Instructions in this group are concerned with tables [table](#syntax-table).

​[instr](#syntax-instr)​::=∣∣∣∣∣∣∣∣​…[table.get](#syntax-instr-table) [tableidx](#syntax-tableidx)[table.set](#syntax-instr-table) [tableidx](#syntax-tableidx)[table.size](#syntax-instr-table) [tableidx](#syntax-tableidx)[table.grow](#syntax-instr-table) [tableidx](#syntax-tableidx)[table.fill](#syntax-instr-table) [tableidx](#syntax-tableidx)[table.copy](#syntax-instr-table) [tableidx](#syntax-tableidx) [tableidx](#syntax-tableidx)[table.init](#syntax-instr-table) [tableidx](#syntax-tableidx) [elemidx](#syntax-elemidx)[elem.drop](#syntax-instr-table) [elemidx](#syntax-elemidx)​​

The table.get and table.set instructions load or store an element in a table, respectively.

The table.size instruction returns the current size of a table. The table.grow instruction grows table by a given delta and returns the previous size, or −1 if enough space cannot be allocated. It also takes an initialization value for the newly allocated entries.

The table.fill instruction sets all entries in a range to a given value. The table.copy instruction copies elements from a source table region to a possibly overlapping destination region; the first index denotes the destination. The table.init instruction copies elements from a [passive element segment](#syntax-elem) into a table.

The elem.drop instruction prevents further use of a passive element segment. This instruction is intended to be used as an optimization hint. After an element segment is dropped its elements can no longer be retrieved, so the memory used by this segment may be freed.

Note

An additional instruction that accesses a table is the [control instruction](#syntax-instr-control) call\_indirect.

#### 2.4.5. Memory Instructions[](#memory-instructions①)

Instructions in this group are concerned with linear [memory](#syntax-mem).

​[memarg](#syntax-memarg)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣​{[align](#syntax-instr-memory) [u32](#syntax-int),[offset](#syntax-instr-memory) [u64](#syntax-int)}​0.8ex\][sz](#syntax-sz)\_[splat](#syntax-instr-memory)[sz](#syntax-sz)\_[zero](#syntax-instr-memory)[numtype](#syntax-numtype).[load](#syntax-instr-memory)[loadop](#syntax-loadop)[numtype](#syntax-numtype)?​ [memidx](#syntax-memidx) [memarg](#syntax-memarg)[numtype](#syntax-numtype).[store](#syntax-instr-memory)[storeop](#syntax-storeop)[numtype](#syntax-numtype)?​ [memidx](#syntax-memidx) [memarg](#syntax-memarg)[vectype](#syntax-vectype).[load](#syntax-instr-memory)[vloadop](#syntax-vloadop)[vectype](#syntax-vectype)?​ [memidx](#syntax-memidx) [memarg](#syntax-memarg)[vectype](#syntax-vectype).[load](#syntax-instr-memory)[sz](#syntax-sz)\_[lane](#syntax-instr-memory) [memidx](#syntax-memidx) [memarg](#syntax-memarg) [laneidx](#syntax-laneidx)[vectype](#syntax-vectype).[store](#syntax-instr-memory) [memidx](#syntax-memidx) [memarg](#syntax-memarg)[vectype](#syntax-vectype).[store](#syntax-instr-memory)[sz](#syntax-sz)\_[lane](#syntax-instr-memory) [memidx](#syntax-memidx) [memarg](#syntax-memarg) [laneidx](#syntax-laneidx)[memory.size](#syntax-instr-memory) [memidx](#syntax-memidx)[memory.grow](#syntax-instr-memory) [memidx](#syntax-memidx)[memory.fill](#syntax-instr-memory) [memidx](#syntax-memidx)[memory.copy](#syntax-instr-memory) [memidx](#syntax-memidx) [memidx](#syntax-memidx)[memory.init](#syntax-instr-memory) [memidx](#syntax-memidx) [dataidx](#syntax-dataidx)[data.drop](#syntax-instr-memory) [dataidx](#syntax-dataidx)​[loadop](#syntax-loadop)[i](#syntax-numtype)[N](#syntax-numtype)​if [sz](#syntax-sz)≥320.8ex\]::=[instr](#syntax-instr)[sz](#syntax-sz)\_[sx](#syntax-sx)::=if [sz](#syntax-sz)<N0.8ex\]…[storeop](#syntax-storeop)[i](#syntax-numtype)[N](#syntax-numtype)​::=[sz](#syntax-sz)if [sz](#syntax-sz)<N0.8ex\][vloadop](#syntax-vloadop)[vectype](#syntax-vectype)​::=[sz](#syntax-sz)[x](#syntax-shape)M\_[sx](#syntax-sx)if [sz](#syntax-sz)⋅M\=∣[vectype](#syntax-vectype)∣/2​

Memory is accessed with load and store instructions for the different [number types](#syntax-numtype) and [vector types](#syntax-vectype). They all take a [memory index](#syntax-memidx) and a _memory argument_ [memarg](#syntax-memarg) that contains an address _offset_ and the expected _alignment_ (expressed as the exponent of a power of 2).

Integer loads and stores can optionally specify a _storage size_ [sz](#syntax-sz) that is smaller than the [bit width](#syntax-numtype) of the respective value type. In the case of loads, a sign extension mode [sx](#syntax-sx) is then required to select appropriate behavior.

Vector loads can specify a shape that is half the [bit width](#syntax-valtype) of v128. Each lane is half its usual size, and the sign extension mode [sx](#syntax-sx) then specifies how the smaller lane is extended to the larger lane. Alternatively, vector loads can perform a _splat_, such that only a single lane of the specified storage size is loaded, and the result is duplicated to all lanes.

The static address offset is added to the dynamic address operand, yielding a 33-bit or 65-bit _effective address_ that is the zero-based index at which the memory is accessed. All values are read and written in [little endian](https://en.wikipedia.org/wiki/Endianness#Little-endian) byte order. A [trap](#trap) results if any of the accessed memory bytes lies outside the address range implied by the memory’s current size.

The memory.size instruction returns the current size of a memory. The memory.grow instruction grows a memory by a given delta and returns the previous size, or −1 if enough memory cannot be allocated. Both instructions operate in units of [page size](#page-size).

The memory.fill instruction sets all values in a region of memory to a given byte. The memory.copy instruction copies data from a source memory region to a possibly overlapping destination region in another or the same memory; the first index denotes the destination. The memory.init instruction copies data from a [passive data segment](#syntax-data) into a memory.

The data.drop instruction prevents further use of a passive data segment. This instruction is intended to be used as an optimization hint. After a data segment is dropped its data can no longer be retrieved, so the memory used by this segment may be freed.

#### 2.4.6. Reference Instructions[](#reference-instructions①)

Instructions in this group are concerned with accessing [references](#syntax-reftype).

​[instr](#syntax-instr)​::=∣∣∣∣∣∣∣​…[ref.func](#syntax-instr-ref) [funcidx](#syntax-funcidx)[ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype)[ref.is\_null](#syntax-instr-ref)[ref.as\_non\_null](#syntax-instr-ref)[ref.eq](#syntax-instr-ref)[ref.test](#syntax-instr-ref) [reftype](#syntax-reftype)[ref.cast](#syntax-instr-ref) [reftype](#syntax-reftype)​​

The ref.null and ref.func instructions produce a [null](#syntax-nullref) reference or a reference to a given function, respectively.

The instruction ref.is\_null checks for null, while ref.as\_non\_null converts a [nullable](#syntax-reftype) to a non-null one, and [traps](#trap) if it encounters null.

The ref.eq compares two references.

The instructions ref.test and ref.cast test the [dynamic type](#type-inst) of a reference operand. The former merely returns the result of the test, while the latter performs a downcast and [traps](#trap) if the operand’s type does not match.

Note

The br\_on\_null and br\_on\_non\_null instructions provide versions of ref.as\_null that branch depending on the success of failure of a null test instead of trapping. Similarly, the br\_on\_cast and br\_on\_cast\_fail instructions provides versions of ref.cast that branch depending on the success of the downcast instead of trapping.

An additional instruction operating on function references is the [control instruction](#syntax-instr-control) call\_ref.

#### 2.4.7. Aggregate Instructions[](#aggregate-instructions①)

Instructions in this group are concerned with creating and accessing [references](#syntax-reftype) to [aggregate](#syntax-aggrtype) types.

​[instr](#syntax-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…[struct.new](#syntax-instr-struct) [typeidx](#syntax-typeidx)[struct.new\_default](#syntax-instr-struct) [typeidx](#syntax-typeidx)[struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? [typeidx](#syntax-typeidx) [u32](#syntax-int)[struct.set](#syntax-instr-struct) [typeidx](#syntax-typeidx) [u32](#syntax-int)[array.new](#syntax-instr-array) [typeidx](#syntax-typeidx)[array.new\_default](#syntax-instr-array) [typeidx](#syntax-typeidx)[array.new\_fixed](#syntax-instr-array) [typeidx](#syntax-typeidx) [u32](#syntax-int)[array.new\_data](#syntax-instr-array) [typeidx](#syntax-typeidx) [dataidx](#syntax-dataidx)[array.new\_elem](#syntax-instr-array) [typeidx](#syntax-typeidx) [elemidx](#syntax-elemidx)[array.get](#syntax-instr-array)\_[sx](#syntax-sx)? [typeidx](#syntax-typeidx)[array.set](#syntax-instr-array) [typeidx](#syntax-typeidx)[array.len](#syntax-instr-array)[array.fill](#syntax-instr-array) [typeidx](#syntax-typeidx)[array.copy](#syntax-instr-array) [typeidx](#syntax-typeidx) [typeidx](#syntax-typeidx)[array.init\_data](#syntax-instr-array) [typeidx](#syntax-typeidx) [dataidx](#syntax-dataidx)[array.init\_elem](#syntax-instr-array) [typeidx](#syntax-typeidx) [elemidx](#syntax-elemidx)[ref.i31](#syntax-instr-i31)[i31.get](#syntax-instr-i31)\_[sx](#syntax-sx)[extern.convert\_any](#syntax-instr-extern)[any.convert\_extern](#syntax-instr-extern)​​

The instructions struct.new and struct.new\_default allocate a new [structure](#syntax-structtype), initializing them either with operands or with default values. The remaining instructions on structs access individual fields, allowing for different sign extension modes in the case of [packed](#syntax-packtype) storage types.

Similarly, [arrays](#syntax-arraytype) can be allocated either with an explicit initialization operand or a default value. Furthermore, array.new\_fixed allocates an array with statically fixed size, and array.new\_data and array.new\_elem allocate an array and initialize it from a [data](#syntax-data) or [element](#syntax-elem) segment, respectively. The instructions array.get, array.get [sx](#syntax-sx), and array.set access individual slots, again allowing for different sign extension modes in the case of a [packed](#syntax-packtype) storage type; array.len produces the length of an array; array.fill fills a specified slice of an array with a given value and array.copy, array.init\_data, and array.init\_elem copy elements to a specified slice of an array from a given array, data segment, or element segment, respectively.

The instructions ref.i31 and i31.get [sx](#syntax-sx) convert between type i32 and an unboxed [scalar](#syntax-i31).

The instructions any.convert\_extern and extern.convert\_any allow lossless conversion between references represented as type ([ref](#syntax-reftype) [null](#syntax-reftype) [extern](#syntax-heaptype)) and as ([ref](#syntax-reftype) [null](#syntax-reftype) [any](#syntax-heaptype)).

#### 2.4.8. Numeric Instructions[](#numeric-instructions①)

Numeric instructions provide basic operations over numeric [values](#syntax-value) of specific [type](#syntax-numtype). These operations closely match respective operations available in hardware.

​[sz](#syntax-sz)[sx](#syntax-sx)[num](#syntax-num)[f](#syntax-numtype)[N](#syntax-numtype)​[unop](#syntax-unop)[f](#syntax-numtype)[N](#syntax-numtype)​[binop](#syntax-binop)[f](#syntax-numtype)[N](#syntax-numtype)​[relop](#syntax-relop)[f](#syntax-numtype)[N](#syntax-numtype)​[cvtop](#syntax-cvtop)[i](#syntax-numtype)[N](#syntax-numtype)1​,[f](#syntax-numtype)[N](#syntax-numtype)2​​[cvtop](#syntax-cvtop)[f](#syntax-numtype)[N](#syntax-numtype)1​,[i](#syntax-numtype)[N](#syntax-numtype)2​​[cvtop](#syntax-cvtop)[f](#syntax-numtype)[N](#syntax-numtype)1​,[f](#syntax-numtype)[N](#syntax-numtype)2​​​::=::=::=∣∣∣∣∣∣::=∣::=::=∣::=∣::=∣∣::=∣​8 ∣ 16 ∣ 32 ∣ 64[u](#syntax-sx) ∣ [s](#syntax-sx)0.8ex\][f](#syntax-float)N0.8ex\][numtype](#syntax-numtype).[const](#syntax-instr-numeric) [num](#syntax-num)[numtype](#syntax-numtype)​[numtype](#syntax-numtype).[unop](#syntax-unop)[numtype](#syntax-numtype)​[numtype](#syntax-numtype).[binop](#syntax-binop)[numtype](#syntax-numtype)​[numtype](#syntax-numtype).[testop](#syntax-testop)[numtype](#syntax-numtype)​[numtype](#syntax-numtype).[relop](#syntax-relop)[numtype](#syntax-numtype)​[numtype](#syntax-numtype)1​.[cvtop](#syntax-cvtop)[numtype](#syntax-numtype)2​,[numtype](#syntax-numtype)1​​\_[numtype](#syntax-numtype)2​0.8ex\][abs](#syntax-instr-numeric) ∣ [neg](#syntax-instr-numeric) ∣ [sqrt](#syntax-instr-numeric) ∣ [ceil](#syntax-instr-numeric) ∣ [floor](#syntax-instr-numeric) ∣ [trunc](#syntax-instr-numeric) ∣ [nearest](#syntax-instr-numeric)0.8ex\][and](#syntax-instr-numeric) ∣ [or](#syntax-instr-numeric) ∣ [xor](#syntax-instr-numeric) ∣ [shl](#syntax-instr-numeric) ∣ [shr](#syntax-instr-numeric)\_[sx](#syntax-sx) ∣ [rotl](#syntax-instr-numeric) ∣ [rotr](#syntax-instr-numeric)[add](#syntax-instr-numeric) ∣ [sub](#syntax-instr-numeric) ∣ [mul](#syntax-instr-numeric) ∣ [div](#syntax-instr-numeric) ∣ [min](#syntax-instr-numeric) ∣ [max](#syntax-instr-numeric) ∣ [copysign](#syntax-instr-numeric)0.8ex\][eq](#syntax-instr-numeric) ∣ [ne](#syntax-instr-numeric) ∣ [lt](#syntax-instr-numeric) ∣ [gt](#syntax-instr-numeric) ∣ [le](#syntax-instr-numeric) ∣ [ge](#syntax-instr-numeric)0.8ex\][wrap](#syntax-instr-numeric)[convert](#syntax-instr-numeric)\_[sx](#syntax-sx)[reinterpret](#syntax-instr-numeric)[trunc](#syntax-instr-numeric)\_[sx](#syntax-sx)[trunc\_sat](#syntax-instr-numeric)\_[sx](#syntax-sx)[reinterpret](#syntax-instr-numeric)[promote](#syntax-instr-numeric)[demote](#syntax-instr-numeric)​[num](#syntax-num)[i](#syntax-numtype)[N](#syntax-numtype)​[instr](#syntax-instr)[unop](#syntax-unop)[i](#syntax-numtype)[N](#syntax-numtype)​[binop](#syntax-binop)[i](#syntax-numtype)[N](#syntax-numtype)​[testop](#syntax-testop)[i](#syntax-numtype)[N](#syntax-numtype)​[cvtop](#syntax-cvtop)[i](#syntax-numtype)[N](#syntax-numtype)1​,[i](#syntax-numtype)[N](#syntax-numtype)2​​if N1​\>N2​if N1​\=N2​if N1​\=N2​if N1​<N2​if N1​\>N2​​::=::=::=::=::=::=​[i](#syntax-int)N…[clz](#syntax-instr-numeric) ∣ [ctz](#syntax-instr-numeric) ∣ [popcnt](#syntax-instr-numeric) ∣ [extend](#syntax-instr-numeric)[sz](#syntax-sz)\_[s](#syntax-sx)[add](#syntax-instr-numeric) ∣ [sub](#syntax-instr-numeric) ∣ [mul](#syntax-instr-numeric) ∣ [div](#syntax-instr-numeric)\_[sx](#syntax-sx) ∣ [rem](#syntax-instr-numeric)\_[sx](#syntax-sx)[eqz](#syntax-instr-numeric)0.8ex\][extend](#syntax-instr-numeric)\_[sx](#syntax-sx)​if [sz](#syntax-sz)<N[relop](#syntax-relop)[i](#syntax-numtype)[N](#syntax-numtype)​if N1​<N2​​::=​[eq](#syntax-instr-numeric) ∣ [ne](#syntax-instr-numeric) ∣ [lt](#syntax-instr-numeric)\_[sx](#syntax-sx) ∣ [gt](#syntax-instr-numeric)\_[sx](#syntax-sx) ∣ [le](#syntax-instr-numeric)\_[sx](#syntax-sx) ∣ [ge](#syntax-instr-numeric)\_[sx](#syntax-sx)​​

Numeric instructions are divided by [number type](#syntax-numtype). For each type, several subcategories can be distinguished:

*   _Constants_: return a static constant.
    
*   _Unary operations_: consume one operand and produce one result of the respective type.
    
*   _Binary operations_: consume two operands and produce one result of the respective type.
    
*   _Tests_: consume one operand of the respective type and produce a Boolean integer result.
    
*   _Comparisons_: consume two operands of the respective type and produce a Boolean integer result.
    
*   _Conversions_: consume a value of one type and produce a result of another (the source type of the conversion is the one after the “\_”).
    

Some integer instructions come in two flavors, where a signedness annotation [sx](#syntax-sx) distinguishes whether the operands are to be [interpreted](#aux-signed) as [unsigned](#syntax-uint) or [signed](#syntax-sint) integers. For the other integer instructions, the use of two’s complement for the signed interpretation means that they behave the same regardless of signedness.

#### 2.4.9. Vector Instructions[](#vector-instructions①)

Vector instructions (also known as _SIMD_ instructions, _single instruction multiple data_) provide basic operations over [values](#syntax-value) of [vector type](#syntax-vectype).

​[lanetype](#syntax-lanetype)[dim](#syntax-dim)[shape](#syntax-shape)[ishape](#syntax-shape)[bshape](#syntax-shape)​::=::=::=::=::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​[numtype](#syntax-numtype) ∣ [packtype](#syntax-packtype)1 ∣ 2 ∣ 4 ∣ 8 ∣ 16[lanetype](#syntax-lanetype)[x](#syntax-shape)[dim](#syntax-dim)[shape](#syntax-shape)[shape](#syntax-shape)[vectype](#syntax-vectype).[const](#syntax-instr-numeric) [vec](#syntax-vec)[vectype](#syntax-vectype)​[vectype](#syntax-vectype).[vvunop](#syntax-vvunop)[vectype](#syntax-vectype).[vvbinop](#syntax-vvbinop)[vectype](#syntax-vectype).[vvternop](#syntax-vvternop)[vectype](#syntax-vectype).[vvtestop](#syntax-vvtestop)[shape](#syntax-shape).[vunop](#syntax-vunop)[shape](#syntax-shape)​[shape](#syntax-shape).[vbinop](#syntax-vbinop)[shape](#syntax-shape)​[shape](#syntax-shape).[vternop](#syntax-vternop)[shape](#syntax-shape)​[shape](#syntax-shape).[vtestop](#syntax-vrelop)[shape](#syntax-shape)​[shape](#syntax-shape).[vrelop](#syntax-vrelop)[shape](#syntax-shape)​[ishape](#syntax-shape).[vshiftop](#syntax-vshiftop)[ishape](#syntax-shape)​[ishape](#syntax-shape).[bitmask](#syntax-instr-vec)[bshape](#syntax-shape).[vswizzlop](#syntax-vswizzlop)[bshape](#syntax-shape)​[bshape](#syntax-shape).[shuffle](#syntax-instr-vec) [laneidx](#syntax-laneidx)∗[ishape](#syntax-shape)1​.[vextunop](#syntax-vextunop)[ishape](#syntax-shape)2​,[ishape](#syntax-shape)1​​\_[ishape](#syntax-shape)2​[ishape](#syntax-shape)1​.[vextbinop](#syntax-vextbinop)[ishape](#syntax-shape)2​,[ishape](#syntax-shape)1​​\_[ishape](#syntax-shape)2​[ishape](#syntax-shape)1​.[vextternop](#syntax-vextternop)[ishape](#syntax-shape)2​,[ishape](#syntax-shape)1​​\_[ishape](#syntax-shape)2​[ishape](#syntax-shape)1​.[narrow](#syntax-instr-vec)\_[ishape](#syntax-shape)2​\_[sx](#syntax-sx)[shape](#syntax-shape)1​.[vcvtop](#syntax-vcvtop)[shape](#syntax-shape)2​,[shape](#syntax-shape)1​​\_[shape](#syntax-shape)2​[shape](#syntax-shape).[splat](#syntax-instr-vec)[shape](#syntax-shape).[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx)? [laneidx](#syntax-laneidx)[shape](#syntax-shape).[replace\_lane](#syntax-instr-vec) [laneidx](#syntax-laneidx)​if ∣[lanetype](#syntax-lanetype)∣⋅[dim](#syntax-dim)\=128if [lanetype](#aux-lanetype)([shape](#syntax-shape))\=[i](#syntax-numtype)[N](#syntax-numtype)if [lanetype](#aux-lanetype)([shape](#syntax-shape))\=[i8](#syntax-storagetype)0.8ex\]if ∣[laneidx](#syntax-laneidx)∗∣\=[dim](#aux-dim)([bshape](#syntax-shape))if ∣[lanetype](#aux-lanetype)([ishape](#syntax-shape)2​)∣\=2⋅∣[lanetype](#aux-lanetype)([ishape](#syntax-shape)1​)∣≤32if [sx](#syntax-sx)?\=ϵ⇔[lanetype](#aux-lanetype)([shape](#syntax-shape))∈[i32](#syntax-numtype) [i64](#syntax-numtype) [f32](#syntax-numtype) [f64](#syntax-numtype)​[half](#syntax-half)::=[low](#syntax-instr-vec) ∣ [high](#syntax-instr-vec)0.8ex\][zero](#syntax-zero)::=[zero](#syntax-instr-vec)0.8ex\][laneidx](#syntax-laneidx)::=[u8](#syntax-int)0.8ex\][instr](#syntax-instr)::=…​

Vector instructions have a naming convention involving a _shape_ prefix that determines how their operands will be interpreted, written txN, and consisting of a _lane type_ t, a possibly _packed_ [numeric type](#syntax-numtype), and its _dimension_ N, which denotes the number of lanes of that type. Operations are performed point-wise on the values of each lane.

Instructions prefixed with v128 do not involve a specific interpretation, and treat the v128 as either an [i128](#syntax-int) value or a vector of 128 individual bits.

Note

For example, the shape [i32](#syntax-numtype)[x](#syntax-shape)4 interprets the operand as four [i32](#syntax-int) values, packed into an [i128](#syntax-int). The bit width of the lane type t times N always is 128.

​[vvunop](#syntax-vvunop)[vunop](#syntax-vunop)[f](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vbinop](#syntax-vbinop)[f](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vternop](#syntax-vternop)[f](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vrelop](#syntax-vrelop)[f](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vcvtop](#syntax-vcvtop)[i](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[f](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​[vcvtop](#syntax-vcvtop)[f](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[i](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​[vcvtop](#syntax-vcvtop)[f](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[f](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​​::=∣::=∣∣∣∣∣∣∣∣∣::=∣::=∣∣∣∣::=∣∣::=::=∣::=∣​[not](#syntax-instr-vec)0.8ex\][popcnt](#syntax-instr-vec)[abs](#syntax-instr-vec) ∣ [neg](#syntax-instr-vec) ∣ [sqrt](#syntax-instr-vec) ∣ [ceil](#syntax-instr-vec) ∣ [floor](#syntax-instr-vec) ∣ [trunc](#syntax-instr-vec) ∣ [nearest](#syntax-instr-vec)0.8ex\][sub](#syntax-instr-vec)[add\_sat](#syntax-instr-vec)\_[sx](#syntax-sx)[sub\_sat](#syntax-instr-vec)\_[sx](#syntax-sx)[mul](#syntax-instr-vec)[avgr](#syntax-instr-vec)\_[u](#syntax-sx)[q15mulr\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[relaxed\_q15mulr](#syntax-instr-vec)\_[s](#syntax-sx)[min](#syntax-instr-vec)\_[sx](#syntax-sx)[max](#syntax-instr-vec)\_[sx](#syntax-sx)[add](#syntax-instr-vec) ∣ [sub](#syntax-instr-vec) ∣ [mul](#syntax-instr-vec) ∣ [div](#syntax-instr-vec) ∣ [min](#syntax-instr-vec) ∣ [max](#syntax-instr-vec) ∣ [pmin](#syntax-instr-vec) ∣ [pmax](#syntax-instr-vec)[relaxed\_min](#syntax-instr-vec) ∣ [relaxed\_max](#syntax-instr-vec)0.8ex\][relaxed\_madd](#syntax-instr-vec) ∣ [relaxed\_nmadd](#syntax-instr-vec)0.8ex\][lt](#syntax-instr-vec)\_[sx](#syntax-sx)[gt](#syntax-instr-vec)\_[sx](#syntax-sx)[le](#syntax-instr-vec)\_[sx](#syntax-sx)[ge](#syntax-instr-vec)\_[sx](#syntax-sx)[eq](#syntax-instr-vec) ∣ [ne](#syntax-instr-vec) ∣ [lt](#syntax-instr-vec) ∣ [gt](#syntax-instr-vec) ∣ [le](#syntax-instr-vec) ∣ [ge](#syntax-instr-vec)0.8ex\][dot](#syntax-instr-vec)\_[s](#syntax-sx)[relaxed\_dot](#syntax-instr-vec)\_[s](#syntax-sx)[convert](#syntax-instr-vec)\_[half](#syntax-half)?\_[sx](#syntax-sx)[trunc\_sat](#syntax-instr-vec)\_[sx](#syntax-sx)\_[zero](#syntax-zero)?[relaxed\_trunc](#syntax-instr-vec)\_[sx](#syntax-sx)\_[zero](#syntax-zero)?[demote](#syntax-instr-vec)\_[zero](#syntax-instr-vec)[promote](#syntax-instr-vec)\_[low](#syntax-instr-vec)​[vvbinop](#syntax-vvbinop)if N\=8[vbinop](#syntax-vbinop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​if N≤16if N≤16if N≥16if N≤16if N\=16if N\=16if N≤32if N≤32[vternop](#syntax-vternop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vtestop](#syntax-vrelop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​if N\=64∨[sx](#syntax-sx)\=[s](#syntax-sx)if N\=64∨[sx](#syntax-sx)\=[s](#syntax-sx)if N\=64∨[sx](#syntax-sx)\=[s](#syntax-sx)if N\=64∨[sx](#syntax-sx)\=[s](#syntax-sx)[vswizzlop](#syntax-vswizzlop)[i8](#syntax-storagetype)[x](#syntax-shape)M​if 2⋅N1​\=N2​\=32if 2⋅N1​\=N2​\=160.8ex\]if N2​\=N1​\=32∧[half](#syntax-half)?\=ϵ∨N2​\=2⋅N1​∧[half](#syntax-half)?\=[low](#syntax-instr-vec)if N1​\=N2​\=32∧[zero](#syntax-zero)?\=ϵ∨N1​\=2⋅N2​∧[zero](#syntax-zero)?\=[zero](#syntax-instr-vec)if N1​\=N2​\=32∧[zero](#syntax-zero)?\=ϵ∨N1​\=2⋅N2​∧[zero](#syntax-zero)?\=[zero](#syntax-instr-vec)if N1​\=2⋅N2​if 2⋅N1​\=N2​​::=::=::=::=::=[vextternop](#syntax-vextternop)[i](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[i](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​​[and](#syntax-instr-vec) ∣ [andnot](#syntax-instr-vec) ∣ [or](#syntax-instr-vec) ∣ [xor](#syntax-instr-vec)0.8ex\][add](#syntax-instr-vec)[relaxed\_laneselect](#syntax-instr-vec)[all\_true](#syntax-instr-vec)0.8ex\][swizzle](#syntax-instr-vec) ∣ [relaxed\_swizzle](#syntax-instr-vec)0.8ex\]::=​[vvternop](#syntax-vvternop)[vrelop](#syntax-vrelop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vshiftop](#syntax-vshiftop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[relaxed\_dot\_add](#syntax-instr-vec)\_[s](#syntax-sx)​::=::=::=if 4⋅N1​\=N2​\=320.8ex\]​[bitselect](#syntax-instr-vec)0.8ex\][eq](#syntax-instr-vec) ∣ [ne](#syntax-instr-vec)[shl](#syntax-instr-vec) ∣ [shr](#syntax-instr-vec)\_[sx](#syntax-sx)0.8ex\][vcvtop](#syntax-vcvtop)[i](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[i](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​​[vvtestop](#syntax-vvtestop)[vextunop](#syntax-vextunop)[i](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[i](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​::=​::=::=[extend](#syntax-instr-vec)\_[half](#syntax-half)\_[sx](#syntax-sx)​[any\_true](#syntax-instr-vec)0.8ex\][extadd\_pairwise](#syntax-instr-vec)\_[sx](#syntax-sx)if N2​\=2⋅N1​​[vunop](#syntax-vunop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​if 16≤2⋅N1​\=N2​≤320.8ex\]​::=[vextbinop](#syntax-vextbinop)[i](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[i](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​​[abs](#syntax-instr-vec) ∣ [neg](#syntax-instr-vec)::=​[extmul](#syntax-instr-vec)\_[half](#syntax-half)\_[sx](#syntax-sx)​if 2⋅N1​\=N2​≥16​​

Vector instructions can be grouped into several subcategories:

*   _Constants_: return a static constant.
    
*   _Unary Operations_: consume one v128 operand and produce one v128 result.
    
*   _Binary Operations_: consume two v128 operands and produce one v128 result.
    
*   _Ternary Operations_: consume three v128 operands and produce one v128 result.
    
*   _Tests_: consume one v128 operand and produce a Boolean integer result.
    
*   _Shifts_: consume a v128 operand and an i32 operand, producing one v128 result.
    
*   _Splats_: consume a value of numeric type and produce a v128 result of a specified shape.
    
*   _Extract lanes_: consume a v128 operand and return the numeric value in a given lane.
    
*   _Replace lanes_: consume a v128 operand and a numeric value for a given lane, and produce a v128 result.
    

Some vector instructions have a signedness annotation [sx](#syntax-sx) which distinguishes whether the elements in the operands are to be [interpreted](#aux-signed) as [unsigned](#syntax-uint) or [signed](#syntax-sint) integers. For the other vector instructions, the use of two’s complement for the signed interpretation means that they behave the same regardless of signedness.

##### 2.4.9.1. Conventions[](#conventions①⑤)

*   The function [lanetype](#aux-lanetype)([shape](#syntax-shape)) extracts the lane type of a shape.
    
*   The function [dim](#aux-dim)([shape](#syntax-shape)) extracts the dimension of a shape.
    
*   The function [zeroop](#aux-zeroop)([vcvtop](#syntax-vcvtop)) extracts the zero flag from a vector conversion operator, or returns ϵ if it does not contain any.
    
*   The function [halfop](#aux-halfop)([vcvtop](#syntax-vcvtop)) extracts the [half](#syntax-half) flag from a vector conversion operator, or returns ϵ if it does not contain any.
    

#### 2.4.10. Expressions[](#expressions①)

[Function](#syntax-func) bodies, initialization values for [globals](#syntax-global), elements and offsets of [element](#syntax-elem) segments, and offsets of [data](#syntax-data) segments are given as expressions, which are sequences of [instructions](#syntax-instr).

​[expr](#syntax-expr)​::=​[instr](#syntax-instr)∗​​

In some places, validation [restricts](#valid-constant) expressions to be _constant_, which limits the set of allowable instructions.

### 2.5. Modules[](#modules①)

WebAssembly programs are organized into _modules_, which are the unit of deployment, loading, and compilation. A module collects definitions for [types](#syntax-type), [tags](#syntax-tag), and [globals](#syntax-global), [memories](#syntax-mem), [tables](#syntax-table), [functions](#syntax-func). In addition, it can declare [imports](#syntax-import) and [exports](#syntax-export) and provide initialization in the form of [data](#syntax-data) and [element](#syntax-elem) segments, or a [start function](#syntax-start).

​[module](#syntax-module)​::=​[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗​​

Each of the lists — and thus the entire module — may be empty.

#### 2.5.1. Indices[](#indices①)

Definitions are referenced with zero-based _indices_. Each class of definition has its own _index space_, as distinguished by the following classes.

​[idx](#syntax-idx)[typeidx](#syntax-typeidx)[funcidx](#syntax-funcidx)[globalidx](#syntax-globalidx)[tableidx](#syntax-tableidx)[memidx](#syntax-memidx)[tagidx](#syntax-tagidx)[elemidx](#syntax-elemidx)[dataidx](#syntax-dataidx)[labelidx](#syntax-labelidx)[localidx](#syntax-localidx)[fieldidx](#syntax-fieldidx)​::=::=::=::=::=::=::=::=::=::=::=::=​[u32](#syntax-int)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)​​

The index space for [tags](#syntax-tag), [globals](#syntax-global), [memories](#syntax-mem), [tables](#syntax-table), and [functions](#syntax-func) includes respective [imports](#syntax-import) declared in the same module. The indices of these imports precede the indices of other definitions in the same index space.

Data indices reference [data segments](#syntax-data) and element indices reference [element segments](#syntax-elem).

The index space for [locals](#syntax-local) is only accessible inside a [function](#syntax-func) and includes the parameters of that function, which precede the local variables.

Label indices reference [structured control instructions](#syntax-instr-control) inside an instruction sequence.

Each [aggregate type](#syntax-aggrtype) provides an index space for its [fields](#syntax-fieldtype).

##### 2.5.1.1. Conventions[](#conventions①⑦)

*   The meta variable l ranges over label indices.
    
*   The meta variables x, y range over indices in any of the other index spaces.
    

*   For every index space abcidx, the notation abcidx(A) denotes the set of indices from that index space occurring free in A. Sometimes this set is reinterpreted as the [list](#syntax-list) of its elements.
    

Note

For example, if [instr](#syntax-instr)∗ is ([data.drop](#syntax-instr-memory) 1) ([memory.init](#syntax-instr-memory) 2 3), then dataidxinstrs​([instr](#syntax-instr)∗)\=1 3, or equivalently, the set {1,3}.

#### 2.5.2. Types[](#types③)

The [type](#syntax-rectype) section of a module defines a list of [recursive types](#syntax-rectype), each consisting of a list of [sub types](#syntax-subtype) referenced by individual [type indices](#syntax-typeidx). All [function](#syntax-functype), [structure](#syntax-structtype), or [array](#syntax-arraytype) types used in a module must be defined in this section.

​[type](#syntax-rectype)​::=​[type](#syntax-type) [rectype](#syntax-rectype)​​

#### 2.5.3. Tags[](#tags①)

The [tag](#syntax-tag) section of a module defines a list of _tags_:

​[tag](#syntax-tag)​::=​[tag](#syntax-tag) [tagtype](#syntax-tagtype)​​

The [type index](#syntax-typeidx) of a tag must refer to a [function type](#syntax-functype) that declares its [tag type](#syntax-tagtype).

Tags are referenced through [tag indices](#syntax-tagidx), starting with the smallest index not referencing a tag [import](#syntax-import).

#### 2.5.4. Globals[](#globals①)

The [global](#syntax-global) section of a module defines a list of _global variables_ (or _globals_ for short):

​[global](#syntax-global)​::=​[global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)​​

Each global stores a single value of the type specified in the [global type](#syntax-globaltype). It also specifies whether a global is immutable or mutable. Moreover, each global is initialized with a value given by a [constant](#valid-constant) initializer [expression](#syntax-expr).

Globals are referenced through [global indices](#syntax-globalidx), starting with the smallest index not referencing a global [import](#syntax-import).

#### 2.5.5. Memories[](#memories①)

The [mem](#syntax-mem) section of a module defines a list of _linear memories_ (or _memories_ for short) as described by their [memory type](#syntax-memtype):

​[mem](#syntax-mem)​::=​[memory](#syntax-mem) [memtype](#syntax-memtype)​​

A memory is a list of raw uninterpreted bytes. The minimum size in the [limits](#syntax-limits) of its [memory type](#syntax-memtype) specifies the initial size of that memory, while its maximum, if present, restricts the size to which it can grow later. Both are in units of [page size](#page-size).

Memories can be initialized through [data segments](#syntax-data).

Memories are referenced through [memory indices](#syntax-memidx), starting with the smallest index not referencing a memory [import](#syntax-import). Most constructs implicitly reference memory index 0.

#### 2.5.6. Tables[](#tables①)

The [table](#syntax-table) section of a module defines a list of _tables_ described by their [table type](#syntax-tabletype):

​[table](#syntax-table)​::=​[table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)​​

A table is an array of opaque values of a particular [reference type](#syntax-reftype) that is specified by the [table type](#syntax-tabletype). Each table slot is initialized with a value given by a [constant](#valid-constant) initializer [expression](#syntax-expr). Tables can further be initialized through [element segments](#syntax-elem).

The minimum size in the [limits](#syntax-limits) of the table type specifies the initial size of that table, while its maximum restricts the size to which it can grow later.

Tables are referenced through [table indices](#syntax-tableidx), starting with the smallest index not referencing a table [import](#syntax-import). Most constructs implicitly reference table index 0.

#### 2.5.7. Functions[](#functions①)

The [func](#syntax-func) section of a module defines a list of _functions_ with the following structure:

​[func](#syntax-func)[local](#syntax-local)​::=::=​[func](#syntax-func) [typeidx](#syntax-typeidx) [local](#syntax-local)∗ [expr](#syntax-expr)[local](#syntax-local) [valtype](#syntax-valtype)​​

The [type index](#syntax-typeidx) of a function declares its signature by reference to a [function type](#syntax-functype) defined in the module. The parameters of the function are referenced through 0-based [local indices](#syntax-localidx) in the function’s body; they are mutable.

The locals declare a list of mutable local variables and their types. These variables are referenced through [local indices](#syntax-localidx) in the function’s body. The index of the first local is the smallest index not referencing a parameter.

A function’s [expression](#syntax-expr) is an [instruction](#syntax-instr) sequence that represents the body of the function. Upon termination it must produce a stack matching the function type’s [result type](#syntax-resulttype).

Functions are referenced through [function indices](#syntax-funcidx), starting with the smallest index not referencing a function [import](#syntax-import).

#### 2.5.8. Data Segments[](#data-segments①)

The [data](#syntax-data) section of a module defines a list of _data segments_, which can be used to initialize a range of memory from a static [list](#syntax-list) of [bytes](#syntax-byte).

​[data](#syntax-data)[datamode](#syntax-datamode)​::=::=​[data](#syntax-data) [byte](#syntax-byte)∗ [datamode](#syntax-datamode)[active](#syntax-datamode) [memidx](#syntax-memidx) [expr](#syntax-expr) ∣ [passive](#syntax-datamode)​​

Similar to element segments, data segments have a mode that identifies them as either _active_ or _passive_. A passive data segment’s contents can be copied into a memory using the memory.init instruction. An active data segment copies its contents into a memory during [instantiation](#exec-instantiation), as specified by a [memory index](#syntax-memidx) and a [constant](#valid-constant) [expression](#syntax-expr) defining an offset into that memory.

Data segments are referenced through [data indices](#syntax-dataidx).

#### 2.5.9. Element Segments[](#element-segments①)

The [elem](#syntax-elem) section of a module defines a list of _element segments_, which can be used to initialize a subrange of a table from a static [list](#syntax-list) of elements.

​[elem](#syntax-elem)[elemmode](#syntax-elemmode)​::=::=​[elem](#syntax-elem) [reftype](#syntax-reftype) [expr](#syntax-expr)∗ [elemmode](#syntax-elemmode)[active](#syntax-elemmode) [tableidx](#syntax-tableidx) [expr](#syntax-expr) ∣ [passive](#syntax-elemmode) ∣ [declare](#syntax-elemmode)​​

Each element segment defines a [reference type](#syntax-reftype) and a corresponding list of [constant](#valid-constant) element [expressions](#syntax-expr).

Element segments have a mode that identifies them as either _active_, _passive_, or _declarative_. A passive element segment’s elements can be copied to a table using the table.init instruction. An active element segment copies its elements into a table during [instantiation](#exec-instantiation), as specified by a [table index](#syntax-tableidx) and a [constant](#valid-constant) [expression](#syntax-expr) defining an offset into that table. A declarative element segment is not available at runtime but merely serves to forward-declare references that are formed in code with instructions like ref.func. The offset is given by another [constant](#valid-constant) [expression](#syntax-expr).

Element segments are referenced through [element indices](#syntax-elemidx).

#### 2.5.10. Start Function[](#start-function①)

The [start](#syntax-start) section of a module declares the [function index](#syntax-funcidx) of a _start function_ that is automatically invoked when the module is [instantiated](#exec-instantiation), after [tables](#syntax-table) and [memories](#syntax-mem) have been initialized.

​[start](#syntax-start)​::=​[start](#syntax-start) [funcidx](#syntax-funcidx)​​

Note

The start function is intended for initializing the state of a module. The module and its exports are not accessible externally before this initialization has completed.

#### 2.5.11. Imports[](#imports①)

The [import](#syntax-import) section of a module defines a set of _imports_ that are required for [instantiation](#exec-instantiation).

​[import](#syntax-import)​::=​[import](#syntax-import) [name](#syntax-name) [name](#syntax-name) [externtype](#syntax-externtype)​​

Each import is labeled by a two-level [name](#syntax-name) space, consisting of a _module name_ and an _item name_ for an entity within that module. Importable definitions are [tags](#syntax-tag), [globals](#syntax-global), [memories](#syntax-mem), [tables](#syntax-table), and [functions](#syntax-func). Each import is specified by a respective [external type](#syntax-externtype) that a definition provided during instantiation is required to match.

Every import defines an index in the respective [index space](#syntax-index). In each index space, the indices of imports go before the first index of any definition contained in the module itself.

Note

Unlike export names, import names are not necessarily unique. It is possible to import the same module/item name pair multiple times; such imports may even have different type descriptions, including different kinds of entities. A module with such imports can still be instantiated depending on the specifics of how an [embedder](#embedder) allows resolving and supplying imports. However, embedders are not required to support such overloading, and a WebAssembly module itself cannot implement an overloaded name.

#### 2.5.12. Exports[](#exports①)

The [export](#syntax-export) section of a module defines a set of _exports_ that become accessible to the host environment once the module has been [instantiated](#exec-instantiation).

​[export](#syntax-export)​::=​[export](#syntax-export) [name](#syntax-name) [externidx](#syntax-externidx)0.8ex\]​[externidx](#syntax-externidx)​::=​[func](#syntax-externidx) [funcidx](#syntax-funcidx) ∣ [global](#syntax-externidx) [globalidx](#syntax-globalidx) ∣ [table](#syntax-externidx) [tableidx](#syntax-tableidx) ∣ [memory](#syntax-externidx) [memidx](#syntax-memidx) ∣ [tag](#syntax-externidx) [tagidx](#syntax-tagidx)​​

Each export is labeled by a unique [name](#syntax-name). Exportable definitions are [tags](#syntax-tag), [globals](#syntax-global), [memories](#syntax-mem), [tables](#syntax-table), and [functions](#syntax-func), which are referenced through a respective index.

##### 2.5.12.1. Conventions[](#conventions①⑧)

The following auxiliary notation is defined for sequences of exports, filtering out indices of a specific kind in an order-preserving fashion:

[funcs](#syntax-externidx)(ϵ)[funcs](#syntax-externidx)(([func](#syntax-externidx) x) xx∗)[funcs](#syntax-externidx)([externidx](#syntax-externidx) xx∗)[tables](#syntax-externidx)(([table](#syntax-externidx) x) xx∗)[tables](#syntax-externidx)([externidx](#syntax-externidx) xx∗)[mems](#syntax-externidx)(([memory](#syntax-externidx) x) xx∗)[mems](#syntax-externidx)([externidx](#syntax-externidx) xx∗)[globals](#syntax-externidx)(([global](#syntax-externidx) x) xx∗)[globals](#syntax-externidx)([externidx](#syntax-externidx) xx∗)[tags](#syntax-externidx)(([tag](#syntax-externidx) x) xx∗)[tags](#syntax-externidx)([externidx](#syntax-externidx) xx∗)​\=\=\=\=\=\=\=\=\=\=\=​ϵx [funcs](#syntax-externidx)(xx∗)[funcs](#syntax-externidx)(xx∗)x [tables](#syntax-externidx)(xx∗)[tables](#syntax-externidx)(xx∗)x [mems](#syntax-externidx)(xx∗)[mems](#syntax-externidx)(xx∗)x [globals](#syntax-externidx)(xx∗)[globals](#syntax-externidx)(xx∗)x [tags](#syntax-externidx)(xx∗)[tags](#syntax-externidx)(xx∗)​otherwise0.8ex\][tables](#syntax-externidx)(ϵ)otherwise0.8ex\][mems](#syntax-externidx)(ϵ)otherwise0.8ex\][globals](#syntax-externidx)(ϵ)otherwise0.8ex\][tags](#syntax-externidx)(ϵ)otherwise​\=\=\=\=​ϵϵϵϵ​​

3\. Validation[](#validation②)
------------------------------

### 3.1. Conventions[](#conventions②⓪)

Validation checks that a WebAssembly module is well-formed. Only valid modules can be [instantiated](#exec-instantiation).

Validity is defined by a _type system_ over the [abstract syntax](#syntax) of a [module](#syntax-module) and its contents. For each piece of abstract syntax, there is a typing rule that specifies the constraints that apply to it. All rules are given in two _equivalent_ forms:

1.  In _prose_, describing the meaning in intuitive form.
    
2.  In _formal notation_, describing the rule in mathematical form. [\[1\]](#cite-pldi2017)
    

Note

The prose and formal rules are equivalent, so that understanding of the formal notation is _not_ required to read this specification. The formalism offers a more concise description in notation that is used widely in programming languages semantics and is readily amenable to mathematical proof.

In both cases, the rules are formulated in a _declarative_ manner. That is, they only formulate the constraints, they do not define an algorithm. The skeleton of a sound and complete algorithm for type-checking instruction sequences according to this specification is provided in the [appendix](#algo-valid).

#### 3.1.1. Types[](#types⑤)

To define the semantics, the definition of some sorts of types is extended to include additional forms. By virtue of not being representable in either the [binary format](#binary-valtype) or the [text format](#text-valtype), these forms cannot be used in a program; they only occur during [validation](#valid) or [execution](#exec).

​[valtype](#syntax-valtype)[absheaptype](#syntax-absheaptype)[typeuse](#syntax-typeuse)​::=::=::=​… ∣ [bot](#syntax-valtype-ext)… ∣ [bot](#syntax-valtype-ext)… ∣ [deftype](#syntax-deftype) ∣ [rec](#syntax-heaptype).n​​

The unique [value type](#syntax-valtype) [bot](#syntax-valtype-ext) is a _bottom type_ that [matches](#match-valtype) all value types. Similarly, [bot](#syntax-valtype-ext) is also used as a bottom type of all [heap types](#syntax-heaptype).

Note

No validation rule uses bottom types explicitly, but various rules can pick any value or heap type, including bottom. This ensures the existence of [principal types](#principality), and thus a [validation algorithm](#algo-valid) without back tracking.

A [type use](#syntax-typeuse) can consist directly of a [defined type](#syntax-deftype). This occurs as the result of [substituting](#notation-subst) a [type index](#syntax-typeidx) with its definition.

A type use may also be a _recursive type index_. Such an index refers to the i\-th component of a surrounding [recursive type](#syntax-rectype). It occurs as the result of [rolling up](#aux-roll-rectype) the definition of a [recursive type](#syntax-rectype).

Both extensions affect occurrences of type uses in concrete [heap types](#syntax-heaptype), in [sub types](#syntax-subtype) and in [instructions](#syntax-instr).

A type of any form is _closed_ when it does not contain a heap type that is a [type index](#syntax-typeidx) or a recursive type index without a surrounding [recursive type](#syntax-reftype), i.e., all [type indices](#syntax-typeidx) have been [substituted](#notation-subst) with their [defined type](#syntax-deftype) and all free recursive type indices have been [unrolled](#aux-unroll-rectype).

Note

It is an invariant of the semantics that sub types occur only in one of two forms: either as “syntactic” types as in a source module, where all supertypes are type indices, or as “semantic” types, where all supertypes are resolved to either defined types or recursive type indices.

Recursive type indices are local to a recursive type. They are distinguished from regular type indices and represented such that two closed types are syntactically equal if and only if they have the same recursive structure.

##### 3.1.1.1. Convention[](#convention③)

*   The _difference_ rt1​[∖](#aux-reftypediff)rt2​ between two [reference types](#syntax-reftype) is defined as follows:
    
    ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​)[∖](#aux-reftypediff)([ref](#syntax-reftype) [null](#syntax-reftype) ht2​)([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​)[∖](#aux-reftypediff)([ref](#syntax-reftype) ht2​)​\=\=​([ref](#syntax-reftype) ht1​)([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​)​​
    

Note

This definition computes an approximation of the reference type that is inhabited by all values from rt1​ except those from rt2​. Since the type system does not have general union types, the definition only affects the presence of null and cannot express the absence of other values.

#### 3.1.2. Defined Types[](#defined-types①)

_Defined types_ denote the individual types defined in a [module](#syntax-module). Each such type is represented as a projection from the [recursive type](#syntax-rectype) group it originates from, indexed by its position in that group.

​[deftype](#syntax-deftype)​::=​[rectype](#syntax-rectype).n​​

Defined types do not occur in the [binary](#binary) or [text](#text) format, but are formed by [rolling up](#aux-roll-deftype) the [recursive types](#syntax-reftype) defined in a module.

Note

It is an invariant of the semantics that all [recursive types](#syntax-rectype) occurring in defined types are [rolled up](#aux-roll-rectype).

##### 3.1.2.1. Conventions[](#conventions②①)

*   t\[x∗[:=](#notation-subst)dt∗\] denotes the parallel _substitution_ of [type indices](#syntax-typeidx) x∗ with corresponding [defined types](#syntax-deftype) dt∗ in type t, provided ∣x∗∣\=∣dt∗∣.
    
*   t\[(rec i)∗[:=](#notation-subst)dt∗\] denotes the parallel substitution of [recursive type indices](#syntax-rectypeidx) (rec i)∗ with [defined types](#syntax-deftype) dt∗ in type t, provided ∣(rec i)∗∣\=∣dt∗∣. This substitution does not proceed under [recursive types](#syntax-rectype), since they are considered local _binders_ for all recursive type indices.
    
*   t\[[:=](#notation-subst)dt∗\] is shorthand for the substitution t\[x∗[:=](#notation-subst)dt∗\], where x∗\=0 … (∣dt∗∣−1).
    

Note

All recursive types formed by the semantics are closed with respect to recursive type indices that occur inside them. Hence, substitution of recursive type indices never needs to modify the bodies of recursive types. In addition, all types used for substitution are closed with respect to recursive type indices, such that name capture of recursive type indices cannot occur.

#### 3.1.3. Rolling and Unrolling[](#rolling-and-unrolling①)

In order to allow comparing [recursive types](#syntax-rectype) for [equivalence](#match-deftype), their representation is changed such that all [type indices](#syntax-typeidx) internal to the same recursive type are replaced by [recursive type indices](#syntax-rectypeidx).

Note

This representation is independent of the type index space, so that it is meaningful across module boundaries. Moreover, this representation ensures that types with equivalent recursive structure are also syntactically equal, hence allowing a simple equality check on (closed) types. It gives rise to an _iso-recursive_ interpretation of types.

The representation change is performed by two auxiliary operations on the syntax of [recursive types](#syntax-rectype):

*   _Rolling up_ a recursive type [substitutes](#notation-subst) its internal [type indices](#syntax-typeidx) with corresponding [recursive type indices](#syntax-rectypeidx).
    
*   _Unrolling_ a recursive type [substitutes](#notation-subst) its [recursive type indices](#syntax-rectypeidx) with the corresponding [defined types](#syntax-deftype).
    

These operations are extended to [defined types](#syntax-deftype) and defined as follows:

[roll](#aux-roll-rectype)x​([rectype](#syntax-rectype))​\=​[rec](#syntax-rectype) ([subtype](#syntax-subtype)\[(x+i)i<n[:=](#notation-subst)([rec](#syntax-heaptype).i)i<n\])n​if [rectype](#syntax-rectype)\=[rec](#syntax-rectype) [subtype](#syntax-subtype)n0.8ex\][unroll](#aux-unroll-rectype)([rectype](#syntax-rectype))​\=​[rec](#syntax-rectype) ([subtype](#syntax-subtype)\[([rec](#syntax-heaptype).i)i<n[:=](#notation-subst)([rectype](#syntax-rectype).i)i<n\])n​if [rectype](#syntax-rectype)\=[rec](#syntax-rectype) [subtype](#syntax-subtype)n0.8ex\][roll](#aux-roll-deftype)x∗​([rectype](#syntax-rectype))​\=​(([rec](#syntax-rectype) [subtype](#syntax-subtype)n).i)i<n​if [roll](#aux-roll-rectype)x​([rectype](#syntax-rectype))\=[rec](#syntax-rectype) [subtype](#syntax-subtype)n0.8ex\][unroll](#aux-unroll-deftype)([rectype](#syntax-rectype).i)​\=​[subtype](#syntax-subtype)∗\[i\]​if [unroll](#aux-unroll-rectype)([rectype](#syntax-rectype))\=[rec](#syntax-rectype) [subtype](#syntax-subtype)∗​​

In addition, the following auxiliary relation denotes the _expansion_ of a [defined type](#syntax-deftype) or [type use](#syntax-typeuse):

​[deftype](#syntax-deftype)[typeidx](#syntax-typeidx)​[≈](#aux-expand-deftype)[≈](#aux-expand-typeuse)C​​[comptype](#syntax-comptype)[comptype](#syntax-comptype)​if [expand](#aux-expand-deftype)([deftype](#syntax-deftype))\=[comptype](#syntax-comptype)0.8ex\]if C.[types](#context)\[[typeidx](#syntax-typeidx)\][≈](#aux-expand-deftype)[comptype](#syntax-comptype)​[deftype](#syntax-deftype)[≈](#aux-expand-typeuse)C​[comptype](#syntax-comptype)if [deftype](#syntax-deftype)[≈](#aux-expand-deftype)[comptype](#syntax-comptype)​

#### 3.1.4. Instruction Types[](#instruction-types①)

_Instruction types_ classify the behaviour of [instructions](#syntax-instr) or instruction sequences, by describing how they manipulate the [operand stack](#stack) and the initialization status of [locals](#syntax-local):

​[instrtype](#syntax-instrtype)​::=​[resulttype](#syntax-resulttype)[→](#syntax-instrtype)[localidx](#syntax-localidx)∗​[resulttype](#syntax-resulttype)​​

An instruction type t1∗​[→](#syntax-instrtype)x∗​t2∗​ describes the required input stack with argument values of types t1∗​ that an instruction pops off and the provided output stack with result values of types t2∗​ that it pushes back. Moreover, it enumerates the [indices](#syntax-localidx) x∗ of locals that have been set by the instruction or sequence.

Note

Instruction types are only used for [validation](#valid), they do not occur in programs.

#### 3.1.5. Local Types[](#local-types①)

_Local types_ classify [locals](#syntax-local), by describing their [value type](#syntax-valtype) as well as their _initialization status_:

​[localtype](#syntax-localtype)[init](#syntax-init)​::=::=​[init](#syntax-init) [valtype](#syntax-valtype)[set](#syntax-init) ∣ [unset](#syntax-init)​​

Note

Local types are only used for [validation](#valid), they do not occur in programs.

#### 3.1.6. Contexts[](#contexts①)

Validity of an individual definition is specified relative to a _context_, which collects relevant information about the surrounding [module](#syntax-module) and the definitions in scope:

*   _Types_: the list of [types](#syntax-type) defined in the current module.
    
*   _Recursive Types_: the list of [sub types](#syntax-subtype) in the current group of recursive types.
    
*   _Functions_: the list of [functions](#syntax-func) declared in the current module, represented by a [defined type](#syntax-deftype) that [expands](#aux-expand-deftype) to their [function type](#syntax-functype).
    
*   _Tables_: the list of [tables](#syntax-table) declared in the current module, represented by their [table type](#syntax-tabletype).
    
*   _Memories_: the list of [memories](#syntax-mem) declared in the current module, represented by their [memory type](#syntax-memtype).
    
*   _Globals_: the list of [globals](#syntax-global) declared in the current module, represented by their [global type](#syntax-globaltype).
    
*   _Tags_: the list of tags declared in the current module, represented by their [tag type](#syntax-tagtype).
    
*   _Element Segments_: the list of [element segments](#syntax-elem) declared in the current module, represented by the elements’ [reference type](#syntax-reftype).
    
*   _Data Segments_: the list of [data segments](#syntax-data) declared in the current module, each represented by an [ok](#valid-data) entry.
    
*   _Locals_: the list of [locals](#syntax-local) declared in the current [function](#syntax-func) (including parameters), represented by their [local type](#syntax-localtype).
    
*   _Labels_: the stack of [labels](#syntax-label) accessible from the current position, represented by their [result type](#syntax-resulttype).
    
*   _Return_: the return type of the current [function](#syntax-func), represented as an optional [result type](#syntax-resulttype) that is absent when no return is allowed, as in free-standing expressions.
    
*   _References_: the list of [function indices](#syntax-funcidx) that occur in the module outside functions and can hence be used to form references inside them.
    

In other words, a context contains a sequence of suitable [types](#syntax-type) for each [index space](#syntax-index), describing each defined entry in that space. Locals, labels and return type are only used for validating [instructions](#syntax-instr) in [function bodies](#syntax-func), and are left empty elsewhere. The label stack is the only part of the context that changes as validation of an instruction sequence proceeds.

More concretely, contexts are defined as [records](#notation-record) C with abstract syntax:

​[context](#context)​::=​{[types](#context) [deftype](#syntax-deftype)∗[recs](#context-ext) [subtype](#syntax-subtype)∗[tags](#context) [tagtype](#syntax-tagtype)∗[globals](#context) [globaltype](#syntax-globaltype)∗[mems](#context) [memtype](#syntax-memtype)∗[tables](#context) [tabletype](#syntax-tabletype)∗[funcs](#context) [deftype](#syntax-deftype)∗[datas](#context) [datatype](#syntax-datatype)∗[elems](#context) [elemtype](#syntax-elemtype)∗[locals](#context) [localtype](#syntax-localtype)∗[labels](#context) [resulttype](#syntax-resulttype)∗[return](#context) [resulttype](#syntax-resulttype)?[refs](#context) [funcidx](#syntax-funcidx)∗}​​​

##### 3.1.6.1. Convention[](#convention④)

A type of any shape can be _closed_ to bring it into [closed](#type-closed) form relative to a [context](#context) it is [valid](#valid-type) in, by [substituting](#notation-subst) each [type index](#syntax-typeidx) x occurring in it with its own corresponding [defined type](#syntax-deftype) C.[types](#context)\[x\], after first closing the types in C.[types](#context) themselves.

[clos](#aux-clostype)C​(t)[clos](#aux-clostype)∗(dt∗ dtn​)​\=\=​t\[[:=](#notation-subst)dt∗\]dt′∗ dtn​\[[:=](#notation-subst)dt′∗\]​if dt∗\=[clos](#aux-clostype)∗(C.[types](#context))0.8ex\][clos](#aux-clostype)∗(ϵ)if dt′∗\=[clos](#aux-clostype)∗(dt∗)​\=ϵ​

Note

Free type indices referring to types within the same [recursive type](#syntax-rectype) are handled separately by [rolling up](#aux-roll-rectype) recursive types before closing them.

#### 3.1.7. Prose Notation[](#prose-notation①)

Validation is specified by stylised rules for each relevant part of the [abstract syntax](#syntax). The rules not only state constraints defining when a phrase is valid, they also classify it with a type. The following conventions are adopted in stating these rules.

*   A phrase A is said to be “valid with type T” if and only if all constraints expressed by the respective rules are met. The form of T depends on the syntactic class of A.
    
    Note
    
    For example, if A is a [function](#syntax-func), then T is a [defined function type](#syntax-deftype); for an A that is a [global](#syntax-global), T is a [global type](#syntax-globaltype); and so on.
    
*   The rules implicitly assume a given [context](#context) C.
    
*   In some places, this context is locally extended to a context C′ with additional entries. The formulation “Under context C′, … _statement_ …” is adopted to express that the following statement must apply under the assumptions embodied in the extended context.
    

#### 3.1.8. Formal Notation[](#formal-notation①)

Note

This section gives a brief explanation of the notation for specifying typing rules formally. For the interested reader, a more thorough introduction can be found in respective text books. [\[2\]](#cite-tapl)

The proposition that a phrase A has a respective type T is written A : T. In general, however, typing is dependent on a context C. To express this explicitly, the complete form is a _judgement_ C ⊢ A : T, which says that A : T holds under the assumptions encoded in C.

The formal typing rules use a standard approach for specifying type systems, rendering them into _deduction rules_. Every rule has the following general form:

conclusionpremise1​premise2​…premisen​​​

Such a rule is read as a big implication: if all premises hold, then the conclusion holds. Some rules have no premises; they are _axioms_ whose conclusion holds unconditionally. The conclusion always is a judgment C ⊢ A : T, and there usually is one respective rule for each relevant construct A of the abstract syntax.

Note

For example, the typing rule for the [i32](#syntax-numtype).[add](#syntax-instr-numeric) instruction can be given as an axiom:

C⊢[i32](#syntax-numtype).[add](#syntax-instr-numeric):[i32](#syntax-numtype) [i32](#syntax-numtype)→[i32](#syntax-numtype)​​

The instruction is always valid with type [i32](#syntax-numtype) [i32](#syntax-numtype)→[i32](#syntax-numtype) (saying that it consumes two [i32](#syntax-numtype) values and produces one), independent of any side conditions.

An instruction like global.get can be typed as follows:

C⊢[global.get](#syntax-instr-variable) x:ϵ→tC.[globals](#context)\[x\]\=[mut](#syntax-mut) t​​

Here, the premise enforces that the immediate [global index](#syntax-globalidx) x exists in the context. The instruction produces a value of its respective type t (and does not consume any values). If C.[globals](#context)\[x\] does not exist then the premise does not hold, and the instruction is ill-typed.

Finally, a [structured](#syntax-instr-control) instruction requires a recursive rule, where the premise is itself a typing judgement:

C⊢[block](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗:t1∗​→t2∗​C[⊢](#valid-blocktype)[blocktype](#syntax-blocktype):t1∗​→t2∗​{[labels](#context) (t2∗​)}⊕C⊢[instr](#syntax-instr)∗:t1∗​→t2∗​​​

A block instruction is only valid when the instruction sequence in its body is. Moreover, the result type must match the block’s annotation [blocktype](#syntax-blocktype). If so, then the block instruction has the same type as the body. Inside the body an additional label of the corresponding result type is available, which is expressed by extending the context C with the additional label information for the premise.

\[[1](#id1)\]

The semantics is derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. [Bringing the Web up to Speed with WebAssembly](https://dl.acm.org/citation.cfm?doid=3062341.3062363). Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.

\[[2](#id4)\]

For example: Benjamin Pierce. [Types and Programming Languages](https://www.cis.upenn.edu/~bcpierce/tapl/). The MIT Press 2002

### 3.2. Types[](#types⑦)

Simple [types](#syntax-type), such as [number types](#syntax-numtype) are universally valid. However, restrictions apply to most other types, such as [reference types](#syntax-reftype), [function types](#syntax-functype), as well as the [limits](#syntax-limits) of [table types](#syntax-tabletype) and [memory types](#syntax-memtype), which must be checked during validation.

Moreover, [block types](#syntax-blocktype) are converted to [instruction types](#syntax-instrtype) for ease of processing.

#### 3.2.1. Number Types[](#number-types③)

The [number type](#syntax-numtype) [numtype](#syntax-numtype) is always [valid](#valid-numtype).

C[⊢](#valid-numtype)[numtype](#syntax-numtype):[ok](#valid-numtype)​​

#### 3.2.2. Vector Types[](#vector-types③)

The [vector type](#syntax-vectype) [vectype](#syntax-vectype) is always [valid](#valid-vectype).

C[⊢](#valid-vectype)[vectype](#syntax-vectype):[ok](#valid-vectype)​​

#### 3.2.3. Type Uses[](#type-uses③)

The [type use](#syntax-typeuse) [typeidx](#syntax-typeidx) is [valid](#valid-typeuse) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\] exists.
>     

C[⊢](#valid-typeuse)[typeidx](#syntax-typeidx):[ok](#valid-typeuse)C.[types](#context)\[[typeidx](#syntax-typeidx)\]\=dt​​

#### 3.2.4. Heap Types[](#heap-types③)

The [heap type](#syntax-heaptype) [absheaptype](#syntax-absheaptype) is always [valid](#valid-heaptype).

C[⊢](#valid-heaptype)[absheaptype](#syntax-absheaptype):[ok](#valid-heaptype)​​

#### 3.2.5. Reference Types[](#reference-types③)

The [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype)? [heaptype](#syntax-heaptype)) is [valid](#valid-reftype) if:

> *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype) is [valid](#valid-heaptype).
>     

C[⊢](#valid-reftype)[ref](#syntax-reftype) [null](#syntax-reftype)? [heaptype](#syntax-heaptype):[ok](#valid-reftype)C[⊢](#valid-heaptype)[heaptype](#syntax-heaptype):[ok](#valid-heaptype)​​

#### 3.2.6. Value Types[](#value-types③)

The [value type](#syntax-valtype) [valtype](#syntax-valtype) is [valid](#valid-valtype) if:

> *   Either:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype) is of the form [numtype](#syntax-numtype).
>     >     
>     > *   The [number type](#syntax-numtype) [numtype](#syntax-numtype) is [valid](#valid-numtype).
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype) is of the form [vectype](#syntax-vectype).
>     >     
>     > *   The [vector type](#syntax-vectype) [vectype](#syntax-vectype) is [valid](#valid-vectype).
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype) is of the form [reftype](#syntax-reftype).
>     >     
>     > *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype) is [valid](#valid-reftype).
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype) is of the form [bot](#syntax-valtype-ext).
>     >     
>     

C[⊢](#valid-valtype)[bot](#syntax-valtype-ext):[ok](#valid-valtype)​​

#### 3.2.7. Result Types[](#result-types③)

The [result type](#syntax-resulttype) t∗ is [valid](#valid-resulttype) if:

> *   For all t in t∗:
>     
>     > *   The [value type](#syntax-valtype) t is [valid](#valid-valtype).
>     >     
>     

C[⊢](#valid-resulttype)t∗:[ok](#valid-resulttype)(C[⊢](#valid-valtype)t:[ok](#valid-valtype))∗​​

#### 3.2.8. Block Types[](#block-types③)

[Block types](#syntax-blocktype) may be expressed in one of two forms, both of which are converted to [instruction types](#syntax-instrtype) by the following rules.

The [block type](#syntax-blocktype) [typeidx](#syntax-typeidx) is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[[typeidx](#syntax-typeidx)\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-blocktype)[typeidx](#syntax-typeidx):t1∗​→t2∗​C.[types](#context)\[[typeidx](#syntax-typeidx)\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

The [block type](#syntax-blocktype) [valtype](#syntax-valtype)? is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) ϵ → [valtype](#syntax-valtype)? if:

> *   If [valtype](#syntax-valtype) is defined, then:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype) is [valid](#valid-valtype).
>     >     
>     

C[⊢](#valid-blocktype)[valtype](#syntax-valtype)?:ϵ→[valtype](#syntax-valtype)?(C[⊢](#valid-valtype)[valtype](#syntax-valtype):[ok](#valid-valtype))?​​

#### 3.2.9. Instruction Types[](#instruction-types③)

The [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x∗​t2∗​ is [valid](#valid-instrtype) if:

> *   The [result type](#syntax-resulttype) t1∗​ is [valid](#valid-resulttype).
>     
> *   The [result type](#syntax-resulttype) t2∗​ is [valid](#valid-resulttype).
>     
> *   For all x in x∗:
>     
>     > *   The [local](#syntax-localtype) C.[locals](#context)\[x\] exists.
>     >     
>     

C[⊢](#valid-instrtype)t1∗​[→](#syntax-instrtype)x∗​t2∗​:[ok](#valid-instrtype)C[⊢](#valid-resulttype)t1∗​:[ok](#valid-resulttype)C[⊢](#valid-resulttype)t2∗​:[ok](#valid-resulttype)(C.[locals](#context)\[x\]\=lt)∗​​

#### 3.2.10. Composite Types[](#composite-types③)

The [composite type](#syntax-comptype) ([struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗) is [valid](#valid-comptype) if:

> *   For all [fieldtype](#syntax-fieldtype) in [fieldtype](#syntax-fieldtype)∗:
>     
>     > *   The [field type](#syntax-fieldtype) [fieldtype](#syntax-fieldtype) is [valid](#valid-fieldtype).
>     >     
>     

C[⊢](#valid-comptype)[struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗:[ok](#valid-comptype)(C[⊢](#valid-fieldtype)[fieldtype](#syntax-fieldtype):[ok](#valid-fieldtype))∗​​

The [composite type](#syntax-comptype) ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)) is [valid](#valid-comptype) if:

> *   The [field type](#syntax-fieldtype) [fieldtype](#syntax-fieldtype) is [valid](#valid-fieldtype).
>     

C[⊢](#valid-comptype)[array](#syntax-comptype) [fieldtype](#syntax-fieldtype):[ok](#valid-comptype)C[⊢](#valid-fieldtype)[fieldtype](#syntax-fieldtype):[ok](#valid-fieldtype)​​

The [composite type](#syntax-comptype) ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​) is [valid](#valid-comptype) if:

> *   The [result type](#syntax-resulttype) t1∗​ is [valid](#valid-resulttype).
>     
> *   The [result type](#syntax-resulttype) t2∗​ is [valid](#valid-resulttype).
>     

C[⊢](#valid-comptype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​:[ok](#valid-comptype)C[⊢](#valid-resulttype)t1∗​:[ok](#valid-resulttype)C[⊢](#valid-resulttype)t2∗​:[ok](#valid-resulttype)​​

The [field type](#syntax-fieldtype) ([mut](#syntax-mut)? [storagetype](#syntax-storagetype)) is [valid](#valid-fieldtype) if:

> *   The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype) is [valid](#valid-storagetype).
>     

C[⊢](#valid-fieldtype)[mut](#syntax-mut)? [storagetype](#syntax-storagetype):[ok](#valid-fieldtype)C[⊢](#valid-storagetype)[storagetype](#syntax-storagetype):[ok](#valid-storagetype)​​

The [packed type](#syntax-packtype) [packtype](#syntax-packtype) is always [valid](#valid-packtype).

C[⊢](#valid-packtype)[packtype](#syntax-packtype):[ok](#valid-packtype)​​

#### 3.2.11. Recursive Types[](#recursive-types③)

[Recursive types](#syntax-rectype) are validated with respect to the first [type index](#syntax-typeidx) defined by the recursive group.

##### 3.2.11.1. [rec](#syntax-rectype) [subtype](#syntax-subtype)∗[](#-hrefsyntax-rectypemathsfrechrefsyntax-subtypemathitsubtypeast)

The [recursive type](#syntax-rectype) ([rec](#syntax-rectype) [subtype](#syntax-subtype)∗) is [valid](#valid-rectype) for the type index x if:

> *   Either:
>     
>     > *   The sub type sequence [subtype](#syntax-subtype)∗ is empty.
>     >     
>     
> *   Or:
>     
>     > *   The sub type sequence [subtype](#syntax-subtype)∗ is of the form [subtype](#syntax-subtype)1​ [subtype](#syntax-subtype)′∗.
>     >     
>     > *   The [sub type](#syntax-subtype) [subtype](#syntax-subtype)1​ is [valid](#valid-subtype) for the type index x.
>     >     
>     > *   The [recursive type](#syntax-rectype) ([rec](#syntax-rectype) [subtype](#syntax-subtype)′∗) is [valid](#valid-rectype) for the type index x+1.
>     >     
>     

C[⊢](#valid-rectype)[rec](#syntax-rectype) ϵ:[ok](#valid-subtype)(x)​C[⊢](#valid-rectype)[rec](#syntax-rectype) ([subtype](#syntax-subtype)1​ [subtype](#syntax-subtype)∗):[ok](#valid-subtype)(x)C[⊢](#valid-subtype)[subtype](#syntax-subtype)1​:[ok](#valid-subtype)(x)C[⊢](#valid-rectype)[rec](#syntax-rectype) [subtype](#syntax-subtype)∗:[ok](#valid-subtype)(x+1)​​

##### 3.2.11.2. [sub](#syntax-subtype) [final](#syntax-subtype)? y∗ [comptype](#syntax-comptype)[](#-hrefsyntax-subtypemathsfsubhrefsyntax-subtypemathsffinalyasthrefsyntax-comptypemathitcomptype)

The [sub type](#syntax-subtype) ([sub](#syntax-subtype) [final](#syntax-subtype)? x∗ [comptype](#syntax-comptype)) is [valid](#valid-subtype) for the type index x0​ if:

> *   The length of x∗ is less than or equal to 1.
>     
> *   For all x in x∗:
>     
>     > *   The [index](#syntax-idx) x is less than x0​.
>     >     
>     > *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     >     
>     > *   The [sub type](#syntax-subtype) [unroll](#aux-unroll-deftype)(C.[types](#context)\[x\]) is of the form ([sub](#syntax-subtype) x′∗ [comptype](#syntax-comptype)′).
>     >     
>     
> *   [comptype](#syntax-comptype)′∗ is the concatenation of all such [comptype](#syntax-comptype)′.
>     
> *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype) is [valid](#valid-comptype).
>     
> *   For all [comptype](#syntax-comptype)′ in [comptype](#syntax-comptype)′∗:
>     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype) [matches](#match-comptype) the [composite type](#syntax-comptype) [comptype](#syntax-comptype)′.
>     >     
>     

C[⊢](#valid-subtype)[sub](#syntax-subtype) [final](#syntax-subtype)? x∗ [comptype](#syntax-comptype):[ok](#valid-subtype)(x0​)∣x∗∣≤1(x<x0​)∗([unroll](#aux-unroll-deftype)(C.[types](#context)\[x\])\=[sub](#syntax-subtype) x′∗ [comptype](#syntax-comptype)′)∗C[⊢](#valid-comptype)[comptype](#syntax-comptype):[ok](#valid-comptype)(C[⊢](#match-comptype)[comptype](#syntax-comptype)[≤](#match-comptype)[comptype](#syntax-comptype)′)∗​​​​

Note

The side condition on the index ensures that a declared supertype is a previously defined types, preventing cyclic subtype hierarchies.

Future versions of WebAssembly may allow more than one supertype.

#### 3.2.12. Limits[](#limits③)

[Limits](#syntax-limits) must have meaningful bounds that are within a given range.

The [limits range](#syntax-limits) \[n[..](#syntax-limits)m?\] is [valid](#valid-limits) within k if:

> *   n is less than or equal to k.
>     
> *   If m is defined, then:
>     
>     > *   n is less than or equal to m.
>     >     
>     > *   m is less than or equal to k.
>     >     
>     

C[⊢](#valid-limits)\[n[..](#syntax-limits)m?\]:kn≤k(n≤m≤k)?​​

#### 3.2.13. Tag Types[](#tag-types③)

The [tag type](#syntax-tagtype) [typeuse](#syntax-typeuse) is [valid](#valid-tagtype) if:

> *   The [type use](#syntax-typeuse) [typeuse](#syntax-typeuse) is [valid](#valid-typeuse).
>     
> *   The [expansion](#aux-expand-typeuse) of C is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-tagtype)[typeuse](#syntax-typeuse):[ok](#valid-tagtype)C[⊢](#valid-typeuse)[typeuse](#syntax-typeuse):[ok](#valid-typeuse)[typeuse](#syntax-typeuse)[≈](#aux-expand-typeuse)C​[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

#### 3.2.14. Global Types[](#global-types③)

The [global type](#syntax-globaltype) ([mut](#syntax-mut)? t) is [valid](#valid-globaltype) if:

> *   The [value type](#syntax-valtype) t is [valid](#valid-valtype).
>     

C[⊢](#valid-globaltype)[mut](#syntax-mut)? t:[ok](#valid-globaltype)C[⊢](#valid-valtype)t:[ok](#valid-valtype)​​

#### 3.2.15. Memory Types[](#memory-types③)

The [memory type](#syntax-memtype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits) [page](#syntax-memtype)) is [valid](#valid-memtype) if:

> *   The [limits range](#syntax-limits) [limits](#syntax-limits) is [valid](#valid-limits) within 216.
>     

C[⊢](#valid-memtype)[addrtype](#syntax-addrtype) [limits](#syntax-limits) [page](#syntax-memtype):[ok](#valid-memtype)C[⊢](#valid-limits)[limits](#syntax-limits):216​​

#### 3.2.16. Table Types[](#table-types③)

The [table type](#syntax-tabletype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits) [reftype](#syntax-reftype)) is [valid](#valid-tabletype) if:

> *   The [limits range](#syntax-limits) [limits](#syntax-limits) is [valid](#valid-limits) within 232−1.
>     
> *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype) is [valid](#valid-reftype).
>     

C[⊢](#valid-tabletype)[addrtype](#syntax-addrtype) [limits](#syntax-limits) [reftype](#syntax-reftype):[ok](#valid-tabletype)C[⊢](#valid-limits)[limits](#syntax-limits):232−1C[⊢](#valid-reftype)[reftype](#syntax-reftype):[ok](#valid-reftype)​​

#### 3.2.17. External Types[](#external-types③)

The [external type](#syntax-externtype) ([tag](#syntax-externtype) [tagtype](#syntax-tagtype)) is [valid](#valid-externtype) if:

> *   The [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype) is [valid](#valid-tagtype).
>     

C[⊢](#valid-externtype)[tag](#syntax-externtype) [tagtype](#syntax-tagtype):[ok](#valid-externtype)C[⊢](#valid-tagtype)[tagtype](#syntax-tagtype):[ok](#valid-tagtype)​​

The [external type](#syntax-externtype) ([global](#syntax-externtype) [globaltype](#syntax-globaltype)) is [valid](#valid-externtype) if:

> *   The [global type](#syntax-globaltype) [globaltype](#syntax-globaltype) is [valid](#valid-globaltype).
>     

C[⊢](#valid-externtype)[global](#syntax-externtype) [globaltype](#syntax-globaltype):[ok](#valid-externtype)C[⊢](#valid-globaltype)[globaltype](#syntax-globaltype):[ok](#valid-globaltype)​​

The [external type](#syntax-externtype) ([mem](#syntax-externtype) [memtype](#syntax-memtype)) is [valid](#valid-externtype) if:

> *   The [memory type](#syntax-memtype) [memtype](#syntax-memtype) is [valid](#valid-memtype).
>     

C[⊢](#valid-externtype)[mem](#syntax-externtype) [memtype](#syntax-memtype):[ok](#valid-externtype)C[⊢](#valid-memtype)[memtype](#syntax-memtype):[ok](#valid-memtype)​​

The [external type](#syntax-externtype) ([table](#syntax-externtype) [tabletype](#syntax-tabletype)) is [valid](#valid-externtype) if:

> *   The [table type](#syntax-tabletype) [tabletype](#syntax-tabletype) is [valid](#valid-tabletype).
>     

C[⊢](#valid-externtype)[table](#syntax-externtype) [tabletype](#syntax-tabletype):[ok](#valid-externtype)C[⊢](#valid-tabletype)[tabletype](#syntax-tabletype):[ok](#valid-tabletype)​​

The [external type](#syntax-externtype) ([func](#syntax-externtype) [typeuse](#syntax-typeuse)) is [valid](#valid-externtype) if:

> *   The [type use](#syntax-typeuse) [typeuse](#syntax-typeuse) is [valid](#valid-typeuse).
>     
> *   The [expansion](#aux-expand-typeuse) of C is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-externtype)[func](#syntax-externtype) [typeuse](#syntax-typeuse):[ok](#valid-externtype)C[⊢](#valid-typeuse)[typeuse](#syntax-typeuse):[ok](#valid-typeuse)[typeuse](#syntax-typeuse)[≈](#aux-expand-typeuse)C​[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

### 3.3. Matching[](#matching①)

On most types, a notion of _subtyping_ is defined that is applicable in [validation](#valid) rules, during [module instantiation](#exec-instantiation) when checking the types of imports, or during [execution](#exec), when performing casts.

#### 3.3.1. Number Types[](#number-types⑤)

The [number type](#syntax-numtype) [numtype](#syntax-numtype) [matches](#match-numtype) only itself.

C[⊢](#match-numtype)[numtype](#syntax-numtype)[≤](#match-numtype)[numtype](#syntax-numtype)​​

#### 3.3.2. Vector Types[](#vector-types⑤)

The [vector type](#syntax-vectype) [vectype](#syntax-vectype) [matches](#match-vectype) only itself.

C[⊢](#match-vectype)[vectype](#syntax-vectype)[≤](#match-vectype)[vectype](#syntax-vectype)​​

#### 3.3.3. Heap Types[](#heap-types⑤)

The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ if:

> *   Either:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [heaptype](#syntax-heaptype)1​.
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)′ is [valid](#valid-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)′.
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)′ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [eq](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [any](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [i31](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [eq](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [struct](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [eq](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [array](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [eq](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [deftype](#syntax-deftype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [struct](#syntax-heaptype).
>     >     
>     > *   The [expansion](#aux-expand-deftype) of [deftype](#syntax-deftype) is ([struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [deftype](#syntax-deftype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [array](#syntax-heaptype).
>     >     
>     > *   The [expansion](#aux-expand-deftype) of [deftype](#syntax-deftype) is ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [deftype](#syntax-deftype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [func](#syntax-heaptype).
>     >     
>     > *   The [expansion](#aux-expand-deftype) of [deftype](#syntax-deftype) is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [deftype](#syntax-deftype)1​.
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [deftype](#syntax-deftype)2​.
>     >     
>     > *   The [defined type](#syntax-deftype) [deftype](#syntax-deftype)1​ [matches](#match-deftype) the [defined type](#syntax-deftype) [deftype](#syntax-deftype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [typeidx](#syntax-typeidx).
>     >     
>     > *   The [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\] exists.
>     >     
>     > *   The [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\] [matches](#match-deftype) the [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [typeidx](#syntax-typeidx).
>     >     
>     > *   The [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\] exists.
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ [matches](#match-heaptype) the [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\].
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form ([rec](#syntax-heaptype).i).
>     >     
>     > *   The length of [typeuse](#syntax-typeuse)∗ is greater than j.
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [typeuse](#syntax-typeuse)∗\[j\].
>     >     
>     > *   The [recursive type](#syntax-subtype) C.[recs](#context-ext)\[i\] exists.
>     >     
>     > *   The [recursive type](#syntax-subtype) C.[recs](#context-ext)\[i\] is of the form ([sub](#syntax-subtype) [final](#syntax-subtype)? [typeuse](#syntax-typeuse)∗ ct).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [none](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [any](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [nofunc](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [func](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [noexn](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [exn](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [noextern](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [extern](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [bot](#syntax-valtype-ext).
>     >     
>     

C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[heaptype](#syntax-heaptype)​C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)1​[≤](#match-heaptype)[heaptype](#syntax-heaptype)2​C[⊢](#valid-heaptype)[heaptype](#syntax-heaptype)′:[ok](#valid-heaptype)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)1​[≤](#match-heaptype)[heaptype](#syntax-heaptype)′C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)′[≤](#match-heaptype)[heaptype](#syntax-heaptype)2​​3ex\]C[⊢](#match-heaptype)[eq](#syntax-heaptype)[≤](#match-heaptype)[any](#syntax-heaptype)​C[⊢](#match-heaptype)[i31](#syntax-heaptype)[≤](#match-heaptype)[eq](#syntax-heaptype)​C[⊢](#match-heaptype)[struct](#syntax-heaptype)[≤](#match-heaptype)[eq](#syntax-heaptype)​C[⊢](#match-heaptype)[array](#syntax-heaptype)[≤](#match-heaptype)[eq](#syntax-heaptype)​3ex\]C[⊢](#match-heaptype)[deftype](#syntax-deftype)[≤](#match-heaptype)[struct](#syntax-heaptype)[deftype](#syntax-deftype)[≈](#aux-expand-deftype)[struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗​C[⊢](#match-heaptype)[deftype](#syntax-deftype)[≤](#match-heaptype)[array](#syntax-heaptype)[deftype](#syntax-deftype)[≈](#aux-expand-deftype)[array](#syntax-comptype) [fieldtype](#syntax-fieldtype)​C[⊢](#match-heaptype)[deftype](#syntax-deftype)[≤](#match-heaptype)[func](#syntax-heaptype)[deftype](#syntax-deftype)[≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​3ex\]C[⊢](#match-heaptype)[typeidx](#syntax-typeidx)[≤](#match-heaptype)[heaptype](#syntax-heaptype)C[⊢](#match-heaptype)C.[types](#context)\[[typeidx](#syntax-typeidx)\][≤](#match-heaptype)[heaptype](#syntax-heaptype)​C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[typeidx](#syntax-typeidx)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)C.[types](#context)\[[typeidx](#syntax-typeidx)\]​3ex\]C[⊢](#match-heaptype)[rec](#syntax-heaptype).i[≤](#match-heaptype)[typeuse](#syntax-typeuse)∗\[j\]C.[recs](#context-ext)\[i\]\=[sub](#syntax-subtype) [final](#syntax-subtype)? [typeuse](#syntax-typeuse)∗ ct​3ex\]C[⊢](#match-heaptype)[none](#syntax-heaptype)[≤](#match-heaptype)[heaptype](#syntax-heaptype)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[any](#syntax-heaptype)​C[⊢](#match-heaptype)[nofunc](#syntax-heaptype)[≤](#match-heaptype)[heaptype](#syntax-heaptype)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[func](#syntax-heaptype)​C[⊢](#match-heaptype)[noexn](#syntax-heaptype)[≤](#match-heaptype)[heaptype](#syntax-heaptype)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[exn](#syntax-heaptype)​C[⊢](#match-heaptype)[noextern](#syntax-heaptype)[≤](#match-heaptype)[heaptype](#syntax-heaptype)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[extern](#syntax-heaptype)​3ex\]C[⊢](#match-heaptype)[bot](#syntax-valtype-ext)[≤](#match-heaptype)[heaptype](#syntax-heaptype)​​​

#### 3.3.4. Reference Types[](#reference-types⑤)

The [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​) [matches](#match-reftype) the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype)2?​ ht2​) if:

> *   The [heap type](#syntax-heaptype) ht1​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) ht2​.
>     
> *   Either:
>     
>     > *   [null](#syntax-reftype)1?​ is absent.
>     >     
>     > *   [null](#syntax-reftype)2?​ is absent.
>     >     
>     
> *   Or:
>     
>     > *   [null](#syntax-reftype)1?​ is of the form [null](#syntax-reftype)?.
>     >     
>     > *   [null](#syntax-reftype)2?​ is of the form [null](#syntax-reftype).
>     >     
>     

C[⊢](#match-reftype)[ref](#syntax-reftype) ht1​[≤](#match-reftype)[ref](#syntax-reftype) ht2​C[⊢](#match-heaptype)ht1​[≤](#match-heaptype)ht2​​C[⊢](#match-reftype)[ref](#syntax-reftype) [null](#syntax-reftype)? ht1​[≤](#match-reftype)[ref](#syntax-reftype) [null](#syntax-reftype) ht2​C[⊢](#match-heaptype)ht1​[≤](#match-heaptype)ht2​​​

#### 3.3.5. Value Types[](#value-types⑤)

The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ [matches](#match-valtype) the [value type](#syntax-valtype) [valtype](#syntax-valtype)2​ if:

> *   Either:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ is of the form [numtype](#syntax-numtype)1​.
>     >     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)2​ is of the form [numtype](#syntax-numtype)2​.
>     >     
>     > *   The [number type](#syntax-numtype) [numtype](#syntax-numtype)1​ [matches](#match-numtype) the [number type](#syntax-numtype) [numtype](#syntax-numtype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ is of the form [vectype](#syntax-vectype)1​.
>     >     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)2​ is of the form [vectype](#syntax-vectype)2​.
>     >     
>     > *   The [vector type](#syntax-vectype) [vectype](#syntax-vectype)1​ [matches](#match-vectype) the [vector type](#syntax-vectype) [vectype](#syntax-vectype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ is of the form [reftype](#syntax-reftype)1​.
>     >     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)2​ is of the form [reftype](#syntax-reftype)2​.
>     >     
>     > *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype)1​ [matches](#match-reftype) the [reference type](#syntax-reftype) [reftype](#syntax-reftype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ is of the form [bot](#syntax-valtype-ext).
>     >     
>     

C[⊢](#match-valtype)[bot](#syntax-valtype-ext)[≤](#match-valtype)[valtype](#syntax-valtype)​​

#### 3.3.6. Result Types[](#result-types⑤)

Subtyping is lifted to [result types](#syntax-resulttype) in a pointwise manner.

The [result type](#syntax-resulttype) t1∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t2∗​ if:

> *   For all t1​ in t1∗​, and corresponding t2​ in t2∗​:
>     
>     > *   The [value type](#syntax-valtype) t1​ [matches](#match-valtype) the [value type](#syntax-valtype) t2​.
>     >     
>     

C[⊢](#match-resulttype)t1∗​[≤](#match-resulttype)t2∗​(C[⊢](#match-valtype)t1​[≤](#match-valtype)t2​)∗​​

#### 3.3.7. Instruction Types[](#instruction-types⑤)

Subtyping is further lifted to [instruction types](#syntax-instrtype).

The [instruction type](#syntax-instrtype) t11∗​ [→](#syntax-instrtype)x1∗​​t12∗​ [matches](#match-instrtype) the [instruction type](#syntax-instrtype) t21∗​ [→](#syntax-instrtype)x2∗​​t22∗​ if:

> *   The [result type](#syntax-resulttype) t21∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t11∗​.
>     
> *   The [result type](#syntax-resulttype) t12∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t22∗​.
>     
> *   The local index sequence x∗ is of the form x2∗​∖x1∗​.
>     
> *   For all x in x∗:
>     
>     > *   The [local](#syntax-localtype) C.[locals](#context)\[x\] exists.
>     >     
>     > *   The [local](#syntax-localtype) C.[locals](#context)\[x\] is of the form ([set](#syntax-init) t).
>     >     
>     

C[⊢](#match-instrtype)t11∗​[→](#syntax-instrtype)x1∗​​t12∗​[≤](#match-instrtype)t21∗​[→](#syntax-instrtype)x2∗​​t22∗​C[⊢](#match-resulttype)t21∗​[≤](#match-resulttype)t11∗​C[⊢](#match-resulttype)t12∗​[≤](#match-resulttype)t22∗​x∗\=x2∗​∖x1∗​(C.[locals](#context)\[x\]\=[set](#syntax-init) t)∗​​

Note

Instruction types are contravariant in their input and covariant in their output. Moreover, the supertype may ignore variables from the init set x1∗​. It may also _add_ variables to the init set, provided these are already set in the context, i.e., are vacuously initialized.

#### 3.3.8. Composite Types[](#composite-types⑤)

The [composite type](#syntax-comptype) [comptype](#syntax-comptype)1​ [matches](#match-comptype) the [composite type](#syntax-comptype) [comptype](#syntax-comptype)2​ if:

> *   Either:
>     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)1​ is of the form ([struct](#syntax-comptype) ft1∗​ ft′1∗​).
>     >     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)2​ is of the form ([struct](#syntax-comptype) ft2∗​).
>     >     
>     > *   For all ft1​ in ft1∗​, and corresponding ft2​ in ft2∗​:
>     >     
>     >     > *   The [field type](#syntax-fieldtype) ft1​ [matches](#match-fieldtype) the [field type](#syntax-fieldtype) ft2​.
>     >     >     
>     >     
>     
> *   Or:
>     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)1​ is of the form ([array](#syntax-comptype) ft1​).
>     >     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)2​ is of the form ([array](#syntax-comptype) ft2​).
>     >     
>     > *   The [field type](#syntax-fieldtype) ft1​ [matches](#match-fieldtype) the [field type](#syntax-fieldtype) ft2​.
>     >     
>     
> *   Or:
>     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)1​ is of the form ([func](#syntax-comptype) t11∗​ [→](#syntax-comptype) t12∗​).
>     >     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)2​ is of the form ([func](#syntax-comptype) t21∗​ [→](#syntax-comptype) t22∗​).
>     >     
>     > *   The [result type](#syntax-resulttype) t21∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t11∗​.
>     >     
>     > *   The [result type](#syntax-resulttype) t12∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t22∗​.
>     >     
>     

C[⊢](#match-comptype)[struct](#syntax-comptype) (ft1∗​ ft′1∗​)[≤](#match-comptype)[struct](#syntax-comptype) ft2∗​(C[⊢](#match-fieldtype)ft1​[≤](#match-fieldtype)ft2​)∗​C[⊢](#match-comptype)[array](#syntax-comptype) ft1​[≤](#match-comptype)[array](#syntax-comptype) ft2​C[⊢](#match-fieldtype)ft1​[≤](#match-fieldtype)ft2​​C[⊢](#match-comptype)[func](#syntax-comptype) t11∗​[→](#syntax-comptype)t12∗​[≤](#match-comptype)[func](#syntax-comptype) t21∗​[→](#syntax-comptype)t22∗​C[⊢](#match-resulttype)t21∗​[≤](#match-resulttype)t11∗​C[⊢](#match-resulttype)t12∗​[≤](#match-resulttype)t22∗​​​

#### 3.3.9. Field Types[](#field-types①)

The [field type](#syntax-fieldtype) ([mut](#syntax-mut)1?​ zt1​) [matches](#match-fieldtype) the [field type](#syntax-fieldtype) ([mut](#syntax-mut)2?​ zt2​) if:

> *   The [storage type](#syntax-storagetype) zt1​ [matches](#match-storagetype) the [storage type](#syntax-storagetype) zt2​.
>     
> *   Either:
>     
>     > *   [mut](#syntax-mut)1?​ is absent.
>     >     
>     > *   [mut](#syntax-mut)2?​ is absent.
>     >     
>     
> *   Or:
>     
>     > *   [mut](#syntax-mut)1?​ is of the form [mut](#syntax-mut).
>     >     
>     > *   [mut](#syntax-mut)2?​ is of the form [mut](#syntax-mut).
>     >     
>     > *   The [storage type](#syntax-storagetype) zt2​ [matches](#match-storagetype) the [storage type](#syntax-storagetype) zt1​.
>     >     
>     

C[⊢](#match-fieldtype)zt1​[≤](#match-fieldtype)zt2​C[⊢](#match-storagetype)zt1​[≤](#match-storagetype)zt2​​C[⊢](#match-fieldtype)[mut](#syntax-mut) zt1​[≤](#match-fieldtype)[mut](#syntax-mut) zt2​C[⊢](#match-storagetype)zt1​[≤](#match-storagetype)zt2​C[⊢](#match-storagetype)zt2​[≤](#match-storagetype)zt1​​​

The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)1​ [matches](#match-storagetype) the [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)2​ if:

> *   Either:
>     
>     > *   The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)1​ is of the form [valtype](#syntax-valtype)1​.
>     >     
>     > *   The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)2​ is of the form [valtype](#syntax-valtype)2​.
>     >     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ [matches](#match-valtype) the [value type](#syntax-valtype) [valtype](#syntax-valtype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)1​ is of the form [packtype](#syntax-packtype)1​.
>     >     
>     > *   The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)2​ is of the form [packtype](#syntax-packtype)2​.
>     >     
>     > *   The [packed type](#syntax-packtype) [packtype](#syntax-packtype)1​ [matches](#match-packtype) the [packed type](#syntax-packtype) [packtype](#syntax-packtype)2​.
>     >     
>     

The [packed type](#syntax-packtype) [packtype](#syntax-packtype) [matches](#match-packtype) only itself.

C[⊢](#match-packtype)[packtype](#syntax-packtype)[≤](#match-packtype)[packtype](#syntax-packtype)​​

#### 3.3.10. Defined Types[](#defined-types③)

The [defined type](#syntax-deftype) [deftype](#syntax-deftype)1​ [matches](#match-deftype) the [defined type](#syntax-deftype) [deftype](#syntax-deftype)2​ if:

> *   Either:
>     
>     > *   The [defined type](#syntax-deftype) [clos](#aux-clostype)C​([deftype](#syntax-deftype)1​) is of the form [clos](#aux-clostype)C​([deftype](#syntax-deftype)2​).
>     >     
>     
> *   Or:
>     
>     > *   The [sub type](#syntax-subtype) [unroll](#aux-unroll-deftype)([deftype](#syntax-deftype)1​) is of the form ([sub](#syntax-subtype) [final](#syntax-subtype)? [typeuse](#syntax-typeuse)∗ ct).
>     >     
>     > *   The length of [typeuse](#syntax-typeuse)∗ is greater than i.
>     >     
>     > *   The [type use](#syntax-typeuse) [typeuse](#syntax-typeuse)∗\[i\] [matches](#match) the [heap type](#syntax-heaptype) [deftype](#syntax-deftype)2​.
>     >     
>     

C[⊢](#match-deftype)[deftype](#syntax-deftype)1​[≤](#match-deftype)[deftype](#syntax-deftype)2​[clos](#aux-clostype)C​([deftype](#syntax-deftype)1​)\=[clos](#aux-clostype)C​([deftype](#syntax-deftype)2​)​3ex\]C[⊢](#match-deftype)[deftype](#syntax-deftype)1​[≤](#match-deftype)[deftype](#syntax-deftype)2​[unroll](#aux-unroll-deftype)([deftype](#syntax-deftype)1​)\=[sub](#syntax-subtype) [final](#syntax-subtype)? [typeuse](#syntax-typeuse)∗ ctC[⊢](#match-heaptype)[typeuse](#syntax-typeuse)∗\[i\][≤](#match-heaptype)[deftype](#syntax-deftype)2​​​​

Note

Note that there is no explicit definition of type _equivalence_, since it coincides with syntactic equality, as used in the premise of the former rule above.

#### 3.3.11. Limits[](#limits⑤)

The [limits range](#syntax-limits) \[n1​[..](#syntax-limits)[u64](#syntax-int)1?​\] [matches](#match-limits) the [limits range](#syntax-limits) \[n2​[..](#syntax-limits)[u64](#syntax-int)2?​\] if:

> *   n1​ is greater than or equal to n2​.
>     
> *   Either:
>     
>     > *   [u64](#syntax-int)1?​ is of the form m1​.
>     >     
>     > *   If [u64](#syntax-int)2​ is defined, then:
>     >     
>     >     > *   m1​ is less than or equal to [u64](#syntax-int)2​.
>     >     >     
>     >     
>     
> *   Or:
>     
>     > *   [u64](#syntax-int)1?​ is absent.
>     >     
>     > *   [u64](#syntax-int)2?​ is absent.
>     >     
>     

C[⊢](#match-limits)\[n1​[..](#syntax-limits)m1​\][≤](#match-limits)\[n2​[..](#syntax-limits)m2?​\]n1​≥n2​(m1​≤m2​)?​C[⊢](#match-limits)\[n1​[..](#syntax-limits)ϵ\][≤](#match-limits)\[n2​[..](#syntax-limits)ϵ\]n1​≥n2​​​

#### 3.3.12. Tag Types[](#tag-types⑤)

The [tag type](#syntax-tagtype) [deftype](#syntax-deftype)1​ [matches](#match-tagtype) the [tag type](#syntax-tagtype) [deftype](#syntax-deftype)2​ if:

> *   The [defined type](#syntax-deftype) [deftype](#syntax-deftype)1​ [matches](#match-deftype) the [defined type](#syntax-deftype) [deftype](#syntax-deftype)2​.
>     
> *   The [defined type](#syntax-deftype) [deftype](#syntax-deftype)2​ [matches](#match-deftype) the [defined type](#syntax-deftype) [deftype](#syntax-deftype)1​.
>     

C[⊢](#match-tagtype)[deftype](#syntax-deftype)1​[≤](#match-tagtype)[deftype](#syntax-deftype)2​C[⊢](#match-deftype)[deftype](#syntax-deftype)1​[≤](#match-deftype)[deftype](#syntax-deftype)2​C[⊢](#match-deftype)[deftype](#syntax-deftype)2​[≤](#match-deftype)[deftype](#syntax-deftype)1​​​

Note

Although the conclusion of this rule looks identical to its premise, they in fact describe different relations: the premise invokes subtyping on defined types, while the conclusion defines it on tag types that happen to be expressed as defined types.

#### 3.3.13. Global Types[](#global-types⑤)

The [global type](#syntax-globaltype) ([mut](#syntax-mut)1?​ [valtype](#syntax-valtype)1​) [matches](#match-globaltype) the [global type](#syntax-globaltype) ([mut](#syntax-mut)2?​ [valtype](#syntax-valtype)2​) if:

> *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ [matches](#match-valtype) the [value type](#syntax-valtype) [valtype](#syntax-valtype)2​.
>     
> *   Either:
>     
>     > *   [mut](#syntax-mut)1?​ is absent.
>     >     
>     > *   [mut](#syntax-mut)2?​ is absent.
>     >     
>     
> *   Or:
>     
>     > *   [mut](#syntax-mut)1?​ is of the form [mut](#syntax-mut).
>     >     
>     > *   [mut](#syntax-mut)2?​ is of the form [mut](#syntax-mut).
>     >     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)2​ [matches](#match-valtype) the [value type](#syntax-valtype) [valtype](#syntax-valtype)1​.
>     >     
>     

C[⊢](#match-globaltype)[valtype](#syntax-valtype)1​[≤](#match-globaltype)[valtype](#syntax-valtype)2​C[⊢](#match-valtype)[valtype](#syntax-valtype)1​[≤](#match-valtype)[valtype](#syntax-valtype)2​​C[⊢](#match-globaltype)[mut](#syntax-mut) [valtype](#syntax-valtype)1​[≤](#match-globaltype)[mut](#syntax-mut) [valtype](#syntax-valtype)2​C[⊢](#match-valtype)[valtype](#syntax-valtype)1​[≤](#match-valtype)[valtype](#syntax-valtype)2​C[⊢](#match-valtype)[valtype](#syntax-valtype)2​[≤](#match-valtype)[valtype](#syntax-valtype)1​​​

#### 3.3.14. Memory Types[](#memory-types⑤)

The [memory type](#syntax-memtype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits)1​ [page](#syntax-memtype)) [matches](#match-memtype) the [memory type](#syntax-memtype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits)2​ [page](#syntax-memtype)) if:

> *   The [limits range](#syntax-limits) [limits](#syntax-limits)1​ [matches](#match-limits) the [limits range](#syntax-limits) [limits](#syntax-limits)2​.
>     

C[⊢](#match-memtype)[addrtype](#syntax-addrtype) [limits](#syntax-limits)1​ [page](#syntax-memtype)[≤](#match-memtype)[addrtype](#syntax-addrtype) [limits](#syntax-limits)2​ [page](#syntax-memtype)C[⊢](#match-limits)[limits](#syntax-limits)1​[≤](#match-limits)[limits](#syntax-limits)2​​​

#### 3.3.15. Table Types[](#table-types⑤)

The [table type](#syntax-tabletype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits)1​ [reftype](#syntax-reftype)1​) [matches](#match-tabletype) the [table type](#syntax-tabletype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits)2​ [reftype](#syntax-reftype)2​) if:

> *   The [limits range](#syntax-limits) [limits](#syntax-limits)1​ [matches](#match-limits) the [limits range](#syntax-limits) [limits](#syntax-limits)2​.
>     
> *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype)1​ [matches](#match-reftype) the [reference type](#syntax-reftype) [reftype](#syntax-reftype)2​.
>     
> *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype)2​ [matches](#match-reftype) the [reference type](#syntax-reftype) [reftype](#syntax-reftype)1​.
>     

C[⊢](#match-tabletype)[addrtype](#syntax-addrtype) [limits](#syntax-limits)1​ [reftype](#syntax-reftype)1​[≤](#match-tabletype)[addrtype](#syntax-addrtype) [limits](#syntax-limits)2​ [reftype](#syntax-reftype)2​C[⊢](#match-limits)[limits](#syntax-limits)1​[≤](#match-limits)[limits](#syntax-limits)2​C[⊢](#match-reftype)[reftype](#syntax-reftype)1​[≤](#match-reftype)[reftype](#syntax-reftype)2​C[⊢](#match-reftype)[reftype](#syntax-reftype)2​[≤](#match-reftype)[reftype](#syntax-reftype)1​​​

#### 3.3.16. External Types[](#external-types⑤)

The [external type](#syntax-externtype) ([tag](#syntax-externtype) [tagtype](#syntax-tagtype)1​) [matches](#match-externtype) the [external type](#syntax-externtype) ([tag](#syntax-externtype) [tagtype](#syntax-tagtype)2​) if:

> *   The [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype)1​ [matches](#match-tagtype) the [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype)2​.
>     

C[⊢](#match-externtype)[tag](#syntax-externtype) [tagtype](#syntax-tagtype)1​[≤](#match-externtype)[tag](#syntax-externtype) [tagtype](#syntax-tagtype)2​C[⊢](#match-tagtype)[tagtype](#syntax-tagtype)1​[≤](#match-tagtype)[tagtype](#syntax-tagtype)2​​​

The [external type](#syntax-externtype) ([global](#syntax-externtype) [globaltype](#syntax-globaltype)1​) [matches](#match-externtype) the [external type](#syntax-externtype) ([global](#syntax-externtype) [globaltype](#syntax-globaltype)2​) if:

> *   The [global type](#syntax-globaltype) [globaltype](#syntax-globaltype)1​ [matches](#match-globaltype) the [global type](#syntax-globaltype) [globaltype](#syntax-globaltype)2​.
>     

C[⊢](#match-externtype)[global](#syntax-externtype) [globaltype](#syntax-globaltype)1​[≤](#match-externtype)[global](#syntax-externtype) [globaltype](#syntax-globaltype)2​C[⊢](#match-globaltype)[globaltype](#syntax-globaltype)1​[≤](#match-globaltype)[globaltype](#syntax-globaltype)2​​​

The [external type](#syntax-externtype) ([mem](#syntax-externtype) [memtype](#syntax-memtype)1​) [matches](#match-externtype) the [external type](#syntax-externtype) ([mem](#syntax-externtype) [memtype](#syntax-memtype)2​) if:

> *   The [memory type](#syntax-memtype) [memtype](#syntax-memtype)1​ [matches](#match-memtype) the [memory type](#syntax-memtype) [memtype](#syntax-memtype)2​.
>     

C[⊢](#match-externtype)[mem](#syntax-externtype) [memtype](#syntax-memtype)1​[≤](#match-externtype)[mem](#syntax-externtype) [memtype](#syntax-memtype)2​C[⊢](#match-memtype)[memtype](#syntax-memtype)1​[≤](#match-memtype)[memtype](#syntax-memtype)2​​​

The [external type](#syntax-externtype) ([table](#syntax-externtype) [tabletype](#syntax-tabletype)1​) [matches](#match-externtype) the [external type](#syntax-externtype) ([table](#syntax-externtype) [tabletype](#syntax-tabletype)2​) if:

> *   The [table type](#syntax-tabletype) [tabletype](#syntax-tabletype)1​ [matches](#match-tabletype) the [table type](#syntax-tabletype) [tabletype](#syntax-tabletype)2​.
>     

C[⊢](#match-externtype)[table](#syntax-externtype) [tabletype](#syntax-tabletype)1​[≤](#match-externtype)[table](#syntax-externtype) [tabletype](#syntax-tabletype)2​C[⊢](#match-tabletype)[tabletype](#syntax-tabletype)1​[≤](#match-tabletype)[tabletype](#syntax-tabletype)2​​​

The [external type](#syntax-externtype) ([func](#syntax-externtype) [deftype](#syntax-deftype)1​) [matches](#match-externtype) the [external type](#syntax-externtype) ([func](#syntax-externtype) [deftype](#syntax-deftype)2​) if:

> *   The [defined type](#syntax-deftype) [deftype](#syntax-deftype)1​ [matches](#match-deftype) the [defined type](#syntax-deftype) [deftype](#syntax-deftype)2​.
>     

C[⊢](#match-externtype)[func](#syntax-externtype) [deftype](#syntax-deftype)1​[≤](#match-externtype)[func](#syntax-externtype) [deftype](#syntax-deftype)2​C[⊢](#match-deftype)[deftype](#syntax-deftype)1​[≤](#match-deftype)[deftype](#syntax-deftype)2​​​

### 3.4. Instructions[](#instructions③)

[Instructions](#syntax-instr) are classified by [instruction types](#syntax-instrtype) that describe how they manipulate the [operand stack](#stack) and initialize [locals](#syntax-local): A type t1∗​[→](#syntax-instrtype)x∗​t2∗​ describes the required input stack with argument values of types t1∗​ that an instruction pops off and the provided output stack with result values of types t2∗​ that it pushes back. Moreover, it enumerates the [indices](#syntax-localidx) x∗ of locals that have been set by the instruction. In most cases, this is empty.

Note

For example, the instruction [i32](#syntax-numtype).[add](#syntax-instr-numeric) has type [i32](#syntax-numtype) [i32](#syntax-numtype)→[i32](#syntax-numtype), consuming two [i32](#syntax-numtype) values and producing one. The instruction ([local.set](#syntax-instr-variable) x) has type t[→](#syntax-instrtype)x​ϵ, provided t is the type declared for the local x.

Typing extends to [instruction sequences](#valid-instrs) [instr](#syntax-instr)∗. Such a sequence has an instruction type t1∗​[→](#syntax-instrtype)x∗​t2∗​ if the accumulative effect of executing the instructions is consuming values of types t1∗​ off the operand stack, pushing new values of types t2∗​, and setting all locals x∗.

For some instructions, the typing rules do not fully constrain the type, and therefore allow for multiple types. Such instructions are called _polymorphic_. Two degrees of polymorphism can be distinguished:

*   _value-polymorphic_: the [value type](#syntax-valtype) t of one or several individual operands is unconstrained. That is the case for all [parametric instructions](#valid-instr-parametric) like drop and select.
    
*   _stack-polymorphic_: the entire (or most of the) [instruction type](#syntax-instrtype) t1∗​→t2∗​ of the instruction is unconstrained. That is the case for all [control instructions](#valid-instr-control) that perform an _unconditional control transfer_, such as unreachable, br, or return.
    

In both cases, the unconstrained types or type sequences can be chosen arbitrarily, as long as they meet the constraints imposed for the surrounding parts of the program.

Note

For example, the select instruction is valid with type t t [i32](#syntax-numtype)→t, for any possible [number type](#syntax-numtype) t. Consequently, both instruction sequences

([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 2) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 3) ([select](#syntax-instr-parametric))

and

([f64](#syntax-numtype).[const](#syntax-instr-numeric) +64) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) +64) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) +64) ([select](#syntax-instr-parametric))

are valid, with t in the typing of select being instantiated to i32 or f64, respectively.

The unreachable instruction is stack-polymorphic, and hence valid with type t1∗​→t2∗​ for any possible sequences of value types t1∗​ and t2∗​. Consequently,

([unreachable](#syntax-instr-control)) ([i32](#syntax-numtype).[add](#syntax-instr-numeric))

is valid by assuming type ϵ→[i32](#syntax-numtype) for the unreachable instruction. In contrast,

([unreachable](#syntax-instr-control)) ([i64](#syntax-numtype).[const](#syntax-instr-numeric) 0) ([i32](#syntax-numtype).[add](#syntax-instr-numeric))

is invalid, because there is no possible type to pick for the unreachable instruction that would make the sequence well-typed.

The [Appendix](#algo-valid) describes a type checking [algorithm](#algo-valid) that efficiently implements validation of instruction sequences as prescribed by the rules given here.

#### 3.4.1. Parametric Instructions[](#parametric-instructions③)

##### 3.4.1.1. [nop](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfnop)

The [instruction](#syntax-instr) [nop](#syntax-instr-control) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ϵ.

C[⊢](#valid-instr)[nop](#syntax-instr-control):ϵ→ϵ​​

##### 3.4.1.2. [unreachable](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfunreachable)

The [instruction](#syntax-instr) [unreachable](#syntax-instr-control) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [instruction type](#syntax-instrtype) t1∗​ → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[unreachable](#syntax-instr-control):t1∗​→t2∗​C[⊢](#valid-instrtype)t1∗​→t2∗​:[ok](#valid-instrtype)​​

Note

The unreachable instruction is [stack-polymorphic](#polymorphism).

##### 3.4.1.3. [drop](#syntax-instr-parametric)[](#-hrefsyntax-instr-parametricmathsfdrop)

The [instruction](#syntax-instr) [drop](#syntax-instr-parametric) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t → ϵ if:

> *   The [value type](#syntax-valtype) t is [valid](#valid-valtype).
>     

C[⊢](#valid-instr)[drop](#syntax-instr-parametric):t→ϵC[⊢](#valid-valtype)t:[ok](#valid-valtype)​​

Note

Both drop and select without annotation are [value-polymorphic](#polymorphism) instructions.

##### 3.4.1.4. [select](#syntax-instr-parametric) (t∗)?[](#-hrefsyntax-instr-parametricmathsfselect-tast)

The [instruction](#syntax-instr) ([select](#syntax-instr-parametric) [valtype](#syntax-valtype)?) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t t [i32](#syntax-numtype) → t if:

> *   The [value type](#syntax-valtype) t is [valid](#valid-valtype).
>     
> *   Either:
>     
>     > *   The value type sequence [valtype](#syntax-valtype)? is of the form t.
>     >     
>     
> *   Or:
>     
>     > *   The value type sequence [valtype](#syntax-valtype)? is absent.
>     >     
>     > *   The [value type](#syntax-valtype) t [matches](#match-valtype) the [value type](#syntax-valtype) t′.
>     >     
>     > *   The [value type](#syntax-valtype) t′ is of the form [numtype](#syntax-numtype) or t′ is of the form [vectype](#syntax-vectype).
>     >     
>     

C[⊢](#valid-instr)[select](#syntax-instr-parametric) t:t t [i32](#syntax-numtype)→tC[⊢](#valid-valtype)t:[ok](#valid-valtype)​C[⊢](#valid-instr)[select](#syntax-instr-parametric):t t [i32](#syntax-numtype)→tC[⊢](#valid-valtype)t:[ok](#valid-valtype)C[⊢](#match-valtype)t[≤](#match-valtype)t′t′\=[numtype](#syntax-numtype)∨t′\=[vectype](#syntax-vectype)​​

Note

In future versions of WebAssembly, select may allow more than one value per choice.

#### 3.4.2. Control Instructions[](#control-instructions③)

##### 3.4.2.1. [block](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsfblockhrefsyntax-blocktypemathitblocktypehrefsyntax-instrmathitinstrast)

The [instruction](#syntax-instr) ([block](#syntax-instr-control) bt [instr](#syntax-instr)∗) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [block type](#syntax-blocktype) bt is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) t1∗​ → t2∗​.
>     
> *   Let C′ be the same context as C, but with the result type sequence t2∗​ prepended to the field [labels](#context).
>     
> *   Under the context C′, the instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x∗​t2∗​.
>     

C[⊢](#valid-instr)[block](#syntax-instr-control) bt [instr](#syntax-instr)∗:t1∗​→t2∗​C[⊢](#valid-blocktype)bt:t1∗​→t2∗​{[labels](#context) (t2∗​)}⊕C[⊢](#valid-instrs)[instr](#syntax-instr)∗:t1∗​[→](#syntax-instrtype)x∗​t2∗​​​

Note

The [notation](#notation-concat) {[labels](#context) (t∗)}⊕C inserts the new label type at index 0, shifting all others. The same applies to all other block instructions.

##### 3.4.2.2. [loop](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsfloophrefsyntax-blocktypemathitblocktypehrefsyntax-instrmathitinstrast)

The [instruction](#syntax-instr) ([loop](#syntax-instr-control) bt [instr](#syntax-instr)∗) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [block type](#syntax-blocktype) bt is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) t1∗​ → t2∗​.
>     
> *   Let C′ be the same context as C, but with the result type sequence t1∗​ prepended to the field [labels](#context).
>     
> *   Under the context C′, the instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x∗​t2∗​.
>     

C[⊢](#valid-instr)[loop](#syntax-instr-control) bt [instr](#syntax-instr)∗:t1∗​→t2∗​C[⊢](#valid-blocktype)bt:t1∗​→t2∗​{[labels](#context) (t1∗​)}⊕C[⊢](#valid-instrs)[instr](#syntax-instr)∗:t1∗​[→](#syntax-instrtype)x∗​t2∗​​​

##### 3.4.2.3. [if](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)1∗​ [else](#syntax-instr-control) [instr](#syntax-instr)2∗​[](#-hrefsyntax-instr-controlmathsfifhrefsyntax-blocktypemathitblocktypehrefsyntax-instrmathitinstr_1asthrefsyntax-instr-controlmathsfelsehrefsyntax-instrmathitinstr_2ast)

The [instruction](#syntax-instr) ([if](#syntax-instr-control) bt [instr](#syntax-instr)1∗​ [else](#syntax-instr-control) [instr](#syntax-instr)2∗​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [i32](#syntax-numtype) → t2∗​ if:

> *   The [block type](#syntax-blocktype) bt is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) t1∗​ → t2∗​.
>     
> *   Let C′ be the same context as C, but with the result type sequence t2∗​ prepended to the field [labels](#context).
>     
> *   Under the context C′, the instruction sequence [instr](#syntax-instr)1∗​ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x1∗​​t2∗​.
>     
> *   Under the context C′, the instruction sequence [instr](#syntax-instr)2∗​ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x2∗​​t2∗​.
>     

C[⊢](#valid-instr)[if](#syntax-instr-control) bt [instr](#syntax-instr)1∗​ [else](#syntax-instr-control) [instr](#syntax-instr)2∗​:t1∗​ [i32](#syntax-numtype)→t2∗​C[⊢](#valid-blocktype)bt:t1∗​→t2∗​{[labels](#context) (t2∗​)}⊕C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​:t1∗​[→](#syntax-instrtype)x1∗​​t2∗​{[labels](#context) (t2∗​)}⊕C[⊢](#valid-instrs)[instr](#syntax-instr)2∗​:t1∗​[→](#syntax-instrtype)x2∗​​t2∗​​​

##### 3.4.2.4. [br](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbrl)

The [instruction](#syntax-instr) ([br](#syntax-instr-control) l) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ t∗ → t2∗​ if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗.
>     
> *   The [instruction type](#syntax-instrtype) t1∗​ → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[br](#syntax-instr-control) l:t1∗​ t∗→t2∗​C.[labels](#context)\[l\]\=t∗C[⊢](#valid-instrtype)t1∗​→t2∗​:[ok](#valid-instrtype)​​

Note

The [label index](#syntax-labelidx) space in the [context](#context) C contains the most recent label first, so that C.labels\[l\] performs a relative lookup as expected. This applies to other branch instructions as well.

The br instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.5. [br\_if](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_ifl)

The [instruction](#syntax-instr) ([br\_if](#syntax-instr-control) l) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ [i32](#syntax-numtype) → t∗ if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗.
>     

C[⊢](#valid-instr)[br\_if](#syntax-instr-control) l:t∗ [i32](#syntax-numtype)→t∗C.[labels](#context)\[l\]\=t∗​​

##### 3.4.2.6. [br\_table](#syntax-instr-control) l∗ lN​[](#-hrefsyntax-instr-controlmathsfbr_tablelastl_n)

The [instruction](#syntax-instr) ([br\_table](#syntax-instr-control) l∗ l′) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ t∗ [i32](#syntax-numtype) → t2∗​ if:

> *   For all l in l∗:
>     
>     > *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     >     
>     > *   The [result type](#syntax-resulttype) t∗ [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l\].
>     >     
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l′\] exists.
>     
> *   The [result type](#syntax-resulttype) t∗ [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l′\].
>     
> *   The [instruction type](#syntax-instrtype) t1∗​ t∗ [i32](#syntax-numtype) → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[br\_table](#syntax-instr-control) l∗ l′:t1∗​ t∗ [i32](#syntax-numtype)→t2∗​(C[⊢](#match-resulttype)t∗[≤](#match-resulttype)C.[labels](#context)\[l\])∗C[⊢](#match-resulttype)t∗[≤](#match-resulttype)C.[labels](#context)\[l′\]C[⊢](#valid-instrtype)t1∗​ t∗ [i32](#syntax-numtype)→t2∗​:[ok](#valid-instrtype)​​

Note

The br\_table instruction is [stack-polymorphic](#polymorphism).

Furthermore, the [result type](#syntax-resulttype) t∗ is also chosen non-deterministically in this rule. Although it may seem necessary to compute t∗ as the greatest lower bound of all label types in practice, a simple [sequential algorithm](#algo-valid) does not require this.

##### 3.4.2.7. [br\_on\_null](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_on_nulll)

The [instruction](#syntax-instr) ([br\_on\_null](#syntax-instr-control) l) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ ([ref](#syntax-reftype) [null](#syntax-reftype) ht) → t∗ ([ref](#syntax-reftype) ht) if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗.
>     
> *   The [heap type](#syntax-heaptype) ht is [valid](#valid-heaptype).
>     

C[⊢](#valid-instr)[br\_on\_null](#syntax-instr-control) l:t∗ ([ref](#syntax-reftype) [null](#syntax-reftype) ht)→t∗ ([ref](#syntax-reftype) ht)C.[labels](#context)\[l\]\=t∗C[⊢](#valid-heaptype)ht:[ok](#valid-heaptype)​​

##### 3.4.2.8. [br\_on\_non\_null](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_on_non_nulll)

The [instruction](#syntax-instr) ([br\_on\_non\_null](#syntax-instr-control) l) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ ([ref](#syntax-reftype) [null](#syntax-reftype) ht) → t∗ if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗ ([ref](#syntax-reftype) [null](#syntax-reftype)? ht).
>     

C[⊢](#valid-instr)[br\_on\_non\_null](#syntax-instr-control) l:t∗ ([ref](#syntax-reftype) [null](#syntax-reftype) ht)→t∗C.[labels](#context)\[l\]\=t∗ ([ref](#syntax-reftype) [null](#syntax-reftype)? ht)​​

##### 3.4.2.9. [br\_on\_cast](#syntax-instr-control) l rt1​ rt2​[](#-hrefsyntax-instr-controlmathsfbr_on_castlmathitrt_1mathitrt_2)

The [instruction](#syntax-instr) ([br\_on\_cast](#syntax-instr-control) l rt1​ rt2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ rt1​ → t∗ [reftype](#syntax-reftype) if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗ rt.
>     
> *   The [reference type](#syntax-reftype) rt1​ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt2​ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt1​.
>     
> *   The [reference type](#syntax-reftype) rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt.
>     
> *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype) is rt1​[∖](#aux-reftypediff)rt2​.
>     

C[⊢](#valid-instr)[br\_on\_cast](#syntax-instr-control) l rt1​ rt2​:t∗ rt1​→t∗ (rt1​[∖](#aux-reftypediff)rt2​)C.[labels](#context)\[l\]\=t∗ rtC[⊢](#valid-reftype)rt1​:[ok](#valid-reftype)C[⊢](#valid-reftype)rt2​:[ok](#valid-reftype)C[⊢](#match-reftype)rt2​[≤](#match-reftype)rt1​C[⊢](#match-reftype)rt2​[≤](#match-reftype)rt​​

##### 3.4.2.10. [br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​[](#-hrefsyntax-instr-controlmathsfbr_on_cast_faillmathitrt_1mathitrt_2)

The [instruction](#syntax-instr) ([br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ rt1​ → t∗ rt2​ if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗ rt.
>     
> *   The [reference type](#syntax-reftype) rt1​ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt2​ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt1​.
>     
> *   The [reference type](#syntax-reftype) rt1​[∖](#aux-reftypediff)rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt.
>     

C[⊢](#valid-instr)[br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​:t∗ rt1​→t∗ rt2​C.[labels](#context)\[l\]\=t∗ rtC[⊢](#valid-reftype)rt1​:[ok](#valid-reftype)C[⊢](#valid-reftype)rt2​:[ok](#valid-reftype)C[⊢](#match-reftype)rt2​[≤](#match-reftype)rt1​C[⊢](#match-reftype)rt1​[∖](#aux-reftypediff)rt2​[≤](#match-reftype)rt​​

##### 3.4.2.11. [call](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfcallx)

The [instruction](#syntax-instr) ([call](#syntax-instr-control) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[funcs](#context)\[x\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-instr)[call](#syntax-instr-control) x:t1∗​→t2∗​C.[funcs](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

##### 3.4.2.12. [call\_ref](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfcall_refx)

The [instruction](#syntax-instr) ([call\_ref](#syntax-instr-control) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x) → t2∗​ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-instr)[call\_ref](#syntax-instr-control) x:t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x)→t2∗​C.[types](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

##### 3.4.2.13. [call\_indirect](#syntax-instr-control) x y[](#-hrefsyntax-instr-controlmathsfcall_indirectxy)

The [instruction](#syntax-instr) ([call\_indirect](#syntax-instr-control) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ at → t2∗​ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     
> *   The [reference type](#syntax-reftype) rt [matches](#match-reftype) the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)).
>     
> *   The [type](#syntax-deftype) C.[types](#context)\[y\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[y\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-instr)[call\_indirect](#syntax-instr-control) x y:t1∗​ at→t2∗​C.[tables](#context)\[x\]\=at lim rtC[⊢](#match-reftype)rt[≤](#match-reftype)([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype))C.[types](#context)\[y\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

##### 3.4.2.14. [return](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfreturn)

The [instruction](#syntax-instr) [return](#syntax-instr-control) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ t∗ → t2∗​ if:

> *   The result type C.[return](#context) is of the form t∗.
>     
> *   The [instruction type](#syntax-instrtype) t1∗​ → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[return](#syntax-instr-control):t1∗​ t∗→t2∗​C.[return](#context)\=(t∗)C[⊢](#valid-instrtype)t1∗​→t2∗​:[ok](#valid-instrtype)​​

Note

The return instruction is [stack-polymorphic](#polymorphism).

C.[return](#context) is absent (set to ϵ) when validating an [expression](#valid-expr) that is not a function body. This differs from it being set to the empty result type \[ϵ\], which is the case for functions not returning anything.

##### 3.4.2.15. [return\_call](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfreturn_callx)

The [instruction](#syntax-instr) ([return\_call](#syntax-instr-control) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t3∗​ t1∗​ → t4∗​ if:

> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[funcs](#context)\[x\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     
> *   The result type C.[return](#context) is of the form t′2∗​.
>     
> *   The [result type](#syntax-resulttype) t2∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t′2∗​.
>     
> *   The [instruction type](#syntax-instrtype) t3∗​ → t4∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[return\_call](#syntax-instr-control) x:t3∗​ t1∗​→t4∗​C.[funcs](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​C.[return](#context)\=(t′2∗​)C[⊢](#match-resulttype)t2∗​[≤](#match-resulttype)t′2∗​C[⊢](#valid-instrtype)t3∗​→t4∗​:[ok](#valid-instrtype)​​

Note

The return\_call instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.16. [return\_call\_ref](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfreturn_call_refx)

The [instruction](#syntax-instr) ([return\_call\_ref](#syntax-instr-control) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t3∗​ t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x) → t4∗​ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     
> *   The result type C.[return](#context) is of the form t′2∗​.
>     
> *   The [result type](#syntax-resulttype) t2∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t′2∗​.
>     
> *   The [instruction type](#syntax-instrtype) t3∗​ → t4∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[return\_call\_ref](#syntax-instr-control) x:t3∗​ t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x)→t4∗​C.[types](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​C.[return](#context)\=(t′2∗​)C[⊢](#match-resulttype)t2∗​[≤](#match-resulttype)t′2∗​C[⊢](#valid-instrtype)t3∗​→t4∗​:[ok](#valid-instrtype)​​

Note

The return\_call\_ref instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.17. [return\_call\_indirect](#syntax-instr-control) x y[](#-hrefsyntax-instr-controlmathsfreturn_call_indirectxy)

The [instruction](#syntax-instr) ([return\_call\_indirect](#syntax-instr-control) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t3∗​ t1∗​ at → t4∗​ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     
> *   The [reference type](#syntax-reftype) rt [matches](#match-reftype) the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)).
>     
> *   The [type](#syntax-deftype) C.[types](#context)\[y\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[y\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     
> *   The result type C.[return](#context) is of the form t′2∗​.
>     
> *   The [result type](#syntax-resulttype) t2∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t′2∗​.
>     
> *   The [instruction type](#syntax-instrtype) t3∗​ → t4∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[return\_call\_indirect](#syntax-instr-control) x y:t3∗​ t1∗​ at→t4∗​C.[tables](#context)\[x\]\=at lim rtC[⊢](#match-reftype)rt[≤](#match-reftype)([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype))C.[types](#context)\[y\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​C.[return](#context)\=(t′2∗​)C[⊢](#match-resulttype)t2∗​[≤](#match-resulttype)t′2∗​C[⊢](#valid-instrtype)t3∗​→t4∗​:[ok](#valid-instrtype)​​​​

Note

The return\_call\_indirect instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.18. [throw](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfthrowx)

The [instruction](#syntax-instr) ([throw](#syntax-instr-control) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ t∗ → t2∗​ if:

> *   The [tag](#syntax-tagtype) C.[tags](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[tags](#context)\[x\] is ([func](#syntax-comptype) t∗ [→](#syntax-comptype)).
>     
> *   The [instruction type](#syntax-instrtype) t1∗​ → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[throw](#syntax-instr-control) x:t1∗​ t∗→t2∗​C.[tags](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t∗[→](#syntax-comptype)ϵC[⊢](#valid-instrtype)t1∗​→t2∗​:[ok](#valid-instrtype)​​

Note

The throw instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.19. [throw\_ref](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfthrow_ref)

The [instruction](#syntax-instr) [throw\_ref](#syntax-instr-control) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) [exn](#syntax-heaptype)) → t2∗​ if:

> *   The [instruction type](#syntax-instrtype) t1∗​ → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[throw\_ref](#syntax-instr-control):t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) [exn](#syntax-heaptype))→t2∗​C[⊢](#valid-instrtype)t1∗​→t2∗​:[ok](#valid-instrtype)​​

Note

The throw\_ref instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.20. [try\_table](#syntax-instr-control) [blocktype](#syntax-blocktype) [catch](#syntax-catch)∗ [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsftry_tablehrefsyntax-blocktypemathitblocktypehrefsyntax-catchmathitcatchasthrefsyntax-instrmathitinstrast)

The [instruction](#syntax-instr) ([try\_table](#syntax-instr-control) bt [catch](#syntax-catch)∗ [instr](#syntax-instr)∗) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [block type](#syntax-blocktype) bt is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) t1∗​ → t2∗​.
>     
> *   Let C′ be the same context as C, but with the result type sequence t2∗​ prepended to the field [labels](#context).
>     
> *   Under the context C′, the instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x∗​t2∗​.
>     
> *   For all [catch](#syntax-catch) in [catch](#syntax-catch)∗:
>     
>     > *   The [catch clause](#syntax-catch) [catch](#syntax-catch) is [valid](#valid-catch).
>     >     
>     

C[⊢](#valid-instr)[try\_table](#syntax-instr-control) bt [catch](#syntax-catch)∗ [instr](#syntax-instr)∗:t1∗​→t2∗​C[⊢](#valid-blocktype)bt:t1∗​→t2∗​{[labels](#context) (t2∗​)}⊕C[⊢](#valid-instrs)[instr](#syntax-instr)∗:t1∗​[→](#syntax-instrtype)x∗​t2∗​(C[⊢](#valid-catch)[catch](#syntax-catch):[ok](#valid-catch))∗​​

##### 3.4.2.21. [catch](#syntax-instr-control) x l[](#-hrefsyntax-instr-controlmathsfcatchxl)

The [catch clause](#syntax-catch) ([catch](#syntax-instr-control) x l) is [valid](#valid-catch) if:

> *   The [tag](#syntax-tagtype) C.[tags](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[tags](#context)\[x\] is ([func](#syntax-comptype) t∗ [→](#syntax-comptype)).
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [result type](#syntax-resulttype) t∗ [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l\].
>     

C[⊢](#valid-catch)[catch](#syntax-instr-control) x l:[ok](#valid-catch)C.[tags](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t∗[→](#syntax-comptype)ϵC[⊢](#match-resulttype)t∗[≤](#match-resulttype)C.[labels](#context)\[l\]​​

##### 3.4.2.22. [catch\_ref](#syntax-instr-control) x l[](#-hrefsyntax-instr-controlmathsfcatch_refxl)

The [catch clause](#syntax-catch) ([catch\_ref](#syntax-instr-control) x l) is [valid](#valid-catch) if:

> *   The [tag](#syntax-tagtype) C.[tags](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[tags](#context)\[x\] is ([func](#syntax-comptype) t∗ [→](#syntax-comptype)).
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [result type](#syntax-resulttype) t∗ ([ref](#syntax-reftype) [exn](#syntax-heaptype)) [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l\].
>     

C[⊢](#valid-catch)[catch\_ref](#syntax-instr-control) x l:[ok](#valid-catch)C.[tags](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t∗[→](#syntax-comptype)ϵC[⊢](#match-resulttype)t∗ ([ref](#syntax-reftype) [exn](#syntax-heaptype))[≤](#match-resulttype)C.[labels](#context)\[l\]​​

##### 3.4.2.23. [catch\_all](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfcatch_alll)

The [catch clause](#syntax-catch) ([catch\_all](#syntax-instr-control) l) is [valid](#valid-catch) if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [result type](#syntax-resulttype) ϵ [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l\].
>     

C[⊢](#valid-catch)[catch\_all](#syntax-instr-control) l:[ok](#valid-catch)C[⊢](#match-resulttype)ϵ[≤](#match-resulttype)C.[labels](#context)\[l\]​​

##### 3.4.2.24. [catch\_all\_ref](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfcatch_all_refl)

The [catch clause](#syntax-catch) ([catch\_all\_ref](#syntax-instr-control) l) is [valid](#valid-catch) if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [result type](#syntax-resulttype) ([ref](#syntax-reftype) [exn](#syntax-heaptype)) [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l\].
>     

C[⊢](#valid-catch)[catch\_all\_ref](#syntax-instr-control) l:[ok](#valid-catch)C[⊢](#match-resulttype)([ref](#syntax-reftype) [exn](#syntax-heaptype))[≤](#match-resulttype)C.[labels](#context)\[l\]​​

#### 3.4.3. Variable Instructions[](#variable-instructions③)

##### 3.4.3.1. [local.get](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalgetx)

The [instruction](#syntax-instr) ([local.get](#syntax-instr-variable) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → t if:

> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] exists.
>     
> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] is of the form ([set](#syntax-init) t).
>     

C[⊢](#valid-instr)[local.get](#syntax-instr-variable) x:ϵ→tC.[locals](#context)\[x\]\=[set](#syntax-init) t​​

##### 3.4.3.2. [local.set](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalsetx)

The [instruction](#syntax-instr) ([local.set](#syntax-instr-variable) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t [→](#syntax-instrtype)x​ϵ if:

> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] exists.
>     
> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] is of the form ([init](#syntax-init) t).
>     

C[⊢](#valid-instr)[local.set](#syntax-instr-variable) x:t[→](#syntax-instrtype)x​ϵC.[locals](#context)\[x\]\=[init](#syntax-init) t​​

##### 3.4.3.3. [local.tee](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalteex)

The [instruction](#syntax-instr) ([local.tee](#syntax-instr-variable) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t [→](#syntax-instrtype)x​t if:

> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] exists.
>     
> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] is of the form ([init](#syntax-init) t).
>     

C[⊢](#valid-instr)[local.tee](#syntax-instr-variable) x:t[→](#syntax-instrtype)x​tC.[locals](#context)\[x\]\=[init](#syntax-init) t​​

##### 3.4.3.4. [global.get](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsfglobalgetx)

The [instruction](#syntax-instr) ([global.get](#syntax-instr-variable) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → t if:

> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] exists.
>     
> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] is of the form ([mut](#syntax-mut)? t).
>     

C[⊢](#valid-instr)[global.get](#syntax-instr-variable) x:ϵ→tC.[globals](#context)\[x\]\=[mut](#syntax-mut)? t​​

##### 3.4.3.5. [global.set](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsfglobalsetx)

The [instruction](#syntax-instr) ([global.set](#syntax-instr-variable) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t → ϵ if:

> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] exists.
>     
> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] is of the form ([mut](#syntax-mut) t).
>     

C[⊢](#valid-instr)[global.set](#syntax-instr-variable) x:t→ϵC.[globals](#context)\[x\]\=[mut](#syntax-mut) t​​

#### 3.4.4. Table Instructions[](#table-instructions③)

##### 3.4.4.1. [table.get](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablegetx)

The [instruction](#syntax-instr) ([table.get](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → rt if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     

C[⊢](#valid-instr)[table.get](#syntax-instr-table) x:at→rtC.[tables](#context)\[x\]\=at lim rt​​

##### 3.4.4.2. [table.set](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablesetx)

The [instruction](#syntax-instr) ([table.set](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at rt → ϵ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     

C[⊢](#valid-instr)[table.set](#syntax-instr-table) x:at rt→ϵC.[tables](#context)\[x\]\=at lim rt​​

##### 3.4.4.3. [table.size](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablesizex)

The [instruction](#syntax-instr) ([table.size](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → at if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     

C[⊢](#valid-instr)[table.size](#syntax-instr-table) x:ϵ→atC.[tables](#context)\[x\]\=at lim rt​​

##### 3.4.4.4. [table.grow](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablegrowx)

The [instruction](#syntax-instr) ([table.grow](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) rt at → [i32](#syntax-numtype) if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     

C[⊢](#valid-instr)[table.grow](#syntax-instr-table) x:rt at→[i32](#syntax-numtype)C.[tables](#context)\[x\]\=at lim rt​​

##### 3.4.4.5. [table.fill](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablefillx)

The [instruction](#syntax-instr) ([table.fill](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at rt at → ϵ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     

C[⊢](#valid-instr)[table.fill](#syntax-instr-table) x:at rt at→ϵC.[tables](#context)\[x\]\=at lim rt​​

##### 3.4.4.6. [table.copy](#syntax-instr-table) x y[](#-hrefsyntax-instr-tablemathsftablecopyxy)

The [instruction](#syntax-instr) ([table.copy](#syntax-instr-table) x1​ x2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at1​ at2​ [addrtype](#syntax-addrtype) → ϵ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x1​\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x1​\] is of the form (at1​ lim1​ rt1​).
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x2​\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x2​\] is of the form (at2​ lim2​ rt2​).
>     
> *   The [reference type](#syntax-reftype) rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt1​.
>     
> *   The [address type](#syntax-addrtype) [addrtype](#syntax-addrtype) is [min](#aux-addrtype-min)(at1​,at2​).
>     

C[⊢](#valid-instr)[table.copy](#syntax-instr-table) x1​ x2​:at1​ at2​ [min](#aux-addrtype-min)(at1​,at2​)→ϵC.[tables](#context)\[x1​\]\=at1​ lim1​ rt1​C.[tables](#context)\[x2​\]\=at2​ lim2​ rt2​C[⊢](#match-reftype)rt2​[≤](#match-reftype)rt1​​​

##### 3.4.4.7. [table.init](#syntax-instr-table) x y[](#-hrefsyntax-instr-tablemathsftableinitxy)

The [instruction](#syntax-instr) ([table.init](#syntax-instr-table) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [i32](#syntax-numtype) [i32](#syntax-numtype) → ϵ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt1​).
>     
> *   The [element segment](#syntax-elemtype) C.[elems](#context)\[y\] exists.
>     
> *   The [element segment](#syntax-reftype) C.[elems](#context)\[y\] is of the form rt2​.
>     
> *   The [reference type](#syntax-reftype) rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt1​.
>     

C[⊢](#valid-instr)[table.init](#syntax-instr-table) x y:at [i32](#syntax-numtype) [i32](#syntax-numtype)→ϵC.[tables](#context)\[x\]\=at lim rt1​C.[elems](#context)\[y\]\=rt2​C[⊢](#match-reftype)rt2​[≤](#match-reftype)rt1​​​

##### 3.4.4.8. [elem.drop](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsfelemdropx)

The [instruction](#syntax-instr) ([elem.drop](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ϵ if:

> *   The [element segment](#syntax-elemtype) C.[elems](#context)\[x\] exists.
>     

C[⊢](#valid-instr)[elem.drop](#syntax-instr-table) x:ϵ→ϵC.[elems](#context)\[x\]\=rt​​

#### 3.4.5. Memory Instructions[](#memory-instructions③)

Memory instructions use [memory arguments](#syntax-memarg), which are classified by the [address type](#syntax-addrtype) and the and [bit width](#bitwidth-valtype) of the access they are suitable for.

##### 3.4.5.1. [memarg](#syntax-memarg)[](#-hrefsyntax-memargmathitmemarg)

{[align](#syntax-instr-memory) n,[offset](#syntax-instr-memory) m} is valid for at and N if:

> *   2n is less than or equal to N/8.
>     
> *   m is less than 2∣at∣.
>     

[⊢](#valid-memarg){[align](#syntax-instr-memory) n,[offset](#syntax-instr-memory) m}:at[→](#valid-memarg)N2n≤N/8m<2∣at∣​​

##### 3.4.5.2. t.[load](#syntax-instr-memory) x [memarg](#syntax-memarg)[](#-tmathsfhrefsyntax-instr-memorymathsfloadxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) (nt.[load](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → nt if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and ∣nt∣.
>     

C[⊢](#valid-instr)nt.[load](#syntax-instr-memory) x [memarg](#syntax-memarg):at→ntC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)∣nt∣​​

##### 3.4.5.3. t.[load](#syntax-instr-memory)N\_[sx](#syntax-sx) x [memarg](#syntax-memarg)[](#-tmathsfhrefsyntax-instr-memorymathsfloadnmathsf_hrefsyntax-sxmathitsxxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([i](#syntax-numtype)[N](#syntax-numtype).[load](#syntax-instr-memory)M\_[sx](#syntax-sx) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → [i](#syntax-numtype)[N](#syntax-numtype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and M.
>     

C[⊢](#valid-instr)[i](#syntax-numtype)[N](#syntax-numtype).[load](#syntax-instr-memory)M\_[sx](#syntax-sx) x [memarg](#syntax-memarg):at→[i](#syntax-numtype)[N](#syntax-numtype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)M​​

##### 3.4.5.4. t.[store](#syntax-instr-memory) x [memarg](#syntax-memarg)[](#-tmathsfhrefsyntax-instr-memorymathsfstorexhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) (nt.[store](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at nt → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and ∣nt∣.
>     

C[⊢](#valid-instr)nt.[store](#syntax-instr-memory) x [memarg](#syntax-memarg):at nt→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)∣nt∣​​

##### 3.4.5.5. t.[store](#syntax-instr-memory)N x [memarg](#syntax-memarg)[](#-tmathsfhrefsyntax-instr-memorymathsfstorenxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([i](#syntax-numtype)[N](#syntax-numtype).[store](#syntax-instr-memory)M x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [i](#syntax-numtype)[N](#syntax-numtype) → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and M.
>     

C[⊢](#valid-instr)[i](#syntax-numtype)[N](#syntax-numtype).[store](#syntax-instr-memory)M x [memarg](#syntax-memarg):at [i](#syntax-numtype)[N](#syntax-numtype)→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)M​​

##### 3.4.5.6. v128.[load](#syntax-instr-memory) x [memarg](#syntax-memarg)[](#-mathsfv128hrefsyntax-instr-memorymathsfloadxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[load](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → [v128](#syntax-vectype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and ∣[v128](#syntax-vectype)∣.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[load](#syntax-instr-memory) x [memarg](#syntax-memarg):at→[v128](#syntax-vectype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)∣[v128](#syntax-vectype)∣​​

##### 3.4.5.7. v128.[load](#syntax-instr-memory)NxM\_[sx](#syntax-sx) x [memarg](#syntax-memarg)[](#-mathsfv128hrefsyntax-instr-memorymathsfloadnmathsfxm_hrefsyntax-sxmathitsxxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[load](#syntax-instr-memory)M[x](#syntax-shape)N\_[sx](#syntax-sx) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → [v128](#syntax-vectype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and M⋅N.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[load](#syntax-instr-memory)M[x](#syntax-shape)N\_[sx](#syntax-sx) x [memarg](#syntax-memarg):at→[v128](#syntax-vectype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)M⋅N​​

##### 3.4.5.8. v128.[load](#syntax-instr-memory)N\_splat x [memarg](#syntax-memarg)[](#-mathsfv128hrefsyntax-instr-memorymathsfloadnmathsf_splatxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[splat](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → [v128](#syntax-vectype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and N.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[splat](#syntax-instr-memory) x [memarg](#syntax-memarg):at→[v128](#syntax-vectype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)N​​

##### 3.4.5.9. v128.[load](#syntax-instr-memory)N\_zero x [memarg](#syntax-memarg)[](#-mathsfv128hrefsyntax-instr-memorymathsfloadnmathsf_zeroxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[zero](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → [v128](#syntax-vectype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and N.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[zero](#syntax-instr-memory) x [memarg](#syntax-memarg):at→[v128](#syntax-vectype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)N​​

##### 3.4.5.10. v128.[load](#syntax-instr-memory)N\_lane x [memarg](#syntax-memarg) [laneidx](#syntax-laneidx)[](#-mathsfv128hrefsyntax-instr-memorymathsfloadnmathsf_lanexhrefsyntax-memargmathitmemarghrefsyntax-laneidxmathitlaneidx)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x [memarg](#syntax-memarg) i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [v128](#syntax-vectype) → [v128](#syntax-vectype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and N.
>     
> *   i is less than 128/N.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x [memarg](#syntax-memarg) i:at [v128](#syntax-vectype)→[v128](#syntax-vectype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)Ni<128/N​​

##### 3.4.5.11. v128.[store](#syntax-instr-memory) x [memarg](#syntax-memarg)[](#-mathsfv128hrefsyntax-instr-memorymathsfstorexhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[store](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [v128](#syntax-vectype) → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and ∣[v128](#syntax-vectype)∣.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[store](#syntax-instr-memory) x [memarg](#syntax-memarg):at [v128](#syntax-vectype)→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)∣[v128](#syntax-vectype)∣​​

##### 3.4.5.12. v128.[store](#syntax-instr-memory)N\_lane x [memarg](#syntax-memarg) [laneidx](#syntax-laneidx)[](#-mathsfv128hrefsyntax-instr-memorymathsfstorenmathsf_lanexhrefsyntax-memargmathitmemarghrefsyntax-laneidxmathitlaneidx)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[store](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x [memarg](#syntax-memarg) i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [v128](#syntax-vectype) → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and N.
>     
> *   i is less than 128/N.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[store](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x [memarg](#syntax-memarg) i:at [v128](#syntax-vectype)→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)Ni<128/N​​

##### 3.4.5.13. [memory.size](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemorysizex)

The [instruction](#syntax-instr) ([memory.size](#syntax-instr-memory) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → at if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     

C[⊢](#valid-instr)[memory.size](#syntax-instr-memory) x:ϵ→atC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)​​

##### 3.4.5.14. [memory.grow](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemorygrowx)

The [instruction](#syntax-instr) ([memory.grow](#syntax-instr-memory) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → at if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     

C[⊢](#valid-instr)[memory.grow](#syntax-instr-memory) x:at→atC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)​​

##### 3.4.5.15. [memory.fill](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemoryfillx)

The [instruction](#syntax-instr) ([memory.fill](#syntax-instr-memory) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [i32](#syntax-numtype) at → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     

C[⊢](#valid-instr)[memory.fill](#syntax-instr-memory) x:at [i32](#syntax-numtype) at→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)​​

##### 3.4.5.16. [memory.copy](#syntax-instr-memory) x y[](#-hrefsyntax-instr-memorymathsfmemorycopyxy)

The [instruction](#syntax-instr) ([memory.copy](#syntax-instr-memory) x1​ x2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at1​ at2​ [addrtype](#syntax-addrtype) → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x1​\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x1​\] is of the form (at1​ lim1​ [page](#syntax-memtype)).
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x2​\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x2​\] is of the form (at2​ lim2​ [page](#syntax-memtype)).
>     
> *   The [address type](#syntax-addrtype) [addrtype](#syntax-addrtype) is [min](#aux-addrtype-min)(at1​,at2​).
>     

C[⊢](#valid-instr)[memory.copy](#syntax-instr-memory) x1​ x2​:at1​ at2​ [min](#aux-addrtype-min)(at1​,at2​)→ϵC.[mems](#context)\[x1​\]\=at1​ lim1​ [page](#syntax-memtype)C.[mems](#context)\[x2​\]\=at2​ lim2​ [page](#syntax-memtype)​​

##### 3.4.5.17. [memory.init](#syntax-instr-memory) x y[](#-hrefsyntax-instr-memorymathsfmemoryinitxy)

The [instruction](#syntax-instr) ([memory.init](#syntax-instr-memory) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [i32](#syntax-numtype) [i32](#syntax-numtype) → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] exists.
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] is of the form [ok](#valid-data).
>     

C[⊢](#valid-instr)[memory.init](#syntax-instr-memory) x y:at [i32](#syntax-numtype) [i32](#syntax-numtype)→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)C.[datas](#context)\[y\]\=[ok](#valid-data)​​

##### 3.4.5.18. [data.drop](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfdatadropx)

The [instruction](#syntax-instr) ([data.drop](#syntax-instr-memory) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ϵ if:

> *   The [data segment](#syntax-datatype) C.[datas](#context)\[x\] exists.
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[x\] is of the form [ok](#valid-data).
>     

C[⊢](#valid-instr)[data.drop](#syntax-instr-memory) x:ϵ→ϵC.[datas](#context)\[x\]\=[ok](#valid-data)​​

#### 3.4.6. Reference Instructions[](#reference-instructions③)

##### 3.4.6.1. [ref.null](#syntax-instr-ref) ht[](#-hrefsyntax-instr-refmathsfrefnullmathitht)

The [instruction](#syntax-instr) ([ref.null](#syntax-instr-ref) ht) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ([ref](#syntax-reftype) [null](#syntax-reftype) ht) if:

> *   The [heap type](#syntax-heaptype) ht is [valid](#valid-heaptype).
>     

C[⊢](#valid-instr)[ref.null](#syntax-instr-ref) ht:ϵ→([ref](#syntax-reftype) [null](#syntax-reftype) ht)C[⊢](#valid-heaptype)ht:[ok](#valid-heaptype)​​

##### 3.4.6.2. [ref.func](#syntax-instr-ref) x[](#-hrefsyntax-instr-refmathsfreffuncx)

The [instruction](#syntax-instr) ([ref.func](#syntax-instr-ref) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ([ref](#syntax-reftype) dt) if:

> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] exists.
>     
> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] is of the form dt.
>     
> *   x is contained in C.[refs](#context).
>     

C[⊢](#valid-instr)[ref.func](#syntax-instr-ref) x:ϵ→([ref](#syntax-reftype) dt)C.[funcs](#context)\[x\]\=dtx∈C.[refs](#context)​​

##### 3.4.6.3. [ref.is\_null](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefis_null)

The [instruction](#syntax-instr) [ref.is\_null](#syntax-instr-ref) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) ht) → [i32](#syntax-numtype) if:

> *   The [heap type](#syntax-heaptype) ht is [valid](#valid-heaptype).
>     

C[⊢](#valid-instr)[ref.is\_null](#syntax-instr-ref):([ref](#syntax-reftype) [null](#syntax-reftype) ht)→[i32](#syntax-numtype)C[⊢](#valid-heaptype)ht:[ok](#valid-heaptype)​​

##### 3.4.6.4. [ref.as\_non\_null](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefas_non_null)

The [instruction](#syntax-instr) [ref.as\_non\_null](#syntax-instr-ref) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) ht) → ([ref](#syntax-reftype) ht) if:

> *   The [heap type](#syntax-heaptype) ht is [valid](#valid-heaptype).
>     

C[⊢](#valid-instr)[ref.as\_non\_null](#syntax-instr-ref):([ref](#syntax-reftype) [null](#syntax-reftype) ht)→([ref](#syntax-reftype) ht)C[⊢](#valid-heaptype)ht:[ok](#valid-heaptype)​​

##### 3.4.6.5. [ref.eq](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefeq)

The [instruction](#syntax-instr) [ref.eq](#syntax-instr-ref) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) [eq](#syntax-heaptype)) ([ref](#syntax-reftype) [null](#syntax-reftype) [eq](#syntax-heaptype)) → [i32](#syntax-numtype).

C[⊢](#valid-instr)[ref.eq](#syntax-instr-ref):([ref](#syntax-reftype) [null](#syntax-reftype) [eq](#syntax-heaptype)) ([ref](#syntax-reftype) [null](#syntax-reftype) [eq](#syntax-heaptype))→[i32](#syntax-numtype)​​

##### 3.4.6.6. [ref.test](#syntax-instr-ref) rt[](#-hrefsyntax-instr-refmathsfreftestmathitrt)

The [instruction](#syntax-instr) ([ref.test](#syntax-instr-ref) rt) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) rt′ → [i32](#syntax-numtype) if:

> *   The [reference type](#syntax-reftype) rt is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt′ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt [matches](#match-reftype) the [reference type](#syntax-reftype) rt′.
>     

C[⊢](#valid-instr)[ref.test](#syntax-instr-ref) rt:rt′→[i32](#syntax-numtype)C[⊢](#valid-reftype)rt:[ok](#valid-reftype)C[⊢](#valid-reftype)rt′:[ok](#valid-reftype)C[⊢](#match-reftype)rt[≤](#match-reftype)rt′​​

Note

The liberty to pick a supertype rt′ allows typing the instruction with the least precise super type of rt as input, that is, the top type in the corresponding heap subtyping hierarchy.

##### 3.4.6.7. [ref.cast](#syntax-instr-ref) rt[](#-hrefsyntax-instr-refmathsfrefcastmathitrt)

The [instruction](#syntax-instr) ([ref.cast](#syntax-instr-ref) rt) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) rt′ → rt if:

> *   The [reference type](#syntax-reftype) rt is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt′ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt [matches](#match-reftype) the [reference type](#syntax-reftype) rt′.
>     

C[⊢](#valid-instr)[ref.cast](#syntax-instr-ref) rt:rt′→rtC[⊢](#valid-reftype)rt:[ok](#valid-reftype)C[⊢](#valid-reftype)rt′:[ok](#valid-reftype)C[⊢](#match-reftype)rt[≤](#match-reftype)rt′​​

Note

The liberty to pick a supertype rt′ allows typing the instruction with the least precise super type of rt as input, that is, the top type in the corresponding heap subtyping hierarchy.

#### 3.4.7. Aggregate Reference Instructions[](#aggregate-reference-instructions①)

##### 3.4.7.1. [struct.new](#syntax-instr-struct) x[](#-hrefsyntax-instr-structmathsfstructnewx)

The [instruction](#syntax-instr) ([struct.new](#syntax-instr-struct) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗).
>     
> *   The value type sequence t∗ is [unpack](#aux-unpack)(zt)∗.
>     

C[⊢](#valid-instr)[struct.new](#syntax-instr-struct) x:[unpack](#aux-unpack)(zt)∗→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗​​

##### 3.4.7.2. [struct.new\_default](#syntax-instr-struct) x[](#-hrefsyntax-instr-structmathsfstructnew_defaultx)

The [instruction](#syntax-instr) ([struct.new\_default](#syntax-instr-struct) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗).
>     
> *   For all zt in zt∗:
>     
>     > *   A [default value](#aux-default) for [unpack](#aux-unpack)(zt) is defined.
>     >     
>     

C[⊢](#valid-instr)[struct.new\_default](#syntax-instr-struct) x:ϵ→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗([default](#aux-default)[unpack](#aux-unpack)(zt)​\=ϵ)∗​​

##### 3.4.7.3. [struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x y[](#-hrefsyntax-instr-structmathsfstructgetmathsf_hrefsyntax-sxmathitsxxy)

The [instruction](#syntax-instr) ([struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) → t if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([struct](#syntax-comptype) ft∗).
>     
> *   The length of ft∗ is greater than i.
>     
> *   The [field type](#syntax-fieldtype) ft∗\[i\] is of the form ([mut](#syntax-mut)? zt).
>     
> *   The signedness [sx](#syntax-sx)? is absent if and only if zt is a packed type.
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x i:([ref](#syntax-reftype) [null](#syntax-reftype) x)→[unpack](#aux-unpack)(zt)C.[types](#context)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ft∗ft∗\[i\]\=[mut](#syntax-mut)? zt[sx](#syntax-sx)?\=ϵ⇔zt\=[unpack](#aux-unpack)(zt)​​

##### 3.4.7.4. [struct.set](#syntax-instr-struct) x y[](#-hrefsyntax-instr-structmathsfstructsetxy)

The [instruction](#syntax-instr) ([struct.set](#syntax-instr-struct) x i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) t → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([struct](#syntax-comptype) ft∗).
>     
> *   The length of ft∗ is greater than i.
>     
> *   The [field type](#syntax-fieldtype) ft∗\[i\] is of the form ([mut](#syntax-mut) zt).
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[struct.set](#syntax-instr-struct) x i:([ref](#syntax-reftype) [null](#syntax-reftype) x) [unpack](#aux-unpack)(zt)→ϵC.[types](#context)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ft∗ft∗\[i\]\=[mut](#syntax-mut) zt​​

##### 3.4.7.5. [array.new](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraynewx)

The [instruction](#syntax-instr) ([array.new](#syntax-instr-array) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t [i32](#syntax-numtype) → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt)).
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[array.new](#syntax-instr-array) x:[unpack](#aux-unpack)(zt) [i32](#syntax-numtype)→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)​​

##### 3.4.7.6. [array.new\_default](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraynew_defaultx)

The [instruction](#syntax-instr) ([array.new\_default](#syntax-instr-array) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [i32](#syntax-numtype) → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt)).
>     
> *   A [default value](#aux-default) for [unpack](#aux-unpack)(zt) is defined.
>     

C[⊢](#valid-instr)[array.new\_default](#syntax-instr-array) x:[i32](#syntax-numtype)→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)[default](#aux-default)[unpack](#aux-unpack)(zt)​\=ϵ​​

##### 3.4.7.7. [array.new\_fixed](#syntax-instr-array) x n[](#-hrefsyntax-instr-arraymathsfarraynew_fixedxn)

The [instruction](#syntax-instr) ([array.new\_fixed](#syntax-instr-array) x n) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) tn → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt)).
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[array.new\_fixed](#syntax-instr-array) x n:[unpack](#aux-unpack)(zt)n→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)​​

##### 3.4.7.8. [array.new\_elem](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarraynew_elemxy)

The [instruction](#syntax-instr) ([array.new\_elem](#syntax-instr-array) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [i32](#syntax-numtype) [i32](#syntax-numtype) → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? rt)).
>     
> *   The [element segment](#syntax-elemtype) C.[elems](#context)\[y\] exists.
>     
> *   The [element segment](#syntax-reftype) C.[elems](#context)\[y\] [matches](#match-reftype) the [reference type](#syntax-reftype) rt.
>     

C[⊢](#valid-instr)[array.new\_elem](#syntax-instr-array) x y:[i32](#syntax-numtype) [i32](#syntax-numtype)→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? rt)C[⊢](#match-reftype)C.[elems](#context)\[y\][≤](#match-reftype)rt​​

##### 3.4.7.9. [array.new\_data](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarraynew_dataxy)

The [instruction](#syntax-instr) ([array.new\_data](#syntax-instr-array) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [i32](#syntax-numtype) [i32](#syntax-numtype) → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt)).
>     
> *   The [value type](#syntax-valtype) [unpack](#aux-unpack)(zt) is of the form [numtype](#syntax-numtype) or [unpack](#aux-unpack)(zt) is of the form [vectype](#syntax-vectype).
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] exists.
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] is of the form [ok](#valid-data).
>     

C[⊢](#valid-instr)[array.new\_data](#syntax-instr-array) x y:[i32](#syntax-numtype) [i32](#syntax-numtype)→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)[unpack](#aux-unpack)(zt)\=[numtype](#syntax-numtype)∨[unpack](#aux-unpack)(zt)\=[vectype](#syntax-vectype)C.[datas](#context)\[y\]\=[ok](#valid-data)​​

##### 3.4.7.10. [array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x[](#-hrefsyntax-instr-arraymathsfarraygetmathsf_hrefsyntax-sxmathitsxx)

The [instruction](#syntax-instr) ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) → t if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt)).
>     
> *   The signedness [sx](#syntax-sx)? is absent if and only if zt is a packed type.
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x:([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype)→[unpack](#aux-unpack)(zt)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)[sx](#syntax-sx)?\=ϵ⇔zt\=[unpack](#aux-unpack)(zt)​​

##### 3.4.7.11. [array.set](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraysetx)

The [instruction](#syntax-instr) ([array.set](#syntax-instr-array) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) t → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut) zt)).
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[array.set](#syntax-instr-array) x:([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [unpack](#aux-unpack)(zt)→ϵC.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut) zt)​​

##### 3.4.7.12. [array.len](#syntax-instr-array)[](#-hrefsyntax-instr-arraymathsfarraylen)

The [instruction](#syntax-instr) [array.len](#syntax-instr-array) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) [array](#syntax-heaptype)) → [i32](#syntax-numtype).

C[⊢](#valid-instr)[array.len](#syntax-instr-array):([ref](#syntax-reftype) [null](#syntax-reftype) [array](#syntax-heaptype))→[i32](#syntax-numtype)​​

##### 3.4.7.13. [array.fill](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarrayfillx)

The [instruction](#syntax-instr) ([array.fill](#syntax-instr-array) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) t [i32](#syntax-numtype) → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut) zt)).
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[array.fill](#syntax-instr-array) x:([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [unpack](#aux-unpack)(zt) [i32](#syntax-numtype)→ϵC.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut) zt)​​

##### 3.4.7.14. [array.copy](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarraycopyxy)

The [instruction](#syntax-instr) ([array.copy](#syntax-instr-array) x1​ x2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x1​) [i32](#syntax-numtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x2​) [i32](#syntax-numtype) [i32](#syntax-numtype) → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x1​\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x1​\] is ([array](#syntax-comptype) ([mut](#syntax-mut) zt1​)).
>     
> *   The [type](#syntax-deftype) C.[types](#context)\[x2​\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x2​\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt2​)).
>     
> *   The [storage type](#syntax-storagetype) zt2​ [matches](#match-storagetype) the [storage type](#syntax-storagetype) zt1​.
>     

C[⊢](#valid-instr)[array.copy](#syntax-instr-array) x1​ x2​:([ref](#syntax-reftype) [null](#syntax-reftype) x1​) [i32](#syntax-numtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x2​) [i32](#syntax-numtype) [i32](#syntax-numtype)→ϵC.[types](#context)\[x1​\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut) zt1​)C.[types](#context)\[x2​\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt2​)C[⊢](#match-storagetype)zt2​[≤](#match-storagetype)zt1​​​

##### 3.4.7.15. [array.init\_elem](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarrayinit_elemxy)

The [instruction](#syntax-instr) ([array.init\_elem](#syntax-instr-array) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [i32](#syntax-numtype) [i32](#syntax-numtype) → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut) zt)).
>     
> *   The [element segment](#syntax-elemtype) C.[elems](#context)\[y\] exists.
>     
> *   The [element segment](#syntax-elemtype) C.[elems](#context)\[y\] [matches](#match) the [storage type](#syntax-storagetype) zt.
>     

C[⊢](#valid-instr)[array.init\_elem](#syntax-instr-array) x y:([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [i32](#syntax-numtype) [i32](#syntax-numtype)→ϵC.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut) zt)C[⊢](#match-storagetype)C.[elems](#context)\[y\][≤](#match-storagetype)zt​​

##### 3.4.7.16. [array.init\_data](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarrayinit_dataxy)

The [instruction](#syntax-instr) ([array.init\_data](#syntax-instr-array) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [i32](#syntax-numtype) [i32](#syntax-numtype) → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut) zt)).
>     
> *   The [value type](#syntax-valtype) [unpack](#aux-unpack)(zt) is of the form [numtype](#syntax-numtype) or [unpack](#aux-unpack)(zt) is of the form [vectype](#syntax-vectype).
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] exists.
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] is of the form [ok](#valid-data).
>     

C[⊢](#valid-instr)[array.init\_data](#syntax-instr-array) x y:([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [i32](#syntax-numtype) [i32](#syntax-numtype)→ϵC.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut) zt)[unpack](#aux-unpack)(zt)\=[numtype](#syntax-numtype)∨[unpack](#aux-unpack)(zt)\=[vectype](#syntax-vectype)C.[datas](#context)\[y\]\=[ok](#valid-data)​​

#### 3.4.8. Scalar Reference Instructions[](#scalar-reference-instructions①)

##### 3.4.8.1. [ref.i31](#syntax-instr-i31)[](#-hrefsyntax-instr-i31mathsfrefiscriptstyle31)

The [instruction](#syntax-instr) [ref.i31](#syntax-instr-i31) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [i32](#syntax-numtype) → ([ref](#syntax-reftype) [i31](#syntax-heaptype)).

C[⊢](#valid-instr)[ref.i31](#syntax-instr-i31):[i32](#syntax-numtype)→([ref](#syntax-reftype) [i31](#syntax-heaptype))​​

##### 3.4.8.2. [i31.get](#syntax-instr-i31)\_[sx](#syntax-sx)[](#-hrefsyntax-instr-i31mathsfiscriptstyle31getmathsf_hrefsyntax-sxmathitsx)

The [instruction](#syntax-instr) ([i31.get](#syntax-instr-i31)\_[sx](#syntax-sx)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) [i31](#syntax-heaptype)) → [i32](#syntax-numtype).

C[⊢](#valid-instr)[i31.get](#syntax-instr-i31)\_[sx](#syntax-sx):([ref](#syntax-reftype) [null](#syntax-reftype) [i31](#syntax-heaptype))→[i32](#syntax-numtype)​​

#### 3.4.9. External Reference Instructions[](#external-reference-instructions①)

##### 3.4.9.1. [any.convert\_extern](#syntax-instr-extern)[](#-hrefsyntax-instr-externmathsfanyconvert_extern)

The [instruction](#syntax-instr) [any.convert\_extern](#syntax-instr-extern) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ [extern](#syntax-heaptype)) → ([ref](#syntax-reftype) [null](#syntax-reftype)2?​ [any](#syntax-heaptype)) if:

> *   [null](#syntax-reftype)1?​ is of the form [null](#syntax-reftype)2?​.
>     

C[⊢](#valid-instr)[any.convert\_extern](#syntax-instr-extern):([ref](#syntax-reftype) [null](#syntax-reftype)1?​ [extern](#syntax-heaptype))→([ref](#syntax-reftype) [null](#syntax-reftype)2?​ [any](#syntax-heaptype))[null](#syntax-reftype)1?​\=[null](#syntax-reftype)2?​​​

##### 3.4.9.2. [extern.convert\_any](#syntax-instr-extern)[](#-hrefsyntax-instr-externmathsfexternconvert_any)

The [instruction](#syntax-instr) [extern.convert\_any](#syntax-instr-extern) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ [any](#syntax-heaptype)) → ([ref](#syntax-reftype) [null](#syntax-reftype)2?​ [extern](#syntax-heaptype)) if:

> *   [null](#syntax-reftype)1?​ is of the form [null](#syntax-reftype)2?​.
>     

C[⊢](#valid-instr)[extern.convert\_any](#syntax-instr-extern):([ref](#syntax-reftype) [null](#syntax-reftype)1?​ [any](#syntax-heaptype))→([ref](#syntax-reftype) [null](#syntax-reftype)2?​ [extern](#syntax-heaptype))[null](#syntax-reftype)1?​\=[null](#syntax-reftype)2?​​​

#### 3.4.10. Numeric Instructions[](#numeric-instructions③)

##### 3.4.10.1. t.[const](#syntax-instr-numeric) c[](#-tmathsfhrefsyntax-instr-numericmathsfconstc)

The [instruction](#syntax-instr) (nt.[const](#syntax-instr-numeric) cnt​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → nt.

C[⊢](#valid-instr)nt.[const](#syntax-instr-numeric) cnt​:ϵ→nt​​

##### 3.4.10.2. t.[unop](#syntax-unop)[](#-tmathsfhrefsyntax-unopmathitunop)

The [instruction](#syntax-instr) (nt.[unop](#syntax-unop)nt​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) nt → nt.

C[⊢](#valid-instr)nt.[unop](#syntax-unop)nt​:nt→nt​​

##### 3.4.10.3. t.[binop](#syntax-binop)[](#-tmathsfhrefsyntax-binopmathitbinop)

The [instruction](#syntax-instr) (nt.[binop](#syntax-binop)nt​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) nt nt → nt.

C[⊢](#valid-instr)nt.[binop](#syntax-binop)nt​:nt nt→nt​​

##### 3.4.10.4. t.[testop](#syntax-testop)[](#-tmathsfhrefsyntax-testopmathittestop)

The [instruction](#syntax-instr) (nt.[testop](#syntax-testop)nt​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) nt → [i32](#syntax-numtype).

C[⊢](#valid-instr)nt.[testop](#syntax-testop)nt​:nt→[i32](#syntax-numtype)​​

##### 3.4.10.5. t.[relop](#syntax-relop)[](#-tmathsfhrefsyntax-relopmathitrelop)

The [instruction](#syntax-instr) (nt.[relop](#syntax-relop)nt​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) nt nt → [i32](#syntax-numtype).

C[⊢](#valid-instr)nt.[relop](#syntax-relop)nt​:nt nt→[i32](#syntax-numtype)​​

##### 3.4.10.6. t1​.[cvtop](#syntax-cvtop)\_t2​\_[sx](#syntax-sx)?[](#-t_1mathsfhrefsyntax-cvtopmathitcvtopmathsf_t_2mathsf_hrefsyntax-sxmathitsx)

The [instruction](#syntax-instr) (nt1​.[cvtop](#syntax-cvtop)\_nt2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) nt2​ → nt1​.

C[⊢](#valid-instr)nt1​.[cvtop](#syntax-cvtop)\_nt2​:nt2​→nt1​​​

#### 3.4.11. Vector Instructions[](#vector-instructions③)

Vector instructions can have a prefix to describe the [shape](#syntax-shape) of the operand. Packed numeric types, [i8](#syntax-storagetype) and [i16](#syntax-storagetype), are not [value types](#syntax-valtype). An auxiliary function maps such packed type shapes to value types:

[unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)N)​\=​[unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype))​​

##### 3.4.11.1. [v128](#syntax-vectype).[const](#syntax-instr-vec) c[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-instr-vecmathsfconstc)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → [v128](#syntax-vectype).

C[⊢](#valid-instr)[v128](#syntax-vectype).[const](#syntax-instr-numeric) c:ϵ→[v128](#syntax-vectype)​​

##### 3.4.11.2. [v128](#syntax-vectype).[vvunop](#syntax-vvunop)[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-vvunopmathitvvunop)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[vvunop](#syntax-vvunop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)[v128](#syntax-vectype).[vvunop](#syntax-vvunop):[v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.3. [v128](#syntax-vectype).[vvbinop](#syntax-vvbinop)[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-vvbinopmathitvvbinop)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[vvbinop](#syntax-vvbinop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)[v128](#syntax-vectype).[vvbinop](#syntax-vvbinop):[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.4. [v128](#syntax-vectype).[vvternop](#syntax-vvternop)[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-vvternopmathitvvternop)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[vvternop](#syntax-vvternop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)[v128](#syntax-vectype).[vvternop](#syntax-vvternop):[v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.5. [v128](#syntax-vectype).[vvtestop](#syntax-vvtestop)[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-vvtestopmathitvvtestop)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[vvtestop](#syntax-vvtestop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [i32](#syntax-numtype).

C[⊢](#valid-instr)[v128](#syntax-vectype).[vvtestop](#syntax-vvtestop):[v128](#syntax-vectype)→[i32](#syntax-numtype)​​

##### 3.4.11.6. [shape](#syntax-shape).[vunop](#syntax-vunop)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vunopmathitvunop)

The [instruction](#syntax-instr) (sh.[vunop](#syntax-vunop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vunop](#syntax-vunop):[v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.7. [shape](#syntax-shape).[vbinop](#syntax-vbinop)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vbinopmathitvbinop)

The [instruction](#syntax-instr) (sh.[vbinop](#syntax-vbinop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vbinop](#syntax-vbinop):[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.8. [shape](#syntax-shape).[vternop](#syntax-vternop)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vternopmathitvternop)

The [instruction](#syntax-instr) (sh.[vternop](#syntax-vternop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vternop](#syntax-vternop):[v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.9. [shape](#syntax-shape).[vtestop](#syntax-vrelop)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vrelopmathitvtestop)

The [instruction](#syntax-instr) (sh.[vtestop](#syntax-vrelop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [i32](#syntax-numtype).

C[⊢](#valid-instr)sh.[vtestop](#syntax-vrelop):[v128](#syntax-vectype)→[i32](#syntax-numtype)​​

##### 3.4.11.10. [shape](#syntax-shape).[vrelop](#syntax-vrelop)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vrelopmathitvrelop)

The [instruction](#syntax-instr) (sh.[vrelop](#syntax-vrelop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vrelop](#syntax-vrelop):[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.11. [ishape](#syntax-shape).[vishiftop](#syntax-vshiftop)[](#-hrefsyntax-shapemathitishapemathsfhrefsyntax-vshiftopmathitvishiftop)

The [instruction](#syntax-instr) (sh.[vshiftop](#syntax-vshiftop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [i32](#syntax-numtype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vshiftop](#syntax-vshiftop):[v128](#syntax-vectype) [i32](#syntax-numtype)→[v128](#syntax-vectype)​​

##### 3.4.11.12. [ishape](#syntax-shape).[bitmask](#syntax-instr-vec)[](#-hrefsyntax-shapemathitishapemathsfhrefsyntax-instr-vecmathsfbitmask)

The [instruction](#syntax-instr) (sh.[bitmask](#syntax-instr-vec)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [i32](#syntax-numtype).

C[⊢](#valid-instr)sh.[bitmask](#syntax-instr-vec):[v128](#syntax-vectype)→[i32](#syntax-numtype)​​

##### 3.4.11.13. i8x16.[vswizzlop](#syntax-vswizzlop)[](#-mathsfi8x16hrefsyntax-vswizzlopmathitvswizzlop)

The [instruction](#syntax-instr) (sh.[vswizzlop](#syntax-vswizzlop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vswizzlop](#syntax-vswizzlop):[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.14. i8x16.[shuffle](#syntax-instr-vec) [laneidx](#syntax-laneidx)16[](#-mathsfi8x16hrefsyntax-instr-vecmathsfshufflehrefsyntax-laneidxmathitlaneidx16)

The [instruction](#syntax-instr) (sh.[shuffle](#syntax-instr-vec) i∗) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype) if:

> *   For all i in i∗:
>     
>     > *   The [lane index](#syntax-laneidx) i is less than 2⋅[dim](#aux-dim)(sh).
>     >     
>     

C[⊢](#valid-instr)sh.[shuffle](#syntax-instr-vec) i∗:[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)(i<2⋅[dim](#aux-dim)(sh))∗​​

##### 3.4.11.15. [shape](#syntax-shape).[splat](#syntax-instr-vec)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-instr-vecmathsfsplat)

The [instruction](#syntax-instr) (sh.[splat](#syntax-instr-vec)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [numtype](#syntax-numtype) → [v128](#syntax-vectype) if:

> *   The [number type](#syntax-numtype) [numtype](#syntax-numtype) is [unpack](#aux-unpack)(sh).
>     

C[⊢](#valid-instr)sh.[splat](#syntax-instr-vec):[unpack](#aux-unpack)(sh)→[v128](#syntax-vectype)​​

##### 3.4.11.16. [shape](#syntax-shape).[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx)? [laneidx](#syntax-laneidx)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-instr-vecmathsfextract_lanemathsf_hrefsyntax-sxmathitsxhrefsyntax-laneidxmathitlaneidx)

The [instruction](#syntax-instr) (sh.[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx)? i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [numtype](#syntax-numtype) if:

> *   The [lane index](#syntax-laneidx) i is less than [dim](#aux-dim)(sh).
>     
> *   The [number type](#syntax-numtype) [numtype](#syntax-numtype) is [unpack](#aux-unpack)(sh).
>     

C[⊢](#valid-instr)sh.[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx)? i:[v128](#syntax-vectype)→[unpack](#aux-unpack)(sh)i<[dim](#aux-dim)(sh)​​

##### 3.4.11.17. [shape](#syntax-shape).[replace\_lane](#syntax-instr-vec) [laneidx](#syntax-laneidx)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-instr-vecmathsfreplace_lanehrefsyntax-laneidxmathitlaneidx)

The [instruction](#syntax-instr) (sh.[replace\_lane](#syntax-instr-vec) i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [numtype](#syntax-numtype) → [v128](#syntax-vectype) if:

> *   The [lane index](#syntax-laneidx) i is less than [dim](#aux-dim)(sh).
>     
> *   The [number type](#syntax-numtype) [numtype](#syntax-numtype) is [unpack](#aux-unpack)(sh).
>     

C[⊢](#valid-instr)sh.[replace\_lane](#syntax-instr-vec) i:[v128](#syntax-vectype) [unpack](#aux-unpack)(sh)→[v128](#syntax-vectype)i<[dim](#aux-dim)(sh)​​

##### 3.4.11.18. [ishape](#syntax-shape)1​.[vextunop](#syntax-vextunop)\_[ishape](#syntax-shape)2​[](#-hrefsyntax-shapemathitishape_1mathsfhrefsyntax-vextunopmathitvextunopmathsf_hrefsyntax-shapemathitishape_2)

The [instruction](#syntax-instr) (sh1​.[vextunop](#syntax-vextunop)\_sh2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh1​.[vextunop](#syntax-vextunop)\_sh2​:[v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.19. [ishape](#syntax-shape)1​.[vextbinop](#syntax-vextbinop)\_[ishape](#syntax-shape)2​[](#-hrefsyntax-shapemathitishape_1mathsfhrefsyntax-vextbinopmathitvextbinopmathsf_hrefsyntax-shapemathitishape_2)

The [instruction](#syntax-instr) (sh1​.[vextbinop](#syntax-vextbinop)\_sh2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh1​.[vextbinop](#syntax-vextbinop)\_sh2​:[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.20. [ishape](#syntax-shape)1​.[vextternop](#syntax-vextternop)\_[ishape](#syntax-shape)2​[](#-hrefsyntax-shapemathitishape_1mathsfhrefsyntax-vextternopmathitvextternopmathsf_hrefsyntax-shapemathitishape_2)

The [instruction](#syntax-instr) (sh1​.[vextternop](#syntax-vextternop)\_sh2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh1​.[vextternop](#syntax-vextternop)\_sh2​:[v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.21. [ishape](#syntax-shape)1​.[narrow](#syntax-instr-vec)\_[ishape](#syntax-shape)2​\_[sx](#syntax-sx)[](#-hrefsyntax-shapemathitishape_1mathsfhrefsyntax-instr-vecmathsfnarrowmathsf_hrefsyntax-shapemathitishape_2mathsf_hrefsyntax-sxmathitsx)

The [instruction](#syntax-instr) (sh1​.[narrow](#syntax-instr-vec)\_sh2​\_[sx](#syntax-sx)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh1​.[narrow](#syntax-instr-vec)\_sh2​\_[sx](#syntax-sx):[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.22. [shape](#syntax-shape).[vcvtop](#syntax-vcvtop)\_[half](#syntax-half)?\_[shape](#syntax-shape)\_[sx](#syntax-sx)?\_zero?[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vcvtopmathitvcvtopmathsf_hrefsyntax-halfmathithalfmathsf_hrefsyntax-shapemathitshapemathsf_hrefsyntax-sxmathitsxmathsf_zero)

The [instruction](#syntax-instr) (sh1​.[vcvtop](#syntax-vcvtop)\_sh2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh1​.[vcvtop](#syntax-vcvtop)\_sh2​:[v128](#syntax-vectype)→[v128](#syntax-vectype)​​

#### 3.4.12. Instruction Sequences[](#instruction-sequences①)

Typing of instruction sequences is defined recursively.

##### 3.4.12.1. Empty Instruction Sequence: ϵ[](#empty-instruction-sequence--epsilon)

The instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) it if:

> *   Either:
>     
>     > *   The instruction sequence [instr](#syntax-instr)∗ is empty.
>     >     
>     > *   The [instruction type](#syntax-instrtype) it is of the form ϵ → ϵ.
>     >     
>     
> *   Or:
>     
>     > *   The instruction sequence [instr](#syntax-instr)∗ is of the form [instr](#syntax-instr)1​ [instr](#syntax-instr)2∗​.
>     >     
>     > *   The [instruction type](#syntax-instrtype) it is of the form t1∗​ [→](#syntax-instrtype)x1∗​ x2∗​​t3∗​.
>     >     
>     > *   The [instruction](#syntax-instr) [instr](#syntax-instr)1​ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x1∗​​t2∗​.
>     >     
>     > *   For all x1​ in x1∗​:
>     >     
>     >     > *   The [local](#syntax-localtype) C.[locals](#context)\[x1​\] exists.
>     >     >     
>     >     > *   The [local](#syntax-localtype) C.[locals](#context)\[x1​\] is of the form ([init](#syntax-init) t).
>     >     >     
>     >     
>     > *   Under the context C with the local types of x1∗​ updated to ([set](#syntax-init) t)∗, the instruction sequence [instr](#syntax-instr)2∗​ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t2∗​ [→](#syntax-instrtype)x2∗​​t3∗​.
>     >     
>     
> *   Or:
>     
>     > *   The instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) it′′.
>     >     
>     > *   The [instruction type](#syntax-instrtype) it′′ [matches](#match-instrtype) the [instruction type](#syntax-instrtype) it.
>     >     
>     > *   The [instruction type](#syntax-instrtype) it is [valid](#valid-instrtype).
>     >     
>     
> *   Or:
>     
>     > *   The [instruction type](#syntax-instrtype) it is of the form t∗ t1∗​ [→](#syntax-instrtype)x∗​t∗ t2∗​.
>     >     
>     > *   The instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x∗​t2∗​.
>     >     
>     > *   The [result type](#syntax-resulttype) t∗ is [valid](#valid-resulttype).
>     >     
>     

C[⊢](#valid-instrs)ϵ:ϵ→ϵ​​

C[⊢](#valid-instrs)[instr](#syntax-instr)1​ [instr](#syntax-instr)2∗​:t1∗​[→](#syntax-instrtype)x1∗​ x2∗​​t3∗​C[⊢](#valid-instr)[instr](#syntax-instr)1​:t1∗​[→](#syntax-instrtype)x1∗​​t2∗​(C.[locals](#context)\[x1​\]\=[init](#syntax-init) t)∗C\[.[local](#syntax-local)\[x1∗​\]\=([set](#syntax-init) t)∗\][⊢](#valid-instrs)[instr](#syntax-instr)2∗​:t2∗​[→](#syntax-instrtype)x2∗​​t3∗​​​

C[⊢](#valid-instrs)[instr](#syntax-instr)∗:it′C[⊢](#valid-instrs)[instr](#syntax-instr)∗:itC[⊢](#match-instrtype)it[≤](#match-instrtype)it′C[⊢](#valid-instrtype)it′:[ok](#valid-instrtype)​C[⊢](#valid-instrs)[instr](#syntax-instr)∗:(t∗ t1∗​)[→](#syntax-instrtype)x∗​(t∗ t2∗​)C[⊢](#valid-instrs)[instr](#syntax-instr)∗:t1∗​[→](#syntax-instrtype)x∗​t2∗​C[⊢](#valid-resulttype)t∗:[ok](#valid-resulttype)​​

Note

In combination with the previous rule, subsumption allows to compose instructions whose types would not directly fit otherwise. For example, consider the instruction sequence

([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 2) ([i32](#syntax-numtype).[add](#syntax-instr-numeric))

To type this sequence, its subsequence ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 2) ([i32](#syntax-numtype).[add](#syntax-instr-numeric)) needs to be valid with an intermediate type. But the direct type of ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 2) is ϵ→[i32](#syntax-numtype), not matching the two inputs expected by [i32](#syntax-numtype).[add](#syntax-instr-numeric). The subsumption rule allows to weaken the type of (const i32 2) to the supertype [i32](#syntax-numtype)→[i32](#syntax-numtype) [i32](#syntax-numtype), such that it can be composed with [i32](#syntax-numtype).[add](#syntax-instr-numeric) and yields the intermediate type [i32](#syntax-numtype)→[i32](#syntax-numtype) [i32](#syntax-numtype) for the subsequence. That can in turn be composed with the first constant.

Furthermore, subsumption allows to drop init variables x∗ from the instruction type in a context where they are not needed, for example, at the end of the body of a [block](#valid-block).

#### 3.4.13. Expressions[](#expressions③)

Expressions [expr](#syntax-expr) are classified by [result types](#syntax-resulttype) t∗.

The [expression](#syntax-expr) [instr](#syntax-instr)∗ is [valid](#valid-expr) with the [result type](#syntax-resulttype) t∗ if:

> *   The instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → t∗.
>     

C[⊢](#valid-expr)[instr](#syntax-instr)∗:t∗C[⊢](#valid-instrs)[instr](#syntax-instr)∗:ϵ[→](#syntax-instrtype)ϵ​t∗​​

##### 3.4.13.1. Constant Expressions[](#constant-expressions①)

In a _constant_ expression, all instructions must be constant.

[instr](#syntax-instr)∗ is constant if:

> *   For all [instr](#syntax-instr) in [instr](#syntax-instr)∗:
>     
>     > *   [instr](#syntax-instr) is constant.
>     >     
>     

[val](#syntax-val) is constant if:

> *   Either:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form (nt.[const](#syntax-instr-numeric) cnt​).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form (vt.[const](#syntax-instr-numeric) cvt​).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([ref.null](#syntax-instr-ref) ht).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form [ref.i31](#syntax-instr-i31).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([ref.func](#syntax-instr-ref) x).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([struct.new](#syntax-instr-struct) x).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([struct.new\_default](#syntax-instr-struct) x).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([array.new](#syntax-instr-array) x).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([array.new\_default](#syntax-instr-array) x).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([array.new\_fixed](#syntax-instr-array) x n).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form [any.convert\_extern](#syntax-instr-extern).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form [extern.convert\_any](#syntax-instr-extern).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([global.get](#syntax-instr-variable) x).
>     >     
>     > *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] exists.
>     >     
>     > *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] is of the form (ϵ t).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([i](#syntax-numtype)[N](#syntax-numtype).[binop](#syntax-binop)).
>     >     
>     > *   [i](#syntax-numtype)[N](#syntax-numtype) is contained in \[[i32](#syntax-numtype); [i64](#syntax-numtype)\].
>     >     
>     > *   [binop](#syntax-binop) is contained in \[[add](#syntax-instr-numeric); [sub](#syntax-instr-numeric); [mul](#syntax-instr-numeric)\].
>     >     
>     

C[⊢](#valid-const)[instr](#syntax-instr)∗ [const](#valid-const)(C[⊢](#valid-const)[instr](#syntax-instr) [const](#valid-const))∗​​

C[⊢](#valid-const)(nt.[const](#syntax-instr-numeric) cnt​) [const](#valid-const)​C[⊢](#valid-const)(vt.[const](#syntax-instr-numeric) cvt​) [const](#valid-const)​C[⊢](#valid-const)([i](#syntax-numtype)[N](#syntax-numtype).[binop](#syntax-binop)) [const](#valid-const)[i](#syntax-numtype)[N](#syntax-numtype)∈[i32](#syntax-numtype) [i64](#syntax-numtype)[binop](#syntax-binop)∈[add](#syntax-instr-numeric) [sub](#syntax-instr-numeric) [mul](#syntax-instr-numeric)​3ex\]C[⊢](#valid-const)([ref.null](#syntax-instr-ref) ht) [const](#valid-const)​C[⊢](#valid-const)([ref.i31](#syntax-instr-i31)) [const](#valid-const)​C[⊢](#valid-const)([ref.func](#syntax-instr-ref) x) [const](#valid-const)​3ex\]C[⊢](#valid-const)([struct.new](#syntax-instr-struct) x) [const](#valid-const)​C[⊢](#valid-const)([struct.new\_default](#syntax-instr-struct) x) [const](#valid-const)​3ex\]C[⊢](#valid-const)([array.new](#syntax-instr-array) x) [const](#valid-const)​C[⊢](#valid-const)([array.new\_default](#syntax-instr-array) x) [const](#valid-const)​C[⊢](#valid-const)([array.new\_fixed](#syntax-instr-array) x n) [const](#valid-const)​3ex\]C[⊢](#valid-const)([any.convert\_extern](#syntax-instr-extern)) [const](#valid-const)​C[⊢](#valid-const)([extern.convert\_any](#syntax-instr-extern)) [const](#valid-const)​3ex\]C[⊢](#valid-const)([global.get](#syntax-instr-variable) x) [const](#valid-const)C.[globals](#context)\[x\]\=t​​​

Note

Currently, constant expressions occurring in [globals](#syntax-global) are further constrained in that contained global.get instructions are only allowed to refer to _imported_ or _previously defined_ globals. Constant expressions occurring in [tables](#syntax-table) may only have global.get instructions that refer to _imported_ globals. This is enforced in the [validation rule for modules](#valid-module) by constraining the context C accordingly.

The definition of constant expression may be extended in future versions of WebAssembly.

### 3.5. Modules[](#modules③)

[Modules](#syntax-module) are valid when all the components they contain are valid. To verify this, most definitions are themselves classified with a suitable type.

#### 3.5.1. Types[](#types⑨)

The sequence of [types](#syntax-type) defined in a module is validated incrementally, yielding a sequence of [defined types](#syntax-deftype) representing them individually.

The [type definition](#syntax-type) ([type](#syntax-type) [rectype](#syntax-rectype)) is [valid](#valid-type) with the defined type sequence dt∗ if:

> *   The length of C.[types](#context) is equal to x.
>     
> *   The defined type sequence dt∗ is of the form [roll](#aux-roll-deftype)x∗​([rectype](#syntax-rectype)).
>     
> *   Let C′ be the same context as C, but with the defined type sequence dt∗ appended to the field [types](#context).
>     
> *   Under the context C′, the [recursive type](#syntax-rectype) [rectype](#syntax-rectype) is [valid](#valid-rectype) for the type index x.
>     

C[⊢](#valid-type)[type](#syntax-type) [rectype](#syntax-rectype):dt∗x\=∣C.[types](#context)∣dt∗\=[roll](#aux-roll-deftype)x∗​([rectype](#syntax-rectype))C⊕{[types](#context) dt∗}[⊢](#valid-rectype)[rectype](#syntax-rectype):[ok](#valid-subtype)(x)​​

The type definition sequence [type](#syntax-rectype)∗ is [valid](#valid-type) with the defined type sequence [deftype](#syntax-deftype)∗ if:

> *   Either:
>     
>     > *   The type definition sequence [type](#syntax-rectype)∗ is empty.
>     >     
>     > *   The defined type sequence [deftype](#syntax-deftype)∗ is empty.
>     >     
>     
> *   Or:
>     
>     > *   The type definition sequence [type](#syntax-rectype)∗ is of the form [type](#syntax-rectype)1​ [type](#syntax-rectype)′∗.
>     >     
>     > *   The defined type sequence [deftype](#syntax-deftype)∗ is of the form dt1∗​ dt∗.
>     >     
>     > *   The [type definition](#syntax-type) [type](#syntax-rectype)1​ is [valid](#valid-type) with the defined type sequence dt1∗​.
>     >     
>     > *   Let C′ be the same context as C, but with the defined type sequence dt1∗​ appended to the field [types](#context).
>     >     
>     > *   Under the context C′, the type definition sequence [type](#syntax-rectype)′∗ is [valid](#valid-type) with the defined type sequence dt∗.
>     >     
>     

C[⊢](#valid-types)ϵ:ϵ​C[⊢](#valid-types)[type](#syntax-rectype)1​ [type](#syntax-rectype)∗:dt1∗​ dt∗C[⊢](#valid-type)[type](#syntax-rectype)1​:dt1∗​C⊕{[types](#context) dt1∗​}[⊢](#valid-types)[type](#syntax-rectype)∗:dt∗​​

#### 3.5.2. Tags[](#tags③)

Tags [tag](#syntax-tag) are classified by their [tag types](#syntax-tagtype), which are [defined types](#syntax-deftype) expanding to [function types](#syntax-functype).

The [tag](#syntax-tag) ([tag](#syntax-tag) [tagtype](#syntax-tagtype)) is [valid](#valid-tag) with the [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype)′ if:

> *   The [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype) is [valid](#valid-tagtype).
>     
> *   The [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype)′ is [clos](#aux-clostype)C​([tagtype](#syntax-tagtype)).
>     

C[⊢](#valid-tag)[tag](#syntax-tag) [tagtype](#syntax-tagtype):[clos](#aux-clostype)C​([tagtype](#syntax-tagtype))C[⊢](#valid-tagtype)[tagtype](#syntax-tagtype):[ok](#valid-tagtype)​​

#### 3.5.3. Globals[](#globals③)

Globals [global](#syntax-global) are classified by [global types](#syntax-globaltype).

The [global](#syntax-global) ([global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)) is [valid](#valid-global) with the [global type](#syntax-globaltype) [globaltype](#syntax-globaltype) if:

> *   The [global type](#syntax-globaltype) [globaltype](#syntax-globaltype) is [valid](#valid-globaltype).
>     
> *   The [global type](#syntax-globaltype) [globaltype](#syntax-globaltype) is of the form ([mut](#syntax-mut)? t).
>     
> *   The [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [value type](#syntax-valtype) t.
>     
> *   [expr](#syntax-expr) is constant.
>     

C[⊢](#valid-global)[global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr):[globaltype](#syntax-globaltype)C[⊢](#valid-globaltype)[globaltype](#syntax-globaltype):[ok](#valid-globaltype)[globaltype](#syntax-globaltype)\=[mut](#syntax-mut)? tC[⊢](#valid-const)[expr](#syntax-expr):t [const](#valid-const)​​

Sequences of globals are handled incrementally, such that each definition has access to previous definitions.

The global sequence [global](#syntax-global)∗ is [valid](#valid-global) with the global type sequence [globaltype](#syntax-globaltype)∗ if:

> *   Either:
>     
>     > *   The global sequence [global](#syntax-global)∗ is empty.
>     >     
>     > *   The global type sequence [globaltype](#syntax-globaltype)∗ is empty.
>     >     
>     
> *   Or:
>     
>     > *   The global sequence [global](#syntax-global)∗ is of the form [global](#syntax-global)1​ [global](#syntax-global)′∗.
>     >     
>     > *   The global type sequence [globaltype](#syntax-globaltype)∗ is of the form gt1​ gt∗.
>     >     
>     > *   The [global](#syntax-global) [global](#syntax-global)1​ is [valid](#valid-global) with the [global type](#syntax-globaltype) gt1​.
>     >     
>     > *   Let C′ be the same context as C, but with the global type sequence gt1​ appended to the field [globals](#context).
>     >     
>     > *   Under the context C′, the global sequence [global](#syntax-global)′∗ is [valid](#valid-global) with the global type sequence gt∗.
>     >     
>     

C[⊢](#valid-globalseq)ϵ:ϵ​C[⊢](#valid-globalseq)[global](#syntax-global)1​ [global](#syntax-global)∗:gt1​ gt∗C[⊢](#valid-global)[global](#syntax-global)1​:gt1​C⊕{[globals](#context) gt1​}[⊢](#valid-globalseq)[global](#syntax-global)∗:gt∗​​

#### 3.5.4. Memories[](#memories③)

Memories [mem](#syntax-mem) are classified by [memory types](#syntax-memtype).

The [memory](#syntax-mem) ([memory](#syntax-mem) [memtype](#syntax-memtype)) is [valid](#valid-mem) with the [memory type](#syntax-memtype) [memtype](#syntax-memtype) if:

> *   The [memory type](#syntax-memtype) [memtype](#syntax-memtype) is [valid](#valid-memtype).
>     

C[⊢](#valid-mem)[memory](#syntax-mem) [memtype](#syntax-memtype):[memtype](#syntax-memtype)C[⊢](#valid-memtype)[memtype](#syntax-memtype):[ok](#valid-memtype)​​

#### 3.5.5. Tables[](#tables③)

Tables [table](#syntax-table) are classified by [table types](#syntax-tabletype).

The [table](#syntax-table) ([table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)) is [valid](#valid-table) with the [table type](#syntax-tabletype) [tabletype](#syntax-tabletype) if:

> *   The [table type](#syntax-tabletype) [tabletype](#syntax-tabletype) is [valid](#valid-tabletype).
>     
> *   The [table type](#syntax-tabletype) [tabletype](#syntax-tabletype) is of the form (at lim rt).
>     
> *   The [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [value type](#syntax-valtype) rt.
>     
> *   [expr](#syntax-expr) is constant.
>     

C[⊢](#valid-table)[table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr):[tabletype](#syntax-tabletype)C[⊢](#valid-tabletype)[tabletype](#syntax-tabletype):[ok](#valid-tabletype)[tabletype](#syntax-tabletype)\=at lim rtC[⊢](#valid-const)[expr](#syntax-expr):rt [const](#valid-const)​​

#### 3.5.6. Functions[](#functions③)

Functions [func](#syntax-func) are classified by [defined types](#syntax-deftype) that [expand](#aux-expand-deftype) to [function types](#syntax-functype) of the form [func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​.

The [function](#syntax-func) ([func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr)) is [valid](#valid-func) with the [type](#syntax-deftype) C.[types](#context)\[x\] if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     
> *   For all [local](#syntax-local) in [local](#syntax-local)∗:
>     
>     > *   The [local](#syntax-local) [local](#syntax-local) is [valid](#valid-local) with the [local type](#syntax-localtype) lt.
>     >     
>     
> *   lt∗ is the concatenation of all such lt.
>     
> *   Under the context C with the field [locals](#context) appended by ([set](#syntax-init) t1​)∗ lt∗ and the field [labels](#context) appended by t2∗​ and the field [return](#context) appended by t2∗​, the [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [result type](#syntax-resulttype) t2∗​.
>     

C[⊢](#valid-func)[func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr):C.[types](#context)\[x\]C.[types](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​(C[⊢](#valid-local)[local](#syntax-local):lt)∗C⊕{[locals](#context) ([set](#syntax-init) t1​)∗ lt∗,[labels](#context) (t2∗​),[return](#context) (t2∗​)}[⊢](#valid-expr)[expr](#syntax-expr):t2∗​​​​​

#### 3.5.7. Locals[](#locals①)

Locals [local](#syntax-local) are classified with [local types](#syntax-localtype).

The [local](#syntax-local) ([local](#syntax-local) t) is [valid](#valid-local) with the [local type](#syntax-localtype) ([init](#syntax-init) t) if:

> *   Either:
>     
>     > *   The [initialization status](#syntax-init) [init](#syntax-init) is of the form [set](#syntax-init).
>     >     
>     > *   A [default value](#aux-default) for t is defined.
>     >     
>     
> *   Or:
>     
>     > *   The [initialization status](#syntax-init) [init](#syntax-init) is of the form [unset](#syntax-init).
>     >     
>     > *   A [default value](#aux-default) for t is not defined.
>     >     
>     

C[⊢](#valid-local)[local](#syntax-local) t:[set](#syntax-init) t[default](#aux-default)t​\=ϵ​C[⊢](#valid-local)[local](#syntax-local) t:[unset](#syntax-init) t[default](#aux-default)t​\=ϵ​​

Note

For cases where both rules are applicable, the former yields the more permissable type.

#### 3.5.8. Data Segments[](#data-segments③)

Data segments [data](#syntax-data) are classified by the singleton [data type](#syntax-datatype), which merely expresses well-formedness.

The [memory segment](#syntax-data) ([data](#syntax-data) b∗ [datamode](#syntax-datamode)) is [valid](#valid-data) if:

> *   The [data mode](#syntax-datamode) [datamode](#syntax-datamode) is [valid](#valid-datamode).
>     

C[⊢](#valid-data)[data](#syntax-data) b∗ [datamode](#syntax-datamode):[ok](#valid-data)C[⊢](#valid-datamode)[datamode](#syntax-datamode):[ok](#valid-data)​​

The [data mode](#syntax-datamode) [datamode](#syntax-datamode) is [valid](#valid-datamode) if:

> *   Either:
>     
>     > *   The [data mode](#syntax-datamode) [datamode](#syntax-datamode) is of the form [passive](#syntax-datamode).
>     >     
>     
> *   Or:
>     
>     > *   The [data mode](#syntax-datamode) [datamode](#syntax-datamode) is of the form ([active](#syntax-datamode) x [expr](#syntax-expr)).
>     >     
>     > *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     >     
>     > *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     >     
>     > *   The [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [value type](#syntax-valtype) at.
>     >     
>     > *   [expr](#syntax-expr) is constant.
>     >     
>     

C[⊢](#valid-datamode)[passive](#syntax-datamode):[ok](#valid-data)​C[⊢](#valid-datamode)[active](#syntax-datamode) x [expr](#syntax-expr):[ok](#valid-data)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)C[⊢](#valid-const)[expr](#syntax-expr):at [const](#valid-const)​​

#### 3.5.9. Element Segments[](#element-segments③)

Element segments [elem](#syntax-elem) are classified by their [element type](#syntax-elemtype).

The [table segment](#syntax-elem) ([elem](#syntax-elem) [elemtype](#syntax-elemtype) [expr](#syntax-expr)∗ [elemmode](#syntax-elemmode)) is [valid](#valid-elem) with the [element type](#syntax-elemtype) [elemtype](#syntax-elemtype) if:

> *   The [reference type](#syntax-reftype) [elemtype](#syntax-elemtype) is [valid](#valid-reftype).
>     
> *   For all [expr](#syntax-expr) in [expr](#syntax-expr)∗:
>     
>     > *   The [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [value type](#syntax-valtype) [elemtype](#syntax-elemtype).
>     >     
>     > *   [expr](#syntax-expr) is constant.
>     >     
>     
> *   The [element mode](#syntax-elemmode) [elemmode](#syntax-elemmode) is [valid](#valid-elemmode) with the [element type](#syntax-elemtype) [elemtype](#syntax-elemtype).
>     

C[⊢](#valid-elem)[elem](#syntax-elem) [elemtype](#syntax-elemtype) [expr](#syntax-expr)∗ [elemmode](#syntax-elemmode):[elemtype](#syntax-elemtype)C[⊢](#valid-reftype)[elemtype](#syntax-elemtype):[ok](#valid-reftype)(C[⊢](#valid-const)[expr](#syntax-expr):[elemtype](#syntax-elemtype) [const](#valid-const))∗C[⊢](#valid-elemmode)[elemmode](#syntax-elemmode):[elemtype](#syntax-elemtype)​​

The [element mode](#syntax-elemmode) [elemmode](#syntax-elemmode) is [valid](#valid-elemmode) with the [element type](#syntax-elemtype) rt if:

> *   Either:
>     
>     > *   The [element mode](#syntax-elemmode) [elemmode](#syntax-elemmode) is of the form [passive](#syntax-elemmode).
>     >     
>     
> *   Or:
>     
>     > *   The [element mode](#syntax-elemmode) [elemmode](#syntax-elemmode) is of the form [declare](#syntax-elemmode).
>     >     
>     
> *   Or:
>     
>     > *   The [element mode](#syntax-elemmode) [elemmode](#syntax-elemmode) is of the form ([active](#syntax-elemmode) x [expr](#syntax-expr)).
>     >     
>     > *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     >     
>     > *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt′).
>     >     
>     > *   The [reference type](#syntax-reftype) rt [matches](#match-reftype) the [reference type](#syntax-reftype) rt′.
>     >     
>     > *   The [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [value type](#syntax-valtype) at.
>     >     
>     > *   [expr](#syntax-expr) is constant.
>     >     
>     

C[⊢](#valid-elemmode)[passive](#syntax-elemmode):rt​C[⊢](#valid-elemmode)[declare](#syntax-elemmode):rt​3ex\]C[⊢](#valid-elemmode)[active](#syntax-elemmode) x [expr](#syntax-expr):rtC.[tables](#context)\[x\]\=at lim rt′C[⊢](#match-reftype)rt[≤](#match-reftype)rt′C[⊢](#valid-const)[expr](#syntax-expr):at [const](#valid-const)​​​

#### 3.5.10. Start Function[](#start-function③)

The [start function](#syntax-start) ([start](#syntax-start) x) is [valid](#valid-start) if:

> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[funcs](#context)\[x\] is ([func](#syntax-comptype) [→](#syntax-comptype)).
>     

C[⊢](#valid-start)[start](#syntax-start) x:[ok](#valid-start)C.[funcs](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) ϵ[→](#syntax-comptype)ϵ​​

#### 3.5.11. Imports[](#imports③)

Imports [import](#syntax-import) are classified by [external types](#syntax-externtype).

The [import](#syntax-import) ([import](#syntax-import) [name](#syntax-name)1​ [name](#syntax-name)2​ xt) is [valid](#valid-import) with the [external type](#syntax-externtype) [externtype](#syntax-externtype) if:

> *   The [external type](#syntax-externtype) xt is [valid](#valid-externtype).
>     
> *   The [external type](#syntax-externtype) [externtype](#syntax-externtype) is [clos](#aux-clostype)C​(xt).
>     

C[⊢](#valid-import)[import](#syntax-import) [name](#syntax-name)1​ [name](#syntax-name)2​ xt:[clos](#aux-clostype)C​(xt)C[⊢](#valid-externtype)xt:[ok](#valid-externtype)​​

#### 3.5.12. Exports[](#exports③)

Exports [export](#syntax-export) are classified by their [external type](#syntax-externtype).

The [export](#syntax-export) ([export](#syntax-export) [name](#syntax-name) [externidx](#syntax-externidx)) is [valid](#valid-export) with the [name](#syntax-name) [name](#syntax-name) and the [external type](#syntax-externtype) xt if:

> *   The [external index](#syntax-externidx) [externidx](#syntax-externidx) is [valid](#valid-externidx) with the [external type](#syntax-externtype) xt.
>     

C[⊢](#valid-export)[export](#syntax-export) [name](#syntax-name) [externidx](#syntax-externidx):[name](#syntax-name) xtC[⊢](#valid-externidx)[externidx](#syntax-externidx):xt​​

##### 3.5.12.1. [tag](#syntax-externidx) x[](#-hrefsyntax-externidxmathsftagx)

The [external index](#syntax-externidx) ([tag](#syntax-externidx) x) is [valid](#valid-externidx) with the [external type](#syntax-externtype) ([tag](#syntax-externtype) jt) if:

> *   The [tag](#syntax-tagtype) C.[tags](#context)\[x\] exists.
>     
> *   The [tag](#syntax-tagtype) C.[tags](#context)\[x\] is of the form jt.
>     

C[⊢](#valid-externidx)[tag](#syntax-externidx) x:[tag](#syntax-externtype) jtC.[tags](#context)\[x\]\=jt​​

##### 3.5.12.2. [global](#syntax-externidx) x[](#-hrefsyntax-externidxmathsfglobalx)

The [external index](#syntax-externidx) ([global](#syntax-externidx) x) is [valid](#valid-externidx) with the [external type](#syntax-externtype) ([global](#syntax-externtype) gt) if:

> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] exists.
>     
> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] is of the form gt.
>     

C[⊢](#valid-externidx)[global](#syntax-externidx) x:[global](#syntax-externtype) gtC.[globals](#context)\[x\]\=gt​​

##### 3.5.12.3. [memory](#syntax-externidx) x[](#-hrefsyntax-externidxmathsfmemoryx)

The [external index](#syntax-externidx) ([memory](#syntax-externidx) x) is [valid](#valid-externidx) with the [external type](#syntax-externtype) ([mem](#syntax-externtype) mt) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form mt.
>     

C[⊢](#valid-externidx)[memory](#syntax-externidx) x:[mem](#syntax-externtype) mtC.[mems](#context)\[x\]\=mt​​

##### 3.5.12.4. [table](#syntax-externidx) x[](#-hrefsyntax-externidxmathsftablex)

The [external index](#syntax-externidx) ([table](#syntax-externidx) x) is [valid](#valid-externidx) with the [external type](#syntax-externtype) ([table](#syntax-externtype) tt) if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form tt.
>     

C[⊢](#valid-externidx)[table](#syntax-externidx) x:[table](#syntax-externtype) ttC.[tables](#context)\[x\]\=tt​​

##### 3.5.12.5. [func](#syntax-externidx) x[](#-hrefsyntax-externidxmathsffuncx)

The [external index](#syntax-externidx) ([func](#syntax-externidx) x) is [valid](#valid-externidx) with the [external type](#syntax-externtype) ([func](#syntax-externtype) dt) if:

> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] exists.
>     
> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] is of the form dt.
>     

C[⊢](#valid-externidx)[func](#syntax-externidx) x:[func](#syntax-externtype) dtC.[funcs](#context)\[x\]\=dt​​

#### 3.5.13. Modules[](#modules④)

Modules are classified by their mapping from the [external types](#syntax-externtype) of their [imports](#syntax-import) to those of their [exports](#syntax-export).

A module is entirely _closed_, that is, its components can only refer to definitions that appear in the module itself. Consequently, no initial [context](#context) is required. Instead, the [context](#context) C for validation of the module’s content is constructed from the definitions in the module.

The [module](#syntax-module) ([module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗) is [valid](#valid-module) with the [module type](#syntax-moduletype) [moduletype](#syntax-moduletype) if:

> *   Under the context {[return](#context) ϵ}, the type definition sequence [type](#syntax-rectype)∗ is [valid](#valid-type) with the defined type sequence dt′∗.
>     
> *   For all [import](#syntax-import) in [import](#syntax-import)∗:
>     
>     > *   Under the context {[types](#context) dt′∗,[return](#context) ϵ}, the [import](#syntax-import) [import](#syntax-import) is [valid](#valid-import) with the [external type](#syntax-externtype) xti​.
>     >     
>     
> *   xti∗​ is the concatenation of all such xti​.
>     
> *   For all [tag](#syntax-tag) in [tag](#syntax-tag)∗:
>     
>     > *   Under the context C′, the [tag](#syntax-tag) [tag](#syntax-tag) is [valid](#valid-tag) with the [tag type](#syntax-tagtype) jt.
>     >     
>     
> *   jt∗ is the concatenation of all such jt.
>     
> *   Under the context C′, the global sequence [global](#syntax-global)∗ is [valid](#valid-global) with the global type sequence gt∗.
>     
> *   For all [mem](#syntax-mem) in [mem](#syntax-mem)∗:
>     
>     > *   Under the context C′, the [memory](#syntax-mem) [mem](#syntax-mem) is [valid](#valid-mem) with the [memory type](#syntax-memtype) mt.
>     >     
>     
> *   mt∗ is the concatenation of all such mt.
>     
> *   For all [table](#syntax-table) in [table](#syntax-table)∗:
>     
>     > *   Under the context C′, the [table](#syntax-table) [table](#syntax-table) is [valid](#valid-table) with the [table type](#syntax-tabletype) tt.
>     >     
>     
> *   tt∗ is the concatenation of all such tt.
>     
> *   For all [func](#syntax-func) in [func](#syntax-func)∗:
>     
>     > *   The [function](#syntax-func) [func](#syntax-func) is [valid](#valid-func) with the [defined type](#syntax-deftype) dt.
>     >     
>     
> *   dt∗ is the concatenation of all such dt.
>     
> *   For all [data](#syntax-data) in [data](#syntax-data)∗:
>     
>     > *   The [memory segment](#syntax-data) [data](#syntax-data) is [valid](#valid-data).
>     >     
>     
> *   ok∗ is the concatenation of all such ok.
>     
> *   For all [elem](#syntax-elem) in [elem](#syntax-elem)∗:
>     
>     > *   The [table segment](#syntax-elem) [elem](#syntax-elem) is [valid](#valid-elem) with the [element type](#syntax-elemtype) rt.
>     >     
>     
> *   rt∗ is the concatenation of all such rt.
>     
> *   If [start](#syntax-start) is defined, then:
>     
>     > *   The [start function](#syntax-start) [start](#syntax-start) is [valid](#valid-start).
>     >     
>     
> *   For all [export](#syntax-export) in [export](#syntax-export)∗:
>     
>     > *   The [export](#syntax-export) [export](#syntax-export) is [valid](#valid-export) with the [name](#syntax-name) nm and the [external type](#syntax-externtype) xte​.
>     >     
>     
> *   nm∗ is the concatenation of all such nm.
>     
> *   xte∗​ is the concatenation of all such xte​.
>     
> *   nm∗ disjoint is true.
>     
> *   The [context](#context) C is of the form C′ with the field [tags](#context) appended by jti∗​ jt∗ and the field [globals](#context) appended by gt∗ and the field [mems](#context) appended by mti∗​ mt∗ and the field [tables](#context) appended by tti∗​ tt∗ and the field [datas](#context) appended by ok∗ and the field [elems](#context) appended by rt∗.
>     
> *   The [context](#context) C′ is of the form {[types](#context) dt′∗,[globals](#context) gti∗​,[funcs](#context) dti∗​ dt∗,[return](#context) ϵ,[refs](#context) x∗}.
>     
> *   The function index sequence x∗ is of the form [funcidx](#syntax-funcidx)([global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [elem](#syntax-elem)∗).
>     
> *   The tag type sequence jti∗​ is of the form [tags](#syntax-externtype)(xti∗​).
>     
> *   The global type sequence gti∗​ is of the form [globals](#syntax-externtype)(xti∗​).
>     
> *   The memory type sequence mti∗​ is of the form [mems](#syntax-externtype)(xti∗​).
>     
> *   The table type sequence tti∗​ is of the form [tables](#syntax-externtype)(xti∗​).
>     
> *   The defined type sequence dti∗​ is of the form [funcs](#syntax-externtype)(xti∗​).
>     
> *   The [module type](#syntax-moduletype) [moduletype](#syntax-moduletype) is [clos](#aux-clostype)C​(xti∗​ [→](#syntax-moduletype) xte∗​).
>     

[⊢](#valid-module)[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗:[clos](#aux-clostype)C​(xti∗​[→](#syntax-moduletype)xte∗​){}[⊢](#valid-types)[type](#syntax-rectype)∗:dt′∗({[types](#context) dt′∗}[⊢](#valid-import)[import](#syntax-import):xti​)∗(C′[⊢](#valid-tag)[tag](#syntax-tag):jt)∗C′[⊢](#valid-globalseq)[global](#syntax-global)∗:gt∗(C′[⊢](#valid-mem)[mem](#syntax-mem):mt)∗(C′[⊢](#valid-table)[table](#syntax-table):tt)∗(C[⊢](#valid-func)[func](#syntax-func):dt)∗(C[⊢](#valid-data)[data](#syntax-data):ok)∗(C[⊢](#valid-elem)[elem](#syntax-elem):rt)∗(C[⊢](#valid-start)[start](#syntax-start):[ok](#valid-start))?(C[⊢](#valid-export)[export](#syntax-export):nm xte​)∗nm∗ disjointC\=C′⊕{[tags](#context) jti∗​ jt∗,[globals](#context) gt∗,[mems](#context) mti∗​ mt∗,[tables](#context) tti∗​ tt∗,[datas](#context) ok∗,[elems](#context) rt∗}C′\={[types](#context) dt′∗,[globals](#context) gti∗​,[funcs](#context) dti∗​ dt∗,[refs](#context) x∗}x∗\=[funcidx](#syntax-funcidx)([global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [elem](#syntax-elem)∗)jti∗​\=[tags](#syntax-externtype)(xti∗​)gti∗​\=[globals](#syntax-externtype)(xti∗​)mti∗​\=[mems](#syntax-externtype)(xti∗​)tti∗​\=[tables](#syntax-externtype)(xti∗​)dti∗​\=[funcs](#syntax-externtype)(xti∗​)​​​​

Note

All functions in a module are mutually recursive. Consequently, the definition of the [context](#context) C in this rule is recursive: it depends on the outcome of validation of the function, table, memory, and global definitions contained in the module, which itself depends on C. However, this recursion is just a specification device. All types needed to construct C can easily be determined from a simple pre-pass over the module that does not perform any actual validation.

Globals, however, are not recursive but evaluated sequentially, such that each [constant expressions](#valid-const) only has access to imported or previously defined globals.

4\. Execution[](#execution②)
----------------------------

### 4.1. Conventions[](#conventions②③)

WebAssembly code is _executed_ when [instantiating](#exec-instantiation) a module or [invoking](#exec-invocation) an [exported](#syntax-export) function on the resulting module [instance](#syntax-moduleinst).

Execution behavior is defined in terms of an _abstract machine_ that models the _program state_. It includes a _stack_, which records operand values and control constructs, and an abstract _store_ containing global state.

For each instruction, there is a rule that specifies the effect of its execution on the program state. Furthermore, there are rules describing the instantiation of a module. As with [validation](#validation), all rules are given in two _equivalent_ forms:

1.  In _prose_, describing the execution in intuitive form.
    
2.  In _formal notation_, describing the rule in mathematical form. [\[1\]](#cite-pldi2017)
    

Note

As with validation, the prose and formal rules are equivalent, so that understanding of the formal notation is _not_ required to read this specification. The formalism offers a more concise description in notation that is used widely in programming languages semantics and is readily amenable to mathematical proof.

#### 4.1.1. Prose Notation[](#prose-notation③)

Execution is specified by stylised, step-wise rules for each [instruction](#syntax-instr) of the [abstract syntax](#syntax). The following conventions are adopted in stating these rules.

*   The execution rules implicitly assume a given [store](#store) s.
    
*   The execution rules also assume the presence of an implicit [stack](#stack) that is modified by _pushing_ or _popping_ [values](#syntax-value), [labels](#syntax-label), and [frames](#syntax-frame).
    
*   Certain rules require the stack to contain at least one frame. The most recent frame is referred to as the _current_ frame.
    
*   Both the store and the current frame are mutated by _replacing_ some of their components. Such replacement is assumed to apply globally.
    
*   The execution of an instruction may _trap_, in which case the entire computation is aborted and no further modifications to the store are performed by it. (Other computations can still be initiated afterwards.)
    
*   The execution of an instruction may also end in a _jump_ to a designated target, which defines the next instruction to execute.
    
*   Execution can _enter_ and _exit_ [instruction sequences](#syntax-instrs) that form [blocks](#syntax-instr-control).
    
*   [Instruction sequences](#syntax-instrs) are implicitly executed in order, unless a trap, jump, or exception occurs.
    
*   In various places the rules contain _assertions_ expressing crucial invariants about the program state.
    

#### 4.1.2. Formal Notation[](#formal-notation③)

Note

This section gives a brief explanation of the notation for specifying execution formally. For the interested reader, a more thorough introduction can be found in respective text books. [\[2\]](#cite-tapl)

The formal execution rules use a standard approach for specifying operational semantics, rendering them into _reduction rules_. Every rule has the following general form:

configuration↪configuration

A _configuration_ is a syntactic description of a program state. Each rule specifies one _step_ of execution. As long as there is at most one reduction rule applicable to a given configuration, reduction – and thereby execution – is _deterministic_. WebAssembly has only very few exceptions to this, which are noted explicitly in this specification.

For WebAssembly, a configuration typically is a tuple (s;f;[instr](#syntax-instr)∗) consisting of the current [store](#store) s, the [call frame](#frame) f of the current function, and the sequence of [instructions](#syntax-instr) that is to be executed. (A more precise definition is given [later](#syntax-config).)

To avoid unnecessary clutter, the store s and the frame f are often combined into a _state_ z, which is a pair (s;f). Moreover, z is omitted from reduction rules that do not touch them.

There is no separate representation of the [stack](#stack). Instead, it is conveniently represented as part of the configuration’s instruction sequence. In particular, [values](#syntax-val) are defined to coincide with const and ref instructions, and a sequence of such instructions can be interpreted as an operand “stack” that grows to the right.

Note

For example, the [reduction rule](#exec-binop) for the [i32](#syntax-numtype).[add](#syntax-instr-numeric) instruction can be given as follows:

([i32](#syntax-numtype).[const](#syntax-instr-numeric) n1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n2​) ([i32](#syntax-numtype).[add](#syntax-instr-numeric))[↪](#exec-notation)([i32](#syntax-numtype).[const](#syntax-instr-numeric) (n1​+n2​)mod232)

Per this rule, two const instructions and the add instruction itself are removed from the instruction stream and replaced with one new const instruction. This can be interpreted as popping two values off the stack and pushing the result.

When no result is produced, an instruction reduces to the empty sequence:

[nop](#syntax-instr-control)[↪](#exec-notation)ϵ

[Labels](#label) and [frames](#frame) are similarly [defined](#syntax-instr-admin) to be part of an instruction sequence.

The order of reduction is determined by the details of the reduction rules. Usually, the left-most instruction that is not a constant will be the subject of the next reduction _step_.

Reduction _terminates_ when no more reduction rules are applicable. [Soundness](#soundness) of the WebAssembly [type system](#type-system) guarantees that this is only the case when the original instruction sequence has either been reduced to a sequence of [value](#syntax-val) instructions, which can be interpreted as the [values](#syntax-val) of the resulting operand stack, or if an [exception](#exception) or [trap](#trap) occurred.

Note

For example, the following instruction sequence,

([f64](#syntax-numtype).[const](#syntax-instr-numeric) q1​) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) q2​) ([f64](#syntax-numtype).[neg](#syntax-instr-numeric)) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) q3​) ([f64](#syntax-numtype).[add](#syntax-instr-numeric)) ([f64](#syntax-numtype).[mul](#syntax-instr-numeric))

terminates after three steps:

​​↪↪↪​([f64](#syntax-numtype).[const](#syntax-instr-numeric) q1​) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) q4​) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) q3​) ([f64](#syntax-numtype).[add](#syntax-instr-numeric)) ([f64](#syntax-numtype).[mul](#syntax-instr-numeric))([f64](#syntax-numtype).[const](#syntax-instr-numeric) q1​) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) q5​) ([f64](#syntax-numtype).[mul](#syntax-instr-numeric))([f64](#syntax-numtype).[const](#syntax-instr-numeric) q6​)​​

where q4​\=−q2​ and q5​\=−q2​+q3​ and q6​\=q1​⋅(−q2​+q3​).

\[[1](#id1)\]

The semantics is derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. [Bringing the Web up to Speed with WebAssembly](https://dl.acm.org/citation.cfm?doid=3062341.3062363). Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.

\[[2](#id2)\]

For example: Benjamin Pierce. [Types and Programming Languages](https://www.cis.upenn.edu/~bcpierce/tapl/). The MIT Press 2002

### 4.2. Runtime Structure[](#runtime-structure①)

[Store](#store), [stack](#stack), and other _runtime structure_ forming the WebAssembly abstract machine, such as [values](#syntax-val) or [module instances](#syntax-moduleinst), are made precise in terms of additional auxiliary syntax.

#### 4.2.1. Values[](#values③)

WebAssembly computations manipulate _values_ of either the four basic [number types](#syntax-numtype), i.e., [integers](#syntax-int) and [floating-point data](#syntax-float) of 32 or 64 bit width each, or [vectors](#syntax-vecnum) of 128 bit width, or of [reference type](#syntax-reftype).

In most places of the semantics, values of different types can occur. In order to avoid ambiguities, values are therefore represented with an abstract syntax that makes their type explicit. It is convenient to reuse the same notation as for the const [instructions](#syntax-const) and ref.null producing them.

References other than null are represented with additional [administrative instructions](#syntax-instr-admin). They either are _scalar references_, containing a 31-bit [integer](#syntax-int), _structure references_, pointing to a specific [structure address](#syntax-structaddr), _array references_, pointing to a specific [array address](#syntax-arrayaddr), _function references_, pointing to a specific [function address](#syntax-funcaddr), _exception references_, pointing to a specific [exception address](#syntax-exnaddr), or _host references_ pointing to an uninterpreted form of [host address](#syntax-hostaddr) defined by the [embedder](#embedder). Any of the aformentioned references can furthermore be wrapped up as an _external reference_.

​[val](#syntax-val)​::=∣∣∣∣∣∣∣​[num](#syntax-num) ∣ [vec](#syntax-vec) ∣ [ref](#syntax-ref)0.8ex\][ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype)0.8ex\][ref.struct](#syntax-ref) [structaddr](#syntax-structaddr)[ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr)[ref.func](#syntax-ref) [funcaddr](#syntax-funcaddr)[ref.exn](#syntax-ref) [exnaddr](#syntax-exnaddr)[ref.host](#syntax-ref) [hostaddr](#syntax-hostaddr)[ref.extern](#syntax-ref) [addrref](#syntax-addrref)​[num](#syntax-num)[addrref](#syntax-addrref)::=::=[numtype](#syntax-numtype).[const](#syntax-instr-numeric) [num](#syntax-num)[numtype](#syntax-numtype)​0.8ex\][ref.i31](#syntax-ref) [u31](#syntax-int)[vec](#syntax-vec)::=[vectype](#syntax-vectype).[const](#syntax-instr-vec) [vec](#syntax-vec)[vectype](#syntax-vectype)​0.8ex\][ref](#syntax-ref)::=[addrref](#syntax-addrref)​

Note

Future versions of WebAssembly may add additional forms of values.

[Value types](#syntax-valtype) can have an associated _default value_; it is the respective value 0 for [number types](#syntax-numtype), 0 for [vector types](#syntax-vectype), and null for nullable [reference types](#syntax-reftype). For other references, no default value is defined, [default](#aux-default)t​ hence is an optional value [val](#syntax-val)?.

[default](#aux-default)[i](#syntax-numtype)[N](#syntax-numtype)​[default](#aux-default)[f](#syntax-numtype)[N](#syntax-numtype)​[default](#aux-default)[v](#syntax-numtype)[N](#syntax-numtype)​[default](#aux-default)[ref](#syntax-reftype) [null](#syntax-reftype) ht​[default](#aux-default)[ref](#syntax-reftype) ht​​\=\=\=\=\=​([i](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-numeric) 0)([f](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-numeric) +0)([v](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-vec) 0)([ref.null](#syntax-instr-ref) ht)ϵ​​

##### 4.2.1.1. Convention[](#convention⑥)

*   The meta variable r ranges over reference values where clear from context.
    

#### 4.2.2. Results[](#results①)

A _result_ is the outcome of a computation. It is either a sequence of [values](#syntax-val), a thrown [exception](#exec-throw-ref), or a [trap](#syntax-trap).

​[result](#syntax-result)​::=​[val](#syntax-val)∗ ∣ ([ref.exn](#syntax-ref) [exnaddr](#syntax-exnaddr)) [throw\_ref](#syntax-instr-control) ∣ [trap](#syntax-trap)​​

#### 4.2.3. Store[](#store①)

The _store_ represents all global state that can be manipulated by WebAssembly programs. It consists of the runtime representation of all _instances_ of [functions](#syntax-funcinst), [tables](#syntax-tableinst), [memories](#syntax-meminst), [globals](#syntax-globalinst), [tags](#syntax-taginst), [element segments](#syntax-eleminst), [data segments](#syntax-datainst), and [structures](#syntax-structinst), [arrays](#syntax-arrayinst) or [exceptions](#syntax-exninst) that have been [allocated](#alloc) during the life time of the abstract machine.

It is an invariant of the semantics that no element or data instance is [addressed](#syntax-addr) from anywhere else but the owning module instances.

Syntactically, the store is defined as a [record](#notation-record) listing the existing instances of each category:

​[store](#syntax-store)​::=​{[tags](#syntax-store) [taginst](#syntax-taginst)∗[globals](#syntax-store) [globalinst](#syntax-globalinst)∗[mems](#syntax-store) [meminst](#syntax-meminst)∗[tables](#syntax-store) [tableinst](#syntax-tableinst)∗[funcs](#syntax-store) [funcinst](#syntax-funcinst)∗[datas](#syntax-store) [datainst](#syntax-datainst)∗[elems](#syntax-store) [eleminst](#syntax-eleminst)∗[structs](#syntax-store) [structinst](#syntax-structinst)∗[arrays](#syntax-store) [arrayinst](#syntax-arrayinst)∗[exns](#syntax-store) [exninst](#syntax-exninst)∗}​​​

Note

In practice, implementations may apply techniques like garbage collection or reference counting to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.

##### 4.2.3.1. Convention[](#convention⑦)

*   The meta variable s ranges over stores where clear from context.
    

#### 4.2.4. Addresses[](#addresses①)

[Function instances](#syntax-funcinst), [table instances](#syntax-tableinst), [memory instances](#syntax-meminst), [global instances](#syntax-globalinst), [tag instances](#syntax-taginst), [element instances](#syntax-eleminst), [data instances](#syntax-datainst) and [structure](#syntax-structinst), [array](#syntax-arrayinst) or [exception instances](#syntax-exninst) in the [store](#syntax-store) are referenced with abstract _addresses_. These are simply indices into the respective store component. In addition, an [embedder](#embedder) may supply an uninterpreted set of _host addresses_.

​[addr](#syntax-addr)[funcaddr](#syntax-funcaddr)[tableaddr](#syntax-tableaddr)[memaddr](#syntax-memaddr)[globaladdr](#syntax-globaladdr)[tagaddr](#syntax-tagaddr)[elemaddr](#syntax-elemaddr)[dataaddr](#syntax-dataaddr)[structaddr](#syntax-structaddr)[arrayaddr](#syntax-arrayaddr)[hostaddr](#syntax-hostaddr)​::=::=::=::=::=::=::=::=::=::=::=​0 ∣ 1 ∣ 2 ∣ …[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)​​

An [embedder](#embedder) may assign identity to [exported](#syntax-export) store objects corresponding to their addresses, even where this identity is not observable from within WebAssembly code itself (such as for [function instances](#syntax-funcinst) or immutable [globals](#syntax-globalinst)).

Note

Addresses are _dynamic_, globally unique references to runtime objects, in contrast to [indices](#syntax-index), which are _static_, module-local references to their original definitions. A _memory address_ [memaddr](#syntax-memaddr) denotes the abstract address _of_ a memory _instance_ in the store, not an offset _inside_ a memory instance.

There is no specific limit on the number of allocations of store objects, hence logical addresses can be arbitrarily large natural numbers.

##### 4.2.4.1. Conventions[](#conventions②⑤)

*   The notation addr(A) denotes the set of addresses from address space [addr](#syntax-addr) occurring free in A. We sometimes reinterpret this set as the [list](#syntax-list) of its elements, without assuming any particular order.
    

#### 4.2.5. External Addresses[](#external-addresses①)

An _external address_ is the runtime [address](#syntax-addr) of an entity that can be imported or exported. It is an [address](#syntax-addr) denoting either a [function instance](#syntax-funcinst), [global instance](#syntax-globalinst), [table instance](#syntax-tableinst), [memory instance](#syntax-meminst), or [tag instance](#syntax-taginst) in the shared [store](#syntax-store).

​[externaddr](#syntax-externaddr)​::=​[tag](#syntax-externaddr) [tagaddr](#syntax-tagaddr) ∣ [global](#syntax-externaddr) [globaladdr](#syntax-globaladdr) ∣ [mem](#syntax-externaddr) [memaddr](#syntax-memaddr) ∣ [table](#syntax-externaddr) [tableaddr](#syntax-tableaddr) ∣ [func](#syntax-externaddr) [funcaddr](#syntax-funcaddr)​​

#### 4.2.6. Module Instances[](#module-instances①)

A _module instance_ is the runtime representation of a [module](#syntax-module). It is created by [instantiating](#exec-instantiation) a module, and collects runtime representations of all entities that are imported, defined, or exported by the module.

​[moduleinst](#syntax-moduleinst)​::=​{[types](#syntax-moduleinst) [deftype](#syntax-deftype)∗[tags](#syntax-moduleinst) [tagaddr](#syntax-tagaddr)∗[globals](#syntax-moduleinst) [globaladdr](#syntax-globaladdr)∗[mems](#syntax-moduleinst) [memaddr](#syntax-memaddr)∗[tables](#syntax-moduleinst) [tableaddr](#syntax-tableaddr)∗[funcs](#syntax-moduleinst) [funcaddr](#syntax-funcaddr)∗[datas](#syntax-moduleinst) [dataaddr](#syntax-dataaddr)∗[elems](#syntax-moduleinst) [elemaddr](#syntax-elemaddr)∗[exports](#syntax-moduleinst) [exportinst](#syntax-exportinst)∗}​​​

Each component references runtime instances corresponding to respective declarations from the original module – whether imported or defined – in the order of their static [indices](#syntax-index). [Function instances](#syntax-funcinst), [table instances](#syntax-tableinst), [memory instances](#syntax-meminst), [global instances](#syntax-globalinst), and [tag instances](#syntax-taginst) are denoted by their respective [addresses](#syntax-addr) in the [store](#syntax-store).

It is an invariant of the semantics that all [export instances](#syntax-exportinst) in a given module instance have different [names](#syntax-name).

Note

All record fields except exports are to be considered _private_ components of a module instance. They are not accessible to other modules, only to function instances originating from the same module.

#### 4.2.7. Function Instances[](#function-instances①)

A _function instance_ is the runtime representation of a [function](#syntax-func). It effectively is a _closure_ of the original function over the runtime [module instance](#syntax-moduleinst) of its originating [module](#syntax-module). The module instance is used to resolve references to other definitions during execution of the function.

​[funcinst](#syntax-funcinst)[code](#syntax-funcinst)​::=::=​{[type](#syntax-funcinst) [deftype](#syntax-deftype),[module](#syntax-funcinst) [moduleinst](#syntax-moduleinst),[code](#syntax-funcinst) [code](#syntax-funcinst)}​[func](#syntax-func) ∣ [hostfunc](#syntax-hostfunc)​​

A _host function_ is a function expressed outside WebAssembly but passed to a [module](#syntax-module) as an [import](#syntax-import). The definition and behavior of host functions are outside the scope of this specification. For the purpose of this specification, it is assumed that when [invoked](#exec-invoke-host), a host function behaves non-deterministically, but within certain [constraints](#exec-invoke-host) that ensure the integrity of the runtime.

Note

Function instances are immutable, and their identity is not observable by WebAssembly code. However, an [embedder](#embedder) might provide implicit or explicit means for distinguishing their [addresses](#syntax-funcaddr).

#### 4.2.8. Table Instances[](#table-instances①)

A _table instance_ is the runtime representation of a [table](#syntax-table). It records its [type](#syntax-tabletype) and holds a sequence of [reference values](#syntax-ref).

​[tableinst](#syntax-tableinst)​::=​{[type](#syntax-tableinst) [tabletype](#syntax-tabletype),[refs](#syntax-tableinst) [ref](#syntax-ref)∗}​​​

Table elements can be mutated through [table instructions](#syntax-instr-table), the execution of an active [element segment](#syntax-elem), or by external means provided by the [embedder](#embedder).

It is an invariant of the semantics that all table elements have a type [matching](#match-reftype) the element type of [tabletype](#syntax-tabletype). It also is an invariant that the length of the element sequence never exceeds the maximum size of [tabletype](#syntax-tabletype).

#### 4.2.9. Memory Instances[](#memory-instances①)

A _memory instance_ is the runtime representation of a linear [memory](#syntax-mem). It records its [type](#syntax-memtype) and holds a sequence of [bytes](#syntax-byte).

​[meminst](#syntax-meminst)​::=​{[type](#syntax-meminst) [memtype](#syntax-memtype),[bytes](#syntax-meminst) [byte](#syntax-byte)∗}​​​

The length of the sequence always is a multiple of the WebAssembly _page size_, which is defined to be the constant 65536 – abbreviated 64 Ki.

A memory’s bytes can be mutated through [memory instructions](#syntax-instr-memory), the execution of an active [data segment](#syntax-data), or by external means provided by the [embedder](#embedder).

It is an invariant of the semantics that the length of the byte sequence, divided by page size, never exceeds the maximum size of [memtype](#syntax-memtype).

#### 4.2.10. Global Instances[](#global-instances①)

A _global instance_ is the runtime representation of a [global](#syntax-global) variable. It records its [type](#syntax-globaltype) and holds an individual [value](#syntax-val).

​[globalinst](#syntax-globalinst)​::=​{[type](#syntax-globalinst) [globaltype](#syntax-globaltype),[value](#syntax-globalinst) [val](#syntax-val)}​​​

The value of mutable globals can be mutated through [variable instructions](#syntax-instr-variable) or by external means provided by the [embedder](#embedder).

It is an invariant of the semantics that the value has a type [matching](#match-valtype) the [value type](#syntax-valtype) of [globaltype](#syntax-globaltype).

#### 4.2.11. Tag Instances[](#tag-instances①)

A _tag instance_ is the runtime representation of a [tag](#syntax-tag) definition. It records the [defined type](#syntax-deftype) of the tag.

​[taginst](#syntax-taginst)​::=​{[type](#syntax-taginst) [tagtype](#syntax-tagtype)}​​​

#### 4.2.12. Element Instances[](#element-instances①)

An _element instance_ is the runtime representation of an [element segment](#syntax-elem). It holds a list of references and its [type](#syntax-reftype).

​[eleminst](#syntax-eleminst)​::=​{[type](#syntax-eleminst) [elemtype](#syntax-elemtype),[refs](#syntax-eleminst) [ref](#syntax-ref)∗}​​​

It is an invariant of the semantics that all elements of a segment have a type [matching](#match-reftype) [elemtype](#syntax-elemtype).

#### 4.2.13. Data Instances[](#data-instances①)

A _data instance_ is the runtime representation of a [data segment](#syntax-data). It holds a list of [bytes](#syntax-byte).

​[datainst](#syntax-datainst)​::=​{[bytes](#syntax-datainst) [byte](#syntax-byte)∗}​​​

#### 4.2.14. Export Instances[](#export-instances①)

An _export instance_ is the runtime representation of an [export](#syntax-export). It defines the export’s [name](#syntax-name) and the associated [external address](#syntax-externaddr).

​[exportinst](#syntax-exportinst)​::=​{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) [externaddr](#syntax-externaddr)}​​​

##### 4.2.14.1. Conventions[](#conventions②⑥)

The following auxiliary functions are assumed on sequences of external addresses. They extract addresses of a specific kind in an order-preserving fashion:

*   [funcs](#syntax-externaddr)(xa∗) extracts all [function addresses](#syntax-funcaddr) from xa∗,
    
*   [tables](#syntax-externaddr)(xa∗) extracts all [table addresses](#syntax-funcaddr) from xa∗,
    
*   [mems](#syntax-externaddr)(xa∗) extracts all [memory addresses](#syntax-funcaddr) from xa∗,
    
*   [globals](#syntax-externaddr)(xa∗) extracts all [global addresses](#syntax-funcaddr) from xa∗,
    
*   [tags](#syntax-externaddr)(xa∗) extracts all [tag addresses](#syntax-funcaddr) from xa∗.
    

#### 4.2.15. Aggregate Instances[](#aggregate-instances①)

A _structure instance_ is the runtime representation of a heap object allocated from a [structure type](#syntax-structtype). Likewise, an _array instance_ is the runtime representation of a heap object allocated from an [array type](#syntax-arraytype). Both record their respective [defined type](#syntax-deftype) and hold a list of the values of their _fields_.

​[structinst](#syntax-structinst)[arrayinst](#syntax-arrayinst)[fieldval](#syntax-fieldval)[packval](#syntax-packval)​::=::=::=::=​{[type](#syntax-structinst) [deftype](#syntax-deftype),[fields](#syntax-structinst) [fieldval](#syntax-fieldval)∗}​{[type](#syntax-arrayinst) [deftype](#syntax-deftype),[fields](#syntax-arrayinst) [fieldval](#syntax-fieldval)∗}​[val](#syntax-val) ∣ [packval](#syntax-packval)[packtype](#syntax-packtype).[pack](#syntax-packval) [i](#syntax-int)N​​

##### 4.2.15.1. Conventions[](#conventions②⑦)

*   Conversion of a regular [value](#syntax-val) to a [field value](#syntax-fieldval) is defined as follows:
    
    [pack](#aux-packfield)[valtype](#syntax-valtype)​([val](#syntax-val))[pack](#aux-packfield)[packtype](#syntax-packtype)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) i)​\=\=​[val](#syntax-val)[packtype](#syntax-packtype).[pack](#syntax-packval) [wrap](#op-wrap)32,∣[packtype](#syntax-packtype)∣​(i)​​
    
*   The inverse conversion of a [field value](#syntax-fieldval) to a regular [value](#syntax-val) is defined as follows:
    
    [unpack](#aux-unpackfield)[valtype](#syntax-valtype)ϵ​([val](#syntax-val))[unpack](#aux-unpackfield)[packtype](#syntax-packtype)[sx](#syntax-sx)​([packtype](#syntax-packtype).[pack](#syntax-packval) i)​\=\=​[val](#syntax-val)[i32](#syntax-numtype).[const](#syntax-instr-numeric) [extend](#op-extend)∣[packtype](#syntax-packtype)∣,32[sx](#syntax-sx)​(i)​​
    

#### 4.2.16. Exception Instances[](#exception-instances①)

An _exception instance_ is the runtime representation of an [exception](#exception) produced by a throw instruction. It holds the [address](#syntax-tagaddr) of the respective [tag](#syntax-tag) and the argument [values](#syntax-val).

​[exninst](#syntax-exninst)​::=​{[tag](#syntax-exninst) [tagaddr](#syntax-tagaddr),[fields](#syntax-exninst) [val](#syntax-val)∗}​​​

#### 4.2.17. Stack[](#stack①)

Besides the [store](#store), most [instructions](#syntax-instr) interact with an implicit _stack_. The stack contains the two kinds of entries:

*   _Values_: the _operands_ of instructions.
    
*   _Control Frames_: currently active control flow structures.
    

The latter can in turn be one of the following:

*   _Labels_: active [structured control instructions](#syntax-instr-control) that can be targeted by branches.
    
*   _(Call) Frames_: the _activation records_ of active [function](#syntax-func) calls.
    
*   _Handlers_: active exception handlers.
    

Note

Where clear from context, _call frame_ is abbreviated to just _frame_.

All these entries can occur on the stack in any order during the execution of a program. Stack entries are described by abstract syntax as follows.

Note

It is possible to model the WebAssembly semantics using separate stacks for operands, control constructs, and calls. However, because the stacks are interdependent, additional book keeping about associated stack heights would be required. For the purpose of this specification, an interleaved representation is simpler.

##### 4.2.17.1. Values[](#values④)

Values are represented by [themselves](#syntax-val).

##### 4.2.17.2. Labels[](#labels①)

Labels carry an argument arity n and their associated branch _target_, which is expressed syntactically as an [instruction](#syntax-instr) sequence:

​[label](#syntax-label)​::=​[label](#syntax-label)n​{[instr](#syntax-instr)∗}​​

Intuitively, [instr](#syntax-instr)∗ is the _continuation_ to execute when the branch is taken, in place of the original control construct.

Note

For example, a loop label has the form

[label](#syntax-label)n​{([loop](#syntax-instr-control) bt …)}

When performing a branch to this label, this executes the loop, effectively restarting it from the beginning. Conversely, a simple block label has the form

[label](#syntax-label)n​{ϵ}

When branching, the empty continuation ends the targeted block, such that execution can proceed with consecutive instructions.

##### 4.2.17.3. Call Frames[](#call-frames①)

Call frames carry the return arity n of the respective function, hold the values of its [locals](#syntax-local) (including arguments) in the order corresponding to their static [local indices](#syntax-localidx), and a reference to the function’s own [module instance](#syntax-moduleinst):

​[callframe](#syntax-callframe)[frame](#syntax-frame)​::=::=​[frame](#syntax-frame)n​{[frame](#syntax-frame)}{[locals](#syntax-frame) ([val](#syntax-val)?)∗,[module](#syntax-frame) [moduleinst](#syntax-moduleinst)}​​​

Locals may be uninitialized, in which case they are empty. Locals are mutated by respective [variable instructions](#syntax-instr-variable).

##### 4.2.17.4. Exception Handlers[](#exception-handlers①)

Exception handlers are installed by [try\_table](#syntax-instr-control) instructions and record the corresponding list of [catch clauses](#syntax-catch):

​[handler](#syntax-handler)​::=​[handler](#syntax-handler)n​{[catch](#syntax-catch)∗}​

The handlers on the stack are searched when an exception is [thrown](#syntax-throw).

##### 4.2.17.5. Conventions[](#conventions②⑧)

*   The meta variable L ranges over labels where clear from context.
    
*   The meta variable f ranges over frame states where clear from context.
    
*   The meta variable H ranges over exception handlers where clear from context.
    
*   The following auxiliary definition takes a [block type](#syntax-blocktype) and looks up the [instruction type](#syntax-instrtype) that it denotes in the current frame:
    
    [instrtype](#aux-blocktype)z​(x)[instrtype](#aux-blocktype)z​(t?)​\=\=​t1∗​→t2∗​ϵ→t?​if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​
    

#### 4.2.18. Administrative Instructions[](#administrative-instructions①)

Note

This section is only relevant for the [formal notation](#exec-notation).

In order to express the reduction of [traps](#trap), [calls](#syntax-call), [exception handling](#syntax-handler), and [control instructions](#syntax-instr-control), the syntax of instructions is extended to include the following _administrative instructions_:

​[instr](#syntax-instr)​::=∣∣∣∣∣​…[addrref](#syntax-addrref)[label](#syntax-label)n​{[instr](#syntax-instr)∗} [instr](#syntax-instr)∗[frame](#syntax-frame)n​{[frame](#syntax-frame)} [instr](#syntax-instr)∗[handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [instr](#syntax-instr)∗[trap](#syntax-trap)​​

An [address reference](#syntax-addrref) represents an allocated [reference](#syntax-ref) value of respective form [“on the stack”](#exec-notation).

The label, frame, and handler instructions model [labels](#syntax-label), [frames](#syntax-frame), and active [exception handlers](#syntax-handler), respectively, [“on the stack”](#exec-notation). Moreover, the administrative syntax maintains the nesting structure of the original [structured control instruction](#syntax-instr-control) or [function body](#syntax-func) and their [instruction sequences](#syntax-instrs).

The trap instruction represents the occurrence of a trap. Traps are bubbled up through nested instruction sequences, ultimately reducing the entire program to a single trap instruction, signalling abrupt termination.

Note

For example, the [reduction rule](#exec-block) for block is:

([block](#syntax-instr-control) bt [instr](#syntax-instr)∗)[↪](#exec-notation)([label](#syntax-label)n​{ϵ} [instr](#syntax-instr)∗)

if the [block type](#syntax-blocktype) bt denotes a [function type](#syntax-functype) [func](#syntax-comptype) t1m​[→](#syntax-comptype)t2n​, such that n is the block’s result arity. This rule replaces the block with a label instruction, which can be interpreted as “pushing” the label on the stack. When its end is reached, i.e., the inner instruction sequence has been reduced to the empty sequence – or rather, a sequence of n [values](#syntax-val) representing the results – then the label instruction is eliminated courtesy of its own [reduction rule](#exec-label):

([label](#syntax-label)n​{[instr](#syntax-instr)∗} [val](#syntax-val)∗)[↪](#exec-notation)[val](#syntax-val)∗

This can be interpreted as removing the label from the stack and only leaving the locally accumulated operand values. Validation guarantees that n matches the number ∣[val](#syntax-val)∗∣ of resulting values at this point.

#### 4.2.19. Configurations[](#configurations①)

A _configuration_ describes the current computation. It consists of the computations’s _state_ and the sequence of [instructions](#syntax-instr) left to execute. The state in turn consists of a global [store](#syntax-store) and a current [frame](#syntax-frame) referring to the [module instance](#syntax-moduleinst) in which the computation runs, i.e., where the current function originates from.

​[config](#syntax-config)​::=​[state](#syntax-state);[instr](#syntax-instr)∗0.8ex\]​[state](#syntax-state)​::=​[store](#syntax-store);[frame](#syntax-frame)​​

Note

The current version of WebAssembly is single-threaded, but configurations with multiple threads may be supported in the future.

##### 4.2.19.1. Conventions[](#conventions②⑨)

*   The meta variable z ranges over frame states where clear from context.
    
*   The following shorthands are defined for accessing a state z\=(s;f):
    
    *   (s;f).[types](#syntax-state)\[x\]​\=​f.[module](#syntax-frame).[types](#syntax-moduleinst)\[x\]​
        
    *   (s;f).[tags](#syntax-state)\[x\]​\=​s.[tags](#syntax-store)\[f.[module](#syntax-frame).[tags](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[globals](#syntax-state)\[x\]​\=​s.[globals](#syntax-store)\[f.[module](#syntax-frame).[globals](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[mems](#syntax-state)\[x\]​\=​s.[mems](#syntax-store)\[f.[module](#syntax-frame).[mems](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[tables](#syntax-state)\[x\]​\=​s.[tables](#syntax-store)\[f.[module](#syntax-frame).[tables](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[funcs](#syntax-state)\[x\]​\=​s.[funcs](#syntax-store)\[f.[module](#syntax-frame).[funcs](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[datas](#syntax-state)\[x\]​\=​s.[datas](#syntax-store)\[f.[module](#syntax-frame).[datas](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[elems](#syntax-state)\[x\]​\=​s.[elems](#syntax-store)\[f.[module](#syntax-frame).[elems](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[locals](#syntax-state)\[x\]​\=​f.[locals](#syntax-frame)\[x\]​
        
*   These shorthands also extend to [notation](#notation-replace) for updating state:
    
    *   (s;f)\[.[globals](#syntax-state)\[x\].[value](#syntax-globalinst)\=v\]​\=​s\[.[globals](#syntax-store)\[f.[module](#syntax-frame).[globals](#syntax-moduleinst)\[x\]\].[value](#syntax-globalinst)\=v\];f​
        
    *   (s;f)\[.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i:j\]\=b∗\]​\=​s\[.[mems](#syntax-store)\[f.[module](#syntax-frame).[mems](#syntax-moduleinst)\[x\]\].[bytes](#syntax-meminst)\[i:j\]\=b∗\];f​
        
    *   (s;f)\[.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)\[i\]\=r\]​\=​s\[.[tables](#syntax-store)\[f.[module](#syntax-frame).[tables](#syntax-moduleinst)\[x\]\].[refs](#syntax-tableinst)\[i\]\=r\];f​
        
    *   (s;f)\[.[locals](#syntax-state)\[x\]\=v\]​\=​s;f\[.[locals](#syntax-frame)\[x\]\=v\]​
        

### 4.3. Numerics[](#numerics①)

Numeric primitives are defined in a generic manner, by operators indexed over a bit width N.

Some operators are _non-deterministic_, because they can return one of several possible results (such as different [NaN](#syntax-nan) values). Technically, each operator thus returns a _set_ of allowed values. For convenience, deterministic results are expressed as plain values, which are assumed to be identified with a respective singleton set.

Some operators are _partial_, because they are not defined on certain inputs. Technically, an empty set of results is returned for these inputs.

In formal notation, each operator is defined by equational clauses that apply in decreasing order of precedence. That is, the first clause that is applicable to the given arguments defines the result. In some cases, similar clauses are combined into one by using the notation ± or ∓. When several of these placeholders occur in a single clause, then they must be resolved consistently: either the upper sign is chosen for all of them or the lower sign.

Note

For example, the [fcopysign](#op-fcopysign) operator is defined as follows:

[fcopysign](#op-fcopysign)N​(±p1​,±p2​)[fcopysign](#op-fcopysign)N​(±p1​,∓p2​)​\=\=​±p1​∓p1​​​

This definition is to be read as a shorthand for the following expansion of each clause into two separate ones:

[fcopysign](#op-fcopysign)N​(+p1​,+p2​)[fcopysign](#op-fcopysign)N​(−p1​,−p2​)[fcopysign](#op-fcopysign)N​(+p1​,−p2​)[fcopysign](#op-fcopysign)N​(−p1​,+p2​)​\=\=\=\=​+p1​−p1​−p1​+p1​​​

Numeric operators are lifted to input sequences by applying the operator element-wise, returning a sequence of results. When there are multiple inputs, they must be of equal length.

op(c1n​,…,ckn​)​\=​op(c1n​\[0\],…,ckn​\[0\]) … op(c1n​\[n−1\],…,ckn​\[n−1\])​

Note

For example, the unary operator [fabs](#op-fabs), when given a sequence of floating-point values, return a sequence of floating-point results:

[fabs](#op-fabs)N​(zn)​\=​[fabs](#op-fabs)N​(z\[0\]) … [fabs](#op-fabs)N​(z\[n\])​

The binary operator [iadd](#op-iadd), when given two sequences of integers of the same length, n, return a sequence of integer results:

[iadd](#op-iadd)N​(i1n​,i2n​)​\=​[iadd](#op-iadd)N​(i1​\[0\],i2​\[0\]) … [iadd](#op-iadd)N​(i1​\[n\],i2​\[n\])​

Conventions:

*   The meta variable d is used to range over single bits.
    
*   The meta variable p is used to range over (signless) [magnitudes](#syntax-float) of floating-point values, including [nan](#syntax-float) and ∞.
    
*   The meta variable q is used to range over (signless) _rational_ [magnitudes](#syntax-float), excluding [nan](#syntax-float) or ∞.
    
*   The notation f−1 denotes the inverse of a bijective function f.
    
*   Truncation of rational values is written [trunc](#aux-trunc)(±q), with the usual mathematical definition:
    
    [trunc](#aux-trunc)(±q)​\=​±i​(ifi∈N∧+q−1<i≤+q)​​
    

*   Saturation of integers is written [sat\_u](#aux-sat)N​(i) and [sat\_s](#aux-sat)N​(i). The arguments to these two functions range over arbitrary signed integers.
    
    *   Unsigned saturation, [sat\_u](#aux-sat)N​(i) clamps i to between 0 and 2N−1:
        
        [sat\_u](#aux-sat)N​(i)[sat\_u](#aux-sat)N​(i)[sat\_u](#aux-sat)N​(i)​\=\=\=​02N−1i​(ifi<0)(ifi\>2N−1)(otherwise)​​
        
    *   Signed saturation, [sat\_s](#aux-sat)N​(i) clamps i to between −2N−1 and 2N−1−1:
        
    
    [sat\_s](#aux-sat)N​(i)[sat\_s](#aux-sat)N​(i)[sat\_s](#aux-sat)N​(i)​\=\=\=​−2N−12N−1−1i​(ifi<−2N−1)(ifi\>2N−1−1)(otherwise)​​
    

#### 4.3.1. Representations[](#representations①)

Numbers and numeric vectors have an underlying binary representation as a sequence of bits:

[bits](#aux-bits)[iN](#syntax-numtype)​(i)[bits](#aux-bits)[fN](#syntax-numtype)​(z)[bits](#aux-bits)[vN](#syntax-vectype)​(i)​\=\=\=​[ibits](#aux-ibits)N​(i)[fbits](#aux-fbits)N​(z)[ibits](#aux-ibits)N​(i)​​

The first case of these applies to representations of both integer [value types](#syntax-valtype) and [packed types](#syntax-packtype).

Each of these functions is a bijection, hence they are invertible.

##### 4.3.1.1. Integers[](#integers③)

[Integers](#syntax-int) are represented as base two unsigned numbers:

[ibits](#aux-ibits)N​(i)​\=​dN−1​ … d0​​(i\=2N−1⋅dN−1​+⋯+20⋅d0​)​​

Boolean operators like ∧, ∨, or ⊻ are lifted to bit sequences of equal length by applying them pointwise.

##### 4.3.1.2. Floating-Point[](#floating-point③)

[Floating-point values](#syntax-float) are represented in the respective binary format defined by [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") (Section 3.4):

[fbits](#aux-fbits)N​(±(1+m⋅2−M)⋅2e)[fbits](#aux-fbits)N​(±(0+m⋅2−M)⋅2e)[fbits](#aux-fbits)N​(±∞)[fbits](#aux-fbits)N​(±[nan](#syntax-float)(n))[fbias](#aux-fbias)N​[fsign](#aux-fsign)(+)[fsign](#aux-fsign)(−)​\=\=\=\=\=\=\=​[fsign](#aux-fsign)(±) [ibits](#aux-ibits)E​(e+[fbias](#aux-fbias)N​) [ibits](#aux-ibits)M​(m)[fsign](#aux-fsign)(±) (0)E [ibits](#aux-ibits)M​(m)[fsign](#aux-fsign)(±) (1)E (0)M[fsign](#aux-fsign)(±) (1)E [ibits](#aux-ibits)M​(n)2E−1−101​​

where M\=[signif](#aux-signif)(N) and E\=[expon](#aux-expon)(N).

##### 4.3.1.3. Vectors[](#vectors③)

Numeric vectors of type [vN](#syntax-vectype) have the same underlying representation as an [iN](#syntax-numtype). They can also be interpreted as a sequence of numeric values packed into a [vN](#syntax-vectype) with a particular [shape](#syntax-shape) txM, provided that N\=∣t∣⋅M.

[lanes](#aux-lanes)txM​(c)​\=​c0​ … cM−1​​(where∧∧​wb∗ci​​\=\=\=​∣t∣/8[bytes](#aux-bytes)[iN](#syntax-numtype)​(c)[bytes](#aux-bytes)t−1​(b∗\[i⋅w[:](#notation-slice)w\]))​​​

This function is a bijection on [iN](#syntax-numtype), hence it is invertible.

Numeric values can be _packed_ into lanes of a specific [lane type](#syntax-lanetype) and vice versa:

[pack](#aux-packnum)[numtype](#syntax-numtype)​(c)[pack](#aux-packnum)[packtype](#syntax-packtype)​(c)[unpack](#aux-unpacknum)[packtype](#syntax-packtype)​(c)​\=\=\=​c[wrap](#op-wrap)∣[unpack](#aux-unpack)([packtype](#syntax-packtype))∣,∣[packtype](#syntax-packtype)∣​(c)0.8ex\][unpack](#aux-unpacknum)[numtype](#syntax-numtype)​(c)[extend](#op-extend)∣[packtype](#syntax-packtype)∣,∣[unpack](#aux-unpack)([packtype](#syntax-packtype))∣[u](#syntax-sx)​(c)​\=​c​​

##### 4.3.1.4. Storage[](#storage①)

When a number is stored into [memory](#syntax-mem), it is converted into a sequence of [bytes](#syntax-byte) in [little endian](https://en.wikipedia.org/wiki/Endianness#Little-endian) byte order:

[bytes](#aux-bytes)t​(i)[littleendian](#aux-littleendian)(ϵ)[littleendian](#aux-littleendian)(d8 d′∗ )​\=\=\=​[littleendian](#aux-littleendian)([bits](#aux-bits)t​(i))ϵ[littleendian](#aux-littleendian)(d′∗) [ibits](#aux-ibits)8−1​(d8)​​

Again these functions are invertible bijections.

#### 4.3.2. Integer Operations[](#integer-operations①)

##### 4.3.2.1. Sign Interpretation[](#sign-interpretation①)

Integer operators are defined on [iN](#syntax-int) values. Operators that use a signed interpretation convert the value using the following definition, which takes the two’s complement when the value lies in the upper half of the value range (i.e., its most significant bit is 1):

[signed](#aux-signed)N​(i)[signed](#aux-signed)N​(i)​\=\=​ii−2N​(0≤i<2N−1)(2N−1≤i<2N)​​

This function is bijective, and hence invertible.

##### 4.3.2.2. Boolean Interpretation[](#boolean-interpretation①)

The integer result of predicates – i.e., [tests](#syntax-testop) and [relational](#syntax-relop) operators – is defined with the help of the following auxiliary function producing the value 1 or 0 depending on a condition.

[bool](#aux-tobool)(C)[bool](#aux-tobool)(C)​\=\=​10​(ifC)(otherwise)​​

##### 4.3.2.3. [iadd](#op-iadd)N​(i1​,i2​)[](#-hrefop-iaddmathrmiadd_n-i_1-i_2)

*   Return the result of adding i1​ and i2​ modulo 2N.
    

[iadd](#op-iadd)N​(i1​,i2​)​\=​(i1​+i2​)mod2N​

##### 4.3.2.4. [isub](#op-isub)N​(i1​,i2​)[](#-hrefop-isubmathrmisub_n-i_1-i_2)

*   Return the result of subtracting i2​ from i1​ modulo 2N.
    

[isub](#op-isub)N​(i1​,i2​)​\=​(i1​−i2​+2N)mod2N​

##### 4.3.2.5. [imul](#op-imul)N​(i1​,i2​)[](#-hrefop-imulmathrmimul_n-i_1-i_2)

*   Return the result of multiplying i1​ and i2​ modulo 2N.
    

[imul](#op-imul)N​(i1​,i2​)​\=​(i1​⋅i2​)mod2N​

##### 4.3.2.6. [idiv\_u](#op-idiv)N​(i1​,i2​)[](#-hrefop-idivmathrmidiv_u_n-i_1-i_2)

*   If i2​ is 0, then the result is undefined.
    
*   Else, return the result of dividing i1​ by i2​, truncated toward zero.
    

[idiv\_u](#op-idiv)N​(i1​,0)[idiv\_u](#op-idiv)N​(i1​,i2​)​\=\=​{}[trunc](#aux-trunc)(i1​/i2​)​​

Note

This operator is [partial](#exec-op-partial).

##### 4.3.2.7. [idiv\_s](#op-idiv)N​(i1​,i2​)[](#-hrefop-idivmathrmidiv_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   If j2​ is 0, then the result is undefined.
    
*   Else if j1​ divided by j2​ is 2N−1, then the result is undefined.
    
*   Else, return the result of dividing j1​ by j2​, truncated toward zero.
    

[idiv\_s](#op-idiv)N​(i1​,0)[idiv\_s](#op-idiv)N​(i1​,i2​)[idiv\_s](#op-idiv)N​(i1​,i2​)​\=\=\=​{}{}(if[signed](#aux-signed)N​(i1​)/[signed](#aux-signed)N​(i2​)\=2N−1)[signed](#aux-signed)N−1​([trunc](#aux-trunc)([signed](#aux-signed)N​(i1​)/[signed](#aux-signed)N​(i2​)))​​

Note

This operator is [partial](#exec-op-partial). Besides division by 0, the result of (−2N−1)/(−1)\=+2N−1 is not representable as an N\-bit signed integer.

##### 4.3.2.8. [irem\_u](#op-irem)N​(i1​,i2​)[](#-hrefop-iremmathrmirem_u_n-i_1-i_2)

*   If i2​ is 0, then the result is undefined.
    
*   Else, return the remainder of dividing i1​ by i2​.
    

[irem\_u](#op-irem)N​(i1​,0)[irem\_u](#op-irem)N​(i1​,i2​)​\=\=​{}i1​−i2​⋅[trunc](#aux-trunc)(i1​/i2​)​​

Note

This operator is [partial](#exec-op-partial).

As long as both operators are defined, it holds that i1​\=i2​⋅[idiv\_u](#op-idiv)(i1​,i2​)+[irem\_u](#op-irem)(i1​,i2​).

##### 4.3.2.9. [irem\_s](#op-irem)N​(i1​,i2​)[](#-hrefop-iremmathrmirem_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   If i2​ is 0, then the result is undefined.
    
*   Else, return the remainder of dividing j1​ by j2​, with the sign of the dividend j1​.
    

[irem\_s](#op-irem)N​(i1​,0)[irem\_s](#op-irem)N​(i1​,i2​)​\=\=​{}[signed](#aux-signed)N−1​(j1​−j2​⋅[trunc](#aux-trunc)(j1​/j2​))(wherej1​\=[signed](#aux-signed)N​(i1​)∧j2​\=[signed](#aux-signed)N​(i2​))​​

Note

This operator is [partial](#exec-op-partial).

As long as both operators are defined, it holds that i1​\=i2​⋅[idiv\_s](#op-idiv)(i1​,i2​)+[irem\_s](#op-irem)(i1​,i2​).

##### 4.3.2.10. [inot](#op-inot)N​(i)[](#-hrefop-inotmathrminot_n-i)

*   Return the bitwise negation of i.
    

[inot](#op-inot)N​(i)​\=​[ibits](#aux-ibits)N−1​([ibits](#aux-ibits)N​(i)⊻[ibits](#aux-ibits)N​(2N−1))​

##### 4.3.2.11. [irev](#op-irev)N​(i)[](#-hrefop-irevmathrmirev_n-i)

*   Return the bitwise reversal of i.
    

[irev](#op-irev)N​(i)​\=​[ibits](#aux-ibits)N−1​((dN\[N−i\])i≤N)​(ifdN\=[ibits](#aux-ibits)N​(i))​

##### 4.3.2.12. [iand](#op-iand)N​(i1​,i2​)[](#-hrefop-iandmathrmiand_n-i_1-i_2)

*   Return the bitwise conjunction of i1​ and i2​.
    

[iand](#op-iand)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​([ibits](#aux-ibits)N​(i1​)∧[ibits](#aux-ibits)N​(i2​))​

##### 4.3.2.13. [iandnot](#op-iandnot)N​(i1​,i2​)[](#-hrefop-iandnotmathrmiandnot_n-i_1-i_2)

*   Return the bitwise conjunction of i1​ and the bitwise negation of i2​.
    

[iandnot](#op-iandnot)N​(i1​,i2​)​\=​[iand](#op-iand)N​(i1​,[inot](#op-inot)N​(i2​))​

##### 4.3.2.14. [ior](#op-ior)N​(i1​,i2​)[](#-hrefop-iormathrmior_n-i_1-i_2)

*   Return the bitwise disjunction of i1​ and i2​.
    

[ior](#op-ior)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​([ibits](#aux-ibits)N​(i1​)∨[ibits](#aux-ibits)N​(i2​))​

##### 4.3.2.15. [ixor](#op-ixor)N​(i1​,i2​)[](#-hrefop-ixormathrmixor_n-i_1-i_2)

*   Return the bitwise exclusive disjunction of i1​ and i2​.
    

[ixor](#op-ixor)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​([ibits](#aux-ibits)N​(i1​)⊻[ibits](#aux-ibits)N​(i2​))​

##### 4.3.2.16. [ishl](#op-ishl)N​(i1​,i2​)[](#-hrefop-ishlmathrmishl_n-i_1-i_2)

*   Let k be i2​ modulo N.
    
*   Return the result of shifting i1​ left by k bits, modulo 2N.
    

[ishl](#op-ishl)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​(d2N−k​ 0k)​(if[ibits](#aux-ibits)N​(i1​)\=d1k​ d2N−k​∧k\=i2​modN)​

##### 4.3.2.17. [ishr\_u](#op-ishr)N​(i1​,i2​)[](#-hrefop-ishrmathrmishr_u_n-i_1-i_2)

*   Let k be i2​ modulo N.
    
*   Return the result of shifting i1​ right by k bits, extended with 0 bits.
    

[ishr\_u](#op-ishr)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​(0k d1N−k​)​(if[ibits](#aux-ibits)N​(i1​)\=d1N−k​ d2k​∧k\=i2​modN)​

##### 4.3.2.18. [ishr\_s](#op-ishr)N​(i1​,i2​)[](#-hrefop-ishrmathrmishr_s_n-i_1-i_2)

*   Let k be i2​ modulo N.
    
*   Return the result of shifting i1​ right by k bits, extended with the most significant bit of the original value.
    

[ishr\_s](#op-ishr)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​(d0k+1​ d1N−k−1​)​(if[ibits](#aux-ibits)N​(i1​)\=d0​ d1N−k−1​ d2k​∧k\=i2​modN)​

##### 4.3.2.19. [irotl](#op-irotl)N​(i1​,i2​)[](#-hrefop-irotlmathrmirotl_n-i_1-i_2)

*   Let k be i2​ modulo N.
    
*   Return the result of rotating i1​ left by k bits.
    

[irotl](#op-irotl)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​(d2N−k​ d1k​)​(if[ibits](#aux-ibits)N​(i1​)\=d1k​ d2N−k​∧k\=i2​modN)​

##### 4.3.2.20. [irotr](#op-irotr)N​(i1​,i2​)[](#-hrefop-irotrmathrmirotr_n-i_1-i_2)

*   Let k be i2​ modulo N.
    
*   Return the result of rotating i1​ right by k bits.
    

[irotr](#op-irotr)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​(d2k​ d1N−k​)​(if[ibits](#aux-ibits)N​(i1​)\=d1N−k​ d2k​∧k\=i2​modN)​

##### 4.3.2.21. [iclz](#op-iclz)N​(i)[](#-hrefop-iclzmathrmiclz_n-i)

*   Return the count of leading zero bits in i; all bits are considered leading zeros if i is 0.
    

[iclz](#op-iclz)N​(i)​\=​k​(if[ibits](#aux-ibits)N​(i)\=0k (1 d∗)?)​

##### 4.3.2.22. [ictz](#op-ictz)N​(i)[](#-hrefop-ictzmathrmictz_n-i)

*   Return the count of trailing zero bits in i; all bits are considered trailing zeros if i is 0.
    

[ictz](#op-ictz)N​(i)​\=​k​(if[ibits](#aux-ibits)N​(i)\=(d∗ 1)? 0k)​

##### 4.3.2.23. [ipopcnt](#op-ipopcnt)N​(i)[](#-hrefop-ipopcntmathrmipopcnt_n-i)

*   Return the count of non-zero bits in i.
    

[ipopcnt](#op-ipopcnt)N​(i)​\=​k​(if[ibits](#aux-ibits)N​(i)\=(0∗ 1)k 0∗)​

##### 4.3.2.24. [ieqz](#op-ieqz)N​(i)[](#-hrefop-ieqzmathrmieqz_n-i)

*   Return 1 if i is zero, 0 otherwise.
    

[ieqz](#op-ieqz)N​(i)​\=​[bool](#aux-tobool)(i\=0)​

##### 4.3.2.25. [inez](#op-inez)N​(i)[](#-hrefop-inezmathrminez_n-i)

*   Return 0 if i is zero, 1 otherwise.
    

[inez](#op-inez)N​(i)​\=​[bool](#aux-tobool)(i\=0)​

##### 4.3.2.26. [ieq](#op-ieq)N​(i1​,i2​)[](#-hrefop-ieqmathrmieq_n-i_1-i_2)

*   Return 1 if i1​ equals i2​, 0 otherwise.
    

[ieq](#op-ieq)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​\=i2​)​

##### 4.3.2.27. [ine](#op-ine)N​(i1​,i2​)[](#-hrefop-inemathrmine_n-i_1-i_2)

*   Return 1 if i1​ does not equal i2​, 0 otherwise.
    

[ine](#op-ine)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​\=i2​)​

##### 4.3.2.28. [ilt\_u](#op-ilt)N​(i1​,i2​)[](#-hrefop-iltmathrmilt_u_n-i_1-i_2)

*   Return 1 if i1​ is less than i2​, 0 otherwise.
    

[ilt\_u](#op-ilt)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​<i2​)​

##### 4.3.2.29. [ilt\_s](#op-ilt)N​(i1​,i2​)[](#-hrefop-iltmathrmilt_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   Return 1 if j1​ is less than j2​, 0 otherwise.
    

[ilt\_s](#op-ilt)N​(i1​,i2​)​\=​[bool](#aux-tobool)([signed](#aux-signed)N​(i1​)<[signed](#aux-signed)N​(i2​))​

##### 4.3.2.30. [igt\_u](#op-igt)N​(i1​,i2​)[](#-hrefop-igtmathrmigt_u_n-i_1-i_2)

*   Return 1 if i1​ is greater than i2​, 0 otherwise.
    

[igt\_u](#op-igt)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​\>i2​)​

##### 4.3.2.31. [igt\_s](#op-igt)N​(i1​,i2​)[](#-hrefop-igtmathrmigt_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   Return 1 if j1​ is greater than j2​, 0 otherwise.
    

[igt\_s](#op-igt)N​(i1​,i2​)​\=​[bool](#aux-tobool)([signed](#aux-signed)N​(i1​)\>[signed](#aux-signed)N​(i2​))​

##### 4.3.2.32. [ile\_u](#op-ile)N​(i1​,i2​)[](#-hrefop-ilemathrmile_u_n-i_1-i_2)

*   Return 1 if i1​ is less than or equal to i2​, 0 otherwise.
    

[ile\_u](#op-ile)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​≤i2​)​

##### 4.3.2.33. [ile\_s](#op-ile)N​(i1​,i2​)[](#-hrefop-ilemathrmile_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   Return 1 if j1​ is less than or equal to j2​, 0 otherwise.
    

[ile\_s](#op-ile)N​(i1​,i2​)​\=​[bool](#aux-tobool)([signed](#aux-signed)N​(i1​)≤[signed](#aux-signed)N​(i2​))​

##### 4.3.2.34. [ige\_u](#op-ige)N​(i1​,i2​)[](#-hrefop-igemathrmige_u_n-i_1-i_2)

*   Return 1 if i1​ is greater than or equal to i2​, 0 otherwise.
    

[ige\_u](#op-ige)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​≥i2​)​

##### 4.3.2.35. [ige\_s](#op-ige)N​(i1​,i2​)[](#-hrefop-igemathrmige_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   Return 1 if j1​ is greater than or equal to j2​, 0 otherwise.
    

[ige\_s](#op-ige)N​(i1​,i2​)​\=​[bool](#aux-tobool)([signed](#aux-signed)N​(i1​)≥[signed](#aux-signed)N​(i2​))​

##### 4.3.2.36. [iextendM\_s](#op-iextendn)N​(i)[](#-hrefop-iextendnmathrmiextendmmathrm_s_n-i)

*   Let j be the result of computing [wrap](#op-wrap)N,M​(i).
    
*   Return [extends](#op-extend)M,N​(j).
    

[iextendM\_s](#op-iextendn)N​(i)​\=​[extends](#op-extend)M,N​([wrap](#op-wrap)N,M​(i))​​

##### 4.3.2.37. [ibitselect](#op-ibitselect)N​(i1​,i2​,i3​)[](#-hrefop-ibitselectmathrmibitselect_n-i_1-i_2-i_3)

*   Let j1​ be the bitwise conjunction of i1​ and i3​.
    
*   Let j3′​ be the bitwise negation of i3​.
    
*   Let j2​ be the bitwise conjunction of i2​ and j3′​.
    
*   Return the bitwise disjunction of j1​ and j2​.
    

[ibitselect](#op-ibitselect)N​(i1​,i2​,i3​)​\=​[ior](#op-ior)N​([iand](#op-iand)N​(i1​,i3​),[iand](#op-iand)N​(i2​,[inot](#op-inot)N​(i3​)))​

##### 4.3.2.38. [iabs](#op-iabs)N​(i)[](#-hrefop-iabsmathrmiabs_n-i)

*   Let j be the [signed interpretation](#aux-signed) of i.
    
*   If j is greater than or equal to 0, then return i.
    
*   Else return the negation of j, modulo 2N.
    

[iabs](#op-iabs)N​(i)[iabs](#op-iabs)N​(i)​\=\=​i−[signed](#aux-signed)N​(i)mod2N​(if[signed](#aux-signed)N​(i)≥0)(otherwise)​​

##### 4.3.2.39. [ineg](#op-ineg)N​(i)[](#-hrefop-inegmathrmineg_n-i)

*   Return the result of negating i, modulo 2N.
    

[ineg](#op-ineg)N​(i)​\=​(2N−i)mod2N​

##### 4.3.2.40. [imin\_u](#op-imin)N​(i1​,i2​)[](#-hrefop-iminmathrmimin_u_n-i_1-i_2)

*   Return i1​ if [ilt\_u](#op-ilt)N​(i1​,i2​) is 1, return i2​ otherwise.
    

[imin\_u](#op-imin)N​(i1​,i2​)[imin\_u](#op-imin)N​(i1​,i2​)​\=\=​i1​i2​​(if[ilt\_u](#op-ilt)N​(i1​,i2​)\=1)(otherwise)​​

##### 4.3.2.41. [imin\_s](#op-imin)N​(i1​,i2​)[](#-hrefop-iminmathrmimin_s_n-i_1-i_2)

*   Return i1​ if [ilt\_s](#op-ilt)N​(i1​,i2​) is 1, return i2​ otherwise.
    

[imin\_s](#op-imin)N​(i1​,i2​)[imin\_s](#op-imin)N​(i1​,i2​)​\=\=​i1​i2​​(if[ilt\_s](#op-ilt)N​(i1​,i2​)\=1)(otherwise)​​

##### 4.3.2.42. [imax\_u](#op-imax)N​(i1​,i2​)[](#-hrefop-imaxmathrmimax_u_n-i_1-i_2)

*   Return i1​ if [igt\_u](#op-igt)N​(i1​,i2​) is 1, return i2​ otherwise.
    

[imax\_u](#op-imax)N​(i1​,i2​)[imax\_u](#op-imax)N​(i1​,i2​)​\=\=​i1​i2​​(if[igt\_u](#op-igt)N​(i1​,i2​)\=1)(otherwise)​​

##### 4.3.2.43. [imax\_s](#op-imax)N​(i1​,i2​)[](#-hrefop-imaxmathrmimax_s_n-i_1-i_2)

*   Return i1​ if [igt\_s](#op-igt)N​(i1​,i2​) is 1, return i2​ otherwise.
    

[imax\_s](#op-imax)N​(i1​,i2​)[imax\_s](#op-imax)N​(i1​,i2​)​\=\=​i1​i2​​(if[igt\_s](#op-igt)N​(i1​,i2​)\=1)(otherwise)​​

##### 4.3.2.44. [iadd\_sat\_u](#op-iadd-sat)N​(i1​,i2​)[](#-hrefop-iadd-satmathrmiadd_sat_u_n-i_1-i_2)

*   Let i be the result of adding i1​ and i2​.
    
*   Return [sat\_u](#aux-sat)N​(i).
    

[iadd\_sat\_u](#op-iadd-sat)N​(i1​,i2​)​\=​[sat\_u](#aux-sat)N​(i1​+i2​)​

##### 4.3.2.45. [iadd\_sat\_s](#op-iadd-sat)N​(i1​,i2​)[](#-hrefop-iadd-satmathrmiadd_sat_s_n-i_1-i_2)

*   Let j1​ be the signed interpretation of i1​
    
*   Let j2​ be the signed interpretation of i2​
    
*   Let j be the result of adding j1​ and j2​.
    
*   Return the value whose signed interpretation is [sat\_s](#aux-sat)N​(j).
    

[iadd\_sat\_s](#op-iadd-sat)N​(i1​,i2​)​\=​[signed](#aux-signed)N−1​([sat\_s](#aux-sat)N​([signed](#aux-signed)N​(i1​)+[signed](#aux-signed)N​(i2​)))​

##### 4.3.2.46. [isub\_sat\_u](#op-isub-sat)N​(i1​,i2​)[](#-hrefop-isub-satmathrmisub_sat_u_n-i_1-i_2)

*   Let i be the result of subtracting i2​ from i1​.
    
*   Return [sat\_u](#aux-sat)N​(i).
    

[isub\_sat\_u](#op-isub-sat)N​(i1​,i2​)​\=​[sat\_u](#aux-sat)N​(i1​−i2​)​

##### 4.3.2.47. [isub\_sat\_s](#op-isub-sat)N​(i1​,i2​)[](#-hrefop-isub-satmathrmisub_sat_s_n-i_1-i_2)

*   Let j1​ be the signed interpretation of i1​
    
*   Let j2​ be the signed interpretation of i2​
    
*   Let j be the result of subtracting j2​ from j1​.
    
*   Return the value whose signed interpretation is [sat\_s](#aux-sat)N​(j).
    

[isub\_sat\_s](#op-isub-sat)N​(i1​,i2​)​\=​[signed](#aux-signed)N−1​([sat\_s](#aux-sat)N​([signed](#aux-signed)N​(i1​)−[signed](#aux-signed)N​(i2​)))​

##### 4.3.2.48. [iavgr\_u](#op-iavgr)N​(i1​,i2​)[](#-hrefop-iavgrmathrmiavgr_u_n-i_1-i_2)

*   Let j be the result of adding i1​, i2​, and 1.
    
*   Return the result of dividing j by 2, truncated toward zero.
    

[iavgr\_u](#op-iavgr)N​(i1​,i2​)​\=​[trunc](#aux-trunc)((i1​+i2​+1)/2)​

##### 4.3.2.49. [iq15mulrsat\_s](#op-iq15mulrsat)N​(i1​,i2​)[](#-hrefop-iq15mulrsatmathrmiq15mulrsat_s_n-i_1-i_2)

*   Return the whose signed interpretation is the result of [sat\_s](#aux-sat)N​([ishr\_s](#op-ishr)N​(i1​⋅i2​+214,15)).
    

[iq15mulrsat\_s](#op-iq15mulrsat)N​(i1​,i2​)​\=​[signed](#aux-signed)N−1​([sat\_s](#aux-sat)N​([ishr\_s](#op-ishr)N​(i1​⋅i2​+214,15)))​

#### 4.3.3. Floating-Point Operations[](#floating-point-operations①)

Floating-point arithmetic follows the [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") standard, with the following qualifications:

*   All operators use round-to-nearest ties-to-even, except where otherwise specified. Non-default directed rounding attributes are not supported.
    
*   Following the recommendation that operators propagate [NaN](#syntax-nan) payloads from their operands is permitted but not required.
    
*   All operators use “non-stop” mode, and floating-point exceptions are not otherwise observable. In particular, neither alternate floating-point exception handling attributes nor operators on status flags are supported. There is no observable difference between quiet and signalling NaNs.
    

Note

Some of these limitations may be lifted in future versions of WebAssembly.

##### 4.3.3.1. Rounding[](#rounding①)

Rounding always is round-to-nearest ties-to-even, in correspondence with [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") (Section 4.3.1).

An _exact_ floating-point number is a rational number that is exactly representable as a [floating-point number](#syntax-float) of given bit width N.

A _limit_ number for a given floating-point bit width N is a positive or negative number whose magnitude is the smallest power of 2 that is not exactly representable as a floating-point number of width N (that magnitude is 2128 for N\=32 and 21024 for N\=64).

A _candidate_ number is either an exact floating-point number or a positive or negative limit number for the given bit width N.

A _candidate pair_ is a pair z1​,z2​ of candidate numbers, such that no candidate number exists that lies between the two.

A real number r is converted to a floating-point value of bit width N as follows:

*   If r is 0, then return +0.
    
*   Else if r is an exact floating-point number, then return r.
    
*   Else if r greater than or equal to the positive limit, then return +∞.
    
*   Else if r is less than or equal to the negative limit, then return −∞.
    
*   Else if z1​ and z2​ are a candidate pair such that z1​<r<z2​, then:
    
    *   If ∣r−z1​∣<∣r−z2​∣, then let z be z1​.
        
    *   Else if ∣r−z1​∣\>∣r−z2​∣, then let z be z2​.
        
    *   Else if ∣r−z1​∣\=∣r−z2​∣ and the [significand](#syntax-float) of z1​ is even, then let z be z1​.
        
    *   Else, let z be z2​.
        
*   If z is 0, then:
    
    *   If r<0, then return −0.
        
    *   Else, return +0.
        
*   Else if z is a limit number, then:
    
    *   If r<0, then return −∞.
        
    *   Else, return +∞.
        
*   Else, return z.
    

[float](#aux-ieee)N​(0)[float](#aux-ieee)N​(r)[float](#aux-ieee)N​(r)[float](#aux-ieee)N​(r)[float](#aux-ieee)N​(r)closestN​(r,z1​,z2​)closestN​(r,z1​,z2​)closestN​(r,z1​,z2​)closestN​(r,z1​,z2​)rectifyN​(r,±limitN​)rectifyN​(r,0)rectifyN​(r,0)rectifyN​(r,z)​\=\=\=\=\=\=\=\=\=\=\=\=\=​+0r+∞−∞closestN​(r,z1​,z2​)rectifyN​(r,z1​)rectifyN​(r,z2​)rectifyN​(r,z1​)rectifyN​(r,z2​)±∞+0(r≥0)−0(r<0)z​(ifr∈exactN​)(ifr≥+limitN​)(ifr≤−limitN​)(ifz1​<r<z2​∧(z1​,z2​)∈candidatepairN​)(if∣r−z1​∣<∣r−z2​∣)(if∣r−z1​∣\>∣r−z2​∣)(if∣r−z1​∣\=∣r−z2​∣∧evenN​(z1​))(if∣r−z1​∣\=∣r−z2​∣∧evenN​(z2​))​​

where:

exactN​limitN​candidateN​candidatepairN​evenN​((d+m⋅2−M)⋅2e)evenN​(±limitN​)​\=\=\=\=⇔⇔​[fN](#syntax-float)∩Q22[expon](#aux-expon)(N)−1exactN​∪{+limitN​,−limitN​}{(z1​,z2​)∈candidateN2​ ∣ z1​<z2​∧∀z∈candidateN​,z≤z1​∨z≥z2​}mmod2\=0true​​

##### 4.3.3.2. NaN Propagation[](#nan-propagation①)

When the result of a floating-point operator other than [fneg](#op-fneg), [fabs](#op-fabs), or [fcopysign](#op-fcopysign) is a [NaN](#syntax-nan), then its sign is non-deterministic and the [payload](#syntax-payload) is computed as follows:

*   If the payload of all NaN inputs to the operator is [canonical](#canonical-nan) (including the case that there are no NaN inputs), then the payload of the output is canonical as well.
    
*   Otherwise the payload is picked non-deterministically among all [arithmetic NaNs](#arithmetic-nan); that is, its most significant bit is 1 and all others are unspecified.
    
*   In the [deterministic profile](#profile-deterministic), however, a positive canonical NaNs is reliably produced in the latter case.
    

The non-deterministic result is expressed by the following auxiliary function producing a set of allowed outputs from a set of inputs:

\[![DET](#profile-deterministic)\]\[![DET](#profile-deterministic)\]​[nans](#aux-nans)N​{z∗}[nans](#aux-nans)N​{z∗}[nans](#aux-nans)N​{z∗}​\=\=\=​{+[nan](#syntax-float)([canon](#aux-canon)N​)}{+[nan](#syntax-float)(n),−[nan](#syntax-float)(n) ∣ n\=[canon](#aux-canon)N​}{+[nan](#syntax-float)(n),−[nan](#syntax-float)(n) ∣ n≥[canon](#aux-canon)N​}​(if{z∗}⊆{+[nan](#syntax-float)([canon](#aux-canon)N​),−[nan](#syntax-float)([canon](#aux-canon)N​)}(if{z∗}⊆{+[nan](#syntax-float)([canon](#aux-canon)N​),−[nan](#syntax-float)([canon](#aux-canon)N​)}​​

##### 4.3.3.3. [fadd](#op-fadd)N​(z1​,z2​)[](#-hrefop-faddmathrmfadd_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if both z1​ and z2​ are infinities of opposite signs, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ and z2​ are infinities of equal sign, then return that infinity.
    
*   Else if either z1​ or z2​ is an infinity, then return that infinity.
    
*   Else if both z1​ and z2​ are zeroes of opposite sign, then return positive zero.
    
*   Else if both z1​ and z2​ are zeroes of equal sign, then return that zero.
    
*   Else if either z1​ or z2​ is a zero, then return the other operand.
    
*   Else if both z1​ and z2​ are values with the same magnitude but opposite signs, then return positive zero.
    
*   Else return the result of adding z1​ and z2​, [rounded](#aux-ieee) to the nearest representable value.
    

[fadd](#op-fadd)N​(±[nan](#syntax-float)(n),z2​)[fadd](#op-fadd)N​(z1​,±[nan](#syntax-float)(n))[fadd](#op-fadd)N​(±∞,∓∞)[fadd](#op-fadd)N​(±∞,±∞)[fadd](#op-fadd)N​(z1​,±∞)[fadd](#op-fadd)N​(±∞,z2​)[fadd](#op-fadd)N​(±0,∓0)[fadd](#op-fadd)N​(±0,±0)[fadd](#op-fadd)N​(z1​,±0)[fadd](#op-fadd)N​(±0,z2​)[fadd](#op-fadd)N​(±q,∓q)[fadd](#op-fadd)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}[nans](#aux-nans)N​{}±∞±∞±∞+0±0z1​z2​+0[float](#aux-ieee)N​(z1​+z2​)​​

##### 4.3.3.4. [fsub](#op-fsub)N​(z1​,z2​)[](#-hrefop-fsubmathrmfsub_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if both z1​ and z2​ are infinities of equal signs, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ and z2​ are infinities of opposite sign, then return z1​.
    
*   Else if z1​ is an infinity, then return that infinity.
    
*   Else if z2​ is an infinity, then return that infinity negated.
    
*   Else if both z1​ and z2​ are zeroes of equal sign, then return positive zero.
    
*   Else if both z1​ and z2​ are zeroes of opposite sign, then return z1​.
    
*   Else if z2​ is a zero, then return z1​.
    
*   Else if z1​ is a zero, then return z2​ negated.
    
*   Else if both z1​ and z2​ are the same value, then return positive zero.
    
*   Else return the result of subtracting z2​ from z1​, [rounded](#aux-ieee) to the nearest representable value.
    

[fsub](#op-fsub)N​(±[nan](#syntax-float)(n),z2​)[fsub](#op-fsub)N​(z1​,±[nan](#syntax-float)(n))[fsub](#op-fsub)N​(±∞,±∞)[fsub](#op-fsub)N​(±∞,∓∞)[fsub](#op-fsub)N​(z1​,±∞)[fsub](#op-fsub)N​(±∞,z2​)[fsub](#op-fsub)N​(±0,±0)[fsub](#op-fsub)N​(±0,∓0)[fsub](#op-fsub)N​(z1​,±0)[fsub](#op-fsub)N​(±0,±q2​)[fsub](#op-fsub)N​(±q,±q)[fsub](#op-fsub)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}[nans](#aux-nans)N​{}±∞∓∞±∞+0±0z1​∓q2​+0[float](#aux-ieee)N​(z1​−z2​)​​

Note

Up to the non-determinism regarding NaNs, it always holds that [fsub](#op-fsub)N​(z1​,z2​)\=[fadd](#op-fadd)N​(z1​,[fneg](#op-fneg)N​(z2​)).

##### 4.3.3.5. [fmul](#op-fmul)N​(z1​,z2​)[](#-hrefop-fmulmathrmfmul_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if one of z1​ and z2​ is a zero and the other an infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ and z2​ are infinities of equal sign, then return positive infinity.
    
*   Else if both z1​ and z2​ are infinities of opposite sign, then return negative infinity.
    
*   Else if either z1​ or z2​ is an infinity and the other a value with equal sign, then return positive infinity.
    
*   Else if either z1​ or z2​ is an infinity and the other a value with opposite sign, then return negative infinity.
    
*   Else if both z1​ and z2​ are zeroes of equal sign, then return positive zero.
    
*   Else if both z1​ and z2​ are zeroes of opposite sign, then return negative zero.
    
*   Else return the result of multiplying z1​ and z2​, [rounded](#aux-ieee) to the nearest representable value.
    

[fmul](#op-fmul)N​(±[nan](#syntax-float)(n),z2​)[fmul](#op-fmul)N​(z1​,±[nan](#syntax-float)(n))[fmul](#op-fmul)N​(±∞,±0)[fmul](#op-fmul)N​(±∞,∓0)[fmul](#op-fmul)N​(±0,±∞)[fmul](#op-fmul)N​(±0,∓∞)[fmul](#op-fmul)N​(±∞,±∞)[fmul](#op-fmul)N​(±∞,∓∞)[fmul](#op-fmul)N​(±q1​,±∞)[fmul](#op-fmul)N​(±q1​,∓∞)[fmul](#op-fmul)N​(±∞,±q2​)[fmul](#op-fmul)N​(±∞,∓q2​)[fmul](#op-fmul)N​(±0,±0)[fmul](#op-fmul)N​(±0,∓0)[fmul](#op-fmul)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}+∞−∞+∞−∞+∞−∞+0−0[float](#aux-ieee)N​(z1​⋅z2​)​​

##### 4.3.3.6. [fdiv](#op-fdiv)N​(z1​,z2​)[](#-hrefop-fdivmathrmfdiv_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if both z1​ and z2​ are infinities, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ and z2​ are zeroes, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if z1​ is an infinity and z2​ a value with equal sign, then return positive infinity.
    
*   Else if z1​ is an infinity and z2​ a value with opposite sign, then return negative infinity.
    
*   Else if z2​ is an infinity and z1​ a value with equal sign, then return positive zero.
    
*   Else if z2​ is an infinity and z1​ a value with opposite sign, then return negative zero.
    
*   Else if z1​ is a zero and z2​ a value with equal sign, then return positive zero.
    
*   Else if z1​ is a zero and z2​ a value with opposite sign, then return negative zero.
    
*   Else if z2​ is a zero and z1​ a value with equal sign, then return positive infinity.
    
*   Else if z2​ is a zero and z1​ a value with opposite sign, then return negative infinity.
    
*   Else return the result of dividing z1​ by z2​, [rounded](#aux-ieee) to the nearest representable value.
    

[fdiv](#op-fdiv)N​(±[nan](#syntax-float)(n),z2​)[fdiv](#op-fdiv)N​(z1​,±[nan](#syntax-float)(n))[fdiv](#op-fdiv)N​(±∞,±∞)[fdiv](#op-fdiv)N​(±∞,∓∞)[fdiv](#op-fdiv)N​(±0,±0)[fdiv](#op-fdiv)N​(±0,∓0)[fdiv](#op-fdiv)N​(±∞,±q2​)[fdiv](#op-fdiv)N​(±∞,∓q2​)[fdiv](#op-fdiv)N​(±q1​,±∞)[fdiv](#op-fdiv)N​(±q1​,∓∞)[fdiv](#op-fdiv)N​(±0,±q2​)[fdiv](#op-fdiv)N​(±0,∓q2​)[fdiv](#op-fdiv)N​(±q1​,±0)[fdiv](#op-fdiv)N​(±q1​,∓0)[fdiv](#op-fdiv)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}+∞−∞+0−0+0−0+∞−∞[float](#aux-ieee)N​(z1​/z2​)​​

##### 4.3.3.7. [fma](#op-fma)N​(z1​,z2​,z3​)[](#-hrefop-fmamathrmfma_n-z_1-z_2-z_3)

The function [fma](#op-fma) is the same as _fusedMultiplyAdd_ defined by [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") (Section 5.4.1). It computes (z1​⋅z2​)+z3​ as if with unbounded range and precision, rounding only once for the final result.

*   If either z1​ or z2​ or z3​ is a NaN, return an element of [nans](#aux-nans)N​z1​,z2​,z3​.
    
*   Else if either z1​ or z2​ is a zero and the other is an infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ or z2​ are infinities of equal sign, and z3​ is a negative infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ or z2​ are infinities of opposite sign, and z3​ is a positive infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if either z1​ or z2​ is an infinity and the other is a value of the same sign, and z3​ is a negative infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if either z1​ or z2​ is an infinity and the other is a value of the opposite sign, and z3​ is a positive infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ and z2​ are zeroes of the same sign and z3​ is a zero, then return positive zero.
    
*   Else if both z1​ and z2​ are zeroes of the opposite sign and z3​ is a positive zero, then return positive zero.
    
*   Else if both z1​ and z2​ are zeroes of the opposite sign and z3​ is a negative zero, then return negative zero.
    
*   Else return the result of multiplying z1​ and z2​, adding z3​ to the intermediate, and the final result ref:rounded <aux-ieee> to the nearest representable value.
    

​[fma](#op-fma)N​(±[nan](#syntax-float)(n),z2​,z3​)[fma](#op-fma)N​(z1​,±[nan](#syntax-float)(n),z3​)[fma](#op-fma)N​(z1​,z2​,±[nan](#syntax-float)(n))[fma](#op-fma)N​(±∞,±0,z3​)[fma](#op-fma)N​(±∞,∓0,z3​)[fma](#op-fma)N​(±∞,±∞,−∞)[fma](#op-fma)N​(±∞,∓∞,+∞)[fma](#op-fma)N​(±q1​,±∞,−∞)[fma](#op-fma)N​(±q1​,∓∞,+∞)[fma](#op-fma)N​(±∞,±q1​,−∞)[fma](#op-fma)N​(∓∞,±q1​,+∞)[fma](#op-fma)N​(±0,±0,∓0)[fma](#op-fma)N​(±0,±0,±0)[fma](#op-fma)N​(±0,∓0,+0)[fma](#op-fma)N​(±0,∓0,−0)[fma](#op-fma)N​(z1​,z2​,z3​)​\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​,z3​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​,z3​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​,z2​}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}+0+0+0−0[float](#aux-ieee)N​(z1​⋅z2​+z3​)​​

##### 4.3.3.8. [fmin](#op-fmin)N​(z1​,z2​)[](#-hrefop-fminmathrmfmin_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if either z1​ or z2​ is a negative infinity, then return negative infinity.
    
*   Else if either z1​ or z2​ is a positive infinity, then return the other value.
    
*   Else if both z1​ and z2​ are zeroes of opposite signs, then return negative zero.
    
*   Else return the smaller value of z1​ and z2​.
    

[fmin](#op-fmin)N​(±[nan](#syntax-float)(n),z2​)[fmin](#op-fmin)N​(z1​,±[nan](#syntax-float)(n))[fmin](#op-fmin)N​(+∞,z2​)[fmin](#op-fmin)N​(−∞,z2​)[fmin](#op-fmin)N​(z1​,+∞)[fmin](#op-fmin)N​(z1​,−∞)[fmin](#op-fmin)N​(±0,∓0)[fmin](#op-fmin)N​(z1​,z2​)[fmin](#op-fmin)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}z2​−∞z1​−∞−0z1​z2​​(ifz1​≤z2​)(ifz2​≤z1​)​​

##### 4.3.3.9. [fmax](#op-fmax)N​(z1​,z2​)[](#-hrefop-fmaxmathrmfmax_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if either z1​ or z2​ is a positive infinity, then return positive infinity.
    
*   Else if either z1​ or z2​ is a negative infinity, then return the other value.
    
*   Else if both z1​ and z2​ are zeroes of opposite signs, then return positive zero.
    
*   Else return the larger value of z1​ and z2​.
    

[fmax](#op-fmax)N​(±[nan](#syntax-float)(n),z2​)[fmax](#op-fmax)N​(z1​,±[nan](#syntax-float)(n))[fmax](#op-fmax)N​(+∞,z2​)[fmax](#op-fmax)N​(−∞,z2​)[fmax](#op-fmax)N​(z1​,+∞)[fmax](#op-fmax)N​(z1​,−∞)[fmax](#op-fmax)N​(±0,∓0)[fmax](#op-fmax)N​(z1​,z2​)[fmax](#op-fmax)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}+∞z2​+∞z1​+0z1​z2​​(ifz1​≥z2​)(ifz2​≥z1​)​​

##### 4.3.3.10. [fcopysign](#op-fcopysign)N​(z1​,z2​)[](#-hrefop-fcopysignmathrmfcopysign_n-z_1-z_2)

*   If z1​ and z2​ have the same sign, then return z1​.
    
*   Else return z1​ with negated sign.
    

[fcopysign](#op-fcopysign)N​(±p1​,±p2​)[fcopysign](#op-fcopysign)N​(±p1​,∓p2​)​\=\=​±p1​∓p1​​​

##### 4.3.3.11. [fabs](#op-fabs)N​(z)[](#-hrefop-fabsmathrmfabs_n-z)

*   If z is a NaN, then return z with positive sign.
    
*   Else if z is an infinity, then return positive infinity.
    
*   Else if z is a zero, then return positive zero.
    
*   Else if z is a positive value, then z.
    
*   Else return z negated.
    

[fabs](#op-fabs)N​(±[nan](#syntax-float)(n))[fabs](#op-fabs)N​(±∞)[fabs](#op-fabs)N​(±0)[fabs](#op-fabs)N​(±q)​\=\=\=\=​+[nan](#syntax-float)(n)+∞+0+q​​

##### 4.3.3.12. [fneg](#op-fneg)N​(z)[](#-hrefop-fnegmathrmfneg_n-z)

*   If z is a NaN, then return z with negated sign.
    
*   Else if z is an infinity, then return that infinity negated.
    
*   Else if z is a zero, then return that zero negated.
    
*   Else return z negated.
    

[fneg](#op-fneg)N​(±[nan](#syntax-float)(n))[fneg](#op-fneg)N​(±∞)[fneg](#op-fneg)N​(±0)[fneg](#op-fneg)N​(±q)​\=\=\=\=​∓[nan](#syntax-float)(n)∓∞∓0∓q​​

##### 4.3.3.13. [fsqrt](#op-fsqrt)N​(z)[](#-hrefop-fsqrtmathrmfsqrt_n-z)

*   If z is a NaN, then return an element of [nans](#aux-nans)N​{z}.
    
*   Else if z is negative infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if z is positive infinity, then return positive infinity.
    
*   Else if z is a zero, then return that zero.
    
*   Else if z has a negative sign, then return an element of [nans](#aux-nans)N​{}.
    
*   Else return the square root of z.
    

[fsqrt](#op-fsqrt)N​(±[nan](#syntax-float)(n))[fsqrt](#op-fsqrt)N​(−∞)[fsqrt](#op-fsqrt)N​(+∞)[fsqrt](#op-fsqrt)N​(±0)[fsqrt](#op-fsqrt)N​(−q)[fsqrt](#op-fsqrt)N​(+q)​\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n)}[nans](#aux-nans)N​{}+∞±0[nans](#aux-nans)N​{}[float](#aux-ieee)N​(q​)​​

##### 4.3.3.14. [fceil](#op-fceil)N​(z)[](#-hrefop-fceilmathrmfceil_n-z)

*   If z is a NaN, then return an element of [nans](#aux-nans)N​{z}.
    
*   Else if z is an infinity, then return z.
    
*   Else if z is a zero, then return z.
    
*   Else if z is smaller than 0 but greater than −1, then return negative zero.
    
*   Else return the smallest integral value that is not smaller than z.
    

[fceil](#op-fceil)N​(±[nan](#syntax-float)(n))[fceil](#op-fceil)N​(±∞)[fceil](#op-fceil)N​(±0)[fceil](#op-fceil)N​(−q)[fceil](#op-fceil)N​(±q)​\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n)}±∞±0−0[float](#aux-ieee)N​(i)​(if−1<−q<0)(if±q≤i<±q+1)​​

##### 4.3.3.15. [ffloor](#op-ffloor)N​(z)[](#-hrefop-ffloormathrmffloor_n-z)

*   If z is a NaN, then return an element of [nans](#aux-nans)N​{z}.
    
*   Else if z is an infinity, then return z.
    
*   Else if z is a zero, then return z.
    
*   Else if z is greater than 0 but smaller than 1, then return positive zero.
    
*   Else return the largest integral value that is not larger than z.
    

[ffloor](#op-ffloor)N​(±[nan](#syntax-float)(n))[ffloor](#op-ffloor)N​(±∞)[ffloor](#op-ffloor)N​(±0)[ffloor](#op-ffloor)N​(+q)[ffloor](#op-ffloor)N​(±q)​\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n)}±∞±0+0[float](#aux-ieee)N​(i)​(if0<+q<1)(if±q−1<i≤±q)​​

##### 4.3.3.16. [ftrunc](#op-ftrunc)N​(z)[](#-hrefop-ftruncmathrmftrunc_n-z)

*   If z is a NaN, then return an element of [nans](#aux-nans)N​{z}.
    
*   Else if z is an infinity, then return z.
    
*   Else if z is a zero, then return z.
    
*   Else if z is greater than 0 but smaller than 1, then return positive zero.
    
*   Else if z is smaller than 0 but greater than −1, then return negative zero.
    
*   Else return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.
    

[ftrunc](#op-ftrunc)N​(±[nan](#syntax-float)(n))[ftrunc](#op-ftrunc)N​(±∞)[ftrunc](#op-ftrunc)N​(±0)[ftrunc](#op-ftrunc)N​(+q)[ftrunc](#op-ftrunc)N​(−q)[ftrunc](#op-ftrunc)N​(±q)​\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n)}±∞±0+0−0[float](#aux-ieee)N​(±i)​(if0<+q<1)(if−1<−q<0)(if+q−1<i≤+q)​​

##### 4.3.3.17. [fnearest](#op-fnearest)N​(z)[](#-hrefop-fnearestmathrmfnearest_n-z)

*   If z is a NaN, then return an element of [nans](#aux-nans)N​{z}.
    
*   Else if z is an infinity, then return z.
    
*   Else if z is a zero, then return z.
    
*   Else if z is greater than 0 but smaller than or equal to 0.5, then return positive zero.
    
*   Else if z is smaller than 0 but greater than or equal to −0.5, then return negative zero.
    
*   Else return the integral value that is nearest to z; if two values are equally near, return the even one.
    

[fnearest](#op-fnearest)N​(±[nan](#syntax-float)(n))[fnearest](#op-fnearest)N​(±∞)[fnearest](#op-fnearest)N​(±0)[fnearest](#op-fnearest)N​(+q)[fnearest](#op-fnearest)N​(−q)[fnearest](#op-fnearest)N​(±q)[fnearest](#op-fnearest)N​(±q)​\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n)}±∞±0+0−0[float](#aux-ieee)N​(±i)[float](#aux-ieee)N​(±i)​(if0<+q≤0.5)(if−0.5≤−q<0)(if∣i−q∣<0.5)(if∣i−q∣\=0.5∧i even)​​

##### 4.3.3.18. [feq](#op-feq)N​(z1​,z2​)[](#-hrefop-feqmathrmfeq_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 0.
    
*   Else if both z1​ and z2​ are zeroes, then return 1.
    
*   Else if both z1​ and z2​ are the same value, then return 1.
    
*   Else return 0.
    

[feq](#op-feq)N​(±[nan](#syntax-float)(n),z2​)[feq](#op-feq)N​(z1​,±[nan](#syntax-float)(n))[feq](#op-feq)N​(±0,∓0)[feq](#op-feq)N​(z1​,z2​)​\=\=\=\=​001[bool](#aux-tobool)(z1​\=z2​)​​

##### 4.3.3.19. [fne](#op-fne)N​(z1​,z2​)[](#-hrefop-fnemathrmfne_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 1.
    
*   Else if both z1​ and z2​ are zeroes, then return 0.
    
*   Else if both z1​ and z2​ are the same value, then return 0.
    
*   Else return 1.
    

[fne](#op-fne)N​(±[nan](#syntax-float)(n),z2​)[fne](#op-fne)N​(z1​,±[nan](#syntax-float)(n))[fne](#op-fne)N​(±0,∓0)[fne](#op-fne)N​(z1​,z2​)​\=\=\=\=​110[bool](#aux-tobool)(z1​\=z2​)​​

##### 4.3.3.20. [flt](#op-flt)N​(z1​,z2​)[](#-hrefop-fltmathrmflt_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 0.
    
*   Else if z1​ and z2​ are the same value, then return 0.
    
*   Else if z1​ is positive infinity, then return 0.
    
*   Else if z1​ is negative infinity, then return 1.
    
*   Else if z2​ is positive infinity, then return 1.
    
*   Else if z2​ is negative infinity, then return 0.
    
*   Else if both z1​ and z2​ are zeroes, then return 0.
    
*   Else if z1​ is smaller than z2​, then return 1.
    
*   Else return 0.
    

[flt](#op-flt)N​(±[nan](#syntax-float)(n),z2​)[flt](#op-flt)N​(z1​,±[nan](#syntax-float)(n))[flt](#op-flt)N​(z,z)[flt](#op-flt)N​(+∞,z2​)[flt](#op-flt)N​(−∞,z2​)[flt](#op-flt)N​(z1​,+∞)[flt](#op-flt)N​(z1​,−∞)[flt](#op-flt)N​(±0,∓0)[flt](#op-flt)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​00001100[bool](#aux-tobool)(z1​<z2​)​​

##### 4.3.3.21. [fgt](#op-fgt)N​(z1​,z2​)[](#-hrefop-fgtmathrmfgt_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 0.
    
*   Else if z1​ and z2​ are the same value, then return 0.
    
*   Else if z1​ is positive infinity, then return 1.
    
*   Else if z1​ is negative infinity, then return 0.
    
*   Else if z2​ is positive infinity, then return 0.
    
*   Else if z2​ is negative infinity, then return 1.
    
*   Else if both z1​ and z2​ are zeroes, then return 0.
    
*   Else if z1​ is larger than z2​, then return 1.
    
*   Else return 0.
    

[fgt](#op-fgt)N​(±[nan](#syntax-float)(n),z2​)[fgt](#op-fgt)N​(z1​,±[nan](#syntax-float)(n))[fgt](#op-fgt)N​(z,z)[fgt](#op-fgt)N​(+∞,z2​)[fgt](#op-fgt)N​(−∞,z2​)[fgt](#op-fgt)N​(z1​,+∞)[fgt](#op-fgt)N​(z1​,−∞)[fgt](#op-fgt)N​(±0,∓0)[fgt](#op-fgt)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​00010010[bool](#aux-tobool)(z1​\>z2​)​​

##### 4.3.3.22. [fle](#op-fle)N​(z1​,z2​)[](#-hrefop-flemathrmfle_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 0.
    
*   Else if z1​ and z2​ are the same value, then return 1.
    
*   Else if z1​ is positive infinity, then return 0.
    
*   Else if z1​ is negative infinity, then return 1.
    
*   Else if z2​ is positive infinity, then return 1.
    
*   Else if z2​ is negative infinity, then return 0.
    
*   Else if both z1​ and z2​ are zeroes, then return 1.
    
*   Else if z1​ is smaller than or equal to z2​, then return 1.
    
*   Else return 0.
    

[fle](#op-fle)N​(±[nan](#syntax-float)(n),z2​)[fle](#op-fle)N​(z1​,±[nan](#syntax-float)(n))[fle](#op-fle)N​(z,z)[fle](#op-fle)N​(+∞,z2​)[fle](#op-fle)N​(−∞,z2​)[fle](#op-fle)N​(z1​,+∞)[fle](#op-fle)N​(z1​,−∞)[fle](#op-fle)N​(±0,∓0)[fle](#op-fle)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​00101101[bool](#aux-tobool)(z1​≤z2​)​​

##### 4.3.3.23. [fge](#op-fge)N​(z1​,z2​)[](#-hrefop-fgemathrmfge_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 0.
    
*   Else if z1​ and z2​ are the same value, then return 1.
    
*   Else if z1​ is positive infinity, then return 1.
    
*   Else if z1​ is negative infinity, then return 0.
    
*   Else if z2​ is positive infinity, then return 0.
    
*   Else if z2​ is negative infinity, then return 1.
    
*   Else if both z1​ and z2​ are zeroes, then return 1.
    
*   Else if z1​ is larger than or equal to z2​, then return 1.
    
*   Else return 0.
    

[fge](#op-fge)N​(±[nan](#syntax-float)(n),z2​)[fge](#op-fge)N​(z1​,±[nan](#syntax-float)(n))[fge](#op-fge)N​(z,z)[fge](#op-fge)N​(+∞,z2​)[fge](#op-fge)N​(−∞,z2​)[fge](#op-fge)N​(z1​,+∞)[fge](#op-fge)N​(z1​,−∞)[fge](#op-fge)N​(±0,∓0)[fge](#op-fge)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​00110011[bool](#aux-tobool)(z1​≥z2​)​​

##### 4.3.3.24. [fpmin](#op-fpmin)N​(z1​,z2​)[](#-hrefop-fpminmathrmfpmin_n-z_1-z_2)

*   If z2​ is less than z1​ then return z2​.
    
*   Else return z1​.
    

[fpmin](#op-fpmin)N​(z1​,z2​)[fpmin](#op-fpmin)N​(z1​,z2​)​\=\=​z2​z1​​(if[flt](#op-flt)N​(z2​,z1​)\=1)(otherwise)​​

##### 4.3.3.25. [fpmax](#op-fpmax)N​(z1​,z2​)[](#-hrefop-fpmaxmathrmfpmax_n-z_1-z_2)

*   If z1​ is less than z2​ then return z2​.
    
*   Else return z1​.
    

[fpmax](#op-fpmax)N​(z1​,z2​)[fpmax](#op-fpmax)N​(z1​,z2​)​\=\=​z2​z1​​(if[flt](#op-flt)N​(z1​,z2​)\=1)(otherwise)​​

#### 4.3.4. Conversions[](#conversions①)

##### 4.3.4.1. [extendu](#op-extend)M,N​(i)[](#-hrefop-extendmathrmextendmathsfu_m-n-i)

*   Return i.
    

[extendu](#op-extend)M,N​(i)​\=​i​​

Note

In the abstract syntax, unsigned extension just reinterprets the same value.

##### 4.3.4.2. [extends](#op-extend)M,N​(i)[](#-hrefop-extendmathrmextendmathsfs_m-n-i)

*   Let j be the [signed interpretation](#aux-signed) of i of size M.
    
*   Return the two’s complement of j relative to size N.
    

[extends](#op-extend)M,N​(i)​\=​[signed](#aux-signed)N−1​([signed](#aux-signed)M​(i))​​

##### 4.3.4.3. [wrap](#op-wrap)M,N​(i)[](#-hrefop-wrapmathrmwrap_m-n-i)

*   Return i modulo 2N.
    

[wrap](#op-wrap)M,N​(i)​\=​imod2N​​

##### 4.3.4.4. [truncu](#op-trunc)M,N​(z)[](#-hrefop-truncmathrmtruncmathsfu_m-n-z)

*   If z is a NaN, then the result is undefined.
    
*   Else if z is an infinity, then the result is undefined.
    
*   Else if z is a number and [trunc](#aux-trunc)(z) is a value within range of the target type, then return that value.
    
*   Else the result is undefined.
    

[truncu](#op-trunc)M,N​(±[nan](#syntax-float)(n))[truncu](#op-trunc)M,N​(±∞)[truncu](#op-trunc)M,N​(±q)[truncu](#op-trunc)M,N​(±q)​\=\=\=\=​{}{}[trunc](#aux-trunc)(±q){}​(if−1<[trunc](#aux-trunc)(±q)<2N)(otherwise)​​

Note

This operator is [partial](#exec-op-partial). It is not defined for NaNs, infinities, or values for which the result is out of range.

##### 4.3.4.5. [truncs](#op-trunc)M,N​(z)[](#-hrefop-truncmathrmtruncmathsfs_m-n-z)

*   If z is a NaN, then the result is undefined.
    
*   Else if z is an infinity, then the result is undefined.
    
*   If z is a number and [trunc](#aux-trunc)(z) is a value within range of the target type, then return that value.
    
*   Else the result is undefined.
    

[truncs](#op-trunc)M,N​(±[nan](#syntax-float)(n))[truncs](#op-trunc)M,N​(±∞)[truncs](#op-trunc)M,N​(±q)[truncs](#op-trunc)M,N​(±q)​\=\=\=\=​{}{}[trunc](#aux-trunc)(±q){}​(if−2N−1−1<[trunc](#aux-trunc)(±q)<2N−1)(otherwise)​​

Note

This operator is [partial](#exec-op-partial). It is not defined for NaNs, infinities, or values for which the result is out of range.

##### 4.3.4.6. [trunc\_sat\_u](#op-trunc-sat)M,N​(z)[](#-hrefop-trunc-satmathrmtrunc_sat_u_m-n-z)

*   If z is a NaN, then return 0.
    
*   Else if z is negative infinity, then return 0.
    
*   Else if z is positive infinity, then return 2N−1.
    
*   Else, return [sat\_u](#aux-sat)N​([trunc](#aux-trunc)(z)).
    

[trunc\_sat\_u](#op-trunc-sat)M,N​(±[nan](#syntax-float)(n))[trunc\_sat\_u](#op-trunc-sat)M,N​(−∞)[trunc\_sat\_u](#op-trunc-sat)M,N​(+∞)[trunc\_sat\_u](#op-trunc-sat)M,N​(z)​\=\=\=\=​002N−1[sat\_u](#aux-sat)N​([trunc](#aux-trunc)(z))​​

##### 4.3.4.7. [trunc\_sat\_s](#op-trunc-sat)M,N​(z)[](#-hrefop-trunc-satmathrmtrunc_sat_s_m-n-z)

*   If z is a NaN, then return 0.
    
*   Else if z is negative infinity, then return −2N−1.
    
*   Else if z is positive infinity, then return 2N−1−1.
    
*   Else, return the value whose signed interpretation is [sat\_s](#aux-sat)N​([trunc](#op-trunc)(z)).
    

[trunc\_sat\_s](#op-trunc-sat)M,N​(±[nan](#syntax-float)(n))[trunc\_sat\_s](#op-trunc-sat)M,N​(−∞)[trunc\_sat\_s](#op-trunc-sat)M,N​(+∞)[trunc\_sat\_s](#op-trunc-sat)M,N​(z)​\=\=\=\=​0−2N−12N−1−1[signed](#aux-signed)N−1​([sat\_s](#aux-sat)N​([trunc](#op-trunc)(z)))​​

##### 4.3.4.8. [promote](#op-promote)M,N​(z)[](#-hrefop-promotemathrmpromote_m-n-z)

*   If z is a [canonical NaN](#canonical-nan), then return an element of [nans](#aux-nans)N​{} (i.e., a canonical NaN of size N).
    
*   Else if z is a NaN, then return an element of [nans](#aux-nans)N​{±[nan](#syntax-float)(1)} (i.e., any [arithmetic NaN](#arithmetic-nan) of size N).
    
*   Else, return z.
    

[promote](#op-promote)M,N​(±[nan](#syntax-float)(n))[promote](#op-promote)M,N​(±[nan](#syntax-float)(n))[promote](#op-promote)M,N​(z)​\=\=\=​[nans](#aux-nans)N​{}[nans](#aux-nans)N​{+[nan](#syntax-float)(1)}z​(ifn\=[canon](#aux-canon)N​)(otherwise)​​

##### 4.3.4.9. [demote](#op-demote)M,N​(z)[](#-hrefop-demotemathrmdemote_m-n-z)

*   If z is a [canonical NaN](#canonical-nan), then return an element of [nans](#aux-nans)N​{} (i.e., a canonical NaN of size N).
    
*   Else if z is a NaN, then return an element of [nans](#aux-nans)N​{±[nan](#syntax-float)(1)} (i.e., any NaN of size N).
    
*   Else if z is an infinity, then return that infinity.
    
*   Else if z is a zero, then return that zero.
    
*   Else, return [float](#aux-ieee)N​(z).
    

[demote](#op-demote)M,N​(±[nan](#syntax-float)(n))[demote](#op-demote)M,N​(±[nan](#syntax-float)(n))[demote](#op-demote)M,N​(±∞)[demote](#op-demote)M,N​(±0)[demote](#op-demote)M,N​(±q)​\=\=\=\=\=​[nans](#aux-nans)N​{}[nans](#aux-nans)N​{+[nan](#syntax-float)(1)}±∞±0[float](#aux-ieee)N​(±q)​(ifn\=[canon](#aux-canon)N​)(otherwise)​

##### 4.3.4.10. [convertu](#op-convert)M,N​(i)[](#-hrefop-convertmathrmconvertmathsfu_m-n-i)

*   Return [float](#aux-ieee)N​(i).
    

[convertu](#op-convert)M,N​(i)​\=​[float](#aux-ieee)N​(i)​​

##### 4.3.4.11. [converts](#op-convert)M,N​(i)[](#-hrefop-convertmathrmconvertmathsfs_m-n-i)

*   Let j be the [signed interpretation](#aux-signed) of i.
    
*   Return [float](#aux-ieee)N​(j).
    

[converts](#op-convert)M,N​(i)​\=​[float](#aux-ieee)N​([signed](#aux-signed)M​(i))​​

##### 4.3.4.12. [reinterpret](#op-reinterpret)t1​,t2​​(c)[](#-hrefop-reinterpretmathrmreinterpret_t_1-t_2-c)

*   Let d∗ be the bit sequence [bits](#aux-bits)t1​​(c).
    
*   Return the constant c′ for which [bits](#aux-bits)t2​​(c′)\=d∗.
    

[reinterpret](#op-reinterpret)t1​,t2​​(c)​\=​[bits](#aux-bits)t2​−1​([bits](#aux-bits)t1​​(c))​​

##### 4.3.4.13. [narrows](#op-narrow)M,N​(i)[](#-hrefop-narrowmathrmnarrowmathsfs_m-n-i)

*   Let j be the [signed interpretation](#aux-signed) of i of size M.
    
*   Return the value whose signed interpretation is [sat\_s](#aux-sat)N​(j).
    

[narrows](#op-narrow)M,N​(i)​\=​[signed](#aux-signed)N−1​([sat\_s](#aux-sat)N​([signed](#aux-signed)M​(i)))​

##### 4.3.4.14. [narrowu](#op-narrow)M,N​(i)[](#-hrefop-narrowmathrmnarrowmathsfu_m-n-i)

*   Let j be the [signed interpretation](#aux-signed) of i of size M.
    
*   Return [sat\_u](#aux-sat)N​(j).
    

[narrowu](#op-narrow)M,N​(i)​\=​[sat\_u](#aux-sat)N​([signed](#aux-signed)M​(i))​

#### 4.3.5. Vector Operations[](#vector-operations①)

Most vector operations are performed by applying numeric operations lanewise. However, some operators consider multiple lanes at once.

##### 4.3.5.1. [ivbitmask](#op-ivbitmask)N​(im)[](#-hrefop-ivbitmaskmathrmivbitmask_n-im)

1.  For each ik​ in im, let bk​ be the result of computing [ilt\_s](#op-ilt)N​(i,0).
    
2.  Let bm be the concatenation of all bk​.
    
3.  Return the result of computing [ibits](#aux-ibits)32−1​((0)32−m bm).
    

[ivbitmask](#op-ivbitmask)N​(im)​\=​[ibits](#aux-ibits)32−1​((0)32−m [ilt\_s](#op-ilt)N​(i,0)m)​

##### 4.3.5.2. [ivswizzle](#op-ivswizzle)(in,jn)[](#-hrefop-ivswizzlemathrmivswizzle-in-jn)

1.  For each jk​ in jn, let rk​ be the value [ivswizzle\_lane](#op-ivswizzle-lane)(in,jk​).
    
2.  Let rn be the concatenation of all rk​.
    
3.  Return rn.
    

[ivswizzle](#op-ivswizzle)(in,jn)​\=​[ivswizzle\_lane](#op-ivswizzle-lane)(in,j)n​​

where:

[ivswizzle\_lane](#op-ivswizzle-lane)(in,j)[ivswizzle\_lane](#op-ivswizzle-lane)(in,j)​\=\=​in\[j\]0​(ifj<n)(otherwise)​​

##### 4.3.5.3. [ivshuffle](#op-ivshuffle)(jn,i1n​,i2n​)[](#-hrefop-ivshufflemathrmivshuffle-jn-i_1n-i_2n)

1.  Let i∗ ne the concatenation of i1n​ and i2n​.
    
2.  For each jk​ in jn, let rk​ be i∗\[jk​\].
    
3.  Let rn be the concatenation of all rk​.
    
4.  Return rn.
    

[ivshuffle](#op-ivshuffle)(jn,i1n​,i2n​)​\=​((i1n​ i2n​)\[j\])n​(if(j<2⋅n)n)​

##### 4.3.5.4. [ivadd\_pairwise](#op-ivadd-pairwise)N​(i2m)[](#-hrefop-ivadd-pairwisemathrmivadd_pairwise_n-i2m)

1.  Let (i1​ i2​)m be i2m, decomposed into pairwise elements.
    
2.  For each i1k​ in i1m​ and corresponding i2k​ in i2m​, let rk​ be [iadd](#op-iadd)N​(i1k​,i2k​).
    
3.  Let rm be the concatenation of all rk​.
    
4.  Return rm.
    

[ivadd\_pairwise](#op-ivadd-pairwise)N​(i2m)​\=​([iadd](#op-iadd)N​(i1​,i2​))m​(ifi2m\=(i1​ i2​)m)​

##### 4.3.5.5. [ivmul](#op-ivmul)N​(i1m​,i2m​)[](#-hrefop-ivmulmathrmivmul_n-i_1m-i_2m)

1.  For each i1k​ in i1m​ and corresponding i2k​ in i2m​, let rk​ be [imul](#op-imul)N​(i1k​,i2k​).
    
2.  Let rm be the concatenation of all rk​.
    
3.  Return rm.
    

[ivmul](#op-ivmul)N​(i1m​,i2m​)​\=​([imul](#op-imul)N​(i1​,i2​))m​

##### 4.3.5.6. [ivdot](#op-ivdot)N​(i12m​,i22m​)[](#-hrefop-ivdotmathrmivdot_n-i_12m-i_22m)

1.  For each i1k​ in i12m​ and corresponding i2k​ in i22m​, let jk​ be [imul](#op-imul)N​(i1k​,i2k​).
    
2.  Let j2m be the concatenation of all jk​.
    
3.  Let (j1​ j2​)m be j2m, decomposed into pairwise elements.
    
4.  For each i1k​ in i1m​ and corresponding i2k​ in i2m​, let rk​ be [iadd](#op-iadd)N​(i1k​,i2k​).
    
5.  Let rm be the concatenation of all rk​.
    
6.  Return rm.
    

[ivdot](#op-ivdot)N​(i12m​,i22m​)​\=​([iadd](#op-iadd)N​(j1​,j2​))m​(if([imul](#op-imul)N​(i1​,i2​))2m\=(j1​ j2​)m)​

##### 4.3.5.7. [ivdotsat](#op-ivdot-sat)N​(i1m​,i2m​)[](#-hrefop-ivdot-satmathrmivdotsat_n-i_1m-i_2m)

1.  For each i1k​ in i12m​ and corresponding i2k​ in i22m​, let jk​ be [imul](#op-imul)N​(i1k​,i2k​).
    
2.  Let j2m be the concatenation of all jk​.
    
3.  Let (j1​ j2​)m be j2m, decomposed into pairwise elements.
    
4.  For each i1k​ in i1m​ and corresponding i2k​ in i2m​, let rk​ be [iadd\_sat](#op-iadd-sat)N​(i1k​,i2k​).
    
5.  Let rm be the concatenation of all rk​.
    
6.  Return rm.
    

[ivdotsat](#op-ivdot-sat)N​(i12m​,i22m​)​\=​([iadd\_sat](#op-iadd-sat)N​(j1​,j2​))m​(if([imul](#op-imul)N​(i1​,i2​))2m\=(j1​ j2​)m)​

The previous operators are lifted to operators on arguments of vector type by wrapping them in corresponding lane projections and injections and intermediate extension operations:

##### 4.3.5.8. [vextunop](#syntax-vextunop)sh1​,sh2​​(c)[](#-hrefsyntax-vextunopmathitvextunop_mathitsh_1-mathitsh_2-c)

[extadd\_pairwise](#syntax-instr-vec)\_[sx](#syntax-sx)iN1​xM1​,iN2​xM2​​(c)​\=​[lanes](#aux-lanes)iN2​xM2​−1​(j∗)​(ifi∗\=[lanes](#aux-lanes)iN1​xM1​​(c)∧ i′∗\=[extend](#op-extend)N1​,N2​[sx](#syntax-sx)​(i)∗∧ j∗\=[ivadd\_pairwise](#op-ivadd-pairwise)N2​​(i′∗)​​​

##### 4.3.5.9. [vextbinop](#syntax-vextbinop)sh1​,sh2​​(c1​,c2​)[](#-hrefsyntax-vextbinopmathitvextbinop_mathitsh_1-mathitsh_2-c_1-c_2)

[vextbinop](#syntax-vextbinop)iN1​xM1​,iN2​xM2​​(c1​,c2​)​\=​[lanes](#aux-lanes)iN2​xM2​−1​(j∗)​(ifi1∗​\=[lanes](#aux-lanes)iN1​xM1​​(c1​)\[h[:](#notation-slice)k\]∧ i2∗​\=[lanes](#aux-lanes)iN1​xM1​​(c2​)\[h[:](#notation-slice)k\]∧ i1′​∗\=[extend](#op-extend)N1​,N2​[sx](#syntax-sx)​(i1​)∗∧ i2′​∗\=[extend](#op-extend)N1​,N2​[sx](#syntax-sx)​(i2​)∗∧ j∗\=fN2​​(i1′​∗,i1′​∗)​​​

where f, [sx](#syntax-sx)1​, [sx](#syntax-sx)2​, h, and k are instantiated as follows, depending on the operator:

[vextbinop](#syntax-vextbinop)[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[sx](#syntax-sx)[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[sx](#syntax-sx)[dot](#syntax-instr-vec)\_[s](#syntax-sx)[relaxed\_dot](#syntax-instr-vec)\_[s](#syntax-sx)​f[ivmul](#op-ivmul)[ivmul](#op-ivmul)[ivdot](#op-ivdot)[ivdotsat](#op-ivdot-sat)​[sx](#syntax-sx)1​[sx](#syntax-sx)[sx](#syntax-sx)[s](#syntax-sx)[s](#syntax-sx)​[sx](#syntax-sx)2​[sx](#syntax-sx)[sx](#syntax-sx)[s](#syntax-sx)[relaxed](#aux-relaxed)(Ridot​)\[[s](#syntax-sx),[u](#syntax-sx)\]​h0M2​00​kM2​M2​M1​M1​​​​

Note

Relaxed operations and the paramater Ridot​ are introduced [below](#relaxed-ops).

##### 4.3.5.10. [vextternop](#syntax-vextternop)sh1​,sh2​​(c1​,c2​,c3​)[](#-hrefsyntax-vextternopmathitvextternop_mathitsh_1-mathitsh_2-c_1-c_2-c_3)

[relaxed\_dot\_add](#syntax-instr-vec)\_[s](#syntax-sx)iN1​xM1​,iN2​xM2​​(c1​,c2​,c3​)​\=​c​(ifN\=2⋅N1​∧ M\=2⋅M2​∧ c′\=[relaxed\_dot](#syntax-instr-vec)\_[s](#syntax-sx)iN1​xM1​,iNxM​(c1​,c2​)∧ c′′\=[extadd\_pairwise](#syntax-instr-vec)\_[s](#syntax-sx)iNxM,iN2​xM2​​(c′)∧ c∈[add](#syntax-instr-vec)iN2​xM2​​(c′′,c3​)​​​

##### 4.3.5.11. [narrow](#syntax-instr-vec)\_[sx](#syntax-sx)sh1​,sh2​​(c1​,c2​)[](#-hrefsyntax-instr-vecmathsfnarrowmathsf_hrefsyntax-sxmathitsx_mathitsh_1-mathitsh_2-c_1-c_2)

[narrow](#syntax-instr-vec)\_[sx](#syntax-sx)iN1​xM1​,iN2​xM2​​(c1​,c2​)​\=​[lanes](#aux-lanes)iN2​xM2​−1​(j∗)​(ifi1∗​\=[lanes](#aux-lanes)iN1​xM1​​(c1​)∧ i2∗​\=[lanes](#aux-lanes)iN1​xM1​​(c2​)∧ i1′​∗\=[narrow](#op-narrow)N1​,N2​[sx](#syntax-sx)​(i1​)∗∧ i2′​∗\=[narrow](#op-narrow)N1​,N2​[sx](#syntax-sx)​(i2​)∗∧ j∗\=i1′​∗⊕i1′​∗​​​

##### 4.3.5.12. [vcvtop](#syntax-vcvtop)\_[half](#syntax-half)?\_[zero](#syntax-zero)sh1​,sh2​?​(i)[](#-hrefsyntax-vcvtopmathitvcvtopmathsf_hrefsyntax-halfmathithalfmathsf_hrefsyntax-zeromathitzero_mathitsh_1-mathitsh_2-i)

[vcvtop](#syntax-vcvtop)\_[half](#syntax-half)?\_[zero](#syntax-zero)t1​xM1​,t2​xM2​?​(i)​\=​j​(ifcondition∧ c∗\=[lanes](#aux-lanes)t1​xM1​​(i)\[h[:](#notation-slice)k\]∧ c′∗∗\=×([vcvtop](#syntax-vcvtop)∣t1​∣,∣t2​∣​(c)∗⊕(0)n)∧ j∈[lanes](#aux-lanes)t2​xM2​−1​(c′∗)∗​​​

where h, k, n, and condition are instantiated as follows, depending on the operator:

[half](#syntax-half)?ϵ[low](#syntax-instr-vec)[high](#syntax-instr-vec)ϵ​[zero](#syntax-zero)?ϵϵϵ[zero](#syntax-instr-vec)​h00M2​0​kM1​M2​M2​M1​​n000M1​​condition(M1​\=M2​)(M1​\=2⋅M2​)(M1​\=2⋅M2​)(2⋅M1​\=M2​)​​​

while ×{x∗}N transforms a sequence of N sets of non-deterministic values into a set of non-deterministic sequences of N values by computing the set product:

×(S1​…SN​)​\=​{x1​…xN​ ∣ x1​∈S1​∧⋯∧xN​∈SN​}​

#### 4.3.6. Relaxed Operations[](#relaxed-operations①)

The result of _relaxed_ operators are _implementation-dependent_, because the set of possible results may depend on properties of the host environment, such as its hardware. Technically, their behaviour is controlled by a set of _global parameters_ to the semantics that an implementation can instantiate in different ways. These choices are fixed, that is, parameters are constant during the execution of any given program.

Every such parameter is an index into a sequence of possible sets of results and must be instantiated to a defined index. In the [deterministic profile](#profile-deterministic), every parameter is prescribed to be 0. This behaviour is expressed by the following auxiliary function, where R is a global parameter selecting one of the allowed outcomes:

\[![DET](#profile-deterministic)\]​[relaxed](#aux-relaxed)(R)\[A0​,…,An​\]\=AR​[relaxed](#aux-relaxed)(R)\[A0​,…,An​\]\=A0​​​

Note

Each parameter can be thought of as inducing a family of operations that is fixed to one particular choice by an implementation. The fixed operation itself can still be non-deterministic or partial.

Implementations are expexted to either choose the behaviour that is the most efficient on the underlying hardware, or the behaviour of the deterministic profile.

##### 4.3.6.1. [frelaxed\_madd](#op-frelaxed-madd)N​(z1​,z2​,z3​)[](#-hrefop-frelaxed-maddmathrmfrelaxed_madd_n-z_1-z_2-z_3)

The implementation-specific behaviour of this operation is determined by the global parameter Rfmadd​∈{0,1}.

*   Return [relaxed](#aux-relaxed)(Rfmadd​)\[[fadd](#op-fadd)N​([fmul](#op-fmul)N​(z1​,z2​),z3​),[fma](#op-fma)N​(z1​,z2​,z3​)\].
    

[frelaxed\_madd](#op-frelaxed-madd)N​(z1​,z2​,z3​)​\=​[relaxed](#aux-relaxed)(Rfmadd​)\[[fadd](#op-fadd)N​([fmul](#op-fmul)N​(z1​,z2​),z3​),[fma](#op-fma)N​(z1​,z2​,z3​)\]​​

Note

Relaxed multiply-add allows for fused or unfused results, which leads to implementation-dependent rounding behaviour. In the [deterministic profile](#profile-deterministic), the unfused behaviour is used.

##### 4.3.6.2. [frelaxed\_nmadd](#op-frelaxed-nmadd)N​(z1​,z2​,z3​)[](#-hrefop-frelaxed-nmaddmathrmfrelaxed_nmadd_n-z_1-z_2-z_3)

*   Return [frelaxed\_madd](#op-frelaxed-madd)(−z1​,z2​,z3​).
    

[frelaxed\_nmadd](#op-frelaxed-nmadd)N​(z1​,z2​,z3​)​\=​[frelaxed\_madd](#op-frelaxed-madd)N​(−z1​,z2​,z3​)​​

Note

This operation is implementation-dependent because [frelaxed\_madd](#op-frelaxed-madd) is implementation-dependent.

##### 4.3.6.3. [frelaxed\_min](#op-frelaxed-min)N​(z1​,z2​)[](#-hrefop-frelaxed-minmathrmfrelaxed_min_n-z_1-z_2)

The implementation-specific behaviour of this operation is determined by the global parameter Rfmin​∈{0,1,2,3}.

*   If z1​ is a NaN, then return [relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(z1​,z2​),[nan](#syntax-float)(n),z2​,z2​\].
    
*   If z2​ is a NaN, then return [relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(z1​,z2​),z1​,[nan](#syntax-float)(n),z1​\].
    
*   If both z1​ and z2​ are zeroes of opposite sign, then return [relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(z1​,z2​), pm 0, mp 0, -0 \]\`.
    
*   Return [fmin](#op-fmin)N​(z1​,z2​).
    

[frelaxed\_min](#op-frelaxed-min)N​(±[nan](#syntax-float)(n),z2​)[frelaxed\_min](#op-frelaxed-min)N​(z1​,±[nan](#syntax-float)(n))[frelaxed\_min](#op-frelaxed-min)N​(±0,∓0)[frelaxed\_min](#op-frelaxed-min)N​(z1​,z2​)​\=\=\=\=​[relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(±[nan](#syntax-float)(n),z2​),[nan](#syntax-float)(n),z2​,z2​\][relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(z1​,±[nan](#syntax-float)(n)),z1​,[nan](#syntax-float)(n),z1​\][relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(±0,∓0),±0,∓0,−0\][fmin](#op-fmin)N​(z1​,z2​)​(otherwise)​​

Note

Relaxed minimum is implementation-dependent for NaNs and for zeroes with different signs. In the [deterministic profile](#profile-deterministic), it behaves like regular [fmin](#op-fmin).

##### 4.3.6.4. [frelaxed\_max](#op-frelaxed-max)N​(z1​,z2​)[](#-hrefop-frelaxed-maxmathrmfrelaxed_max_n-z_1-z_2)

The implementation-specific behaviour of this operation is determined by the global parameter Rfmax​∈{0,1,2,3}.

*   If z1​ is a NaN, then return [relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(z1​,z2​),[nan](#syntax-float)(n),z2​,z2​\].
    
*   If z2​ is a NaN, then return [relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(z1​,z2​),z1​,[nan](#syntax-float)(n),z1​\].
    
*   If both z1​ and z2​ are zeroes of opposite sign, then return [relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(z1​,z2​), pm 0, mp 0, +0 \]\`.
    
*   Return [fmax](#op-fmax)N​(z1​,z2​).
    

[frelaxed\_max](#op-frelaxed-max)N​(±[nan](#syntax-float)(n),z2​)[frelaxed\_max](#op-frelaxed-max)N​(z1​,±[nan](#syntax-float)(n))[frelaxed\_max](#op-frelaxed-max)N​(±0,∓0)[frelaxed\_max](#op-frelaxed-max)N​(z1​,z2​)​\=\=\=\=​[relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(±[nan](#syntax-float)(n),z2​),[nan](#syntax-float)(n),z2​,z2​\][relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(z1​,±[nan](#syntax-float)(n)),z1​,[nan](#syntax-float)(n),z1​\][relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(±0,∓0),±0,∓0,+0\][fmax](#op-fmax)N​(z1​,z2​)​(otherwise)​​

Note

Relaxed maximum is implementation-dependent for NaNs and for zeroes with different signs. In the [deterministic profile](#profile-deterministic), it behaves like regular [fmax](#op-fmax).

##### 4.3.6.5. [irelaxed\_q15mulr\_s](#op-irelaxed-q15mulr-s)N​(i1​,i2​)[](#-hrefop-irelaxed-q15mulr-smathrmirelaxed_q15mulr_s_n-i_1-i_2)

The implementation-specific behaviour of this operation is determined by the global parameter Riq15mulr​∈{0,1}.

*   If both i1​ and i2​ equal ([signed](#aux-signed)N−1​(−2N−1), then return [relaxed](#aux-relaxed)(Riq15mulr​)\[2N−1−1,[signed](#aux-signed)N−1​(−2N−1)\].
    
*   Return [iq15mulrsat\_s](#op-iq15mulrsat)(i1​,i2​)
    

[irelaxed\_q15mulr\_s](#op-irelaxed-q15mulr-s)N​([signed](#aux-signed)N−1​(−2N−1),[signed](#aux-signed)N−1​(−2N−1))[irelaxed\_q15mulr\_s](#op-irelaxed-q15mulr-s)N​(i1​,i2​)​\=\=​[relaxed](#aux-relaxed)(Riq15mulr​)\[2N−1−1,[signed](#aux-signed)N−1​(−2N−1)\][iq15mulrsat\_s](#op-iq15mulrsat)(i1​,i2​)​​

Note

Relaxed Q15 multiplication is implementation-dependent when the result overflows. In the [deterministic profile](#profile-deterministic), it behaves like regular [iq15mulrsat\_s](#op-iq15mulrsat).

##### 4.3.6.6. [relaxed\_trunc](#op-relaxed-trunc)M,Nu​(z)[](#-hrefop-relaxed-truncmathrmrelaxed_truncu_m-n-z)

The implementation-specific behaviour of this operation is determined by the global parameter Rtrunc\_u​∈{0,1}.

*   If z is normal or subnormal and [trunc](#op-trunc)(z) is non-negative and less than 2N, then return [truncu](#op-trunc)M,N​(z).
    
*   Else, return [relaxed](#aux-relaxed)(Rtrunc\_u​)\[[trunc\_sat\_u](#op-trunc-sat)M,N​(z),R\].
    

[relaxed\_trunc](#op-relaxed-trunc)M,Nu​(±q)[relaxed\_trunc](#op-relaxed-trunc)M,Nu​(z)​\=\=​[truncu](#op-trunc)M,N​(±q)[relaxed](#aux-relaxed)(Rtrunc\_u​)\[[trunc\_sat\_u](#op-trunc-sat)M,N​(z),R\]​(if0≤[trunc](#op-trunc)(±q)<2N)(otherwise)​​

Note

Relaxed unsigned truncation is non-deterministic for NaNs and out-of-range values. In the [deterministic profile](#profile-deterministic), it behaves like regular [trunc\_sat\_u](#op-trunc-sat).

##### 4.3.6.7. [relaxed\_trunc](#op-relaxed-trunc)M,Ns​(z)[](#-hrefop-relaxed-truncmathrmrelaxed_truncs_m-n-z)

The implementation-specific behaviour of this operation is determined by the global parameter Rtrunc\_s​∈{0,1}.

*   If z is normal or subnormal and [trunc](#op-trunc)(z) is greater than or equal to −2N−1 and less than 2N−1, then return [truncs](#op-trunc)M,N​(z).
    
*   Else, return [relaxed](#aux-relaxed)(Rtrunc\_s​)\[[trunc\_sat\_s](#op-trunc-sat)M,N​(z),R\].
    

[relaxed\_trunc](#op-relaxed-trunc)M,Ns​(±q)[relaxed\_trunc](#op-relaxed-trunc)M,Ns​(z)​\=\=​[truncs](#op-trunc)M,N​(±q)[relaxed](#aux-relaxed)(Rtrunc\_s​)\[[trunc\_sat\_s](#op-trunc-sat)M,N​(z),R\]​(if−2N−1≤[trunc](#op-trunc)(±q)<2N−1)(otherwise)​​

Note

Relaxed signed truncation is non-deterministic for NaNs and out-of-range values. In the [deterministic profile](#profile-deterministic), it behaves like regular [trunc\_sat\_s](#op-trunc-sat).

##### 4.3.6.8. [ivrelaxed\_swizzle](#op-ivrelaxed-swizzle)(in,jn)[](#-hrefop-ivrelaxed-swizzlemathrmivrelaxed_swizzle-in-jn)

The implementation-specific behaviour of this operation is determined by the global parameter Rswizzle​∈{0,1}.

*   For each jk​ in jn, let rk​ be the value [ivrelaxed\_swizzle\_lane](#op-ivrelaxed-swizzle-lane)(in,jk​).
    
*   Let rn be the concatenation of all rk​.
    
*   Return rn.
    

[ivrelaxed\_swizzle](#op-ivrelaxed-swizzle)(in,jn)​\=​[ivrelaxed\_swizzle\_lane](#op-ivrelaxed-swizzle-lane)(in,j)n​​

where:

[ivrelaxed\_swizzle\_lane](#op-ivrelaxed-swizzle-lane)(in,j)[ivrelaxed\_swizzle\_lane](#op-ivrelaxed-swizzle-lane)(in,j)[ivrelaxed\_swizzle\_lane](#op-ivrelaxed-swizzle-lane)(in,j)​\=\=\=​i\[j\]0[relaxed](#aux-relaxed)(Rswizzle​)\[0,in\[jmodn\]\]​(ifj<16)(if[signed](#aux-signed)8​(j)<0)(otherwise)​​

Note

Relaxed swizzle is implementation-dependent if the signed interpretation of any of the 8-bit indices in jn is larger than or equal to 16. In the [deterministic profile](#profile-deterministic), it behaves like regular [ivswizzle](#op-ivswizzle).

##### 4.3.6.9. [relaxed\_dot](#syntax-instr-vec)(i1​,i2​)[](#-hrefsyntax-instr-vecmathsfrelaxed_dot-i_1-i_2)

The implementation-specific behaviour of this operation is determined by the global parameter Ridot​∈{0,1}. It also affects the behaviour of [relaxed\_dot\_add](#syntax-instr-vec).

Its definition is part of the definition of [vextbinop](#syntax-vextbinop) specified [above](#op-vextbinop).

Note

Relaxed dot product is implementation-dependent when the second operand is negative in a signed intepretation. In the [deterministic profile](#profile-deterministic), it behaves like signed dot product.

##### 4.3.6.10. [irelaxed\_laneselect](#op-irelaxed-laneselect)N​(i1​,i2​,i3​)[](#-hrefop-irelaxed-laneselectmathrmirelaxed_laneselect_n-i_1-i_2-i_3)

The implementation-specific behaviour of this operation is determined by the global parameter Rlaneselect​∈{0,1}.

*   If i3​ is smaller than 2N−1, then let i3′​ be the value 0, otherwise 2N−1.
    
*   Let i3′′​ be [relaxed](#aux-relaxed)(Rlaneselect​)\[i3​,i3′​\].
    
*   Return [ibitselect](#op-ibitselect)N​(i1​,i2​,i3′′​).
    

[irelaxed\_laneselect](#op-irelaxed-laneselect)N​(i1​,i2​,i3​)​\=​[ibitselect](#op-ibitselect)N​(i1​,i2​,[relaxed](#aux-relaxed)(Rlaneselect​)\[i3​,[extends](#op-extend)1,N​([ishr\_u](#op-ishr)N​(i3​,N−1))\])​​

Note

Relaxed lane selection is non-deterministic when the mask mixes set and cleared bits, since the value of the high bit may or may not be expanded to all bits. In the [deterministic profile](#profile-deterministic), it behaves like [ibitselect](#op-ibitselect).

### 4.4. Types[](#types①①)

Execution has to check and compare [types](#syntax-type) in a few places, such as [executing](#exec-call-indirect) call\_indirect or [instantiating](#exec-instantiation) [modules](#syntax-module).

It is an invariant of the semantics that all types occurring during execution are [closed](#type-closed).

Note

Runtime type checks generally involve types from multiple modules or types not defined by a module at all, such that any module-local [type indices](#syntax-typeidx) occurring inside them would not generally be meaningful.

#### 4.4.1. Instantiation[](#instantiation②)

Any form of [type](#syntax-type) can be _instantiated_ into a [closed](#type-closed) type inside a [module instance](#syntax-moduleinst) by [substituting](#notation-subst) each [type index](#syntax-typeidx) x occurring in it with the corresponding [defined type](#syntax-deftype) [moduleinst](#syntax-moduleinst).[types](#syntax-moduleinst)\[x\].

[clos](#type-inst)[moduleinst](#syntax-moduleinst)​(t)​\=​t\[[:=](#notation-subst)dt∗\]​if dt∗\=[moduleinst](#syntax-moduleinst).[types](#syntax-moduleinst)​​

Note

This is the runtime equivalent to [type closure](#type-closure), which is applied at validation time.

### 4.5. Values[](#values⑥)

#### 4.5.1. Value Typing[](#value-typing①)

For the purpose of checking argument [values](#syntax-val) against the parameter types of exported [functions](#syntax-func), values are classified by [value types](#syntax-valtype). The following auxiliary typing rules specify this typing relation relative to a [store](#syntax-store) S in which possibly referenced [addresses](#syntax-addr) live.

##### 4.5.1.1. Numeric Values[](#numeric-values①)

The [number value](#syntax-num) (nt.[const](#syntax-instr-numeric) c) is [valid](#valid-num) with the [number type](#syntax-numtype) nt.

s[⊢](#valid-num)nt.[const](#syntax-instr-numeric) c:nt​​

##### 4.5.1.2. Vector Values[](#vector-values①)

The [vector value](#syntax-vec) (vt.[const](#syntax-instr-vec) c) is [valid](#valid-vec) with the [vector type](#syntax-vectype) vt.

s[⊢](#valid-vec)vt.[const](#syntax-instr-vec) c:vt​​

##### 4.5.1.3. Null References[](#null-references①)

The [reference value](#syntax-ref) ([ref.null](#syntax-instr-ref) ht) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype) ht′) if:

> *   The [heap type](#syntax-heaptype) ht′ [matches](#match-heaptype) the [heap type](#syntax-heaptype) ht.
>     

s[⊢](#valid-ref)[ref.null](#syntax-instr-ref) ht:([ref](#syntax-reftype) [null](#syntax-reftype) ht′){}[⊢](#match-heaptype)ht′[≤](#match-heaptype)ht​​

Note

A null reference can be typed with any smaller type. In particular, that allows it to be typed with the least type in its respective hierarchy. That ensures that the value is compatible with any nullable type in that hierarchy.

##### 4.5.1.4. Scalar References[](#scalar-references①)

The [reference value](#syntax-ref) ([ref.i31](#syntax-ref) i) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [i31](#syntax-heaptype)).

s[⊢](#valid-ref)[ref.i31](#syntax-ref) i:([ref](#syntax-reftype) [i31](#syntax-heaptype))​​

##### 4.5.1.5. Structure References[](#structure-references①)

The [reference value](#syntax-ref) ([ref.struct](#syntax-ref) a) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) dt) if:

> *   The [structure instance](#syntax-structinst) s.[structs](#syntax-store)\[a\] exists.
>     
> *   The [defined type](#syntax-deftype) s.[structs](#syntax-store)\[a\].[type](#syntax-structinst) is of the form dt.
>     

s[⊢](#valid-ref)[ref.struct](#syntax-ref) a:([ref](#syntax-reftype) dt)s.[structs](#syntax-store)\[a\].[type](#syntax-structinst)\=dt​​

##### 4.5.1.6. Array References[](#array-references①)

The [reference value](#syntax-ref) ([ref.array](#syntax-ref) a) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) dt) if:

> *   The [array instance](#syntax-arrayinst) s.[arrays](#syntax-store)\[a\] exists.
>     
> *   The [defined type](#syntax-deftype) s.[arrays](#syntax-store)\[a\].[type](#syntax-arrayinst) is of the form dt.
>     

s[⊢](#valid-ref)[ref.array](#syntax-ref) a:([ref](#syntax-reftype) dt)s.[arrays](#syntax-store)\[a\].[type](#syntax-arrayinst)\=dt​​

##### 4.5.1.7. Exception References[](#exception-references①)

The [reference value](#syntax-ref) ([ref.exn](#syntax-ref) a) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [exn](#syntax-heaptype)) if:

> *   The [exception instance](#syntax-exninst) s.[exns](#syntax-store)\[a\] exists.
>     

s[⊢](#valid-ref)[ref.exn](#syntax-ref) a:([ref](#syntax-reftype) [exn](#syntax-heaptype))s.[exns](#syntax-store)\[a\]\=exn​​

##### 4.5.1.8. Function References[](#function-references①)

The [reference value](#syntax-ref) ([ref.func](#syntax-ref) a) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) dt) if:

> *   The [function instance](#syntax-funcinst) s.[funcs](#syntax-store)\[a\] exists.
>     
> *   The [defined type](#syntax-deftype) s.[funcs](#syntax-store)\[a\].[type](#syntax-funcinst) is of the form dt.
>     

s[⊢](#valid-ref)[ref.func](#syntax-ref) a:([ref](#syntax-reftype) dt)s.[funcs](#syntax-store)\[a\].[type](#syntax-funcinst)\=dt​​

##### 4.5.1.9. Host References[](#host-references①)

The [reference value](#syntax-ref) ([ref.host](#syntax-ref) a) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [any](#syntax-heaptype)).

s[⊢](#valid-ref)[ref.host](#syntax-ref) a:([ref](#syntax-reftype) [any](#syntax-heaptype))​​

Note

A bare host reference is considered internalized.

##### 4.5.1.10. External References[](#external-references①)

The [reference value](#syntax-ref) ([ref.extern](#syntax-ref) [addrref](#syntax-addrref)) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [extern](#syntax-heaptype)) if:

> *   The [reference value](#syntax-ref) [addrref](#syntax-addrref) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [any](#syntax-heaptype)).
>     

s[⊢](#valid-ref)[ref.extern](#syntax-ref) [addrref](#syntax-addrref):([ref](#syntax-reftype) [extern](#syntax-heaptype))s[⊢](#valid-ref)[addrref](#syntax-addrref):([ref](#syntax-reftype) [any](#syntax-heaptype))​​

##### 4.5.1.11. Subsumption[](#subsumption①)

The [reference value](#syntax-ref) [ref](#syntax-ref) is [valid](#valid-ref) with the [reference type](#syntax-reftype) rt if:

> *   The [reference value](#syntax-ref) [ref](#syntax-ref) is [valid](#valid-ref) with the [reference type](#syntax-reftype) rt′.
>     
> *   The [reference type](#syntax-reftype) rt′ [matches](#match-reftype) the [reference type](#syntax-reftype) rt.
>     

s[⊢](#valid-ref)[ref](#syntax-ref):rts[⊢](#valid-ref)[ref](#syntax-ref):rt′{}[⊢](#match-reftype)rt′[≤](#match-reftype)rt​​

#### 4.5.2. External Typing[](#external-typing①)

For the purpose of checking [external address](#syntax-externaddr) against [imports](#syntax-import), such values are classified by [external types](#syntax-externtype). The following auxiliary typing rules specify this typing relation relative to a [store](#syntax-store) S in which the referenced instances live.

##### 4.5.2.1. Functions[](#functions⑤)

The [external address](#syntax-externaddr) ([func](#syntax-externaddr) a) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) ([func](#syntax-externtype) [funcinst](#syntax-funcinst).[type](#syntax-funcinst)) if:

> *   The [function instance](#syntax-funcinst) s.[funcs](#syntax-store)\[a\] exists.
>     
> *   The [function instance](#syntax-funcinst) s.[funcs](#syntax-store)\[a\] is of the form [funcinst](#syntax-funcinst).
>     

s[⊢](#valid-externaddr)[func](#syntax-externaddr) a:[func](#syntax-externtype) [funcinst](#syntax-funcinst).[type](#syntax-funcinst)s.[funcs](#syntax-store)\[a\]\=[funcinst](#syntax-funcinst)​​

##### 4.5.2.2. Tables[](#tables⑤)

The [external address](#syntax-externaddr) ([table](#syntax-externaddr) a) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) ([table](#syntax-externtype) [tableinst](#syntax-tableinst).[type](#syntax-tableinst)) if:

> *   The [table instance](#syntax-tableinst) s.[tables](#syntax-store)\[a\] exists.
>     
> *   The [table instance](#syntax-tableinst) s.[tables](#syntax-store)\[a\] is of the form [tableinst](#syntax-tableinst).
>     

s[⊢](#valid-externaddr)[table](#syntax-externaddr) a:[table](#syntax-externtype) [tableinst](#syntax-tableinst).[type](#syntax-tableinst)s.[tables](#syntax-store)\[a\]\=[tableinst](#syntax-tableinst)​​

##### 4.5.2.3. Memories[](#memories⑤)

The [external address](#syntax-externaddr) ([mem](#syntax-externaddr) a) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) ([mem](#syntax-externtype) [meminst](#syntax-meminst).[type](#syntax-meminst)) if:

> *   The [memory instance](#syntax-meminst) s.[mems](#syntax-store)\[a\] exists.
>     
> *   The [memory instance](#syntax-meminst) s.[mems](#syntax-store)\[a\] is of the form [meminst](#syntax-meminst).
>     

s[⊢](#valid-externaddr)[mem](#syntax-externaddr) a:[mem](#syntax-externtype) [meminst](#syntax-meminst).[type](#syntax-meminst)s.[mems](#syntax-store)\[a\]\=[meminst](#syntax-meminst)​​

##### 4.5.2.4. Globals[](#globals⑤)

The [external address](#syntax-externaddr) ([global](#syntax-externaddr) a) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) ([global](#syntax-externtype) [globalinst](#syntax-globalinst).[type](#syntax-globalinst)) if:

> *   The [global instance](#syntax-globalinst) s.[globals](#syntax-store)\[a\] exists.
>     
> *   The [global instance](#syntax-globalinst) s.[globals](#syntax-store)\[a\] is of the form [globalinst](#syntax-globalinst).
>     

s[⊢](#valid-externaddr)[global](#syntax-externaddr) a:[global](#syntax-externtype) [globalinst](#syntax-globalinst).[type](#syntax-globalinst)s.[globals](#syntax-store)\[a\]\=[globalinst](#syntax-globalinst)​​

##### 4.5.2.5. Tags[](#tags⑤)

The [external address](#syntax-externaddr) ([tag](#syntax-externaddr) a) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) ([tag](#syntax-externtype) [taginst](#syntax-taginst).[type](#syntax-taginst)) if:

> *   The [tag instance](#syntax-taginst) s.[tags](#syntax-store)\[a\] exists.
>     
> *   The [tag instance](#syntax-taginst) s.[tags](#syntax-store)\[a\] is of the form [taginst](#syntax-taginst).
>     

s[⊢](#valid-externaddr)[tag](#syntax-externaddr) a:[tag](#syntax-externtype) [taginst](#syntax-taginst).[type](#syntax-taginst)s.[tags](#syntax-store)\[a\]\=[taginst](#syntax-taginst)​​

##### 4.5.2.6. Subsumption[](#subsumption②)

The [external address](#syntax-externaddr) [externaddr](#syntax-externaddr) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) xt if:

> *   The [external address](#syntax-externaddr) [externaddr](#syntax-externaddr) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) xt′.
>     
> *   The [external type](#syntax-externtype) xt′ [matches](#match-externtype) the [external type](#syntax-externtype) xt.
>     

s[⊢](#valid-externaddr)[externaddr](#syntax-externaddr):xts[⊢](#valid-externaddr)[externaddr](#syntax-externaddr):xt′{}[⊢](#match-externtype)xt′[≤](#match-externtype)xt​​

### 4.6. Instructions[](#instructions⑤)

WebAssembly computation is performed by executing individual [instructions](#syntax-instr).

#### 4.6.1. Parametric Instructions[](#parametric-instructions⑤)

##### 4.6.1.1. [nop](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfnop①)

1.  Do nothing.
    

​[nop](#syntax-instr-control)​[↪](#exec-notation)​ϵ​​

##### 4.6.1.2. [unreachable](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfunreachable①)

1.  Trap.
    

​[unreachable](#syntax-instr-control)​[↪](#exec-notation)​[trap](#syntax-trap)​​

##### 4.6.1.3. [drop](#syntax-instr-parametric)[](#-hrefsyntax-instr-parametricmathsfdrop①)

1.  Assert: Due to [validation](#valid-drop), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    

​[val](#syntax-val) [drop](#syntax-instr-parametric)​[↪](#exec-notation)​ϵ​​

##### 4.6.1.4. [select](#syntax-instr-parametric) (t∗)?[](#-hrefsyntax-instr-parametricmathsfselect-tast①)

1.  Assert: Due to [validation](#valid-select), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) from the stack.
    
3.  Assert: Due to [validation](#valid-select), a value is on the top of the stack.
    
4.  Pop the value [val](#syntax-val)2​ from the stack.
    
5.  Assert: Due to [validation](#valid-select), a value is on the top of the stack.
    
6.  Pop the value [val](#syntax-val)1​ from the stack.
    
7.  If c\=0, then:
    
    1.  Push the value [val](#syntax-val)1​ to the stack.
        
8.  Else:
    
    1.  Push the value [val](#syntax-val)2​ to the stack.
        

​[val](#syntax-val)1​ [val](#syntax-val)2​ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([select](#syntax-instr-parametric) (t∗)?)[val](#syntax-val)1​ [val](#syntax-val)2​ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([select](#syntax-instr-parametric) (t∗)?)​[↪](#exec-notation)[↪](#exec-notation)​[val](#syntax-val)1​[val](#syntax-val)2​​if c\=0if c\=0​​

Note

In future versions of WebAssembly, select may allow more than one value per choice.

#### 4.6.2. Control Instructions[](#control-instructions⑤)

##### 4.6.2.1. [block](#syntax-instr-control) bt [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsfblockmathitbthrefsyntax-instrmathitinstrast)

1.  Let z be the current state.
    
2.  Let t1m​ [→](#syntax-instrtype)[localidx](#syntax-localidx)0∗​​t2n​ be the destructuring of [instrtype](#aux-blocktype)z​(bt).
    
3.  Assert: Due to [validation](#valid-block), [localidx](#syntax-localidx)0∗​\=ϵ.
    
4.  Assert: Due to [validation](#valid-block), there are at least m values on the top of the stack.
    
5.  Pop the values [val](#syntax-val)m from the stack.
    
6.  Let L be the [label](#syntax-label) whose arity is n and whose continuation is the end of the block.
    
7.  Enter the block [val](#syntax-val)m [instr](#syntax-instr)∗ with the [label](#syntax-label) L.
    

​z;[val](#syntax-val)m ([block](#syntax-instr-control) bt [instr](#syntax-instr)∗)​[↪](#exec-notation)​([label](#syntax-label)n​{ϵ} [val](#syntax-val)m [instr](#syntax-instr)∗)​if [instrtype](#aux-blocktype)z​(bt)\=t1m​→t2n​​​

##### 4.6.2.2. [loop](#syntax-instr-control) bt [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsfloopmathitbthrefsyntax-instrmathitinstrast)

1.  Let z be the current state.
    
2.  Let t1m​ [→](#syntax-instrtype)[localidx](#syntax-localidx)0∗​​t2n​ be the destructuring of [instrtype](#aux-blocktype)z​(bt).
    
3.  Assert: Due to [validation](#valid-loop), [localidx](#syntax-localidx)0∗​\=ϵ.
    
4.  Assert: Due to [validation](#valid-loop), there are at least m values on the top of the stack.
    
5.  Pop the values [val](#syntax-val)m from the stack.
    
6.  Let L be the [label](#syntax-label) whose arity is m and whose continuation is the start of the block.
    
7.  Enter the block [val](#syntax-val)m [instr](#syntax-instr)∗ with the [label](#syntax-label) L.
    

​z;[val](#syntax-val)m ([loop](#syntax-instr-control) bt [instr](#syntax-instr)∗)​[↪](#exec-notation)​([label](#syntax-label)m​{[loop](#syntax-instr-control) bt [instr](#syntax-instr)∗} [val](#syntax-val)m [instr](#syntax-instr)∗)​if [instrtype](#aux-blocktype)z​(bt)\=t1m​→t2n​​​

##### 4.6.2.3. [if](#syntax-instr-control) bt [instr](#syntax-instr)1∗​ [instr](#syntax-instr)2∗​[](#-hrefsyntax-instr-controlmathsfifmathitbthrefsyntax-instrmathitinstr_1asthrefsyntax-instrmathitinstr_2ast)

1.  Assert: Due to [validation](#valid-if), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) from the stack.
    
3.  If c\=0, then:
    
    1.  Execute the instruction ([block](#syntax-instr-control) bt [instr](#syntax-instr)1∗​).
        
4.  Else:
    
    1.  Execute the instruction ([block](#syntax-instr-control) bt [instr](#syntax-instr)2∗​).
        

​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([if](#syntax-instr-control) bt [instr](#syntax-instr)1∗​ [else](#syntax-instr-control) [instr](#syntax-instr)2∗​)([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([if](#syntax-instr-control) bt [instr](#syntax-instr)1∗​ [else](#syntax-instr-control) [instr](#syntax-instr)2∗​)​[↪](#exec-notation)[↪](#exec-notation)​([block](#syntax-instr-control) bt [instr](#syntax-instr)1∗​)([block](#syntax-instr-control) bt [instr](#syntax-instr)2∗​)​if c\=0if c\=0​​

##### 4.6.2.4. [br](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbrl①)

1.  If the first non-value entry of the stack is a [label](#syntax-label), then:
    
    1.  Let L be the topmost [label](#syntax-label).
        
    2.  Let n be the arity of L
        
    3.  If l\=0, then:
        
        1.  Assert: Due to [validation](#valid-br), there are at least n values on the top of the stack.
            
        2.  Pop the values [val](#syntax-val)n from the stack.
            
        3.  Pop all values [val](#syntax-val)′∗ from the top of the stack.
            
        4.  Pop the [label](#syntax-label) from the stack.
            
        5.  Push the values [val](#syntax-val)n to the stack.
            
        6.  Jump to the continuation of L.
            
    4.  Else:
        
        1.  Pop all values [val](#syntax-val)∗ from the top of the stack.
            
        2.  Pop the [label](#syntax-label) from the stack.
            
        3.  Push the values [val](#syntax-val)∗ to the stack.
            
        4.  Execute the instruction ([br](#syntax-instr-control) l−1).
            
2.  Else:
    
    1.  Assert: Due to [validation](#valid-br), the first non-value entry of the stack is a [handler](#syntax-handler).
        
    2.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    3.  Pop the [handler](#syntax-handler) from the stack.
        
    4.  Push the values [val](#syntax-val)∗ to the stack.
        
    5.  Execute the instruction ([br](#syntax-instr-control) l).
        

​([label](#syntax-label)n​{[instr](#syntax-instr)′∗} [val](#syntax-val)′∗ [val](#syntax-val)n ([br](#syntax-instr-control) l) [instr](#syntax-instr)∗)([label](#syntax-label)n​{[instr](#syntax-instr)′∗} [val](#syntax-val)∗ ([br](#syntax-instr-control) l) [instr](#syntax-instr)∗)([handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [val](#syntax-val)∗ ([br](#syntax-instr-control) l) [instr](#syntax-instr)∗)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[val](#syntax-val)n [instr](#syntax-instr)′∗[val](#syntax-val)∗ ([br](#syntax-instr-control) l−1)[val](#syntax-val)∗ ([br](#syntax-instr-control) l)​if l\=0if l\>0​​

##### 4.6.2.5. [br\_if](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_ifl①)

1.  Assert: Due to [validation](#valid-br-if), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) from the stack.
    
3.  If c\=0, then:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l).
        
4.  Else:
    
    1.  Do nothing.
        

​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([br\_if](#syntax-instr-control) l)([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([br\_if](#syntax-instr-control) l)​[↪](#exec-notation)[↪](#exec-notation)​([br](#syntax-instr-control) l)ϵ​if c\=0if c\=0​​

##### 4.6.2.6. [br\_table](#syntax-instr-control) l∗ l′[](#-hrefsyntax-instr-controlmathsfbr_tablelastl)

1.  Assert: Due to [validation](#valid-br-table), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
3.  If i<∣l∗∣, then:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l∗\[i\]).
        
4.  Else:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l′).
        

​([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([br\_table](#syntax-instr-control) l∗ l′)([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([br\_table](#syntax-instr-control) l∗ l′)​[↪](#exec-notation)[↪](#exec-notation)​([br](#syntax-instr-control) l∗\[i\])([br](#syntax-instr-control) l′)​if i<∣l∗∣if i≥∣l∗∣​​

##### 4.6.2.7. [br\_on\_null](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_on_nulll①)

1.  Assert: Due to [validation](#valid-br-on-null), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l).
        
4.  Else:
    
    1.  Push the value [val](#syntax-val) to the stack.
        

​[val](#syntax-val) ([br\_on\_null](#syntax-instr-control) l)[val](#syntax-val) ([br\_on\_null](#syntax-instr-control) l)​[↪](#exec-notation)[↪](#exec-notation)​([br](#syntax-instr-control) l)[val](#syntax-val)​if [val](#syntax-val)\=[ref.null](#syntax-instr-ref) htotherwise​​

##### 4.6.2.8. [br\_on\_non\_null](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_on_non_nulll①)

1.  Assert: Due to [validation](#valid-br-on-non-null), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Do nothing.
        
4.  Else:
    
    1.  Push the value [val](#syntax-val) to the stack.
        
    2.  Execute the instruction ([br](#syntax-instr-control) l).
        

​[val](#syntax-val) ([br\_on\_non\_null](#syntax-instr-control) l)[val](#syntax-val) ([br\_on\_non\_null](#syntax-instr-control) l)​[↪](#exec-notation)[↪](#exec-notation)​ϵ[val](#syntax-val) ([br](#syntax-instr-control) l)​if [val](#syntax-val)\=[ref.null](#syntax-instr-ref) htotherwise​​

##### 4.6.2.9. [br\_on\_cast](#syntax-instr-control) l rt1​ rt2​[](#-hrefsyntax-instr-controlmathsfbr_on_castlmathitrt_1mathitrt_2①)

1.  Let f be the topmost frame.
    
2.  Assert: Due to [validation](#valid-br-on-cast), a [reference value](#syntax-ref) is on the top of the stack.
    
3.  Pop the value [ref](#syntax-ref) from the stack.
    
4.  Let rt be the type of [ref](#syntax-ref).
    
5.  Push the value [ref](#syntax-ref) to the stack.
    
6.  If rt matches [clos](#type-inst)f.[module](#syntax-frame)​(rt2​), then:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l).
        
7.  Else:
    
    1.  Do nothing.
        

​s;f;[ref](#syntax-ref) ([br\_on\_cast](#syntax-instr-control) l rt1​ rt2​)s;f;[ref](#syntax-ref) ([br\_on\_cast](#syntax-instr-control) l rt1​ rt2​)​[↪](#exec-notation)[↪](#exec-notation)​[ref](#syntax-ref) ([br](#syntax-instr-control) l)[ref](#syntax-ref)​if s[⊢](#valid-ref)[ref](#syntax-ref):rt∧ {}[⊢](#match-reftype)rt[≤](#match-reftype)[clos](#type-inst)f.[module](#syntax-frame)​(rt2​)​otherwise​​

##### 4.6.2.10. [br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​[](#-hrefsyntax-instr-controlmathsfbr_on_cast_faillmathitrt_1mathitrt_2①)

1.  Let f be the topmost frame.
    
2.  Assert: Due to [validation](#valid-br-on-cast-fail), a [reference value](#syntax-ref) is on the top of the stack.
    
3.  Pop the value [ref](#syntax-ref) from the stack.
    
4.  Let rt be the type of [ref](#syntax-ref).
    
5.  Push the value [ref](#syntax-ref) to the stack.
    
6.  If rt matches [clos](#type-inst)f.[module](#syntax-frame)​(rt2​), then:
    
    1.  Do nothing.
        
7.  Else:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l).
        

​s;f;[ref](#syntax-ref) ([br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​)s;f;[ref](#syntax-ref) ([br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​)​[↪](#exec-notation)[↪](#exec-notation)​[ref](#syntax-ref)[ref](#syntax-ref) ([br](#syntax-instr-control) l)​if s[⊢](#valid-ref)[ref](#syntax-ref):rt∧ {}[⊢](#match-reftype)rt[≤](#match-reftype)[clos](#type-inst)f.[module](#syntax-frame)​(rt2​)​otherwise​​

##### 4.6.2.11. [return](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfreturn①)

1.  If the first non-value entry of the stack is a [frame](#syntax-frame), then:
    
    1.  Let f be the topmost [frame](#syntax-frame).
        
    2.  Let n be the arity of f
        
    3.  Assert: Due to [validation](#valid-return), there are at least n values on the top of the stack.
        
    4.  Pop the values [val](#syntax-val)n from the stack.
        
    5.  Pop all values [val](#syntax-val)′∗ from the top of the stack.
        
    6.  Pop the [frame](#syntax-frame) from the stack.
        
    7.  Push the values [val](#syntax-val)n to the stack.
        
2.  Else if the first non-value entry of the stack is a [label](#syntax-label), then:
    
    1.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    2.  Pop the [label](#syntax-label) from the stack.
        
    3.  Push the values [val](#syntax-val)∗ to the stack.
        
    4.  Execute the instruction [return](#syntax-instr-control).
        
3.  Else:
    
    1.  Assert: Due to [validation](#valid-return), the first non-value entry of the stack is a [handler](#syntax-handler).
        
    2.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    3.  Pop the [handler](#syntax-handler) from the stack.
        
    4.  Push the values [val](#syntax-val)∗ to the stack.
        
    5.  Execute the instruction [return](#syntax-instr-control).
        

​([frame](#syntax-frame)n​{f} [val](#syntax-val)′∗ [val](#syntax-val)n [return](#syntax-instr-control) [instr](#syntax-instr)∗)([label](#syntax-label)n​{[instr](#syntax-instr)′∗} [val](#syntax-val)∗ [return](#syntax-instr-control) [instr](#syntax-instr)∗)([handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [val](#syntax-val)∗ [return](#syntax-instr-control) [instr](#syntax-instr)∗)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[val](#syntax-val)n[val](#syntax-val)∗ [return](#syntax-instr-control)[val](#syntax-val)∗ [return](#syntax-instr-control)​​

##### 4.6.2.12. [call](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfcallx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-call), x<∣z.[module](#syntax-state).[funcs](#syntax-moduleinst)∣.
    
3.  Let a be the [address](#syntax-addr) z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\].
    
4.  Assert: Due to [validation](#valid-call), a<∣z.[funcs](#syntax-state)∣.
    
5.  Push the value ([ref.func](#syntax-ref) a) to the stack.
    
6.  Execute the instruction ([call\_ref](#syntax-instr-control) z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst)).
    

​z;([call](#syntax-instr-control) x)​[↪](#exec-notation)​([ref.func](#syntax-ref) a) ([call\_ref](#syntax-instr-control) z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst))​if z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\]\=a​​

##### 4.6.2.13. [call\_ref](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfcall_refx①)

Todo

(\*) Prose not spliced, for the prose merges the two cases of null and non-null references.

1.  Assert: due to [validation](#valid-call-ref), a null or [function reference](#syntax-ref) is on the top of the stack.
    
2.  Pop the reference value r from the stack.
    
3.  If r is [ref.null](#syntax-instr-ref) ht, then:
    
    > 1.  Trap.
    >     
    
4.  Assert: due to [validation](#valid-call-ref), r is a [function reference](#syntax-ref).
    
5.  Let [ref.func](#syntax-ref) a be the reference r.
    
6.  [Invoke](#exec-invoke) the function instance at address a.
    

​z;([ref.null](#syntax-instr-ref) ht) ([call\_ref](#syntax-instr-control) y)​[↪](#exec-notation)​[trap](#syntax-trap)​​

Note

The formal rule for calling a non-null function reference is described [below](#exec-invoke).

##### 4.6.2.14. [call\_indirect](#syntax-instr-control) x y[](#-hrefsyntax-instr-controlmathsfcall_indirectxy①)

1.  Execute the instruction ([table.get](#syntax-instr-table) x).
    
2.  Execute the instruction ([ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) y)).
    
3.  Execute the instruction ([call\_ref](#syntax-instr-control) y).
    

​([call\_indirect](#syntax-instr-control) x y)​[↪](#exec-notation)​([table.get](#syntax-instr-table) x) ([ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) y)) ([call\_ref](#syntax-instr-control) y)​​

##### 4.6.2.15. [return\_call](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfreturn_callx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-return-call), x<∣z.[module](#syntax-state).[funcs](#syntax-moduleinst)∣.
    
3.  Let a be the [address](#syntax-addr) z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\].
    
4.  Assert: Due to [validation](#valid-return-call), a<∣z.[funcs](#syntax-state)∣.
    
5.  Push the value ([ref.func](#syntax-ref) a) to the stack.
    
6.  Execute the instruction ([return\_call\_ref](#syntax-instr-control) z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst)).
    

​z;([return\_call](#syntax-instr-control) x)​[↪](#exec-notation)​([ref.func](#syntax-ref) a) ([return\_call\_ref](#syntax-instr-control) z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst))​if z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\]\=a​​

##### 4.6.2.16. [return\_call\_ref](#syntax-instr-control) y[](#-hrefsyntax-instr-controlmathsfreturn_call_refy)

1.  Let z be the current state.
    
2.  If the first non-value entry of the stack is a [label](#syntax-label), then:
    
    1.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    2.  Pop the [label](#syntax-label) from the stack.
        
    3.  Push the values [val](#syntax-val)∗ to the stack.
        
    4.  Execute the instruction ([return\_call\_ref](#syntax-instr-control) y).
        
3.  Else if the first non-value entry of the stack is a [handler](#syntax-handler), then:
    
    1.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    2.  Pop the [handler](#syntax-handler) from the stack.
        
    3.  Push the values [val](#syntax-val)∗ to the stack.
        
    4.  Execute the instruction ([return\_call\_ref](#syntax-instr-control) y).
        
4.  Else:
    
    1.  Assert: Due to [validation](#valid-return-call-ref), the first non-value entry of the stack is a [frame](#syntax-frame).
        
    2.  Assert: Due to [validation](#valid-return-call-ref), a value is on the top of the stack.
        
    3.  Pop the value [val](#syntax-val)′′ from the stack.
        
    4.  If [val](#syntax-val)′′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
        
        1.  Trap.
            
    5.  Assert: Due to [validation](#valid-return-call-ref), [val](#syntax-val)′′ is some [ref.func](#syntax-ref) [funcaddr](#syntax-funcaddr).
        
    6.  Let ([ref.func](#syntax-ref) a) be the destructuring of [val](#syntax-val)′′.
        
    7.  Assert: Due to [validation](#valid-return-call-ref), a<∣z.[funcs](#syntax-state)∣.
        
    8.  Assert: Due to [validation](#valid-return-call-ref), the [expansion](#aux-expand-deftype) of z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst) is some [func](#syntax-comptype) [resulttype](#syntax-resulttype)[→](#syntax-comptype)[resulttype](#syntax-resulttype).
        
    9.  Let ([func](#syntax-comptype) t1n​ [→](#syntax-comptype) t2m​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst).
        
    10.  Assert: Due to [validation](#valid-return-call-ref), there are at least n values on the top of the stack.
        
    11.  Pop the values [val](#syntax-val)n from the stack.
        
    12.  Pop all values [val](#syntax-val)′∗ from the top of the stack.
        
    13.  Pop the [frame](#syntax-frame) from the stack.
        
    14.  Push the values [val](#syntax-val)n to the stack.
        
    15.  Push the value ([ref.func](#syntax-ref) a) to the stack.
        
    16.  Execute the instruction ([call\_ref](#syntax-instr-control) y).
        

​z;([label](#syntax-label)k​{[instr](#syntax-instr)′∗} [val](#syntax-val)∗ ([return\_call\_ref](#syntax-instr-control) y) [instr](#syntax-instr)∗)z;([handler](#syntax-handler)k​{[catch](#syntax-catch)∗} [val](#syntax-val)∗ ([return\_call\_ref](#syntax-instr-control) y) [instr](#syntax-instr)∗)z;([frame](#syntax-frame)k​{f} [val](#syntax-val)∗ ([ref.null](#syntax-instr-ref) ht) ([return\_call\_ref](#syntax-instr-control) y) [instr](#syntax-instr)∗)z;([frame](#syntax-frame)k​{f} [val](#syntax-val)′∗ [val](#syntax-val)n ([ref.func](#syntax-ref) a) ([return\_call\_ref](#syntax-instr-control) y) [instr](#syntax-instr)∗)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[val](#syntax-val)∗ ([return\_call\_ref](#syntax-instr-control) y)[val](#syntax-val)∗ ([return\_call\_ref](#syntax-instr-control) y)[trap](#syntax-trap)[val](#syntax-val)n ([ref.func](#syntax-ref) a) ([call\_ref](#syntax-instr-control) y)if z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst)[≈](#aux-expand-deftype)[func](#syntax-comptype) t1n​[→](#syntax-comptype)t2m​​​​

##### 4.6.2.17. [return\_call\_indirect](#syntax-instr-control) x y[](#-hrefsyntax-instr-controlmathsfreturn_call_indirectxy①)

1.  Execute the instruction ([table.get](#syntax-instr-table) x).
    
2.  Execute the instruction ([ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) y)).
    
3.  Execute the instruction ([return\_call\_ref](#syntax-instr-control) y).
    

​([return\_call\_indirect](#syntax-instr-control) x y)​[↪](#exec-notation)​([table.get](#syntax-instr-table) x) ([ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) y)) ([return\_call\_ref](#syntax-instr-control) y)​​

##### 4.6.2.18. [throw](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfthrowx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-throw), x<∣z.[tags](#syntax-state)∣.
    
3.  Assert: Due to [validation](#valid-throw), the [expansion](#aux-expand-deftype) of z.[tags](#syntax-state)\[x\].[type](#syntax-taginst) is some [func](#syntax-comptype) [resulttype](#syntax-resulttype)[→](#syntax-comptype)[resulttype](#syntax-resulttype).
    
4.  Let ([func](#syntax-comptype) tn [→](#syntax-comptype) [resulttype](#syntax-resulttype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[tags](#syntax-state)\[x\].[type](#syntax-taginst).
    
5.  Assert: Due to [validation](#valid-throw), [resulttype](#syntax-resulttype)0​\=ϵ.
    
6.  Let a be the length of z.[exns](#syntax-state).
    
7.  Assert: Due to [validation](#valid-throw), there are at least n values on the top of the stack.
    
8.  Pop the values [val](#syntax-val)n from the stack.
    
9.  Let exn be the [exception instance](#syntax-exninst) {[tag](#syntax-exninst) z.[tags](#syntax-state)\[x\],[fields](#syntax-exninst) [val](#syntax-val)n}.
    
10.  Append exn to z.[exns](#syntax-state).
    
11.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
    
12.  Execute the instruction [throw\_ref](#syntax-instr-control).
    

​z;[val](#syntax-val)n ([throw](#syntax-instr-control) x)​[↪](#exec-notation)​z\[.[exns](#syntax-state)\=⊕exn\];([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)​if z.[tags](#syntax-state)\[x\].[type](#syntax-taginst)[≈](#aux-expand-deftype)[func](#syntax-comptype) tn[→](#syntax-comptype)ϵ∧ a\=∣z.[exns](#syntax-state)∣∧ exn\={[tag](#syntax-exninst) z.[tags](#syntax-state)\[x\],[fields](#syntax-exninst) [val](#syntax-val)n}​​​

##### 4.6.2.19. [throw\_ref](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfthrow_ref①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-throw-ref), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val)′ from the stack.
    
4.  If [val](#syntax-val)′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
5.  If [val](#syntax-val)′ is some [ref.exn](#syntax-ref) [exnaddr](#syntax-exnaddr), then:
    
    1.  Let ([ref.exn](#syntax-ref) a) be the destructuring of [val](#syntax-val)′.
        
    2.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    3.  If [val](#syntax-val)∗\=ϵ, then:
        
        1.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
            
        2.  Execute the instruction [throw\_ref](#syntax-instr-control).
            
    4.  Else if the first non-value entry of the stack is a [label](#syntax-label), then:
        
        1.  Pop the [label](#syntax-label) from the stack.
            
        2.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
            
        3.  Execute the instruction [throw\_ref](#syntax-instr-control).
            
    5.  Else:
        
        1.  If the first non-value entry of the stack is a [frame](#syntax-frame), then:
            
            1.  Pop the [frame](#syntax-frame) from the stack.
                
            2.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                
            3.  Execute the instruction [throw\_ref](#syntax-instr-control).
                
        2.  Else if the first non-value entry of the stack is not a [handler](#syntax-handler), then:
            
            1.  Throw the exception [val](#syntax-val)′ as a result.
                
        3.  Else:
            
            1.  Let H be the topmost [handler](#syntax-handler).
                
            2.  Let n be the arity of H
                
            3.  Let [catch](#syntax-catch)′′∗ be the catch handler of H
                
            4.  If [catch](#syntax-catch)′′∗\=ϵ, then:
                
                1.  Pop the [handler](#syntax-handler) from the stack.
                    
                2.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                    
                3.  Execute the instruction [throw\_ref](#syntax-instr-control).
                    
            5.  Else if a≥∣z.[exns](#syntax-state)∣, then:
                
                1.  Let [catch](#syntax-catch)0​ [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                    
                2.  If [catch](#syntax-catch)0​ is some [catch\_all](#syntax-instr-control) [labelidx](#syntax-labelidx), then:
                    
                    1.  Let ([catch\_all](#syntax-instr-control) l) be the destructuring of [catch](#syntax-catch)0​.
                        
                    2.  Pop the [handler](#syntax-handler) from the stack.
                        
                    3.  Execute the instruction ([br](#syntax-instr-control) l).
                        
                3.  Else if [catch](#syntax-catch)0​ is not some [catch\_all\_ref](#syntax-instr-control) [labelidx](#syntax-labelidx), then:
                    
                    1.  Let [catch](#syntax-catch) [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                        
                    2.  Pop the [handler](#syntax-handler) from the stack.
                        
                    3.  Let H′ be the [handler](#syntax-handler) whose arity is n and whose catch handler is [catch](#syntax-catch)′∗.
                        
                    4.  Push the [handler](#syntax-handler) H′.
                        
                    5.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                        
                    6.  Execute the instruction [throw\_ref](#syntax-instr-control).
                        
                4.  Else:
                    
                    1.  Let ([catch\_all\_ref](#syntax-instr-control) l) be the destructuring of [catch](#syntax-catch)0​.
                        
                    2.  Pop the [handler](#syntax-handler) from the stack.
                        
                    3.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                        
                    4.  Execute the instruction ([br](#syntax-instr-control) l).
                        
            6.  Else:
                
                1.  Let [val](#syntax-val)∗ be z.[exns](#syntax-state)\[a\].[fields](#syntax-exninst).
                    
                2.  Let [catch](#syntax-catch)0​ [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                    
                3.  If [catch](#syntax-catch)0​ is some [catch](#syntax-instr-control) [tagidx](#syntax-tagidx) [labelidx](#syntax-labelidx), then:
                    
                    1.  Let ([catch](#syntax-instr-control) x l) be the destructuring of [catch](#syntax-catch)0​.
                        
                    2.  If x<∣z.[tags](#syntax-state)∣ and z.[exns](#syntax-state)\[a\].[tag](#syntax-exninst)\=z.[tags](#syntax-state)\[x\], then:
                        
                        1.  Pop the [handler](#syntax-handler) from the stack.
                            
                        2.  Push the values [val](#syntax-val)∗ to the stack.
                            
                        3.  Execute the instruction ([br](#syntax-instr-control) l).
                            
                    3.  Else:
                        
                        1.  Let [catch](#syntax-catch) [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                            
                        2.  Pop the [handler](#syntax-handler) from the stack.
                            
                        3.  Let H′ be the [handler](#syntax-handler) whose arity is n and whose catch handler is [catch](#syntax-catch)′∗.
                            
                        4.  Push the [handler](#syntax-handler) H′.
                            
                        5.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                            
                        6.  Execute the instruction [throw\_ref](#syntax-instr-control).
                            
                4.  Else if [catch](#syntax-catch)0​ is some [catch\_ref](#syntax-instr-control) [tagidx](#syntax-tagidx) [labelidx](#syntax-labelidx), then:
                    
                    1.  Let ([catch\_ref](#syntax-instr-control) x l) be the destructuring of [catch](#syntax-catch)0​.
                        
                    2.  If x≥∣z.[tags](#syntax-state)∣ or z.[exns](#syntax-state)\[a\].[tag](#syntax-exninst)\=z.[tags](#syntax-state)\[x\], then:
                        
                        1.  Let [catch](#syntax-catch) [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                            
                        2.  Pop the [handler](#syntax-handler) from the stack.
                            
                        3.  Let H′ be the [handler](#syntax-handler) whose arity is n and whose catch handler is [catch](#syntax-catch)′∗.
                            
                        4.  Push the [handler](#syntax-handler) H′.
                            
                        5.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                            
                        6.  Execute the instruction [throw\_ref](#syntax-instr-control).
                            
                    3.  Else:
                        
                        1.  Pop the [handler](#syntax-handler) from the stack.
                            
                        2.  Push the values [val](#syntax-val)∗ to the stack.
                            
                        3.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                            
                        4.  Execute the instruction ([br](#syntax-instr-control) l).
                            
                5.  Else:
                    
                    1.  If [catch](#syntax-catch)0​ is some [catch\_all](#syntax-instr-control) [labelidx](#syntax-labelidx), then:
                        
                        1.  Let ([catch\_all](#syntax-instr-control) l) be the destructuring of [catch](#syntax-catch)0​.
                            
                        2.  Pop the [handler](#syntax-handler) from the stack.
                            
                        3.  Execute the instruction ([br](#syntax-instr-control) l).
                            
                    2.  Else if [catch](#syntax-catch)0​ is not some [catch\_all\_ref](#syntax-instr-control) [labelidx](#syntax-labelidx), then:
                        
                        1.  Let [catch](#syntax-catch) [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                            
                        2.  Pop the [handler](#syntax-handler) from the stack.
                            
                        3.  Let H be the [handler](#syntax-handler) whose arity is n and whose catch handler is [catch](#syntax-catch)′∗.
                            
                        4.  Push the [handler](#syntax-handler) H.
                            
                        5.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                            
                        6.  Execute the instruction [throw\_ref](#syntax-instr-control).
                            
                    3.  Else:
                        
                        1.  Let ([catch\_all\_ref](#syntax-instr-control) l) be the destructuring of [catch](#syntax-catch)0​.
                            
                        2.  Pop the [handler](#syntax-handler) from the stack.
                            
                        3.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                            
                        4.  Execute the instruction ([br](#syntax-instr-control) l).
                            
6.  Else:
    
    1.  Assert: Due to [validation](#valid-throw-ref), the first non-value entry of the stack is not a [label](#syntax-label).
        
    2.  Assert: Due to [validation](#valid-throw-ref), the first non-value entry of the stack is not a [frame](#syntax-frame).
        
    3.  Assert: Due to [validation](#valid-throw-ref), the first non-value entry of the stack is not a [handler](#syntax-handler).
        
    4.  Throw the exception [val](#syntax-val)′ as a result.
        

​z;([ref.null](#syntax-instr-ref) ht) [throw\_ref](#syntax-instr-control)​[↪](#exec-notation)​[trap](#syntax-trap)0.8ex\]if [val](#syntax-val)∗\=ϵ∨[instr](#syntax-instr)∗\=ϵ0.8ex\]if z.[exns](#syntax-state)\[a\].[tag](#syntax-exninst)\=z.[tags](#syntax-state)\[x\]∧ [val](#syntax-val)∗\=z.[exns](#syntax-state)\[a\].[fields](#syntax-exninst)​0.8ex\]if z.[exns](#syntax-state)\[a\].[tag](#syntax-exninst)\=z.[tags](#syntax-state)\[x\]∧ [val](#syntax-val)∗\=z.[exns](#syntax-state)\[a\].[fields](#syntax-exninst)​0.8ex\]otherwise​z;[val](#syntax-val)∗ ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control) [instr](#syntax-instr)∗z;([label](#syntax-label)n​{[instr](#syntax-instr)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))z;([handler](#syntax-handler)n​{([catch\_ref](#syntax-instr-control) x l) [catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))z;([handler](#syntax-handler)n​{([catch\_all](#syntax-instr-control) l) [catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)0.8ex\][val](#syntax-val)∗ ([ref.exn](#syntax-ref) a) ([br](#syntax-instr-control) l)([br](#syntax-instr-control) l)0.8ex\]​z;([frame](#syntax-frame)n​{f} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))z;([handler](#syntax-handler)n​{([catch\_all\_ref](#syntax-instr-control) l) [catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))​[↪](#exec-notation)[↪](#exec-notation)​([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)0.8ex\]([ref.exn](#syntax-ref) a) ([br](#syntax-instr-control) l)0.8ex\]​z;([handler](#syntax-handler)n​{ϵ} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))z;([handler](#syntax-handler)n​{[catch](#syntax-catch) [catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))​[↪](#exec-notation)[↪](#exec-notation)​([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)0.8ex\]([handler](#syntax-handler)n​{[catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))​z;([handler](#syntax-handler)n​{([catch](#syntax-instr-control) x l) [catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))​[↪](#exec-notation)[val](#syntax-val)∗ ([br](#syntax-instr-control) l)​

##### 4.6.2.20. [try\_table](#syntax-instr-control) bt [catch](#syntax-catch)∗ [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsftry_tablemathitbthrefsyntax-catchmathitcatchasthrefsyntax-instrmathitinstrast)

1.  Let z be the current state.
    
2.  Let t1m​ [→](#syntax-instrtype)[localidx](#syntax-localidx)0∗​​t2n​ be the destructuring of [instrtype](#aux-blocktype)z​(bt).
    
3.  Assert: Due to [validation](#valid-try-table), [localidx](#syntax-localidx)0∗​\=ϵ.
    
4.  Assert: Due to [validation](#valid-try-table), there are at least m values on the top of the stack.
    
5.  Pop the values [val](#syntax-val)m from the stack.
    
6.  Let H be the [handler](#syntax-handler) whose arity is n and whose catch handler is [catch](#syntax-catch)∗.
    
7.  Push the [handler](#syntax-handler) H.
    
8.  Let L be the [label](#syntax-label) whose arity is n and whose continuation is the end of the block.
    
9.  Enter the block [val](#syntax-val)m [instr](#syntax-instr)∗ with the [label](#syntax-label) L.
    

​z;[val](#syntax-val)m ([try\_table](#syntax-instr-control) bt [catch](#syntax-catch)∗ [instr](#syntax-instr)∗)​[↪](#exec-notation)​([handler](#syntax-handler)n​{[catch](#syntax-catch)∗} ([label](#syntax-label)n​{ϵ} [val](#syntax-val)m [instr](#syntax-instr)∗))if [instrtype](#aux-blocktype)z​(bt)\=t1m​→t2n​​​

#### 4.6.3. Blocks[](#blocks①)

The following auxiliary rules define the semantics of executing an [instruction sequence](#syntax-instrs) that forms a [block](#exec-instr-control).

##### 4.6.3.1. Entering [instr](#syntax-instr)∗ with label L and values [val](#syntax-val)∗[](#entering--hrefsyntax-instrmathitinstrast-with-label--l-and-values--hrefsyntax-valmathitvalast)

1.  Push L to the stack.
    
2.  Push the values [val](#syntax-val)∗ to the stack.
    
3.  Jump to the start of the instruction sequence [instr](#syntax-instr)∗.
    

Note

No formal reduction rule is needed for entering an instruction sequence, because the label L is embedded in the [administrative instruction](#syntax-instr-admin) that structured control instructions reduce to directly.

##### 4.6.3.2. Exiting [instr](#syntax-instr)∗ with label L[](#exiting--hrefsyntax-instrmathitinstrast-with-label--l)

When the end of a block is reached without a jump, [exception](#exception), or [trap](#trap) aborting it, then the following steps are performed.

1.  Pop all values [val](#syntax-val)∗ from the top of the stack.
    
2.  Assert: due to [validation](#valid-instrs), the label L is now on the top of the stack.
    
3.  Pop the label from the stack.
    
4.  Push [val](#syntax-val)∗ back to the stack.
    
5.  Jump to the position after the end of the [structured control instruction](#syntax-instr-control) associated with the label L.
    

​([label](#syntax-label)n​{[instr](#syntax-instr)∗} [val](#syntax-val)∗)​[↪](#exec-notation)​[val](#syntax-val)∗​​

Note

This semantics also applies to the instruction sequence contained in a loop instruction. Therefore, execution of a loop falls off the end, unless a backwards branch is performed explicitly.

#### 4.6.4. Exception Handling[](#exception-handling①)

The following auxiliary rules define the semantics of entering and exiting try\_table blocks.

##### 4.6.4.1. Entering [instr](#syntax-instr)∗ with label L and exception handler H[](#entering--hrefsyntax-instrmathitinstrast-with-label--l-and-exception-handler--h)

1.  Push H to the stack.
    
2.  Push L onto the stack.
    
3.  Jump to the start of the instruction sequence [instr](#syntax-instr)∗.
    

Note

No formal reduction rule is needed for entering an exception [handler](#syntax-handler) because it is an [administrative instruction](#syntax-instr-admin) that the try\_table instruction reduces to directly.

##### 4.6.4.2. Exiting an exception handler[](#exiting-an-exception-handler①)

When the end of a try\_table block is reached without a jump, [exception](#exception), or [trap](#trap), then the following steps are performed.

1.  Let m be the number of values on the top of the stack.
    
2.  Pop the values [val](#syntax-val)m from the stack.
    
3.  Assert: due to [validation](#valid-instrs), a handler and a label are now on the top of the stack.
    
4.  Pop the label from the stack.
    
5.  Pop the handler H from the stack.
    
6.  Push [val](#syntax-val)m back to the stack.
    
7.  Jump to the position after the end of the administrative instruction associated with the handler H.
    

​([handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [val](#syntax-val)∗)​[↪](#exec-notation)​[val](#syntax-val)∗​​

#### 4.6.5. Function Calls[](#function-calls①)

The following auxiliary rules define the semantics of invoking a [function instance](#syntax-funcinst) through one of the [call instructions](#exec-instr-control) and returning from it.

##### 4.6.5.1. Invocation of [function reference](#syntax-ref-func) ([ref.func](#syntax-ref) a)[](#invocation-of-function-reference--hrefsyntax-refmathsfreffunca)

1.  Assert: due to [validation](#valid-call), S.[funcs](#syntax-store)\[a\] exists.
    
2.  Let f be the [function instance](#syntax-funcinst), S.[funcs](#syntax-store)\[a\].
    
3.  Let [func](#syntax-comptype) \[t1n​\][→](#syntax-comptype)\[t2m​\] be the [composite type](#syntax-comptype) [expand](#aux-expand-deftype)(f.[type](#syntax-funcinst)).
    
4.  Let [func](#syntax-func) x [local](#syntax-local)∗ [instr](#syntax-instr)∗ be the [function](#syntax-func) f.[code](#syntax-funcinst).
    
5.  Assert: due to [validation](#valid-call), n values are on the top of the stack.
    
6.  Pop the values [val](#syntax-val)n from the stack.
    
7.  Let F be the [frame](#syntax-frame) {[module](#syntax-frame) F.[module](#syntax-funcinst),[locals](#syntax-frame) [val](#syntax-val)n ([default](#aux-default)t​)∗}.
    
8.  Push the activation of f with arity m to the stack.
    
9.  Let L be the [label](#syntax-label) whose arity is m and whose continuation is the end of the function.
    
10.  [Enter](#exec-instrs-enter) the instruction sequence [instr](#syntax-instr)∗ with label L and no values.
    

​z;[val](#syntax-val)n ([ref.func](#syntax-ref) a) ([call\_ref](#syntax-instr-control) y)​[↪](#exec-notation)​([frame](#syntax-frame)m​{f} ([label](#syntax-label)m​{ϵ} [instr](#syntax-instr)∗))if z.[funcs](#syntax-state)\[a\]\=fi∧ fi.[type](#syntax-funcinst)[≈](#aux-expand-deftype)[func](#syntax-comptype) t1n​[→](#syntax-comptype)t2m​∧ fi.[code](#syntax-funcinst)\=[func](#syntax-func) x ([local](#syntax-local) t)∗ ([instr](#syntax-instr)∗)∧ f\={[locals](#syntax-frame) [val](#syntax-val)n ([default](#aux-default)t​)∗,[module](#syntax-frame) fi.[module](#syntax-funcinst)}​​​

Note

For non-defaultable types, the respective local is left uninitialized by these rules.

##### 4.6.5.2. Returning from a function[](#returning-from-a-function①)

When the end of a function is reached without a jump (including through [return](#syntax-instr-control)), or an [exception](#exception) or [trap](#trap) aborting it, then the following steps are performed.

1.  Let F be the [current](#exec-notation-textual) [frame](#syntax-frame).
    
2.  Let n be the arity of the activation of F.
    
3.  Assert: due to [validation](#valid-instrs), there are n values on the top of the stack.
    
4.  Pop the results [val](#syntax-val)n from the stack.
    
5.  Assert: due to [validation](#valid-func), the frame F is now on the top of the stack.
    
6.  Pop the frame from the stack.
    
7.  Push [val](#syntax-val)n back to the stack.
    
8.  Jump to the instruction after the original call.
    

​([frame](#syntax-frame)n​{f} [val](#syntax-val)n)​[↪](#exec-notation)​[val](#syntax-val)n​​

##### 4.6.5.3. Host Functions[](#host-functions①)

Invoking a [host function](#syntax-hostfunc) has non-deterministic behavior. It may either terminate with a [trap](#trap), an [exception](#exception), or return regularly. However, in the latter case, it must consume and produce the right number and types of WebAssembly [values](#syntax-val) on the stack, according to its [function type](#syntax-functype).

A host function may also modify the [store](#syntax-store). However, all store modifications must result in an [extension](#extend-store) of the original store, i.e., they must only modify mutable contents and must not have instances removed. Furthermore, the resulting store must be [valid](#valid-store), i.e., all data and code in it is well-typed.

−1ex\]S;[val](#syntax-val)n ([ref.func](#syntax-ref) a) [call\_ref](#syntax-instr-control)​[↪](#exec-notation)​S′;[result](#syntax-result)​if∧∧​S.[funcs](#syntax-store)\[a\]\={[type](#syntax-funcinst) [deftype](#syntax-deftype),[hostfunc](#syntax-funcinst) hf}[deftype](#syntax-deftype)≈[func](#syntax-comptype) \[t1n​\][→](#syntax-comptype)\[t2m​\](S′;[result](#syntax-result))∈hf(S;[val](#syntax-val)n)​S;[val](#syntax-val)n ([ref.func](#syntax-ref) a) [call\_ref](#syntax-instr-control)​[↪](#exec-notation)​S;[val](#syntax-val)n ([ref.func](#syntax-ref) a) [call\_ref](#syntax-instr-control)​if∧∧​S.[funcs](#syntax-store)\[a\]\={[type](#syntax-funcinst) [deftype](#syntax-deftype),[hostfunc](#syntax-funcinst) hf}[deftype](#syntax-deftype)≈[func](#syntax-comptype) \[t1n​\][→](#syntax-comptype)\[t2m​\]⊥∈hf(S;[val](#syntax-val)n)​​​

Here, hf(S;[val](#syntax-val)n) denotes the implementation-defined execution of host function hf in current store S with arguments [val](#syntax-val)n. It yields a set of possible outcomes, where each element is either a pair of a modified store S′ and a [result](#syntax-result) or the special value ⊥ indicating divergence. A host function is non-deterministic if there is at least one argument for which the set of outcomes is not singular.

For a WebAssembly implementation to be [sound](#soundness) in the presence of host functions, every [host function instance](#syntax-funcinst) must be [valid](#valid-hostfuncinst), which means that it adheres to suitable pre- and post-conditions: under a [valid store](#valid-store) S, and given arguments [val](#syntax-val)n matching the ascribed parameter types t1n​, executing the host function must yield a non-empty set of possible outcomes each of which is either divergence or consists of a valid store S′ that is an [extension](#extend-store) of S and a result matching the ascribed return types t2m​. All these notions are made precise in the [Appendix](#soundness).

Note

A host function can call back into WebAssembly by [invoking](#exec-invocation) a function [exported](#syntax-export) from a [module](#syntax-module). However, the effects of any such call are subsumed by the non-deterministic behavior allowed for the host function.

#### 4.6.6. Variable Instructions[](#variable-instructions⑤)

##### 4.6.6.1. [local.get](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalgetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-local-get), z.[locals](#syntax-state)\[x\] is defined.
    
3.  Let [val](#syntax-val) be z.[locals](#syntax-state)\[x\].
    
4.  Push the value [val](#syntax-val) to the stack.
    

​z;([local.get](#syntax-instr-variable) x)​[↪](#exec-notation)​[val](#syntax-val)​if z.[locals](#syntax-state)\[x\]\=[val](#syntax-val)​​

##### 4.6.6.2. [local.set](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalsetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-local-set), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  Replace z.[locals](#syntax-state)\[x\] with [val](#syntax-val).
    

​z;[val](#syntax-val) ([local.set](#syntax-instr-variable) x)​[↪](#exec-notation)​z\[.[locals](#syntax-state)\[x\]\=[val](#syntax-val)\];ϵ​​

##### 4.6.6.3. [local.tee](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalteex①)

1.  Assert: Due to [validation](#valid-local-tee), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  Push the value [val](#syntax-val) to the stack.
    
4.  Push the value [val](#syntax-val) to the stack.
    
5.  Execute the instruction ([local.set](#syntax-instr-variable) x).
    

​[val](#syntax-val) ([local.tee](#syntax-instr-variable) x)​[↪](#exec-notation)​[val](#syntax-val) [val](#syntax-val) ([local.set](#syntax-instr-variable) x)​​

##### 4.6.6.4. [global.get](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsfglobalgetx①)

1.  Let z be the current state.
    
2.  Let [val](#syntax-val) be the [value](#syntax-val) z.[globals](#syntax-state)\[x\].[value](#syntax-globalinst).
    
3.  Push the value [val](#syntax-val) to the stack.
    

​z;([global.get](#syntax-instr-variable) x)​[↪](#exec-notation)​[val](#syntax-val)​if z.[globals](#syntax-state)\[x\].[value](#syntax-globalinst)\=[val](#syntax-val)​​

##### 4.6.6.5. [global.set](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsfglobalsetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-global-set), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  Replace z.[globals](#syntax-state)\[x\].value with [val](#syntax-val).
    

​z;[val](#syntax-val) ([global.set](#syntax-instr-variable) x)​[↪](#exec-notation)​z\[.[globals](#syntax-state)\[x\].[value](#syntax-globalinst)\=[val](#syntax-val)\];ϵ​​

#### 4.6.7. Table Instructions[](#table-instructions⑤)

##### 4.6.7.1. [table.get](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablegetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-get), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
4.  If i≥∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
5.  Push the value z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)\[i\] to the stack.
    

​z;(at.[const](#syntax-instr-numeric) i) ([table.get](#syntax-instr-table) x)z;(at.[const](#syntax-instr-numeric) i) ([table.get](#syntax-instr-table) x)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)\[i\]​if i≥∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣if i<∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣​​

##### 4.6.7.2. [table.set](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablesetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-set), a [reference value](#syntax-ref) is on the top of the stack.
    
3.  Pop the value [ref](#syntax-ref) from the stack.
    
4.  Assert: Due to [validation](#valid-table-set), a [number value](#syntax-num) is on the top of the stack.
    
5.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
6.  If i≥∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
7.  Replace z.[tables](#syntax-state)\[x\].refs\[i\] with [ref](#syntax-ref).
    

​z;(at.[const](#syntax-instr-numeric) i) [ref](#syntax-ref) ([table.set](#syntax-instr-table) x)z;(at.[const](#syntax-instr-numeric) i) [ref](#syntax-ref) ([table.set](#syntax-instr-table) x)​[↪](#exec-notation)[↪](#exec-notation)​z;[trap](#syntax-trap)z\[.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)\[i\]\=[ref](#syntax-ref)\];ϵ​if i≥∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣if i<∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣​​

##### 4.6.7.3. [table.size](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablesizex①)

1.  Let z be the current state.
    
2.  Let (at lim rt) be the destructuring of z.[tables](#syntax-state)\[x\].[type](#syntax-tableinst).
    
3.  Let n be the length of z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst).
    
4.  Push the value (at.[const](#syntax-instr-numeric) n) to the stack.
    

​z;([table.size](#syntax-instr-table) x)​[↪](#exec-notation)​(at.[const](#syntax-instr-numeric) n)​if ∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣\=n∧ z.[tables](#syntax-state)\[x\].[type](#syntax-tableinst)\=at lim rt​​​

##### 4.6.7.4. [table.grow](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablegrowx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-grow), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-table-grow), a [reference value](#syntax-ref) is on the top of the stack.
    
5.  Pop the value [ref](#syntax-ref) from the stack.
    
6.  Either:
    
    1.  Let ti be the [table instance](#syntax-tableinst) [growtable](#grow-table)(z.[tables](#syntax-state)\[x\],n,[ref](#syntax-ref)).
        
    2.  Push the value (at.[const](#syntax-instr-numeric) ∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣) to the stack.
        
    3.  Replace z.[tables](#syntax-state)\[x\] with ti.
        
7.  Or:
    
    1.  Push the value (at.[const](#syntax-instr-numeric) [signed](#aux-signed)∣at∣−1​(−1)) to the stack.
        

​z;[ref](#syntax-ref) (at.[const](#syntax-instr-numeric) n) ([table.grow](#syntax-instr-table) x)z;[ref](#syntax-ref) (at.[const](#syntax-instr-numeric) n) ([table.grow](#syntax-instr-table) x)​[↪](#exec-notation)[↪](#exec-notation)​z\[.[tables](#syntax-state)\[x\]\=ti\];(at.[const](#syntax-instr-numeric) ∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣)if ti\=[growtable](#grow-table)(z.[tables](#syntax-state)\[x\],n,[ref](#syntax-ref))z;(at.[const](#syntax-instr-numeric) [signed](#aux-signed)∣at∣−1​(−1))​​

Note

The [table.grow](#syntax-instr-table) instruction is non-deterministic. It may either succeed, returning the old table size sz, or fail, returning −1. Failure _must_ occur if the referenced table instance has a maximum size defined that would be exceeded. However, failure _can_ occur in other cases as well. In practice, the choice depends on the [resources](#impl-exec) available to the [embedder](#embedder).

##### 4.6.7.5. [table.fill](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablefillx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-fill), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-table-fill), a value is on the top of the stack.
    
5.  Pop the value [val](#syntax-val) from the stack.
    
6.  Assert: Due to [validation](#valid-table-fill), a value of [number type](#syntax-numtype) at is on the top of the stack.
    
7.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) i) from the stack.
    
8.  If i+n\>∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
9.  If n\=0, then:
    
    1.  Do nothing.
        
10.  Else:
    
    1.  Push the value (at.[const](#syntax-instr-numeric) i) to the stack.
        
    2.  Push the value [val](#syntax-val) to the stack.
        
    3.  Execute the instruction ([table.set](#syntax-instr-table) x).
        
    4.  Push the value (at.[const](#syntax-instr-numeric) i+1) to the stack.
        
    5.  Push the value [val](#syntax-val) to the stack.
        
    6.  Push the value (at.[const](#syntax-instr-numeric) n−1) to the stack.
        
    7.  Execute the instruction ([table.fill](#syntax-instr-table) x).
        

​z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([table.fill](#syntax-instr-table) x)z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([table.fill](#syntax-instr-table) x)z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([table.fill](#syntax-instr-table) x)(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) ([table.set](#syntax-instr-table) x)(at.[const](#syntax-instr-numeric) i+1) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n−1) ([table.fill](#syntax-instr-table) x)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​if i+n\>∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣otherwise, if n\=0​​

##### 4.6.7.6. [table.copy](#syntax-instr-table) x1​ x2​[](#-hrefsyntax-instr-tablemathsftablecopyx_1x_2)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-copy), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-table-copy), a [number value](#syntax-num) is on the top of the stack.
    
5.  Pop the value (at2​.[const](#syntax-instr-numeric) i2​) from the stack.
    
6.  Assert: Due to [validation](#valid-table-copy), a [number value](#syntax-num) is on the top of the stack.
    
7.  Pop the value (at1​.[const](#syntax-instr-numeric) i1​) from the stack.
    
8.  If i1​+n\>∣z.[tables](#syntax-state)\[x1​\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
9.  If i2​+n\>∣z.[tables](#syntax-state)\[x2​\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
10.  If n\=0, then:
    
    1.  Do nothing.
        
11.  Else:
    
    1.  If i1​≤i2​, then:
        
        1.  Push the value (at1​.[const](#syntax-instr-numeric) i1​) to the stack.
            
        2.  Push the value (at2​.[const](#syntax-instr-numeric) i2​) to the stack.
            
        3.  Execute the instruction ([table.get](#syntax-instr-table) x2​).
            
        4.  Execute the instruction ([table.set](#syntax-instr-table) x1​).
            
        5.  Push the value (at1​.[const](#syntax-instr-numeric) i1​+1) to the stack.
            
        6.  Push the value (at2​.[const](#syntax-instr-numeric) i2​+1) to the stack.
            
    2.  Else:
        
        1.  Push the value (at1​.[const](#syntax-instr-numeric) i1​+n−1) to the stack.
            
        2.  Push the value (at2​.[const](#syntax-instr-numeric) i2​+n−1) to the stack.
            
        3.  Execute the instruction ([table.get](#syntax-instr-table) x2​).
            
        4.  Execute the instruction ([table.set](#syntax-instr-table) x1​).
            
        5.  Push the value (at1​.[const](#syntax-instr-numeric) i1​) to the stack.
            
        6.  Push the value (at2​.[const](#syntax-instr-numeric) i2​) to the stack.
            
    3.  Push the value (at.[const](#syntax-instr-numeric) n−1) to the stack.
        
    4.  Execute the instruction ([table.copy](#syntax-instr-table) x1​ x2​).
        

​z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([table.copy](#syntax-instr-table) x1​ x2​)if i1​+n\>∣z.[tables](#syntax-state)\[x1​\].[refs](#syntax-tableinst)∣∨i2​+n\>∣z.[tables](#syntax-state)\[x2​\].[refs](#syntax-tableinst)∣z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([table.copy](#syntax-instr-table) x y)z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([table.copy](#syntax-instr-table) x y)(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) ([table.get](#syntax-instr-table) y) ([table.set](#syntax-instr-table) x)(at1​.[const](#syntax-instr-numeric) i1​+1) (at2​.[const](#syntax-instr-numeric) i2​+1) (at′.[const](#syntax-instr-numeric) n−1) ([table.copy](#syntax-instr-table) x y)​​otherwise, if i1​≤i2​​z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([table.copy](#syntax-instr-table) x y)(at1​.[const](#syntax-instr-numeric) i1​+n−1) (at2​.[const](#syntax-instr-numeric) i2​+n−1) ([table.get](#syntax-instr-table) y) ([table.set](#syntax-instr-table) x)(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n−1) ([table.copy](#syntax-instr-table) x y)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​otherwise, if n\=0​​

##### 4.6.7.7. [table.init](#syntax-instr-table) x y[](#-hrefsyntax-instr-tablemathsftableinitxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-init), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-table-init), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) from the stack.
    
6.  Assert: Due to [validation](#valid-table-init), a [number value](#syntax-num) is on the top of the stack.
    
7.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
8.  If i+n\>∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
9.  If j+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣, then:
    
    1.  Trap.
        
10.  If n\=0, then:
    
    1.  Do nothing.
        
11.  Else:
    
    1.  Assert: Due to [validation](#valid-table-init), j<∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣.
        
    2.  Push the value (at.[const](#syntax-instr-numeric) i) to the stack.
        
    3.  Push the value z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[j\] to the stack.
        
    4.  Execute the instruction ([table.set](#syntax-instr-table) x).
        
    5.  Push the value (at.[const](#syntax-instr-numeric) i+1) to the stack.
        
    6.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) to the stack.
        
    7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
        
    8.  Execute the instruction ([table.init](#syntax-instr-table) x y).
        

​z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([table.init](#syntax-instr-table) x y)if i+n\>∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣∨j+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([table.init](#syntax-instr-table) x y)z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([table.init](#syntax-instr-table) x y)(at.[const](#syntax-instr-numeric) i) z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[j\] ([table.set](#syntax-instr-table) x)(at.[const](#syntax-instr-numeric) i+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([table.init](#syntax-instr-table) x y)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​otherwise, if n\=0​​

##### 4.6.7.8. [elem.drop](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsfelemdropx①)

1.  Let z be the current state.
    
2.  Replace z.[elems](#syntax-state)\[x\].refs with ϵ.
    

​z;([elem.drop](#syntax-instr-table) x)​[↪](#exec-notation)​z\[.[elems](#syntax-state)\[x\].[refs](#syntax-eleminst)\=ϵ\];ϵ​​

#### 4.6.8. Memory Instructions[](#memory-instructions⑤)

Note

The alignment [memarg](#syntax-memarg).[align](#syntax-instr-memory) in load and store instructions does not affect the semantics. It is a hint that the offset ea at which the memory is accessed is intended to satisfy the property eamod2[memarg](#syntax-memarg).[align](#syntax-instr-memory)\=0. A WebAssembly implementation can use this hint to optimize for the intended use. Unaligned access violating that property is still allowed and must succeed regardless of the annotation. However, it may be substantially slower on some hardware.

##### 4.6.8.1. nt.[load](#syntax-instr-memory)[loadop](#syntax-loadop)? x ao[](#-mathitnthrefsyntax-instr-memorymathsfloadhrefsyntax-loadopmathitloadopxmathitao)

1.  Let z be the current state.
    
2.  Assert: Due to validation, a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
4.  If [loadop](#syntax-loadop)? is not defined, then:
    
    1.  If i+ao.[offset](#syntax-instr-memory)+∣nt∣/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
        
        1.  Trap.
            
    2.  Let c be the result for which [bytes](#aux-bytes)nt​(c) \= z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):∣nt∣/8\].
        
    3.  Push the value (nt.[const](#syntax-instr-numeric) c) to the stack.
        
5.  Else:
    
    1.  Assert: Due to validation, nt is [i](#syntax-numtype)[N](#syntax-numtype).
        
    2.  Let [loadop](#syntax-loadop)0​ be [loadop](#syntax-loadop)?.
        
    3.  Let n\_[sx](#syntax-sx) be the destructuring of [loadop](#syntax-loadop)0​.
        
    4.  If i+ao.[offset](#syntax-instr-memory)+n/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
        
        1.  Trap.
            
    5.  Let c be the result for which [bytes](#aux-bytes)[i](#syntax-numtype)n​(c) \= z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):n/8\].
        
    6.  Push the value (nt.[const](#syntax-instr-numeric) [extend](#op-extend)n,∣nt∣[sx](#syntax-sx)​(c)) to the stack.
        

​z;(at.[const](#syntax-instr-numeric) i) (nt.[load](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) (nt.[load](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) ([i](#syntax-numtype)[N](#syntax-numtype).[load](#syntax-instr-memory)n\_[sx](#syntax-sx) x ao)z;(at.[const](#syntax-instr-numeric) i) ([i](#syntax-numtype)[N](#syntax-numtype).[load](#syntax-instr-memory)n\_[sx](#syntax-sx) x ao)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+∣nt∣/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣(nt.[const](#syntax-instr-numeric) c)if [bytes](#aux-bytes)nt​(c)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):∣nt∣/8\][trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+n/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣([i](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-numeric) [extend](#op-extend)n,∣[i](#syntax-numtype)[N](#syntax-numtype)∣[sx](#syntax-sx)​(c))if [bytes](#aux-bytes)[i](#syntax-numtype)n​(c)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):n/8\]​​​

##### 4.6.8.2. [v128](#syntax-vectype).[load](#syntax-instr-memory)M[x](#syntax-shape)K\_[sx](#syntax-sx) x ao[](#-hrefsyntax-vectypemathsfvscriptstyle128hrefsyntax-instr-memorymathsfloadmhrefsyntax-shapemathsfxkmathsf_hrefsyntax-sxmathitsxxmathitao)

1.  Let z be the current state.
    
2.  Assert: Due to validation, a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
4.  If i+ao.[offset](#syntax-instr-memory)+M⋅K/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
5.  Let jK be the result for which ([bytes](#aux-bytes)[i](#syntax-numtype)M​(jK)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory)+k⋅M/8:M/8\])k<K.
    
6.  Let [i](#syntax-numtype)[N](#syntax-numtype) be the result for which N \= M⋅2.
    
7.  Let c be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)K−1​([extend](#op-extend)M,N[sx](#syntax-sx)​(j)K).
    
8.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)M[x](#syntax-shape)K\_[sx](#syntax-sx) x ao)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)M[x](#syntax-shape)K\_[sx](#syntax-sx) x ao)if ([bytes](#aux-bytes)[i](#syntax-numtype)M​(j)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory)+k⋅M/8:M/8\])k<K∧ c\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)K−1​([extend](#op-extend)M,N[sx](#syntax-sx)​(j)K)∧N\=M⋅2​​[↪](#exec-notation)[↪](#exec-notation)[trap](#syntax-trap)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if i+ao.[offset](#syntax-instr-memory)+M⋅K/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣​

##### 4.6.8.3. [v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[splat](#syntax-instr-memory) x ao[](#-hrefsyntax-vectypemathsfvscriptstyle128hrefsyntax-instr-memorymathsfloadnmathsf_hrefsyntax-instr-memorymathsfsplatxmathitao)

1.  Let z be the current state.
    
2.  Assert: Due to validation, a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
4.  If i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
5.  Let M be 128/N.
    
6.  Let [i](#syntax-numtype)[N](#syntax-numtype) be the result for which ∣[i](#syntax-numtype)[N](#syntax-numtype)∣ \= N.
    
7.  Let j be the result for which [bytes](#aux-bytes)[i](#syntax-numtype)N​(j) \= z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\].
    
8.  Let c be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​(jM).
    
9.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[splat](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[splat](#syntax-instr-memory) x ao)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if [bytes](#aux-bytes)[i](#syntax-numtype)N​(j)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\]∧ N\=∣[i](#syntax-numtype)[N](#syntax-numtype)∣∧ M\=128/N∧ c\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​(jM)​​if i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣​

##### 4.6.8.4. [v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[zero](#syntax-instr-memory) x ao[](#-hrefsyntax-vectypemathsfvscriptstyle128hrefsyntax-instr-memorymathsfloadnmathsf_hrefsyntax-instr-memorymathsfzeroxmathitao)

1.  Let z be the current state.
    
2.  Assert: Due to validation, a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
4.  If i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
5.  Let j be the result for which [bytes](#aux-bytes)[i](#syntax-numtype)N​(j) \= z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\].
    
6.  Let c be [extend](#op-extend)N,128[u](#syntax-sx)​(j).
    
7.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[zero](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[zero](#syntax-instr-memory) x ao)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if [bytes](#aux-bytes)[i](#syntax-numtype)N​(j)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\]∧ c\=[extend](#op-extend)N,128[u](#syntax-sx)​(j)​​if i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣​

##### 4.6.8.5. [v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j[](#-hrefsyntax-vectypemathsfvscriptstyle128hrefsyntax-instr-memorymathsfloadnmathsf_hrefsyntax-instr-memorymathsflanexmathitaoj)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-vload-lane), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
3.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
4.  Assert: Due to [validation](#valid-vload-lane), a [number value](#syntax-num) is on the top of the stack.
    
5.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
6.  If i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
7.  Let M be ∣[v128](#syntax-vectype)∣/N.
    
8.  Let [i](#syntax-numtype)[N](#syntax-numtype) be the result for which ∣[i](#syntax-numtype)[N](#syntax-numtype)∣ \= N.
    
9.  Let k be the result for which [bytes](#aux-bytes)[i](#syntax-numtype)N​(k) \= z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\].
    
10.  Let c be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​)\[\[j\]\=k\]).
    
11.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if [bytes](#aux-bytes)[i](#syntax-numtype)N​(k)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\]∧ N\=∣[i](#syntax-numtype)[N](#syntax-numtype)∣∧ M\=∣[v128](#syntax-vectype)∣/N∧ c\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​)\[\[j\]\=k\])​​if i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣​

##### 4.6.8.6. nt.[store](#syntax-instr-memory)[storeop](#syntax-storeop)? x ao[](#-mathitnthrefsyntax-instr-memorymathsfstorehrefsyntax-storeopmathitstoreopxmathitao)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-store), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (nt′.[const](#syntax-instr-numeric) c) from the stack.
    
4.  Assert: Due to [validation](#valid-store), a value is on the top of the stack.
    
5.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
6.  Assert: Due to [validation](#valid-store), nt\=nt′.
    
7.  If [storeop](#syntax-storeop)? is not defined, then:
    
    1.  If i+ao.[offset](#syntax-instr-memory)+∣nt′∣/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
        
        1.  Trap.
            
    2.  Let b∗ be [bytes](#aux-bytes)nt′​(c).
        
    3.  Replace z.[mems](#syntax-state)\[x\].bytes\[i+ao.[offset](#syntax-instr-memory):∣nt′∣/8\] with b∗.
        
8.  Else:
    
    1.  Assert: Due to [validation](#valid-store), nt′ is [i](#syntax-numtype)[N](#syntax-numtype).
        
    2.  Let n be [storeop](#syntax-storeop)?.
        
    3.  If i+ao.[offset](#syntax-instr-memory)+n/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
        
        1.  Trap.
            
    4.  Let b∗ be [bytes](#aux-bytes)[i](#syntax-numtype)n​([wrap](#op-wrap)∣nt′∣,n​(c)).
        
    5.  Replace z.[mems](#syntax-state)\[x\].bytes\[i+ao.[offset](#syntax-instr-memory):n/8\] with b∗.
        

​z;(at.[const](#syntax-instr-numeric) i) (nt.[const](#syntax-instr-numeric) c) (nt.[store](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) (nt.[const](#syntax-instr-numeric) c) (nt.[store](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) ([i](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-numeric) c) ([i](#syntax-numtype)[N](#syntax-numtype).[store](#syntax-instr-memory)n x ao)z;(at.[const](#syntax-instr-numeric) i) ([i](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-numeric) c) ([i](#syntax-numtype)[N](#syntax-numtype).[store](#syntax-instr-memory)n x ao)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) ([v128](#syntax-vectype).[store](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) ([v128](#syntax-vectype).[store](#syntax-instr-memory) x ao)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​z;[trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+∣nt∣/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣z\[.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):∣nt∣/8\]\=b∗\];ϵif b∗\=[bytes](#aux-bytes)nt​(c)z;[trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+n/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣z\[.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):n/8\]\=b∗\];ϵif b∗\=[bytes](#aux-bytes)[i](#syntax-numtype)n​([wrap](#op-wrap)∣[i](#syntax-numtype)[N](#syntax-numtype)∣,n​(c))z;[trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+∣[v128](#syntax-vectype)∣/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣z\[.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):∣[v128](#syntax-vectype)∣/8\]\=b∗\];ϵif b∗\=[bytes](#aux-bytes)[v128](#syntax-vectype)​(c)​​​

##### 4.6.8.7. [v128](#syntax-vectype).[store](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j[](#-hrefsyntax-vectypemathsfvscriptstyle128hrefsyntax-instr-memorymathsfstorenmathsf_hrefsyntax-instr-memorymathsflanexmathitaoj)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-vstore-lane), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
3.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) from the stack.
    
4.  Assert: Due to [validation](#valid-vstore-lane), a [number value](#syntax-num) is on the top of the stack.
    
5.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
6.  If i+ao.[offset](#syntax-instr-memory)+N\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
7.  Let M be 128/N.
    
8.  Let [i](#syntax-numtype)[N](#syntax-numtype) be the result for which ∣[i](#syntax-numtype)[N](#syntax-numtype)∣ \= N.
    
9.  Assert: Due to [validation](#valid-vstore-lane), j<∣[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c)∣.
    
10.  Let b∗ be [bytes](#aux-bytes)[i](#syntax-numtype)N​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c)\[j\]).
    
11.  Replace z.[mems](#syntax-state)\[x\].bytes\[i+ao.[offset](#syntax-instr-memory):N/8\] with b∗.
    

​z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) ([v128](#syntax-vectype).[store](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) ([v128](#syntax-vectype).[store](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j)​[↪](#exec-notation)[↪](#exec-notation)​z;[trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+N\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣z\[.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\]\=b∗\];ϵif N\=∣[i](#syntax-numtype)[N](#syntax-numtype)∣∧ M\=128/N∧ b∗\=[bytes](#aux-bytes)[i](#syntax-numtype)N​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c)\[j\])​​​

##### 4.6.8.8. [memory.size](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemorysizex①)

1.  Let z be the current state.
    
2.  Let (at lim [page](#syntax-memtype)) be the destructuring of z.[mems](#syntax-state)\[x\].[type](#syntax-meminst).
    
3.  Let n⋅64Ki be the length of z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst).
    
4.  Push the value (at.[const](#syntax-instr-numeric) n) to the stack.
    

​z;([memory.size](#syntax-instr-memory) x)​[↪](#exec-notation)​(at.[const](#syntax-instr-numeric) n)​if n⋅64Ki\=∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣∧ z.[mems](#syntax-state)\[x\].[type](#syntax-meminst)\=at lim [page](#syntax-memtype)​​​

##### 4.6.8.9. [memory.grow](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemorygrowx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-memory-grow), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Either:
    
    1.  Let mi be the [memory instance](#syntax-meminst) [growmem](#grow-mem)(z.[mems](#syntax-state)\[x\],n).
        
    2.  Push the value (at.[const](#syntax-instr-numeric) ∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣/(64Ki)) to the stack.
        
    3.  Replace z.[mems](#syntax-state)\[x\] with mi.
        
5.  Or:
    
    1.  Push the value (at.[const](#syntax-instr-numeric) [signed](#aux-signed)∣at∣−1​(−1)) to the stack.
        

​z;(at.[const](#syntax-instr-numeric) n) ([memory.grow](#syntax-instr-memory) x)z;(at.[const](#syntax-instr-numeric) n) ([memory.grow](#syntax-instr-memory) x)​[↪](#exec-notation)[↪](#exec-notation)​z\[.[mems](#syntax-state)\[x\]\=mi\];(at.[const](#syntax-instr-numeric) ∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣/64Ki)if mi\=[growmem](#grow-mem)(z.[mems](#syntax-state)\[x\],n)z;(at.[const](#syntax-instr-numeric) [signed](#aux-signed)∣at∣−1​(−1))​​

Note

The [memory.grow](#syntax-instr-memory) instruction is non-deterministic. It may either succeed, returning the old memory size sz, or fail, returning −1. Failure _must_ occur if the referenced memory instance has a maximum size defined that would be exceeded. However, failure _can_ occur in other cases as well. In practice, the choice depends on the [resources](#impl-exec) available to the [embedder](#embedder).

##### 4.6.8.10. [memory.fill](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemoryfillx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-memory-fill), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-memory-fill), a value is on the top of the stack.
    
5.  Pop the value [val](#syntax-val) from the stack.
    
6.  Assert: Due to [validation](#valid-memory-fill), a value of [number type](#syntax-numtype) at is on the top of the stack.
    
7.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) i) from the stack.
    
8.  If i+n\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
9.  If n\=0, then:
    
    1.  Do nothing.
        
10.  Else:
    
    1.  Push the value (at.[const](#syntax-instr-numeric) i) to the stack.
        
    2.  Push the value [val](#syntax-val) to the stack.
        
    3.  Execute the instruction ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x).
        
    4.  Push the value (at.[const](#syntax-instr-numeric) i+1) to the stack.
        
    5.  Push the value [val](#syntax-val) to the stack.
        
    6.  Push the value (at.[const](#syntax-instr-numeric) n−1) to the stack.
        
    7.  Execute the instruction ([memory.fill](#syntax-instr-memory) x).
        

​z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([memory.fill](#syntax-instr-memory) x)z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([memory.fill](#syntax-instr-memory) x)z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([memory.fill](#syntax-instr-memory) x)(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x)(at.[const](#syntax-instr-numeric) i+1) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n−1) ([memory.fill](#syntax-instr-memory) x)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​if i+n\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣otherwise, if n\=0​​

##### 4.6.8.11. [memory.copy](#syntax-instr-memory) x1​ x2​[](#-hrefsyntax-instr-memorymathsfmemorycopyx_1x_2)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-memory-copy), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-memory-copy), a [number value](#syntax-num) is on the top of the stack.
    
5.  Pop the value (at2​.[const](#syntax-instr-numeric) i2​) from the stack.
    
6.  Assert: Due to [validation](#valid-memory-copy), a [number value](#syntax-num) is on the top of the stack.
    
7.  Pop the value (at1​.[const](#syntax-instr-numeric) i1​) from the stack.
    
8.  If i1​+n\>∣z.[mems](#syntax-state)\[x1​\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
9.  If i2​+n\>∣z.[mems](#syntax-state)\[x2​\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
10.  If n\=0, then:
    
    1.  Do nothing.
        
11.  Else:
    
    1.  If i1​≤i2​, then:
        
        1.  Push the value (at1​.[const](#syntax-instr-numeric) i1​) to the stack.
            
        2.  Push the value (at2​.[const](#syntax-instr-numeric) i2​) to the stack.
            
        3.  Execute the instruction ([i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x2​).
            
        4.  Execute the instruction ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x1​).
            
        5.  Push the value (at1​.[const](#syntax-instr-numeric) i1​+1) to the stack.
            
        6.  Push the value (at2​.[const](#syntax-instr-numeric) i2​+1) to the stack.
            
    2.  Else:
        
        1.  Push the value (at1​.[const](#syntax-instr-numeric) i1​+n−1) to the stack.
            
        2.  Push the value (at2​.[const](#syntax-instr-numeric) i2​+n−1) to the stack.
            
        3.  Execute the instruction ([i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x2​).
            
        4.  Execute the instruction ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x1​).
            
        5.  Push the value (at1​.[const](#syntax-instr-numeric) i1​) to the stack.
            
        6.  Push the value (at2​.[const](#syntax-instr-numeric) i2​) to the stack.
            
    3.  Push the value (at.[const](#syntax-instr-numeric) n−1) to the stack.
        
    4.  Execute the instruction ([memory.copy](#syntax-instr-memory) x1​ x2​).
        

​z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([memory.copy](#syntax-instr-memory) x1​ x2​)if i1​+n\>∣z.[mems](#syntax-state)\[x1​\].[bytes](#syntax-meminst)∣∨i2​+n\>∣z.[mems](#syntax-state)\[x2​\].[bytes](#syntax-meminst)∣z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([memory.copy](#syntax-instr-memory) x1​ x2​)z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([memory.copy](#syntax-instr-memory) x1​ x2​)(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x2​) ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x1​)(at1​.[const](#syntax-instr-numeric) i1​+1) (at2​.[const](#syntax-instr-numeric) i2​+1) (at′.[const](#syntax-instr-numeric) n−1) ([memory.copy](#syntax-instr-memory) x1​ x2​)​​otherwise, if i1​≤i2​​z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([memory.copy](#syntax-instr-memory) x1​ x2​)(at1​.[const](#syntax-instr-numeric) i1​+n−1) (at2​.[const](#syntax-instr-numeric) i2​+n−1) ([i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x2​) ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x1​)(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n−1) ([memory.copy](#syntax-instr-memory) x1​ x2​)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​otherwise, if n\=0​​

##### 4.6.8.12. [memory.init](#syntax-instr-memory) x y[](#-hrefsyntax-instr-memorymathsfmemoryinitxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-memory-init), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-memory-init), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) from the stack.
    
6.  Assert: Due to [validation](#valid-memory-init), a [number value](#syntax-num) is on the top of the stack.
    
7.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
8.  If i+n\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
9.  If j+n\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣, then:
    
    1.  Trap.
        
10.  If n\=0, then:
    
    1.  Do nothing.
        
11.  Else:
    
    1.  Assert: Due to [validation](#valid-memory-init), j<∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣.
        
    2.  Push the value (at.[const](#syntax-instr-numeric) i) to the stack.
        
    3.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[j\]) to the stack.
        
    4.  Execute the instruction ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x).
        
    5.  Push the value (at.[const](#syntax-instr-numeric) i+1) to the stack.
        
    6.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) to the stack.
        
    7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
        
    8.  Execute the instruction ([memory.init](#syntax-instr-memory) x y).
        

​z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([memory.init](#syntax-instr-memory) x y)if i+n\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣∨j+n\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([memory.init](#syntax-instr-memory) x y)z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([memory.init](#syntax-instr-memory) x y)(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[j\]) ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x)(at.[const](#syntax-instr-numeric) i+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([memory.init](#syntax-instr-memory) x y)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​otherwise, if n\=0​​

##### 4.6.8.13. [data.drop](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfdatadropx①)

1.  Let z be the current state.
    
2.  Replace z.[datas](#syntax-state)\[x\].bytes with ϵ.
    

​z;([data.drop](#syntax-instr-memory) x)​[↪](#exec-notation)​z\[.[datas](#syntax-state)\[x\].[bytes](#syntax-datainst)\=ϵ\];ϵ​​

#### 4.6.9. Reference Instructions[](#reference-instructions⑤)

##### 4.6.9.1. [ref.null](#syntax-instr-ref) x[](#-hrefsyntax-instr-refmathsfrefnullx)

1.  Let F be the [current](#exec-notation-textual) [frame](#syntax-frame).
    
2.  Assert: due to [validation](#valid-ref-null), the [defined type](#syntax-deftype) F.[module](#syntax-frame).[types](#syntax-moduleinst)\[x\] exists.
    
3.  Let [deftype](#syntax-deftype) be the [defined type](#syntax-deftype) F.[module](#syntax-frame).[types](#syntax-moduleinst)\[x\].
    
4.  Push the value [ref.null](#syntax-instr-ref) [deftype](#syntax-deftype) to the stack.
    

​z;([ref.null](#syntax-instr-ref) x)​[↪](#exec-notation)​([ref.null](#syntax-instr-ref) z.[types](#syntax-state)\[x\])​​

Note

No formal reduction rule is required for the case [ref.null](#syntax-instr-ref) [absheaptype](#syntax-absheaptype), since the instruction form is already a [value](#syntax-val).

##### 4.6.9.2. [ref.func](#syntax-instr-ref) x[](#-hrefsyntax-instr-refmathsfreffuncx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-ref-func), x<∣z.[module](#syntax-state).[funcs](#syntax-moduleinst)∣.
    
3.  Push the value ([ref.func](#syntax-ref) z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\]) to the stack.
    

​z;([ref.func](#syntax-instr-ref) x)​[↪](#exec-notation)​([ref.func](#syntax-ref) z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\])​​

##### 4.6.9.3. [ref.is\_null](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefis_null①)

1.  Assert: Due to [validation](#valid-ref-is-null), a [reference value](#syntax-ref) is on the top of the stack.
    
2.  Pop the value [ref](#syntax-ref) from the stack.
    
3.  If [ref](#syntax-ref) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) to the stack.
        
4.  Else:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) to the stack.
        

​[ref](#syntax-ref) [ref.is\_null](#syntax-instr-ref)[ref](#syntax-ref) [ref.is\_null](#syntax-instr-ref)​[↪](#exec-notation)[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1)([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0)​if [ref](#syntax-ref)\=([ref.null](#syntax-instr-ref) ht)otherwise​​

##### 4.6.9.4. [ref.as\_non\_null](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefas_non_null①)

1.  Assert: Due to [validation](#valid-ref-as-non-null), a [reference value](#syntax-ref) is on the top of the stack.
    
2.  Pop the value [ref](#syntax-ref) from the stack.
    
3.  If [ref](#syntax-ref) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
4.  Push the value [ref](#syntax-ref) to the stack.
    

​[ref](#syntax-ref) [ref.as\_non\_null](#syntax-instr-ref)[ref](#syntax-ref) [ref.as\_non\_null](#syntax-instr-ref)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[ref](#syntax-ref)​if [ref](#syntax-ref)\=([ref.null](#syntax-instr-ref) ht)otherwise​​

##### 4.6.9.5. [ref.eq](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefeq①)

1.  Assert: Due to [validation](#valid-ref-eq), a [reference value](#syntax-ref) is on the top of the stack.
    
2.  Pop the value [ref](#syntax-ref)2​ from the stack.
    
3.  Assert: Due to [validation](#valid-ref-eq), a [reference value](#syntax-ref) is on the top of the stack.
    
4.  Pop the value [ref](#syntax-ref)1​ from the stack.
    
5.  If [ref](#syntax-ref)1​ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype) and [ref](#syntax-ref)2​ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) to the stack.
        
6.  Else if [ref](#syntax-ref)1​\=[ref](#syntax-ref)2​, then:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) to the stack.
        
7.  Else:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) to the stack.
        

​[ref](#syntax-ref)1​ [ref](#syntax-ref)2​ [ref.eq](#syntax-instr-ref)[ref](#syntax-ref)1​ [ref](#syntax-ref)2​ [ref.eq](#syntax-instr-ref)[ref](#syntax-ref)1​ [ref](#syntax-ref)2​ [ref.eq](#syntax-instr-ref)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1)([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1)([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0)​if [ref](#syntax-ref)1​\=([ref.null](#syntax-instr-ref) ht1​)∧[ref](#syntax-ref)2​\=([ref.null](#syntax-instr-ref) ht2​)otherwise, if [ref](#syntax-ref)1​\=[ref](#syntax-ref)2​otherwise​​

##### 4.6.9.6. [ref.test](#syntax-instr-ref) rt[](#-hrefsyntax-instr-refmathsfreftestmathitrt①)

1.  Let f be the topmost frame.
    
2.  Assert: Due to [validation](#valid-ref-test), a [reference value](#syntax-ref) is on the top of the stack.
    
3.  Pop the value [ref](#syntax-ref) from the stack.
    
4.  Let rt′ be the type of [ref](#syntax-ref).
    
5.  If rt′ matches [clos](#type-inst)f.[module](#syntax-frame)​(rt), then:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) to the stack.
        
6.  Else:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) to the stack.
        

​s;f;[ref](#syntax-ref) ([ref.test](#syntax-instr-ref) rt)s;f;[ref](#syntax-ref) ([ref.test](#syntax-instr-ref) rt)​[↪](#exec-notation)[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1)([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0)​if s[⊢](#valid-ref)[ref](#syntax-ref):rt′∧ {}[⊢](#match-reftype)rt′[≤](#match-reftype)[clos](#type-inst)f.[module](#syntax-frame)​(rt)​otherwise​​

##### 4.6.9.7. [ref.cast](#syntax-instr-ref) rt[](#-hrefsyntax-instr-refmathsfrefcastmathitrt①)

1.  Let f be the topmost frame.
    
2.  Assert: Due to [validation](#valid-ref-cast), a [reference value](#syntax-ref) is on the top of the stack.
    
3.  Pop the value [ref](#syntax-ref) from the stack.
    
4.  Let rt′ be the type of [ref](#syntax-ref).
    
5.  If rt′ does not match [clos](#type-inst)f.[module](#syntax-frame)​(rt), then:
    
    1.  Trap.
        
6.  Push the value [ref](#syntax-ref) to the stack.
    

​s;f;[ref](#syntax-ref) ([ref.cast](#syntax-instr-ref) rt)s;f;[ref](#syntax-ref) ([ref.cast](#syntax-instr-ref) rt)​[↪](#exec-notation)[↪](#exec-notation)​[ref](#syntax-ref)[trap](#syntax-trap)​if s[⊢](#valid-ref)[ref](#syntax-ref):rt′∧ {}[⊢](#match-reftype)rt′[≤](#match-reftype)[clos](#type-inst)f.[module](#syntax-frame)​(rt)​otherwise​​

##### 4.6.9.8. [ref.i31](#syntax-instr-i31)[](#-hrefsyntax-instr-i31mathsfrefiscriptstyle31①)

1.  Assert: Due to [validation](#valid-ref-i31), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
3.  Push the value ([ref.i31](#syntax-ref) [wrap](#op-wrap)32,31​(i)) to the stack.
    

​([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [ref.i31](#syntax-instr-i31)​[↪](#exec-notation)​([ref.i31](#syntax-ref) [wrap](#op-wrap)32,31​(i))​​

##### 4.6.9.9. [i31.get](#syntax-instr-i31)\_[sx](#syntax-sx)[](#-hrefsyntax-instr-i31mathsfiscriptstyle31getmathsf_hrefsyntax-sxmathitsx①)

1.  Assert: Due to [validation](#valid-i31-get), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
4.  Assert: Due to [validation](#valid-i31-get), [val](#syntax-val) is some [ref.i31](#syntax-ref) [u31](#syntax-int).
    
5.  Let ([ref.i31](#syntax-ref) i) be the destructuring of [val](#syntax-val).
    
6.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) [extend](#op-extend)31,32[sx](#syntax-sx)​(i)) to the stack.
    

​([ref.null](#syntax-instr-ref) ht) ([i31.get](#syntax-instr-i31)\_[sx](#syntax-sx))([ref.i31](#syntax-ref) i) ([i31.get](#syntax-instr-i31)\_[sx](#syntax-sx))​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)([i32](#syntax-numtype).[const](#syntax-instr-numeric) [extend](#op-extend)31,32[sx](#syntax-sx)​(i))​​

##### 4.6.9.10. [struct.new](#syntax-instr-struct) x[](#-hrefsyntax-instr-structmathsfstructnewx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-struct-new), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [struct](#syntax-comptype) [list](#syntax-list)([fieldtype](#syntax-fieldtype)).
    
3.  Let ([struct](#syntax-comptype) [list](#syntax-list)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
4.  Let ([mut](#syntax-mut)? zt)n be [list](#syntax-list)0​.
    
5.  Let a be the length of z.[structs](#syntax-state).
    
6.  Assert: Due to [validation](#valid-struct-new), there are at least n values on the top of the stack.
    
7.  Pop the values [val](#syntax-val)n from the stack.
    
8.  Let si be the [structure instance](#syntax-structinst) {[type](#syntax-structinst) z.[types](#syntax-state)\[x\],[fields](#syntax-structinst) [pack](#aux-packfield)zt​([val](#syntax-val))n}.
    
9.  Push the value ([ref.struct](#syntax-ref) a) to the stack.
    
10.  Append si to z.[structs](#syntax-state).
    

​z;[val](#syntax-val)n ([struct.new](#syntax-instr-struct) x)​[↪](#exec-notation)​z\[.[structs](#syntax-state)\=⊕si\];([ref.struct](#syntax-ref) a)​if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)n∧ a\=∣z.[structs](#syntax-state)∣∧ si\={[type](#syntax-structinst) z.[types](#syntax-state)\[x\],[fields](#syntax-structinst) ([pack](#aux-packfield)zt​([val](#syntax-val)))n}​​​

##### 4.6.9.11. [struct.new\_default](#syntax-instr-struct) x[](#-hrefsyntax-instr-structmathsfstructnew_defaultx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-struct-new-default), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [struct](#syntax-comptype) [list](#syntax-list)([fieldtype](#syntax-fieldtype)).
    
3.  Let ([struct](#syntax-comptype) [list](#syntax-list)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
4.  Let ([mut](#syntax-mut)? zt)∗ be [list](#syntax-list)0​.
    
5.  Assert: Due to [validation](#valid-struct-new-default), for all zt in zt∗, [default](#aux-default)[unpack](#aux-unpack)(zt)​ is defined.
    
6.  Let [val](#syntax-val)∗ be the value sequence ϵ.
    
7.  For each zt in zt∗, do:
    
    1.  Let [val](#syntax-val) be [default](#aux-default)[unpack](#aux-unpack)(zt)​.
        
    2.  Append [val](#syntax-val) to [val](#syntax-val)∗.
        
8.  Assert: Due to [validation](#valid-struct-new-default), ∣[val](#syntax-val)∗∣\=∣zt∗∣.
    
9.  Push the values [val](#syntax-val)∗ to the stack.
    
10.  Execute the instruction ([struct.new](#syntax-instr-struct) x).
    

​z;([struct.new\_default](#syntax-instr-struct) x)​[↪](#exec-notation)​[val](#syntax-val)∗ ([struct.new](#syntax-instr-struct) x)​if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗∧ ([default](#aux-default)[unpack](#aux-unpack)(zt)​\=[val](#syntax-val))∗​​​

##### 4.6.9.12. [struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x i[](#-hrefsyntax-instr-structmathsfstructgetmathsf_hrefsyntax-sxmathitsxxi)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-struct-get), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
5.  Assert: Due to [validation](#valid-struct-get), [val](#syntax-val) is some [ref.struct](#syntax-ref) [structaddr](#syntax-structaddr).
    
6.  Let ([ref.struct](#syntax-ref) a) be the destructuring of [val](#syntax-val).
    
7.  Assert: Due to [validation](#valid-struct-get), i<∣z.[structs](#syntax-state)\[a\].[fields](#syntax-structinst)∣.
    
8.  Assert: Due to [validation](#valid-struct-get), a<∣z.[structs](#syntax-state)∣.
    
9.  Assert: Due to [validation](#valid-struct-get), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [struct](#syntax-comptype) [list](#syntax-list)([fieldtype](#syntax-fieldtype)).
    
10.  Let ([struct](#syntax-comptype) [list](#syntax-list)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
11.  Let ([mut](#syntax-mut)? zt)∗ be [list](#syntax-list)0​.
    
12.  Assert: Due to [validation](#valid-struct-get), i<∣zt∗∣.
    
13.  Push the value [unpack](#aux-unpackfield)zt∗\[i\][sx](#syntax-sx)?​(z.[structs](#syntax-state)\[a\].[fields](#syntax-structinst)\[i\]) to the stack.
    

​z;([ref.null](#syntax-instr-ref) ht) ([struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x i)z;([ref.struct](#syntax-ref) a) ([struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x i)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[unpack](#aux-unpackfield)zt∗\[i\][sx](#syntax-sx)?​(z.[structs](#syntax-state)\[a\].[fields](#syntax-structinst)\[i\])if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗​​​

##### 4.6.9.13. [struct.set](#syntax-instr-struct) x i[](#-hrefsyntax-instr-structmathsfstructsetxi)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-struct-set), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  Assert: Due to [validation](#valid-struct-set), a value is on the top of the stack.
    
5.  Pop the value [val](#syntax-val)′ from the stack.
    
6.  If [val](#syntax-val)′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
7.  Assert: Due to [validation](#valid-struct-set), [val](#syntax-val)′ is some [ref.struct](#syntax-ref) [structaddr](#syntax-structaddr).
    
8.  Let ([ref.struct](#syntax-ref) a) be the destructuring of [val](#syntax-val)′.
    
9.  Assert: Due to [validation](#valid-struct-set), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [struct](#syntax-comptype) [list](#syntax-list)([fieldtype](#syntax-fieldtype)).
    
10.  Let ([struct](#syntax-comptype) [list](#syntax-list)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
11.  Let ([mut](#syntax-mut)? zt)∗ be [list](#syntax-list)0​.
    
12.  Assert: Due to [validation](#valid-struct-set), i<∣zt∗∣.
    
13.  Replace z.[structs](#syntax-state)\[a\].fields\[i\] with [pack](#aux-packfield)zt∗\[i\]​([val](#syntax-val)).
    

​z;([ref.null](#syntax-instr-ref) ht) [val](#syntax-val) ([struct.set](#syntax-instr-struct) x i)z;([ref.struct](#syntax-ref) a) [val](#syntax-val) ([struct.set](#syntax-instr-struct) x i)​[↪](#exec-notation)[↪](#exec-notation)​z;[trap](#syntax-trap)z\[.[structs](#syntax-state)\[a\].[fields](#syntax-structinst)\[i\]\=[pack](#aux-packfield)zt∗\[i\]​([val](#syntax-val))\];ϵif z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗​​​

##### 4.6.9.14. [array.new](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraynewx①)

1.  Assert: Due to [validation](#valid-array-new), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
3.  Assert: Due to [validation](#valid-array-new), a value is on the top of the stack.
    
4.  Pop the value [val](#syntax-val) from the stack.
    
5.  Push the values [val](#syntax-val)n to the stack.
    
6.  Execute the instruction ([array.new\_fixed](#syntax-instr-array) x n).
    

​[val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new](#syntax-instr-array) x)​[↪](#exec-notation)​[val](#syntax-val)n ([array.new\_fixed](#syntax-instr-array) x n)​​

##### 4.6.9.15. [array.new\_default](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraynew_defaultx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-new-default), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-new-default), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
    
5.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
6.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
    
7.  Assert: Due to [validation](#valid-array-new-default), [default](#aux-default)[unpack](#aux-unpack)(zt)​ is defined.
    
8.  Let [val](#syntax-val) be [default](#aux-default)[unpack](#aux-unpack)(zt)​.
    
9.  Push the values [val](#syntax-val)n to the stack.
    
10.  Execute the instruction ([array.new\_fixed](#syntax-instr-array) x n).
    

​z;([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new\_default](#syntax-instr-array) x)​[↪](#exec-notation)​[val](#syntax-val)n ([array.new\_fixed](#syntax-instr-array) x n)​if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ [default](#aux-default)[unpack](#aux-unpack)(zt)​\=[val](#syntax-val)​​​

##### 4.6.9.16. [array.new\_fixed](#syntax-instr-array) x n[](#-hrefsyntax-instr-arraymathsfarraynew_fixedxn①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-new-fixed), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
    
3.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
4.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
    
5.  Let a be the length of z.[arrays](#syntax-state).
    
6.  Assert: Due to [validation](#valid-array-new-fixed), there are at least n values on the top of the stack.
    
7.  Pop the values [val](#syntax-val)n from the stack.
    
8.  Let ai be the [array instance](#syntax-arrayinst) {[type](#syntax-arrayinst) z.[types](#syntax-state)\[x\],[fields](#syntax-arrayinst) [pack](#aux-packfield)zt​([val](#syntax-val))n}.
    
9.  Push the value ([ref.array](#syntax-ref) a) to the stack.
    
10.  Append ai to z.[arrays](#syntax-state).
    

​z;[val](#syntax-val)n ([array.new\_fixed](#syntax-instr-array) x n)​[↪](#exec-notation)​z\[.[arrays](#syntax-state)\=⊕ai\];([ref.array](#syntax-ref) a)if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ a\=∣z.[arrays](#syntax-state)∣∧ai\={[type](#syntax-arrayinst) z.[types](#syntax-state)\[x\],[fields](#syntax-arrayinst) ([pack](#aux-packfield)zt​([val](#syntax-val)))n}​​​

##### 4.6.9.17. [array.new\_data](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarraynew_dataxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-new-data), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-new-data), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
6.  Assert: Due to [validation](#valid-array-new-data), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
    
7.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
8.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
    
9.  If i+n⋅∣zt∣/8\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣, then:
    
    1.  Trap.
        
10.  Let [byte](#syntax-byte)∗∗ be the result for which each [byte](#syntax-byte)∗ has length ∣zt∣/8, and the [concatenation](#notation-concat) of [byte](#syntax-byte)∗∗ is z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[i:n⋅∣zt∣/8\].
    
11.  Let cn be the result for which ([bytes](#aux-bytes)zt​(cn)\=[byte](#syntax-byte)∗)∗.
    
12.  Push the values [unpack](#aux-unpack)(zt).[const](#syntax-instr-numeric) [unpack](#aux-unpacknum)zt​(c)n to the stack.
    
13.  Execute the instruction ([array.new\_fixed](#syntax-instr-array) x n).
    

​z;([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new\_data](#syntax-instr-array) x y)z;([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new\_data](#syntax-instr-array) x y)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ i+n⋅∣zt∣/8\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣​([unpack](#aux-unpack)(zt).[const](#syntax-instr-numeric) [unpack](#aux-unpacknum)zt​(c))n ([array.new\_fixed](#syntax-instr-array) x n)if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ [⨁](#notation-concat)[bytes](#aux-bytes)zt​(c)n\=z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[i:n⋅∣zt∣/8\]​​​​

##### 4.6.9.18. [array.new\_elem](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarraynew_elemxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-new-elem), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-new-elem), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
6.  If i+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣, then:
    
    1.  Trap.
        
7.  Let [ref](#syntax-ref)n be z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[i:n\].
    
8.  Push the values [ref](#syntax-ref)n to the stack.
    
9.  Execute the instruction ([array.new\_fixed](#syntax-instr-array) x n).
    

​z;([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new\_elem](#syntax-instr-array) x y)z;([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new\_elem](#syntax-instr-array) x y)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[ref](#syntax-ref)n ([array.new\_fixed](#syntax-instr-array) x n)if [ref](#syntax-ref)n\=z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[i:n\]​if i+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣​​

##### 4.6.9.19. [array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x[](#-hrefsyntax-instr-arraymathsfarraygetmathsf_hrefsyntax-sxmathitsxx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-get), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
4.  Assert: Due to [validation](#valid-array-get), a value is on the top of the stack.
    
5.  Pop the value [val](#syntax-val) from the stack.
    
6.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
7.  Assert: Due to [validation](#valid-array-get), [val](#syntax-val) is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
8.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val).
    
9.  If a<∣z.[arrays](#syntax-state)∣ and i≥∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣, then:
    
    1.  Trap.
        
10.  If i<∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣ and a<∣z.[arrays](#syntax-state)∣, then:
    
    1.  Assert: Due to [validation](#valid-array-get), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
        
    2.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
        
    3.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
        
    4.  Push the value [unpack](#aux-unpackfield)zt[sx](#syntax-sx)?​(z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)\[i\]) to the stack.
        

​z;([ref.null](#syntax-instr-ref) ht) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[trap](#syntax-trap)[unpack](#aux-unpackfield)zt[sx](#syntax-sx)?​(z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)\[i\])if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)​if i≥∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣​​

##### 4.6.9.20. [array.set](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraysetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-set), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  Assert: Due to [validation](#valid-array-set), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
6.  Assert: Due to [validation](#valid-array-set), a value is on the top of the stack.
    
7.  Pop the value [val](#syntax-val)′ from the stack.
    
8.  If [val](#syntax-val)′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
9.  Assert: Due to [validation](#valid-array-set), [val](#syntax-val)′ is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
10.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val)′.
    
11.  If a<∣z.[arrays](#syntax-state)∣ and i≥∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣, then:
    
    1.  Trap.
        
12.  Assert: Due to [validation](#valid-array-set), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
    
13.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
14.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
    
15.  Replace z.[arrays](#syntax-state)\[a\].fields\[i\] with [pack](#aux-packfield)zt​([val](#syntax-val)).
    

​z;([ref.null](#syntax-instr-ref) ht) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([array.set](#syntax-instr-array) x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([array.set](#syntax-instr-array) x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([array.set](#syntax-instr-array) x)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​z;[trap](#syntax-trap)z;[trap](#syntax-trap)z\[.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)\[i\]\=[pack](#aux-packfield)zt​([val](#syntax-val))\];ϵif z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)​if i≥∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣​​

##### 4.6.9.21. [array.len](#syntax-instr-array)[](#-hrefsyntax-instr-arraymathsfarraylen①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-len), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
5.  Assert: Due to [validation](#valid-array-len), [val](#syntax-val) is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
6.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val).
    
7.  Assert: Due to [validation](#valid-array-len), a<∣z.[arrays](#syntax-state)∣.
    
8.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) ∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣) to the stack.
    

​z;([ref.null](#syntax-instr-ref) ht) [array.len](#syntax-instr-array)z;([ref.array](#syntax-ref) a) [array.len](#syntax-instr-array)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)([i32](#syntax-numtype).[const](#syntax-instr-numeric) ∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣)​​

##### 4.6.9.22. [array.fill](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarrayfillx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-fill), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-fill), a value is on the top of the stack.
    
5.  Pop the value [val](#syntax-val) from the stack.
    
6.  Assert: Due to [validation](#valid-array-fill), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
7.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
8.  Assert: Due to [validation](#valid-array-fill), a value is on the top of the stack.
    
9.  Pop the value [val](#syntax-val)′ from the stack.
    
10.  If [val](#syntax-val)′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
11.  Assert: Due to [validation](#valid-array-fill), [val](#syntax-val)′ is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
12.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val)′.
    
13.  If a≥∣z.[arrays](#syntax-state)∣, then:
    
    1.  Do nothing.
        
14.  Else if i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣, then:
    
    1.  Trap.
        
15.  If n\=0, then:
    
    1.  Do nothing.
        
16.  Else:
    
    1.  Push the value ([ref.array](#syntax-ref) a) to the stack.
        
    2.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) to the stack.
        
    3.  Push the value [val](#syntax-val) to the stack.
        
    4.  Execute the instruction ([array.set](#syntax-instr-array) x).
        
    5.  Push the value ([ref.array](#syntax-ref) a) to the stack.
        
    6.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) to the stack.
        
    7.  Push the value [val](#syntax-val) to the stack.
        
    8.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
        
    9.  Execute the instruction ([array.fill](#syntax-instr-array) x).
        

​z;([ref.null](#syntax-instr-ref) ht) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.fill](#syntax-instr-array) x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.fill](#syntax-instr-array) x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.fill](#syntax-instr-array) x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.fill](#syntax-instr-array) x)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([array.set](#syntax-instr-array) x)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) [val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([array.fill](#syntax-instr-array) x)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[trap](#syntax-trap)ϵ​if i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣otherwise, if n\=0​​

##### 4.6.9.23. [array.copy](#syntax-instr-array) x1​ x2​[](#-hrefsyntax-instr-arraymathsfarraycopyx_1x_2)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-copy), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-copy), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) from the stack.
    
6.  Assert: Due to [validation](#valid-array-copy), a value is on the top of the stack.
    
7.  Pop the value [val](#syntax-val) from the stack.
    
8.  Assert: Due to [validation](#valid-array-copy), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
9.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) from the stack.
    
10.  Assert: Due to [validation](#valid-array-copy), a value is on the top of the stack.
    
11.  Pop the value [val](#syntax-val)′ from the stack.
    
12.  If [val](#syntax-val)′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype) and [val](#syntax-val) is reference value, then:
    
    1.  Trap.
        
13.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype) and [val](#syntax-val)′ is reference value, then:
    
    1.  Trap.
        
14.  If [val](#syntax-val)′ is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr), then:
    
    1.  Let ([ref.array](#syntax-ref) a1​) be the destructuring of [val](#syntax-val)′.
        
    2.  If [val](#syntax-val) is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr), then:
        
        1.  If a1​<∣z.[arrays](#syntax-state)∣ and i1​+n\>∣z.[arrays](#syntax-state)\[a1​\].[fields](#syntax-arrayinst)∣, then:
            
            1.  Trap.
                
        2.  Let ([ref.array](#syntax-ref) a2​) be the destructuring of [val](#syntax-val).
            
        3.  If a2​≥∣z.[arrays](#syntax-state)∣, then:
            
            1.  Do nothing.
                
        4.  Else if i2​+n\>∣z.[arrays](#syntax-state)\[a2​\].[fields](#syntax-arrayinst)∣, then:
            
            1.  Trap.
                
        5.  If n\=0, then:
            
            1.  Do nothing.
                
        6.  Else:
            
            1.  Assert: Due to [validation](#valid-array-copy), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x2​\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
                
            2.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x2​\].
                
            3.  Let ([mut](#syntax-mut)? zt2​) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
                
            4.  Let [sx](#syntax-sx)? be [sx](#syntax-sx)(zt2​).
                
            5.  Push the value ([ref.array](#syntax-ref) a1​) to the stack.
                
            6.  If i1​≤i2​, then:
                
                1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) to the stack.
                    
                2.  Push the value ([ref.array](#syntax-ref) a2​) to the stack.
                    
                3.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) to the stack.
                    
                4.  Execute the instruction ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x2​).
                    
                5.  Execute the instruction ([array.set](#syntax-instr-array) x1​).
                    
                6.  Push the value ([ref.array](#syntax-ref) a1​) to the stack.
                    
                7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​+1) to the stack.
                    
                8.  Push the value ([ref.array](#syntax-ref) a2​) to the stack.
                    
                9.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​+1) to the stack.
                    
            7.  Else:
                
                1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​+n−1) to the stack.
                    
                2.  Push the value ([ref.array](#syntax-ref) a2​) to the stack.
                    
                3.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​+n−1) to the stack.
                    
                4.  Execute the instruction ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x2​).
                    
                5.  Execute the instruction ([array.set](#syntax-instr-array) x1​).
                    
                6.  Push the value ([ref.array](#syntax-ref) a1​) to the stack.
                    
                7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) to the stack.
                    
                8.  Push the value ([ref.array](#syntax-ref) a2​) to the stack.
                    
                9.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) to the stack.
                    
            8.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
                
            9.  Execute the instruction ([array.copy](#syntax-instr-array) x1​ x2​).
                

​z;([ref.null](#syntax-instr-ref) ht1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) [ref](#syntax-ref) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)z;[ref](#syntax-ref) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.null](#syntax-instr-ref) ht2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)z;([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)if i1​+n\>∣z.[arrays](#syntax-state)\[a1​\].[fields](#syntax-arrayinst)∣z;([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)if i2​+n\>∣z.[arrays](#syntax-state)\[a2​\].[fields](#syntax-arrayinst)∣z;([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)otherwise, if n\=0z;([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​)([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​)([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x2​) ([array.set](#syntax-instr-array) x1​)([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​+1) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([array.copy](#syntax-instr-array) x1​ x2​)​otherwise, if z.[types](#syntax-state)\[x2​\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt2​)∧ i1​≤i2​∧[sx](#syntax-sx)?\=[sx](#syntax-sx)(zt2​)​​​​​z;([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​+n−1)([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​+n−1)([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x2​) ([array.set](#syntax-instr-array) x1​)([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([array.copy](#syntax-instr-array) x1​ x2​)​otherwise, if z.[types](#syntax-state)\[x2​\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt2​)∧ [sx](#syntax-sx)?\=[sx](#syntax-sx)(zt2​)​​​​​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[trap](#syntax-trap)[trap](#syntax-trap)[trap](#syntax-trap)ϵ​​​

Where:

[sx](#syntax-sx)([consttype](#syntax-consttype))[sx](#syntax-sx)([packtype](#syntax-packtype))​\=\=​ϵ[s](#syntax-sx)​​

##### 4.6.9.24. [array.init\_data](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarrayinit_dataxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-init-data), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-init-data), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) from the stack.
    
6.  Assert: Due to [validation](#valid-array-init-data), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
7.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
8.  Assert: Due to [validation](#valid-array-init-data), a value is on the top of the stack.
    
9.  Pop the value [val](#syntax-val) from the stack.
    
10.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
11.  Assert: Due to [validation](#valid-array-init-data), [val](#syntax-val) is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
12.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val).
    
13.  If a<∣z.[arrays](#syntax-state)∣ and i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣, then:
    
    1.  Trap.
        
14.  If the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype), then:
    
    1.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
        
    2.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
        
    3.  If j+n⋅∣zt∣/8\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣, then:
        
        1.  Trap.
            
    4.  If n\=0, then:
        
        1.  Do nothing.
            
    5.  Else:
        
        1.  Let c be the result for which [bytes](#aux-bytes)zt​(c) \= z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[j:∣zt∣/8\].
            
        2.  Push the value ([ref.array](#syntax-ref) a) to the stack.
            
        3.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) to the stack.
            
        4.  Push the value [unpack](#aux-unpack)(zt).[const](#syntax-instr-numeric) [unpack](#aux-unpacknum)zt​(c) to the stack.
            
        5.  Execute the instruction ([array.set](#syntax-instr-array) x).
            
        6.  Push the value ([ref.array](#syntax-ref) a) to the stack.
            
        7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) to the stack.
            
        8.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+∣zt∣/8) to the stack.
            
        9.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
            
        10.  Execute the instruction ([array.init\_data](#syntax-instr-array) x y).
            
15.  Else if n\=0, then:
    
    1.  Do nothing.
        

​z;([ref.null](#syntax-instr-ref) ht) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_data](#syntax-instr-array) x y)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_data](#syntax-instr-array) x y)if i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_data](#syntax-instr-array) x y)if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ j+n⋅∣zt∣/8\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣​z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_data](#syntax-instr-array) x y)otherwise, if n\=0z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_data](#syntax-instr-array) x y)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([unpack](#aux-unpack)(zt).[const](#syntax-instr-numeric) [unpack](#aux-unpacknum)zt​(c)) ([array.set](#syntax-instr-array) x)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+∣zt∣/8) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([array.init\_data](#syntax-instr-array) x y)​otherwise, if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ [bytes](#aux-bytes)zt​(c)\=z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[j:∣zt∣/8\]​​​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[trap](#syntax-trap)[trap](#syntax-trap)ϵ​​​

##### 4.6.9.25. [array.init\_elem](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarrayinit_elemxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-init-elem), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-init-elem), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) from the stack.
    
6.  Assert: Due to [validation](#valid-array-init-elem), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
7.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
8.  Assert: Due to [validation](#valid-array-init-elem), a value is on the top of the stack.
    
9.  Pop the value [val](#syntax-val) from the stack.
    
10.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
11.  Assert: Due to [validation](#valid-array-init-elem), [val](#syntax-val) is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
12.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val).
    
13.  If a<∣z.[arrays](#syntax-state)∣ and i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣, then:
    
    1.  Trap.
        
14.  If j+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣, then:
    
    1.  Trap.
        
15.  If n\=0, then:
    
    1.  Do nothing.
        
16.  Else if j<∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣, then:
    
    1.  Let [ref](#syntax-ref) be the [reference value](#syntax-ref) z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[j\].
        
    2.  Push the value ([ref.array](#syntax-ref) a) to the stack.
        
    3.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) to the stack.
        
    4.  Push the value [ref](#syntax-ref) to the stack.
        
    5.  Execute the instruction ([array.set](#syntax-instr-array) x).
        
    6.  Push the value ([ref.array](#syntax-ref) a) to the stack.
        
    7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) to the stack.
        
    8.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) to the stack.
        
    9.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
        
    10.  Execute the instruction ([array.init\_elem](#syntax-instr-array) x y).
        

​z;([ref.null](#syntax-instr-ref) ht) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_elem](#syntax-instr-array) x y)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_elem](#syntax-instr-array) x y)if i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_elem](#syntax-instr-array) x y)if j+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_elem](#syntax-instr-array) x y)otherwise, if n\=0z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_elem](#syntax-instr-array) x y)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [ref](#syntax-ref) ([array.set](#syntax-instr-array) x)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([array.init\_elem](#syntax-instr-array) x y)​otherwise, if [ref](#syntax-ref)\=z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[j\]​​​​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[trap](#syntax-trap)[trap](#syntax-trap)ϵ​​​

##### 4.6.9.26. [any.convert\_extern](#syntax-instr-extern)[](#-hrefsyntax-instr-externmathsfanyconvert_extern①)

1.  Assert: Due to [validation](#valid-any-convert-extern), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Push the value ([ref.null](#syntax-instr-ref) [any](#syntax-heaptype)) to the stack.
        
4.  If [val](#syntax-val) is some [ref.extern](#syntax-ref) [addrref](#syntax-addrref), then:
    
    1.  Let ([ref.extern](#syntax-ref) [addrref](#syntax-addrref)) be the destructuring of [val](#syntax-val).
        
    2.  Push the value [addrref](#syntax-addrref) to the stack.
        

​([ref.null](#syntax-instr-ref) ht) [any.convert\_extern](#syntax-instr-extern)([ref.extern](#syntax-ref) [addrref](#syntax-addrref)) [any.convert\_extern](#syntax-instr-extern)​[↪](#exec-notation)[↪](#exec-notation)​([ref.null](#syntax-instr-ref) [any](#syntax-heaptype))[addrref](#syntax-addrref)​​

##### 4.6.9.27. [extern.convert\_any](#syntax-instr-extern)[](#-hrefsyntax-instr-externmathsfexternconvert_any①)

1.  Assert: Due to [validation](#valid-extern-convert-any), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Push the value ([ref.null](#syntax-instr-ref) [extern](#syntax-heaptype)) to the stack.
        
4.  If [val](#syntax-val) is address value, then:
    
    1.  Push the value ([ref.extern](#syntax-ref) [val](#syntax-val)) to the stack.
        

​([ref.null](#syntax-instr-ref) ht) [extern.convert\_any](#syntax-instr-extern)[addrref](#syntax-addrref) [extern.convert\_any](#syntax-instr-extern)​[↪](#exec-notation)[↪](#exec-notation)​([ref.null](#syntax-instr-ref) [extern](#syntax-heaptype))([ref.extern](#syntax-ref) [addrref](#syntax-addrref))​​

#### 4.6.10. Numeric Instructions[](#numeric-instructions⑤)

Numeric instructions are defined in terms of the generic [numeric operators](#exec-numeric). The mapping of numeric instructions to their underlying operators is expressed by the following definition:

op[iN](#syntax-numtype)​(i1​,…,ik​)op[fN](#syntax-numtype)​(z1​,…,zk​)​\=\=​[iop](#int-ops)N​(i1​,…,ik​)[fop](#float-ops)N​(z1​,…,zk​)​​

And for [conversion operators](#exec-cvtop):

[cvtop](#syntax-cvtop)t1​,t2​[sx](#syntax-sx)?​(c)​\=​[cvtop](#convert-ops)∣t1​∣,∣t2​∣[sx](#syntax-sx)?​(c)​​

Where the underlying operators are partial, the corresponding instruction will [trap](#trap) when the result is not defined. Where the underlying operators are non-deterministic, because they may return one of multiple possible [NaN](#syntax-nan) values, so are the corresponding instructions.

Note

For example, the result of instruction [i32](#syntax-numtype).[add](#syntax-instr-numeric) applied to operands i1​,i2​ invokes [add](#syntax-instr-numeric)[i32](#syntax-numtype)​(i1​,i2​), which maps to the generic [iadd](#op-iadd)32​(i1​,i2​) via the above definition. Similarly, [i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[f32](#syntax-numtype)\_s applied to z invokes [trunc](#syntax-instr-numeric)[f32](#syntax-numtype),[i64](#syntax-numtype)s​(z), which maps to the generic [truncs](#op-trunc)32,64​(z).

##### 4.6.10.1. nt.[const](#syntax-instr-numeric) c[](#-mathitntmathsfhrefsyntax-instr-numericmathsfconstc)

1.  Push the value (nt.[const](#syntax-instr-numeric) c) to the stack.
    

Note

No formal reduction rule is required for this instruction, since const instructions already are [values](#syntax-val).

##### 4.6.10.2. nt.[unop](#syntax-unop)[](#-mathitnt--hrefsyntax-unopmathitunop)

1.  Assert: Due to [validation](#valid-unop), a value of [number type](#syntax-numtype) nt is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  If [unop](#syntax-unop)nt​(c1​) is empty, then:
    
    1.  Trap.
        
4.  Let c be an element of [unop](#syntax-unop)nt​(c1​).
    
5.  Push the value (nt.[const](#syntax-instr-numeric) c) to the stack.
    

​(nt.[const](#syntax-instr-numeric) c1​) (nt.[unop](#syntax-unop))(nt.[const](#syntax-instr-numeric) c1​) (nt.[unop](#syntax-unop))​[↪](#exec-notation)[↪](#exec-notation)​(nt.[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[unop](#syntax-unop)nt​(c1​)if [unop](#syntax-unop)nt​(c1​)\=ϵ​​

##### 4.6.10.3. nt.[binop](#syntax-binop)[](#-mathitnt--hrefsyntax-binopmathitbinop)

1.  Assert: Due to [validation](#valid-binop), a value of [number type](#syntax-numtype) nt is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-binop), a [number value](#syntax-num) is on the top of the stack.
    
4.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  If [binop](#syntax-binop)nt​(c1​,c2​) is empty, then:
    
    1.  Trap.
        
6.  Let c be an element of [binop](#syntax-binop)nt​(c1​,c2​).
    
7.  Push the value (nt.[const](#syntax-instr-numeric) c) to the stack.
    

​(nt.[const](#syntax-instr-numeric) c1​) (nt.[const](#syntax-instr-numeric) c2​) (nt.[binop](#syntax-binop))(nt.[const](#syntax-instr-numeric) c1​) (nt.[const](#syntax-instr-numeric) c2​) (nt.[binop](#syntax-binop))​[↪](#exec-notation)[↪](#exec-notation)​(nt.[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[binop](#syntax-binop)nt​(c1​,c2​)if [binop](#syntax-binop)nt​(c1​,c2​)\=ϵ​​

##### 4.6.10.4. nt.[testop](#syntax-testop)[](#-mathitnt--hrefsyntax-testopmathittestop)

1.  Assert: Due to [validation](#valid-testop), a value of [number type](#syntax-numtype) nt is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let c be [testop](#syntax-testop)nt​(c1​).
    
4.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) to the stack.
    

​(nt.[const](#syntax-instr-numeric) c1​) (nt.[testop](#syntax-testop))​[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c)​if c\=[testop](#syntax-testop)nt​(c1​)​​

##### 4.6.10.5. nt.[relop](#syntax-relop)[](#-mathitnt--hrefsyntax-relopmathitrelop)

1.  Assert: Due to [validation](#valid-relop), a value of [number type](#syntax-numtype) nt is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-relop), a [number value](#syntax-num) is on the top of the stack.
    
4.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [relop](#syntax-relop)nt​(c1​,c2​).
    
6.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) to the stack.
    

​(nt.[const](#syntax-instr-numeric) c1​) (nt.[const](#syntax-instr-numeric) c2​) (nt.[relop](#syntax-relop))​[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c)​if c\=[relop](#syntax-relop)nt​(c1​,c2​)​​

##### 4.6.10.6. nt2​.[cvtop](#syntax-cvtop)\_nt1​[](#-mathitnt_2--hrefsyntax-cvtopmathitcvtopmathsf_mathitnt_1)

1.  Assert: Due to [validation](#valid-cvtop), a value of [number type](#syntax-numtype) nt1​ is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  If [cvtop](#syntax-cvtop)nt1​,nt2​​(c1​) is empty, then:
    
    1.  Trap.
        
4.  Let c be an element of [cvtop](#syntax-cvtop)nt1​,nt2​​(c1​).
    
5.  Push the value (nt2​.[const](#syntax-instr-numeric) c) to the stack.
    

​(nt1​.[const](#syntax-instr-numeric) c1​) (nt2​.[cvtop](#syntax-cvtop)\_nt1​)(nt1​.[const](#syntax-instr-numeric) c1​) (nt2​.[cvtop](#syntax-cvtop)\_nt1​)​[↪](#exec-notation)[↪](#exec-notation)​(nt2​.[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[cvtop](#syntax-cvtop)nt1​,nt2​​(c1​)if [cvtop](#syntax-cvtop)nt1​,nt2​​(c1​)\=ϵ​​

#### 4.6.11. Vector Instructions[](#vector-instructions⑤)

Vector instructions that operate bitwise are handled as integer operations of respective bit width.

op[vN](#syntax-vectype)​(i1​,…,ik​)​\=​[iop](#int-ops)N​(i1​,…,ik​)​​

Most other vector instructions are defined in terms of [numeric operators](#exec-numeric) that are applied lane-wise according to the given [shape](#syntax-shape).

optxN​(n1​,…,nk​)​\=​[lanes](#aux-lanes)txN−1​([op](#exec-instr-numeric)t​(i1​,…,ik​)∗)​(ifi1∗​\=[lanes](#aux-lanes)txN​(n1​)∧⋯∧ik∗​\=[lanes](#aux-lanes)txN​(nk​)​​

Note

For example, the result of instruction i32x4.[add](#syntax-instr-numeric) applied to operands v1​,v2​ invokes [add](#syntax-instr-numeric)i32x4​(v1​,v2​), which maps to [lanes](#aux-lanes)i32x4−1​([add](#syntax-instr-numeric)[i32](#syntax-numtype)​(i1​,i2​)∗), where i1∗​ and i2∗​ are sequences resulting from invoking [lanes](#aux-lanes)i32x4​(v1​) and [lanes](#aux-lanes)i32x4​(v2​) respectively.

For non-deterministic operators this definition is generalized to sets:

optxN​(n1​,…,nk​)​\=​{[lanes](#aux-lanes)txN−1​(i∗) ∣ i∗∈×([op](#exec-instr-numeric)t​(i1​,…,ik​)∗)∧i1∗​\=[lanes](#aux-lanes)txN​(n1​)∧⋯∧ik∗​\=[lanes](#aux-lanes)txN​(nk​)}​​

where ×{x∗}N transforms a sequence of N sets of values into a set of sequences of N values by computing the set product:

×(S1​…SN​)​\=​{x1​…xN​ ∣ x1​∈S1​∧⋯∧xN​∈SN​}​

The remaining vector operators use [individual definitions](#op-vec).

##### 4.6.11.1. [v128](#syntax-vectype).[const](#syntax-instr-vec) c[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-instr-vecmathsfconstc①)

1.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

Note

No formal reduction rule is required for this instruction, since const instructions are already [values](#syntax-val).

##### 4.6.11.2. [v128](#syntax-vectype).[vvunop](#syntax-vvunop)[](#-hrefsyntax-vectypemathsfvscriptstyle128--hrefsyntax-vvunopmathitvvunop)

1.  Assert: Due to [validation](#valid-vvunop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Assert: Due to [validation](#valid-vvunop), ∣[vvunop](#syntax-vvunop)[v128](#syntax-vectype)​(c1​)∣\>0.
    
4.  Let c be an element of [vvunop](#syntax-vvunop)[v128](#syntax-vectype)​(c1​).
    
5.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[vvunop](#syntax-vvunop))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c∈[vvunop](#syntax-vvunop)[v128](#syntax-vectype)​(c1​)​​

##### 4.6.11.3. [v128](#syntax-vectype).[vvbinop](#syntax-vvbinop)[](#-hrefsyntax-vectypemathsfvscriptstyle128--hrefsyntax-vvbinopmathitvvbinop)

1.  Assert: Due to [validation](#valid-vvbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vvbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Assert: Due to [validation](#valid-vvbinop), ∣[vvbinop](#syntax-vvbinop)[v128](#syntax-vectype)​(c1​,c2​)∣\>0.
    
6.  Let c be an element of [vvbinop](#syntax-vvbinop)[v128](#syntax-vectype)​(c1​,c2​).
    
7.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) ([v128](#syntax-vectype).[vvbinop](#syntax-vvbinop))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c∈[vvbinop](#syntax-vvbinop)[v128](#syntax-vectype)​(c1​,c2​)​​

##### 4.6.11.4. [v128](#syntax-vectype).[vvternop](#syntax-vvternop)[](#-hrefsyntax-vectypemathsfvscriptstyle128--hrefsyntax-vvternopmathitvvternop)

1.  Assert: Due to [validation](#valid-vvternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) from the stack.
    
3.  Assert: Due to [validation](#valid-vvternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
5.  Assert: Due to [validation](#valid-vvternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
6.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
7.  Assert: Due to [validation](#valid-vvternop), ∣[vvternop](#syntax-vvternop)[v128](#syntax-vectype)​(c1​,c2​,c3​)∣\>0.
    
8.  Let c be an element of [vvternop](#syntax-vvternop)[v128](#syntax-vectype)​(c1​,c2​,c3​).
    
9.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) ([v128](#syntax-vectype).[vvternop](#syntax-vvternop))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if c∈[vvternop](#syntax-vvternop)[v128](#syntax-vectype)​(c1​,c2​,c3​)​​

##### 4.6.11.5. [v128](#syntax-vectype).[any\_true](#syntax-instr-vec)[](#-hrefsyntax-vectypemathsfvscriptstyle128--hrefsyntax-instr-vecmathsfany_true)

1.  Assert: Due to [validation](#valid-vvtestop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let c be [inez](#op-inez)∣[v128](#syntax-vectype)∣​(c1​).
    
4.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[any\_true](#syntax-instr-vec))​[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c)​if c\=[inez](#op-inez)∣[v128](#syntax-vectype)∣​(c1​)​​

##### 4.6.11.6. sh.[vunop](#syntax-vunop)[](#-mathitsh--hrefsyntax-vunopmathitvunop)

1.  Assert: Due to [validation](#valid-vunop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  If [vunop](#syntax-vunop)sh​(c1​) is empty, then:
    
    1.  Trap.
        
4.  Let c be an element of [vunop](#syntax-vunop)sh​(c1​).
    
5.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (sh.[vunop](#syntax-vunop))([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (sh.[vunop](#syntax-vunop))​[↪](#exec-notation)[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[vunop](#syntax-vunop)sh​(c1​)if [vunop](#syntax-vunop)sh​(c1​)\=ϵ​​

##### 4.6.11.7. sh.[vbinop](#syntax-vbinop)[](#-mathitsh--hrefsyntax-vbinopmathitvbinop)

1.  Assert: Due to [validation](#valid-vbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  If [vbinop](#syntax-vbinop)sh​(c1​,c2​) is empty, then:
    
    1.  Trap.
        
6.  Let c be an element of [vbinop](#syntax-vbinop)sh​(c1​,c2​).
    
7.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh.[vbinop](#syntax-vbinop))([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh.[vbinop](#syntax-vbinop))​[↪](#exec-notation)[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[vbinop](#syntax-vbinop)sh​(c1​,c2​)if [vbinop](#syntax-vbinop)sh​(c1​,c2​)\=ϵ​​

##### 4.6.11.8. sh.[vternop](#syntax-vternop)[](#-mathitsh--hrefsyntax-vternopmathitvternop)

1.  Assert: Due to [validation](#valid-vternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) from the stack.
    
3.  Assert: Due to [validation](#valid-vternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
5.  Assert: Due to [validation](#valid-vternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
6.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
7.  If [vternop](#syntax-vternop)sh​(c1​,c2​,c3​) is empty, then:
    
    1.  Trap.
        
8.  Let c be an element of [vternop](#syntax-vternop)sh​(c1​,c2​,c3​).
    
9.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) (sh.[vternop](#syntax-vternop))([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) (sh.[vternop](#syntax-vternop))​[↪](#exec-notation)[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[vternop](#syntax-vternop)sh​(c1​,c2​,c3​)if [vternop](#syntax-vternop)sh​(c1​,c2​,c3​)\=ϵ​​

##### 4.6.11.9. [i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[all\_true](#syntax-instr-vec)[](#-hrefsyntax-numtypemathsfihrefsyntax-numtypescriptstylekern-01emnhrefsyntax-shapemathsfxm--hrefsyntax-instr-vecmathsfall_true)

1.  Assert: Due to [validation](#valid-vtestop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let i∗ be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​).
    
4.  Let c be Π[inez](#op-inez)N​(i)∗.
    
5.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[all\_true](#syntax-instr-vec))​[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c)​if i∗\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​)∧ c\=Π([inez](#op-inez)N​(i)∗)​​​

##### 4.6.11.10. sh.[vrelop](#syntax-vrelop)[](#-mathitsh--hrefsyntax-vrelopmathitvrelop)

1.  Assert: Due to [validation](#valid-vrelop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vrelop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [vrelop](#syntax-vrelop)sh​(c1​,c2​).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh.[vrelop](#syntax-vrelop))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[vrelop](#syntax-vrelop)sh​(c1​,c2​)​​

##### 4.6.11.11. sh.[vshiftop](#syntax-vshiftop)[](#-mathitsh--hrefsyntax-vshiftopmathitvshiftop)

1.  Assert: Due to [validation](#valid-vshiftop), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
3.  Assert: Due to [validation](#valid-vshiftop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [vshiftop](#syntax-vshiftop)sh​(c1​,i).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) (sh.[vshiftop](#syntax-vshiftop))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[vshiftop](#syntax-vshiftop)sh​(c1​,i)​​

##### 4.6.11.12. sh.[bitmask](#syntax-instr-vec)[](#-mathitshhrefsyntax-instr-vecmathsfbitmask)

1.  Assert: Due to [validation](#valid-vbitmask), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let c be [bitmask](#syntax-instr-vec)sh​(c1​).
    
4.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (sh.[bitmask](#syntax-instr-vec))​[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c)​if c\=[bitmask](#syntax-instr-vec)sh​(c1​)​​

##### 4.6.11.13. sh.swizzlop[](#-mathitsh--mathitswizzlop)

1.  Assert: Due to [validation](#valid-vswizzlop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vswizzlop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be swizzlopsh​(c1​,c2​).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh.swizzlop)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=swizzlopsh​(c1​,c2​)​​

##### 4.6.11.14. sh.[shuffle](#syntax-instr-vec) i∗[](#-mathitshhrefsyntax-instr-vecmathsfshuffleiast)

1.  Assert: Due to [validation](#valid-vshuffle), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vshuffle), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [shuffle](#syntax-instr-vec)sh​(i∗,c1​,c2​).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh.[shuffle](#syntax-instr-vec) i∗)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[shuffle](#syntax-instr-vec)sh​(i∗,c1​,c2​)​​

##### 4.6.11.15. [i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[splat](#syntax-instr-vec)[](#-hrefsyntax-numtypemathsfihrefsyntax-numtypescriptstylekern-01emnhrefsyntax-shapemathsfxmhrefsyntax-instr-vecmathsfsplat)

1.  Assert: Due to [validation](#valid-vsplat), a value is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Assert: Due to [validation](#valid-vsplat), [numtype](#syntax-numtype)0​\=[unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype)).
    
4.  Let c be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([pack](#aux-packnum)[i](#syntax-numtype)[N](#syntax-numtype)​(c1​)M).
    
5.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype)).[const](#syntax-instr-numeric) c1​) ([i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[splat](#syntax-instr-vec))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([pack](#aux-packnum)[i](#syntax-numtype)[N](#syntax-numtype)​(c1​)M)​​

##### 4.6.11.16. [lanetype](#syntax-lanetype)[x](#syntax-shape)M.[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx)′? i[](#-hrefsyntax-lanetypemathitlanetypehrefsyntax-shapemathsfxmhrefsyntax-instr-vecmathsfextract_lanemathsf_hrefsyntax-sxmathitsxi)

1.  Assert: Due to [validation](#valid-vextract-lane), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  If [sx](#syntax-sx)′? is not defined, then:
    
    1.  Assert: Due to [validation](#valid-vextract-lane), [lanetype](#syntax-lanetype) is number type.
        
    2.  Assert: Due to [validation](#valid-vextract-lane), i<∣[lanes](#aux-lanes)[lanetype](#syntax-lanetype)[x](#syntax-shape)M​(c1​)∣.
        
    3.  Let c2​ be [lanes](#aux-lanes)[lanetype](#syntax-lanetype)[x](#syntax-shape)M​(c1​)\[i\].
        
    4.  Push the value ([lanetype](#syntax-lanetype).[const](#syntax-instr-numeric) c2​) to the stack.
        
4.  Else:
    
    1.  Assert: Due to [validation](#valid-vextract-lane), [lanetype](#syntax-lanetype) is packed type.
        
    2.  Let [sx](#syntax-sx) be [sx](#syntax-sx)′?.
        
    3.  Assert: Due to [validation](#valid-vextract-lane), i<∣[lanes](#aux-lanes)[lanetype](#syntax-lanetype)[x](#syntax-shape)M​(c1​)∣.
        
    4.  Let c2​ be [extend](#op-extend)∣[lanetype](#syntax-lanetype)∣,32[sx](#syntax-sx)​([lanes](#aux-lanes)[lanetype](#syntax-lanetype)[x](#syntax-shape)M​(c1​)\[i\]).
        
    5.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c2​) to the stack.
        

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (nt[x](#syntax-shape)M.[extract\_lane](#syntax-instr-vec) i)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (pt[x](#syntax-shape)M.[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx) i)​[↪](#exec-notation)[↪](#exec-notation)​(nt.[const](#syntax-instr-numeric) c2​)([i32](#syntax-numtype).[const](#syntax-instr-numeric) c2​)​if c2​\=[lanes](#aux-lanes)nt[x](#syntax-shape)M​(c1​)\[i\]if c2​\=[extend](#op-extend)∣pt∣,32[sx](#syntax-sx)​([lanes](#aux-lanes)pt[x](#syntax-shape)M​(c1​)\[i\])​​

##### 4.6.11.17. [i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[replace\_lane](#syntax-instr-vec) i[](#-hrefsyntax-numtypemathsfihrefsyntax-numtypescriptstylekern-01emnhrefsyntax-shapemathsfxmhrefsyntax-instr-vecmathsfreplace_lanei)

1.  Assert: Due to [validation](#valid-vreplace-lane), a value is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vreplace-lane), [numtype](#syntax-numtype)0​\=[unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype)).
    
4.  Assert: Due to [validation](#valid-vreplace-lane), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
5.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
6.  Let c be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​)\[\[i\]\=[pack](#aux-packnum)[i](#syntax-numtype)[N](#syntax-numtype)​(c2​)\]).
    
7.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype)).[const](#syntax-instr-numeric) c2​) ([i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[replace\_lane](#syntax-instr-vec) i)if c\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​)\[\[i\]\=[pack](#aux-packnum)[i](#syntax-numtype)[N](#syntax-numtype)​(c2​)\])​[↪](#exec-notation)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​

##### 4.6.11.18. sh2​.[vextunop](#syntax-vextunop)\_sh1​[](#-mathitsh_2--hrefsyntax-vextunopmathitvextunopmathsf_mathitsh_1)

1.  Assert: Due to [validation](#valid-vextunop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let c be [vextunop](#syntax-vextunop)sh1​,sh2​​(c1​).
    
4.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (sh2​.[vextunop](#syntax-vextunop)\_sh1​)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if [vextunop](#syntax-vextunop)sh1​,sh2​​(c1​)\=c​​

##### 4.6.11.19. sh2​.[vextbinop](#syntax-vextbinop)\_sh1​[](#-mathitsh_2--hrefsyntax-vextbinopmathitvextbinopmathsf_mathitsh_1)

1.  Assert: Due to [validation](#valid-vextbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vextbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [vextbinop](#syntax-vextbinop)sh1​,sh2​​(c1​,c2​).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh2​.[vextbinop](#syntax-vextbinop)\_sh1​)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if [vextbinop](#syntax-vextbinop)sh1​,sh2​​(c1​,c2​)\=c​​

##### 4.6.11.20. sh2​.[vextternop](#syntax-vextternop)\_sh1​[](#-mathitsh_2--hrefsyntax-vextternopmathitvextternopmathsf_mathitsh_1)

1.  Assert: Due to [validation](#valid-vextternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) from the stack.
    
3.  Assert: Due to [validation](#valid-vextternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
5.  Assert: Due to [validation](#valid-vextternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
6.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
7.  Let c be [vextternop](#syntax-vextternop)sh1​,sh2​​(c1​,c2​,c3​).
    
8.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) (sh2​.[vextternop](#syntax-vextternop)\_sh1​)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if [vextternop](#syntax-vextternop)sh1​,sh2​​(c1​,c2​,c3​)\=c​​

##### 4.6.11.21. sh2​.[narrow](#syntax-instr-vec)\_sh1​\_[sx](#syntax-sx)[](#-mathitsh_2hrefsyntax-instr-vecmathsfnarrowmathsf_mathitsh_1mathsf_hrefsyntax-sxmathitsx)

1.  Assert: Due to [validation](#valid-vnarrow), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vnarrow), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [narrow](#syntax-instr-vec)sh1​,sh2​[sx](#syntax-sx)​(c1​,c2​).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh2​.[narrow](#syntax-instr-vec)\_sh1​\_[sx](#syntax-sx))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[narrow](#syntax-instr-vec)sh1​,sh2​[sx](#syntax-sx)​(c1​,c2​)​​

##### 4.6.11.22. sh2​.[vcvtop](#syntax-vcvtop)\_sh1​[](#-mathitsh_2--hrefsyntax-vcvtopmathitvcvtopmathsf_mathitsh_1)

1.  Assert: Due to [validation](#valid-vcvtop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let c be [vcvtop](#syntax-vcvtop)sh1​,sh2​​([vcvtop](#syntax-vcvtop),c1​).
    
4.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (sh2​.[vcvtop](#syntax-vcvtop)\_sh1​)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[vcvtop](#syntax-vcvtop)sh1​,sh2​​([vcvtop](#syntax-vcvtop),c1​)​​

#### 4.6.12. Expressions[](#expressions⑤)

An [expression](#syntax-expr) is _evaluated_ relative to a [current](#exec-notation-textual) [frame](#syntax-frame) pointing to its containing [module instance](#syntax-moduleinst).

##### 4.6.12.1. eval\_expr [instr](#syntax-instr)∗[](#-mathsfeval_exprhrefsyntax-instrmathitinstrast)

1.  Execute the sequence [instr](#syntax-instr)∗.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  Return [val](#syntax-val).
    

​z;[instr](#syntax-instr)∗​[↪∗](#exec-notation)​z′;[val](#syntax-val)∗​if z;[instr](#syntax-instr)∗[↪∗](#exec-notation)z′;[val](#syntax-val)∗​​

Note

Evaluation iterates this reduction rule until reaching a value. Expressions constituting [function](#syntax-func) bodies are executed during function [invocation](#exec-invoke).

### 4.7. Modules[](#modules⑥)

For modules, the execution semantics primarily defines [instantiation](#exec-instantiation), which [allocates](#alloc) instances for a module and its contained definitions, initializes [memories](#syntax-mem) and [tables](#syntax-table) from contained [data](#syntax-data) and [element](#syntax-elem) segments, and invokes the [start function](#syntax-start) if present. It also includes [invocation](#exec-invocation) of exported functions.

#### 4.7.1. Allocation[](#allocation①)

New instances of [tags](#syntax-taginst), [globals](#syntax-globalinst), [memories](#syntax-meminst), [tables](#syntax-tableinst), [functions](#syntax-funcinst), [data segments](#syntax-datainst), and [element segments](#syntax-eleminst) are _allocated_ in a [store](#syntax-store) s, as defined by the following auxiliary functions.

##### 4.7.1.1. [Tags](#syntax-taginst)[](#tags⑦)

##### 4.7.1.2. [alloctag](#alloc-tag)(s,[tagtype](#syntax-tagtype))[](#-hrefalloc-tagmathrmalloctag-s-hrefsyntax-tagtypemathittagtype)

1.  Let [taginst](#syntax-taginst) be the [tag instance](#syntax-taginst) {[type](#syntax-taginst) [tagtype](#syntax-tagtype)}.
    
2.  Let a be the length of s.[tags](#syntax-store).
    
3.  Append [taginst](#syntax-taginst) to s.[tags](#syntax-store).
    
4.  Return a.
    

[alloctag](#alloc-tag)(s,[tagtype](#syntax-tagtype))if [taginst](#syntax-taginst)\={[type](#syntax-taginst) [tagtype](#syntax-tagtype)}​\=(s⊕{[tags](#syntax-store) [taginst](#syntax-taginst)},∣s.[tags](#syntax-store)∣)​

##### 4.7.1.3. [Globals](#syntax-globalinst)[](#globals⑦)

##### 4.7.1.4. [allocglobal](#alloc-global)(s,[globaltype](#syntax-globaltype),[val](#syntax-val))[](#-hrefalloc-globalmathrmallocglobal-s-hrefsyntax-globaltypemathitglobaltype-hrefsyntax-valmathitval)

1.  Let [globalinst](#syntax-globalinst) be the [global instance](#syntax-globalinst) {[type](#syntax-globalinst) [globaltype](#syntax-globaltype),[value](#syntax-globalinst) [val](#syntax-val)}.
    
2.  Let a be the length of s.[globals](#syntax-store).
    
3.  Append [globalinst](#syntax-globalinst) to s.[globals](#syntax-store).
    
4.  Return a.
    

[allocglobal](#alloc-global)(s,[globaltype](#syntax-globaltype),[val](#syntax-val))if [globalinst](#syntax-globalinst)\={[type](#syntax-globalinst) [globaltype](#syntax-globaltype),[value](#syntax-globalinst) [val](#syntax-val)}​\=(s⊕{[globals](#syntax-store) [globalinst](#syntax-globalinst)},∣s.[globals](#syntax-store)∣)​

##### 4.7.1.5. [Memories](#syntax-meminst)[](#memories⑦)

##### 4.7.1.6. [allocmem](#alloc-mem)(s,at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype))[](#-hrefalloc-memmathrmallocmem-s-mathitat-i-hrefsyntax-limits---j-hrefsyntax-memtypemathsfpage)

1.  Let [meminst](#syntax-meminst) be the [memory instance](#syntax-meminst) {[type](#syntax-meminst) (at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) 0x00i⋅64Ki}.
    
2.  Let a be the length of s.[mems](#syntax-store).
    
3.  Append [meminst](#syntax-meminst) to s.[mems](#syntax-store).
    
4.  Return a.
    

[allocmem](#alloc-mem)(s,at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype))if [meminst](#syntax-meminst)\={[type](#syntax-meminst) (at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) (0x00)i⋅64Ki}​\=(s⊕{[mems](#syntax-store) [meminst](#syntax-meminst)},∣s.[mems](#syntax-store)∣)​

##### 4.7.1.7. [Tables](#syntax-tableinst)[](#tables⑦)

##### 4.7.1.8. [alloctable](#alloc-table)(s,at \[i[..](#syntax-limits)j?\] rt,[ref](#syntax-ref))[](#-hrefalloc-tablemathrmalloctable-s-mathitat-i-hrefsyntax-limits---j-mathitrt-hrefsyntax-refmathitref)

1.  Let [tableinst](#syntax-tableinst) be the [table instance](#syntax-tableinst) {[type](#syntax-tableinst) (at \[i[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) [ref](#syntax-ref)i}.
    
2.  Let a be the length of s.[tables](#syntax-store).
    
3.  Append [tableinst](#syntax-tableinst) to s.[tables](#syntax-store).
    
4.  Return a.
    

[alloctable](#alloc-table)(s,at \[i[..](#syntax-limits)j?\] rt,[ref](#syntax-ref))if [tableinst](#syntax-tableinst)\={[type](#syntax-tableinst) (at \[i[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) [ref](#syntax-ref)i}​\=(s⊕{[tables](#syntax-store) [tableinst](#syntax-tableinst)},∣s.[tables](#syntax-store)∣)​

##### 4.7.1.9. [Functions](#syntax-funcinst)[](#functions⑦)

##### 4.7.1.10. [allocfunc](#alloc-func)(s,[deftype](#syntax-deftype),[code](#syntax-funcinst),[moduleinst](#syntax-moduleinst))[](#-hrefalloc-funcmathrmallocfunc-s-hrefsyntax-deftypemathitdeftype-hrefsyntax-funcinstmathitcode-hrefsyntax-moduleinstmathitmoduleinst)

1.  Let [funcinst](#syntax-funcinst) be the [function instance](#syntax-funcinst) {[type](#syntax-funcinst) [deftype](#syntax-deftype),[module](#syntax-funcinst) [moduleinst](#syntax-moduleinst),[code](#syntax-funcinst) [code](#syntax-funcinst)}.
    
2.  Let a be the length of s.[funcs](#syntax-store).
    
3.  Append [funcinst](#syntax-funcinst) to s.[funcs](#syntax-store).
    
4.  Return a.
    

[allocfunc](#alloc-func)(s,[deftype](#syntax-deftype),[code](#syntax-funcinst),[moduleinst](#syntax-moduleinst))if [funcinst](#syntax-funcinst)\={[type](#syntax-funcinst) [deftype](#syntax-deftype),[module](#syntax-funcinst) [moduleinst](#syntax-moduleinst),[code](#syntax-funcinst) [code](#syntax-funcinst)}​\=(s⊕{[funcs](#syntax-store) [funcinst](#syntax-funcinst)},∣s.[funcs](#syntax-store)∣)​

##### 4.7.1.11. [Data segments](#syntax-datainst)[](#data-segments⑤)

##### 4.7.1.12. [allocdata](#alloc-data)(s,[ok](#valid-data),[byte](#syntax-byte)∗)[](#-hrefalloc-datamathrmallocdata-s-hrefvalid-datamathsfok-hrefsyntax-bytemathitbyteast)

1.  Let [datainst](#syntax-datainst) be the [data instance](#syntax-datainst) {[bytes](#syntax-datainst) [byte](#syntax-byte)∗}.
    
2.  Let a be the length of s.[datas](#syntax-store).
    
3.  Append [datainst](#syntax-datainst) to s.[datas](#syntax-store).
    
4.  Return a.
    

[allocdata](#alloc-data)(s,[ok](#valid-data),[byte](#syntax-byte)∗)if [datainst](#syntax-datainst)\={[bytes](#syntax-datainst) [byte](#syntax-byte)∗}​\=(s⊕{[datas](#syntax-store) [datainst](#syntax-datainst)},∣s.[datas](#syntax-store)∣)​

##### 4.7.1.13. [Element segments](#syntax-eleminst)[](#element-segments⑤)

##### 4.7.1.14. [allocelem](#alloc-elem)(s,[elemtype](#syntax-elemtype),[ref](#syntax-ref)∗)[](#-hrefalloc-elemmathrmallocelem-s-hrefsyntax-elemtypemathitelemtype-hrefsyntax-refmathitrefast)

1.  Let [eleminst](#syntax-eleminst) be the [element instance](#syntax-eleminst) {[type](#syntax-eleminst) [elemtype](#syntax-elemtype),[refs](#syntax-eleminst) [ref](#syntax-ref)∗}.
    
2.  Let a be the length of s.[elems](#syntax-store).
    
3.  Append [eleminst](#syntax-eleminst) to s.[elems](#syntax-store).
    
4.  Return a.
    

[allocelem](#alloc-elem)(s,[elemtype](#syntax-elemtype),[ref](#syntax-ref)∗)if [eleminst](#syntax-eleminst)\={[type](#syntax-eleminst) [elemtype](#syntax-elemtype),[refs](#syntax-eleminst) [ref](#syntax-ref)∗}​\=(s⊕{[elems](#syntax-store) [eleminst](#syntax-eleminst)},∣s.[elems](#syntax-store)∣)​

##### 4.7.1.15. Growing [memories](#syntax-meminst)[](#growing-memories①)

##### 4.7.1.16. [growmem](#grow-mem)([meminst](#syntax-meminst),n)[](#-hrefgrow-memmathrmgrowmem-hrefsyntax-meminstmathitmeminst-n)

1.  Let {[type](#syntax-meminst) (at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) b∗} be the destructuring of [meminst](#syntax-meminst).
    
2.  Let i′ be ∣b∗∣/(64Ki)+n.
    
3.  If (i′≤j)?, then:
    
    1.  Let [meminst](#syntax-meminst)′ be the [memory instance](#syntax-meminst) {[type](#syntax-meminst) (at \[i′[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) b∗ 0x00n⋅64Ki}.
        
    2.  Return [meminst](#syntax-meminst)′.
        
4.  Fail.
    

[growmem](#grow-mem)([meminst](#syntax-meminst),n)​\=​[meminst](#syntax-meminst)′​if [meminst](#syntax-meminst)\={[type](#syntax-meminst) (at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) b∗}∧ [meminst](#syntax-meminst)′\={[type](#syntax-meminst) (at \[i′[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) b∗ (0x00)n⋅64Ki}∧ i′\=∣b∗∣/(64Ki)+n∧ (i′≤j)?​​​

##### 4.7.1.17. Growing [tables](#syntax-tableinst)[](#growing-tables①)

##### 4.7.1.18. [growtable](#grow-table)([tableinst](#syntax-tableinst),n,r)[](#-hrefgrow-tablemathrmgrowtable-hrefsyntax-tableinstmathittableinst-n-r)

1.  Let {[type](#syntax-tableinst) (at \[i[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) r′∗} be the destructuring of [tableinst](#syntax-tableinst).
    
2.  Let i′ be ∣r′∗∣+n.
    
3.  If (i′≤j)?, then:
    
    1.  Let [tableinst](#syntax-tableinst)′ be the [table instance](#syntax-tableinst) {[type](#syntax-tableinst) (at \[i′[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) r′∗ rn}.
        
    2.  Return [tableinst](#syntax-tableinst)′.
        
4.  Fail.
    

[growtable](#grow-table)([tableinst](#syntax-tableinst),n,r)​\=​[tableinst](#syntax-tableinst)′​if [tableinst](#syntax-tableinst)\={[type](#syntax-tableinst) (at \[i[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) r′∗}∧ [tableinst](#syntax-tableinst)′\={[type](#syntax-tableinst) (at \[i′[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) r′∗ rn}∧ i′\=∣r′∗∣+n∧ (i′≤j)?​​​

##### 4.7.1.19. [Modules](#syntax-moduleinst)[](#modules⑦)

##### 4.7.1.20. [allocmodule](#alloc-module)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗,[val](#syntax-val)g∗​,[ref](#syntax-ref)t∗​,[ref](#syntax-ref)e∗​∗)[](#-hrefalloc-modulemathrmallocmodule-s-hrefsyntax-modulemathitmodule-hrefsyntax-externaddrmathitexternaddrast-hrefsyntax-valmathitval_mathsfgast-hrefsyntax-refmathitref_mathsftast-hrefsyntax-refmathitref_mathsfeastast)

1.  Let ([module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗) be the destructuring of [module](#syntax-module).
    
2.  Let aai∗​ be [tags](#syntax-externaddr)([externaddr](#syntax-externaddr)∗).
    
3.  Let gai∗​ be [globals](#syntax-externaddr)([externaddr](#syntax-externaddr)∗).
    
4.  Let fai∗​ be [funcs](#syntax-externaddr)([externaddr](#syntax-externaddr)∗).
    
5.  Let mai∗​ be [mems](#syntax-externaddr)([externaddr](#syntax-externaddr)∗).
    
6.  Let tai∗​ be [tables](#syntax-externaddr)([externaddr](#syntax-externaddr)∗).
    
7.  Let fa∗ be ∣s.[funcs](#syntax-store)∣+if​ for all if​ from 0 to ∣[func](#syntax-func)∗∣−1.
    
8.  Let [tagtype](#syntax-tagtype)∗ be the tag type sequence ϵ.
    
9.  For each [tag](#syntax-tag) in [tag](#syntax-tag)∗, do:
    
    1.  Let ([tag](#syntax-tag) [tagtype](#syntax-tagtype)) be the destructuring of [tag](#syntax-tag).
        
    2.  Append [tagtype](#syntax-tagtype) to [tagtype](#syntax-tagtype)∗.
        
10.  Let [byte](#syntax-byte)∗∗ be the byte sequence sequence ϵ.
    
11.  For each [data](#syntax-data) in [data](#syntax-data)∗, do:
    
    1.  Let ([data](#syntax-data) [byte](#syntax-byte)∗ [datamode](#syntax-datamode)) be the destructuring of [data](#syntax-data).
        
    2.  Append [byte](#syntax-byte)∗ to [byte](#syntax-byte)∗∗.
        
12.  Let [globaltype](#syntax-globaltype)∗ be the global type sequence ϵ.
    
13.  For each [global](#syntax-global) in [global](#syntax-global)∗, do:
    
    1.  Let ([global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)g​) be the destructuring of [global](#syntax-global).
        
    2.  Append [globaltype](#syntax-globaltype) to [globaltype](#syntax-globaltype)∗.
        
14.  Let [tabletype](#syntax-tabletype)∗ be the table type sequence ϵ.
    
15.  For each [table](#syntax-table) in [table](#syntax-table)∗, do:
    
    1.  Let ([table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)t​) be the destructuring of [table](#syntax-table).
        
    2.  Append [tabletype](#syntax-tabletype) to [tabletype](#syntax-tabletype)∗.
        
16.  Let [memtype](#syntax-memtype)∗ be the memory type sequence ϵ.
    
17.  For each [mem](#syntax-mem) in [mem](#syntax-mem)∗, do:
    
    1.  Let ([memory](#syntax-mem) [memtype](#syntax-memtype)) be the destructuring of [mem](#syntax-mem).
        
    2.  Append [memtype](#syntax-memtype) to [memtype](#syntax-memtype)∗.
        
18.  Let dt∗ be [alloctype](#alloc-type)∗([type](#syntax-rectype)∗).
    
19.  Let [elemtype](#syntax-elemtype)∗ be the reference type sequence ϵ.
    
20.  For each [elem](#syntax-elem) in [elem](#syntax-elem)∗, do:
    
    1.  Let ([elem](#syntax-elem) [elemtype](#syntax-elemtype) [expr](#syntax-expr)e∗​ [elemmode](#syntax-elemmode)) be the destructuring of [elem](#syntax-elem).
        
    2.  Append [elemtype](#syntax-elemtype) to [elemtype](#syntax-elemtype)∗.
        
21.  Let [expr](#syntax-expr)f∗​ be the expression sequence ϵ.
    
22.  Let [local](#syntax-local)∗∗ be the local sequence sequence ϵ.
    
23.  Let x∗ be the type index sequence ϵ.
    
24.  For each [func](#syntax-func) in [func](#syntax-func)∗, do:
    
    1.  Let ([func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr)f​) be the destructuring of [func](#syntax-func).
        
    2.  Append [expr](#syntax-expr)f​ to [expr](#syntax-expr)f∗​.
        
    3.  Append [local](#syntax-local)∗ to [local](#syntax-local)∗∗.
        
    4.  Append x to x∗.
        
25.  Let aa∗ be ϵ.
    
26.  For each [tagtype](#syntax-tagtype) in [tagtype](#syntax-tagtype)∗, do:
    
    1.  Let aa be the [tag address](#syntax-tagaddr) [alloctag](#alloc-tag)(s,[tagtype](#syntax-tagtype)\[[:=](#notation-subst)dt∗\]).
        
    2.  Append aa to aa∗.
        
27.  Let ga∗ be ϵ.
    
28.  For each [globaltype](#syntax-globaltype) in [globaltype](#syntax-globaltype)∗ and [val](#syntax-val)g​ in [val](#syntax-val)g∗​, do:
    
    1.  Let ga be the [global address](#syntax-globaladdr) [allocglobal](#alloc-global)(s,[globaltype](#syntax-globaltype)\[[:=](#notation-subst)dt∗\],[val](#syntax-val)g​).
        
    2.  Append ga to ga∗.
        
29.  Let ma∗ be ϵ.
    
30.  For each [memtype](#syntax-memtype) in [memtype](#syntax-memtype)∗, do:
    
    1.  Let ma be the [memory address](#syntax-memaddr) [allocmem](#alloc-mem)(s,[memtype](#syntax-memtype)\[[:=](#notation-subst)dt∗\]).
        
    2.  Append ma to ma∗.
        
31.  Let ta∗ be ϵ.
    
32.  For each [tabletype](#syntax-tabletype) in [tabletype](#syntax-tabletype)∗ and [ref](#syntax-ref)t​ in [ref](#syntax-ref)t∗​, do:
    
    1.  Let ta be the [table address](#syntax-tableaddr) [alloctable](#alloc-table)(s,[tabletype](#syntax-tabletype)\[[:=](#notation-subst)dt∗\],[ref](#syntax-ref)t​).
        
    2.  Append ta to ta∗.
        
33.  Let xi∗ be ϵ.
    
34.  For each [export](#syntax-export) in [export](#syntax-export)∗, do:
    
    1.  Let xi be the [export instance](#syntax-exportinst) [allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export)).
        
    2.  Append xi to xi∗.
        
35.  Let da∗ be ϵ.
    
36.  For each [byte](#syntax-byte)∗ in [byte](#syntax-byte)∗∗, do:
    
    1.  Let da be the [data address](#syntax-dataaddr) [allocdata](#alloc-data)(s,[ok](#valid-data),[byte](#syntax-byte)∗).
        
    2.  Append da to da∗.
        
37.  Let ea∗ be ϵ.
    
38.  For each [elemtype](#syntax-elemtype) in [elemtype](#syntax-elemtype)∗ and [ref](#syntax-ref)e∗​ in [ref](#syntax-ref)e∗​∗, do:
    
    1.  Let ea be the [elem address](#syntax-elemaddr) [allocelem](#alloc-elem)(s,[elemtype](#syntax-elemtype)\[[:=](#notation-subst)dt∗\],[ref](#syntax-ref)e∗​).
        
    2.  Append ea to ea∗.
        
39.  Let [moduleinst](#syntax-moduleinst) be the [module instance](#syntax-moduleinst) {[types](#syntax-moduleinst) dt∗,[tags](#syntax-moduleinst) aai∗​ aa∗,[globals](#syntax-moduleinst) gai∗​ ga∗,[mems](#syntax-moduleinst) mai∗​ ma∗,[tables](#syntax-moduleinst) tai∗​ ta∗,[funcs](#syntax-moduleinst) fai∗​ fa∗,[datas](#syntax-moduleinst) da∗,[elems](#syntax-moduleinst) ea∗,[exports](#syntax-moduleinst) xi∗}.
    
40.  Let [funcaddr](#syntax-funcaddr)0∗​ be ϵ.
    
41.  For each [expr](#syntax-expr)f​ in [expr](#syntax-expr)f∗​ and [local](#syntax-local)∗ in [local](#syntax-local)∗∗ and x in x∗, do:
    
    1.  Let [funcaddr](#syntax-funcaddr)0​ be the [function address](#syntax-funcaddr) [allocfunc](#alloc-func)(s,dt∗\[x\],[func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr)f​,[moduleinst](#syntax-moduleinst)).
        
    2.  Append [funcaddr](#syntax-funcaddr)0​ to [funcaddr](#syntax-funcaddr)0∗​.
        
42.  Assert: Due to validation, [funcaddr](#syntax-funcaddr)0∗​\=fa∗.
    
43.  Return [moduleinst](#syntax-moduleinst).
    

[allocmodule](#alloc-module)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗,[val](#syntax-val)g∗​,[ref](#syntax-ref)t∗​,([ref](#syntax-ref)e∗​)∗)if [module](#syntax-module)\=[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗∧ [tag](#syntax-tag)∗\=([tag](#syntax-tag) [tagtype](#syntax-tagtype))∗∧ [global](#syntax-global)∗\=([global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)g​)∗∧ [mem](#syntax-mem)∗\=([memory](#syntax-mem) [memtype](#syntax-memtype))∗∧ [table](#syntax-table)∗\=([table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)t​)∗∧ [func](#syntax-func)∗\=([func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr)f​)∗∧ [data](#syntax-data)∗\=([data](#syntax-data) [byte](#syntax-byte)∗ [datamode](#syntax-datamode))∗∧ [elem](#syntax-elem)∗\=([elem](#syntax-elem) [elemtype](#syntax-elemtype) [expr](#syntax-expr)e∗​ [elemmode](#syntax-elemmode))∗∧ aai∗​\=[tags](#syntax-externaddr)([externaddr](#syntax-externaddr)∗)∧ gai∗​\=[globals](#syntax-externaddr)([externaddr](#syntax-externaddr)∗)∧ mai∗​\=[mems](#syntax-externaddr)([externaddr](#syntax-externaddr)∗)∧ tai∗​\=[tables](#syntax-externaddr)([externaddr](#syntax-externaddr)∗)∧ fai∗​\=[funcs](#syntax-externaddr)([externaddr](#syntax-externaddr)∗)∧ dt∗\=[alloctype](#alloc-type)∗([type](#syntax-rectype)∗)∧ fa∗\=(∣s.[funcs](#syntax-store)∣+if​)if​<∣[func](#syntax-func)∗∣∧ (s1​,aa∗)\=[alloctag](#alloc-tag)∗(s,[tagtype](#syntax-tagtype)\[[:=](#notation-subst)dt∗\]∗)∧ (s2​,ga∗)\=[allocglobal](#alloc-global)∗(s1​,[globaltype](#syntax-globaltype)\[[:=](#notation-subst)dt∗\]∗,[val](#syntax-val)g∗​)∧ (s3​,ma∗)\=[allocmem](#alloc-mem)∗(s2​,[memtype](#syntax-memtype)\[[:=](#notation-subst)dt∗\]∗)∧ (s4​,ta∗)\=[alloctable](#alloc-table)∗(s3​,[tabletype](#syntax-tabletype)\[[:=](#notation-subst)dt∗\]∗,[ref](#syntax-ref)t∗​)∧ (s5​,da∗)\=[allocdata](#alloc-data)∗(s4​,[ok](#valid-data)∣[data](#syntax-data)∗∣,([byte](#syntax-byte)∗)∗)∧ (s6​,ea∗)\=[allocelem](#alloc-elem)∗(s5​,[elemtype](#syntax-elemtype)\[[:=](#notation-subst)dt∗\]∗,([ref](#syntax-ref)e∗​)∗)∧ (s7​,fa∗)\=[allocfunc](#alloc-func)∗(s6​,dt∗\[x\]∗,([func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr)f​)∗,[moduleinst](#syntax-moduleinst)∣[func](#syntax-func)∗∣)∧ xi∗\=[allocexport](#alloc-export)∗({[tags](#syntax-moduleinst) aai∗​ aa∗,[globals](#syntax-moduleinst) gai∗​ ga∗,[mems](#syntax-moduleinst) mai∗​ ma∗,[tables](#syntax-moduleinst) tai∗​ ta∗,[funcs](#syntax-moduleinst) fai∗​ fa∗},[export](#syntax-export)∗)∧ [moduleinst](#syntax-moduleinst)\={[types](#syntax-moduleinst) dt∗,[tags](#syntax-moduleinst) aai∗​ aa∗,[globals](#syntax-moduleinst) gai∗​ ga∗,[mems](#syntax-moduleinst) mai∗​ ma∗,[tables](#syntax-moduleinst) tai∗​ ta∗,[funcs](#syntax-moduleinst) fai∗​ fa∗,[datas](#syntax-moduleinst) da∗,[elems](#syntax-moduleinst) ea∗,[exports](#syntax-moduleinst) xi∗}​​​\=(s7​,[moduleinst](#syntax-moduleinst))​

Here, the notation allocx∗ is shorthand for multiple [allocations](#alloc) of object kind X, defined as follows:

allocX∗(s,ϵ,ϵ)allocX∗(s,X X′∗,Y Y′∗)​\=\=​(s,ϵ)(s2​,a a′∗)​if (s1​,a)\=allocX(X,Y,s,X,Y)∧ (s2​,a′∗)\=allocX∗(s1​,X′∗,Y′∗)​​​

For types, however, allocation is defined in terms of [rolling](#aux-roll-rectype) and [substitution](#notation-subst) of all preceding types to produce a list of [closed](#type-closed) [defined types](#syntax-deftype):

##### 4.7.1.21. [alloctype](#alloc-type)∗([type](#syntax-rectype)′′∗)[](#-hrefalloc-typemathrmalloctypeast-hrefsyntax-rectypemathittypeast)

1.  If [type](#syntax-rectype)′′∗\=ϵ, then:
    
    1.  Return ϵ.
        
2.  Let [type](#syntax-rectype)′∗ [type](#syntax-rectype) be [type](#syntax-rectype)′′∗.
    
3.  Let ([type](#syntax-type) [rectype](#syntax-rectype)) be the destructuring of [type](#syntax-rectype).
    
4.  Let [deftype](#syntax-deftype)′∗ be [alloctype](#alloc-type)∗([type](#syntax-rectype)′∗).
    
5.  Let x be the length of [deftype](#syntax-deftype)′∗.
    
6.  Let [deftype](#syntax-deftype)∗ be [roll](#aux-roll-deftype)x∗​([rectype](#syntax-rectype))\[[:=](#notation-subst)[deftype](#syntax-deftype)′∗\].
    
7.  Return [deftype](#syntax-deftype)′∗ [deftype](#syntax-deftype)∗.
    

[alloctype](#alloc-type)∗(ϵ)[alloctype](#alloc-type)∗([type](#syntax-rectype)′∗ [type](#syntax-rectype))​\=\=​ϵ[deftype](#syntax-deftype)′∗ [deftype](#syntax-deftype)∗​if [deftype](#syntax-deftype)′∗\=[alloctype](#alloc-type)∗([type](#syntax-rectype)′∗)∧ [type](#syntax-rectype)\=[type](#syntax-type) [rectype](#syntax-rectype)∧ [deftype](#syntax-deftype)∗\=[roll](#aux-roll-deftype)x∗​([rectype](#syntax-rectype))\[[:=](#notation-subst)[deftype](#syntax-deftype)′∗\]∧ x\=∣[deftype](#syntax-deftype)′∗∣​​​

Finally, export instances are produced with the help of the following definition:

##### 4.7.1.22. [allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) [externidx](#syntax-externidx))[](#-hrefalloc-exportmathrmallocexport-hrefsyntax-moduleinstmathitmoduleinst-hrefsyntax-exportmathsfexporthrefsyntax-namemathitnamehrefsyntax-externidxmathitexternidx)

1.  If [externidx](#syntax-externidx) is some [tag](#syntax-externidx) [tagidx](#syntax-tagidx), then:
    
    1.  Let ([tag](#syntax-externidx) x) be the destructuring of [externidx](#syntax-externidx).
        
    2.  Return {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([tag](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[tags](#syntax-moduleinst)\[x\])}.
        
2.  If [externidx](#syntax-externidx) is some [global](#syntax-externidx) [globalidx](#syntax-globalidx), then:
    
    1.  Let ([global](#syntax-externidx) x) be the destructuring of [externidx](#syntax-externidx).
        
    2.  Return {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([global](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[globals](#syntax-moduleinst)\[x\])}.
        
3.  If [externidx](#syntax-externidx) is some [memory](#syntax-externidx) [memidx](#syntax-memidx), then:
    
    1.  Let ([memory](#syntax-externidx) x) be the destructuring of [externidx](#syntax-externidx).
        
    2.  Return {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([mem](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[mems](#syntax-moduleinst)\[x\])}.
        
4.  If [externidx](#syntax-externidx) is some [table](#syntax-externidx) [tableidx](#syntax-tableidx), then:
    
    1.  Let ([table](#syntax-externidx) x) be the destructuring of [externidx](#syntax-externidx).
        
    2.  Return {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([table](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[tables](#syntax-moduleinst)\[x\])}.
        
5.  Assert: Due to validation, [externidx](#syntax-externidx) is some [func](#syntax-externidx) [funcidx](#syntax-funcidx).
    
6.  Let ([func](#syntax-externidx) x) be the destructuring of [externidx](#syntax-externidx).
    
7.  Return {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([func](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[funcs](#syntax-moduleinst)\[x\])}.
    

[allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) ([tag](#syntax-externidx) x))[allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) ([global](#syntax-externidx) x))[allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) ([memory](#syntax-externidx) x))[allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) ([table](#syntax-externidx) x))[allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) ([func](#syntax-externidx) x))​\=\=\=\=\=​{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([tag](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[tags](#syntax-moduleinst)\[x\])}{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([global](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[globals](#syntax-moduleinst)\[x\])}{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([mem](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[mems](#syntax-moduleinst)\[x\])}{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([table](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[tables](#syntax-moduleinst)\[x\])}{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([func](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[funcs](#syntax-moduleinst)\[x\])}​​

Note

The definition of module allocation is mutually recursive with the allocation of its associated functions, because the resulting module instance is passed to the allocators as an argument, in order to form the necessary closures. In an implementation, this recursion is easily unraveled by mutating one or the other in a secondary step.

#### 4.7.2. Instantiation[](#instantiation④)

Given a [store](#syntax-store) s, a [module](#syntax-module) is instantiated with a list of [external addresses](#syntax-externaddr) [externaddr](#syntax-externaddr)∗ supplying the required imports as follows.

Instantiation checks that the module is [valid](#valid) and the provided imports [match](#match-externtype) the declared types, and may _fail_ with an error otherwise. Instantiation can also result in an [exception](#exception) or [trap](#trap) when initializing a [table](#syntax-table) or [memory](#syntax-mem) from an [active segment](#syntax-data) or when executing the [start](#syntax-start) function. It is up to the [embedder](#embedder) to define how such conditions are reported.

##### 4.7.2.1. [instantiate](#exec-instantiation)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗)[](#-hrefexec-instantiationmathrminstantiate-s-hrefsyntax-modulemathitmodule-hrefsyntax-externaddrmathitexternaddrast)

1.  If [module](#syntax-module) is not [valid](#valid-module), then:
    
    1.  Fail.
        
2.  Let xti∗​ [→](#syntax-moduletype) xte∗​ be the destructuring of the type of [module](#syntax-module).
    
3.  Let ([module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗) be the destructuring of [module](#syntax-module).
    
4.  If ∣[externaddr](#syntax-externaddr)∗∣\=∣xti∗​∣, then:
    
    1.  Fail.
        
5.  For all [externaddr](#syntax-externaddr) in [externaddr](#syntax-externaddr)∗, and corresponding xti​ in xti∗​:
    
    1.  If [externaddr](#syntax-externaddr) is not [valid](#valid-val) with type xti​, then:
        
        1.  Fail.
            
6.  Let [instr](#syntax-instr)d∗​ be the [concatenation](#notation-concat) of [rundata](#aux-rundata)id​​([data](#syntax-data)∗\[id​\])id​<∣[data](#syntax-data)∗∣.
    
7.  Let [instr](#syntax-instr)e∗​ be the [concatenation](#notation-concat) of [runelem](#aux-runelem)ie​​([elem](#syntax-elem)∗\[ie​\])ie​<∣[elem](#syntax-elem)∗∣.
    
8.  Let [moduleinst](#syntax-moduleinst)0​ be the [module instance](#syntax-moduleinst) {[types](#syntax-moduleinst) [alloctype](#alloc-type)∗([type](#syntax-rectype)∗),[globals](#syntax-moduleinst) [globals](#syntax-externaddr)([externaddr](#syntax-externaddr)∗),[funcs](#syntax-moduleinst) [funcs](#syntax-externaddr)([externaddr](#syntax-externaddr)∗) (∣s.[funcs](#syntax-store)∣+if​)if​<∣[func](#syntax-func)∗∣}.
    
9.  Let [expr](#syntax-expr)t∗​ be the expression sequence ϵ.
    
10.  For each [table](#syntax-table) in [table](#syntax-table)∗, do:
    
    1.  Let ([table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)t​) be the destructuring of [table](#syntax-table).
        
    2.  Append [expr](#syntax-expr)t​ to [expr](#syntax-expr)t∗​.
        
11.  Let [expr](#syntax-expr)g∗​ be the expression sequence ϵ.
    
12.  Let [globaltype](#syntax-globaltype)∗ be the global type sequence ϵ.
    
13.  For each [global](#syntax-global) in [global](#syntax-global)∗, do:
    
    1.  Let ([global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)g​) be the destructuring of [global](#syntax-global).
        
    2.  Append [expr](#syntax-expr)g​ to [expr](#syntax-expr)g∗​.
        
    3.  Append [globaltype](#syntax-globaltype) to [globaltype](#syntax-globaltype)∗.
        
14.  Let [expr](#syntax-expr)e∗​∗ be the expression sequence sequence ϵ.
    
15.  For each [elem](#syntax-elem) in [elem](#syntax-elem)∗, do:
    
    1.  Let ([elem](#syntax-elem) [reftype](#syntax-reftype) [expr](#syntax-expr)e∗​ [elemmode](#syntax-elemmode)) be the destructuring of [elem](#syntax-elem).
        
    2.  Append [expr](#syntax-expr)e∗​ to [expr](#syntax-expr)e∗​∗.
        
16.  Let z be the [state](#syntax-state) (s,{[module](#syntax-frame) [moduleinst](#syntax-moduleinst)0​}).
    
17.  Let F be the frame z.[frame](#syntax-state).
    
18.  Push the frame F.
    
19.  Let [val](#syntax-val)g∗​ be [evalglobal](#eval-globals)∗(z,[globaltype](#syntax-globaltype)∗,[expr](#syntax-expr)g∗​).
    
20.  Let [ref](#syntax-ref)t∗​ be the reference value sequence ϵ.
    
21.  For each [expr](#syntax-expr)t​ in [expr](#syntax-expr)t∗​, do:
    
    1.  Let [ref](#syntax-ref)t​ be the result of [evaluating](#exec-expr) [expr](#syntax-expr)t​ with state z.
        
    2.  Append [ref](#syntax-ref)t​ to [ref](#syntax-ref)t∗​.
        
22.  Let [ref](#syntax-ref)e∗​∗ be the reference value sequence sequence ϵ.
    
23.  For each [expr](#syntax-expr)e∗​ in [expr](#syntax-expr)e∗​∗, do:
    
    1.  Let [ref](#syntax-ref)e∗​ be the reference value sequence ϵ.
        
    2.  For each [expr](#syntax-expr)e​ in [expr](#syntax-expr)e∗​, do:
        
        1.  Let [ref](#syntax-ref)e​ be the result of [evaluating](#exec-expr) [expr](#syntax-expr)e​ with state z.
            
        2.  Append [ref](#syntax-ref)e​ to [ref](#syntax-ref)e∗​.
            
    3.  Append [ref](#syntax-ref)e∗​ to [ref](#syntax-ref)e∗​∗.
        
24.  Pop the frame from the stack.
    
25.  Let [moduleinst](#syntax-moduleinst) be [allocmodule](#alloc-module)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗,[val](#syntax-val)g∗​,[ref](#syntax-ref)t∗​,[ref](#syntax-ref)e∗​∗).
    
26.  Let F′ be the frame {[module](#syntax-frame) [moduleinst](#syntax-moduleinst)}.
    
27.  Push the frame F′.
    
28.  Execute the sequence [instr](#syntax-instr)e∗​.
    
29.  Execute the sequence [instr](#syntax-instr)d∗​.
    
30.  If [start](#syntax-start)? is defined, then:
    
    1.  Let ([start](#syntax-start) x) be [start](#syntax-start)?.
        
    2.  Let [instr](#syntax-instr)s​ be the [instruction](#syntax-instr) ([call](#syntax-instr-control) x).
        
    3.  Execute the instruction [instr](#syntax-instr)s​.
        
31.  Pop the frame from the stack.
    
32.  Return [moduleinst](#syntax-moduleinst).
    

[instantiate](#exec-instantiation)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗)if [⊢](#valid-module)[module](#syntax-module):xti∗​[→](#syntax-moduletype)xte∗​∧ (s[⊢](#valid-externaddr)[externaddr](#syntax-externaddr):xti​)∗0.8ex\]∧ [module](#syntax-module)\=[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗∧ [global](#syntax-global)∗\=([global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)g​)∗∧ [table](#syntax-table)∗\=([table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)t​)∗∧ [data](#syntax-data)∗\=([data](#syntax-data) [byte](#syntax-byte)∗ [datamode](#syntax-datamode))∗∧ [elem](#syntax-elem)∗\=([elem](#syntax-elem) [reftype](#syntax-reftype) [expr](#syntax-expr)e∗​ [elemmode](#syntax-elemmode))∗∧ [start](#syntax-start)?\=([start](#syntax-start) x)?∧ [moduleinst](#syntax-moduleinst)0​\={[types](#syntax-moduleinst) [alloctype](#alloc-type)∗([type](#syntax-rectype)∗),[globals](#syntax-moduleinst) [globals](#syntax-externaddr)([externaddr](#syntax-externaddr)∗),[funcs](#syntax-moduleinst) [funcs](#syntax-externaddr)([externaddr](#syntax-externaddr)∗) (∣s.[funcs](#syntax-store)∣+if​)if​<∣[func](#syntax-func)∗∣}​∧ z\=s;{[module](#syntax-frame) [moduleinst](#syntax-moduleinst)0​}∧ (z′,[val](#syntax-val)g∗​)\=[evalglobal](#eval-globals)∗(z,[globaltype](#syntax-globaltype)∗,[expr](#syntax-expr)g∗​)∧ (z′;[expr](#syntax-expr)t​[↪∗](#exec-notation)z′;[ref](#syntax-ref)t​)∗∧ (z′;[expr](#syntax-expr)e​[↪∗](#exec-notation)z′;[ref](#syntax-ref)e​)∗∗∧ (s′,[moduleinst](#syntax-moduleinst))\=[allocmodule](#alloc-module)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗,[val](#syntax-val)g∗​,[ref](#syntax-ref)t∗​,([ref](#syntax-ref)e∗​)∗)∧ [instr](#syntax-instr)d∗​\=[⨁](#notation-concat)[rundata](#aux-rundata)id​​([data](#syntax-data)∗\[id​\])id​<∣[data](#syntax-data)∗∣∧ [instr](#syntax-instr)e∗​\=[⨁](#notation-concat)[runelem](#aux-runelem)ie​​([elem](#syntax-elem)∗\[ie​\])ie​<∣[elem](#syntax-elem)∗∣∧ [instr](#syntax-instr)s?​\=([call](#syntax-instr-control) x)?​​\=s′;{[module](#syntax-frame) [moduleinst](#syntax-moduleinst)};[instr](#syntax-instr)e∗​ [instr](#syntax-instr)d∗​ [instr](#syntax-instr)s?​​

where:

##### 4.7.2.2. [evalglobal](#eval-globals)∗(z,[globaltype](#syntax-globaltype)∗,[expr](#syntax-expr)′′∗)[](#-hrefeval-globalsmathrmevalglobalast-z-hrefsyntax-globaltypemathitglobaltypeast-hrefsyntax-exprmathitexprast)

1.  If [expr](#syntax-expr)′′∗\=ϵ, then:
    
    1.  Assert: Due to validation, [globaltype](#syntax-globaltype)∗\=ϵ.
        
    2.  Return ϵ.
        
2.  Else:
    
    1.  Let [expr](#syntax-expr) [expr](#syntax-expr)′∗ be [expr](#syntax-expr)′′∗.
        
    2.  Assert: Due to validation, ∣[globaltype](#syntax-globaltype)∗∣≥1.
        
    3.  Let gt gt′∗ be [globaltype](#syntax-globaltype)∗.
        
    4.  Let (s,f) be the destructuring of z.
        
    5.  Let [val](#syntax-val) be the result of [evaluating](#exec-expr) [expr](#syntax-expr) with state z.
        
    6.  Let a be [allocglobal](#alloc-global)(s,gt,[val](#syntax-val)).
        
    7.  Append a to f.[module](#syntax-frame).[globals](#syntax-moduleinst).
        
    8.  Let [val](#syntax-val)′∗ be [evalglobal](#eval-globals)∗((s,f),gt′∗,[expr](#syntax-expr)′∗).
        
    9.  Return [val](#syntax-val) [val](#syntax-val)′∗.
        

[evalglobal](#eval-globals)∗(z,ϵ,ϵ)[evalglobal](#eval-globals)∗(z,gt gt′∗,[expr](#syntax-expr) [expr](#syntax-expr)′∗)​\=\=​(z,ϵ)(z′,[val](#syntax-val) [val](#syntax-val)′∗)if z;[expr](#syntax-expr)[↪∗](#exec-notation)z;[val](#syntax-val)∧ z\=s;f∧ (s′,a)\=[allocglobal](#alloc-global)(s,gt,[val](#syntax-val))∧ (z′,[val](#syntax-val)′∗)\=[evalglobal](#eval-globals)∗((s′;f\[.[module](#syntax-frame).[globals](#syntax-moduleinst)\=⊕a\]),gt′∗,[expr](#syntax-expr)′∗)​​​

##### 4.7.2.3. [rundata](#aux-rundata)x​([data](#syntax-data) bn [datamode](#syntax-datamode))[](#-hrefaux-rundatamathrmrundata_x-hrefsyntax-datamathsfdatabnhrefsyntax-datamodemathitdatamode)

1.  If [datamode](#syntax-datamode)\=[passive](#syntax-datamode), then:
    
    1.  Return ϵ.
        
2.  Assert: Due to validation, [datamode](#syntax-datamode) is some [active](#syntax-datamode) [memidx](#syntax-memidx) [expr](#syntax-expr).
    
3.  Let ([active](#syntax-datamode) y [instr](#syntax-instr)∗) be the destructuring of [datamode](#syntax-datamode).
    
4.  Return [instr](#syntax-instr)∗ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([memory.init](#syntax-instr-memory) y x) ([data.drop](#syntax-instr-memory) x).
    

##### 4.7.2.4. [runelem](#aux-runelem)x​([elem](#syntax-elem) rt en [elemmode](#syntax-elemmode))[](#-hrefaux-runelemmathrmrunelem_x-hrefsyntax-elemmathsfelemmathitrtenhrefsyntax-elemmodemathitelemmode)

1.  If [elemmode](#syntax-elemmode)\=[passive](#syntax-elemmode), then:
    
    1.  Return ϵ.
        
2.  If [elemmode](#syntax-elemmode)\=[declare](#syntax-elemmode), then:
    
    1.  Return ([elem.drop](#syntax-instr-table) x).
        
3.  Assert: Due to validation, [elemmode](#syntax-elemmode) is some [active](#syntax-elemmode) [tableidx](#syntax-tableidx) [expr](#syntax-expr).
    
4.  Let ([active](#syntax-elemmode) y [instr](#syntax-instr)∗) be the destructuring of [elemmode](#syntax-elemmode).
    
5.  Return [instr](#syntax-instr)∗ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([table.init](#syntax-instr-table) y x) ([elem.drop](#syntax-instr-table) x).
    

[rundata](#aux-rundata)x​([data](#syntax-data) bn ([passive](#syntax-datamode)))[rundata](#aux-rundata)x​([data](#syntax-data) bn ([active](#syntax-datamode) y [instr](#syntax-instr)∗))[instr](#syntax-instr)∗ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([memory.init](#syntax-instr-memory) y x) ([data.drop](#syntax-instr-memory) x)​0.8ex\][runelem](#aux-runelem)x​([elem](#syntax-elem) rt en ([passive](#syntax-elemmode)))[runelem](#aux-runelem)x​([elem](#syntax-elem) rt en ([declare](#syntax-elemmode)))[runelem](#aux-runelem)x​([elem](#syntax-elem) rt en ([active](#syntax-elemmode) y [instr](#syntax-instr)∗))[instr](#syntax-instr)∗ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([table.init](#syntax-instr-table) y x) ([elem.drop](#syntax-instr-table) x)​​\=\=\=\=\=​ϵϵ([elem.drop](#syntax-instr-table) x)​​​

Note

Checking import types assumes that the [module instance](#syntax-moduleinst) has already been [allocated](#alloc-module) to compute the respective [closed](#type-closed) [defined types](#syntax-deftype). However, this forward reference merely is a way to simplify the specification. In practice, implementations will likely allocate or canonicalize types beforehand, when _compiling_ a module, in a stage before instantiation and before imports are checked.

Similarly, module [allocation](#alloc-module) and the [evaluation](#exec-expr) of [global](#syntax-global) and [table](#syntax-table) initializers as well as [element segments](#syntax-elem) are mutually recursive because the global initialization [values](#syntax-val) [val](#syntax-val)g∗​, [ref](#syntax-ref)t​, and element segment contents [ref](#syntax-ref)e∗​∗ are passed to the module allocator while depending on the module instance [moduleinst](#syntax-moduleinst) and store s′ returned by allocation. Again, this recursion is just a specification device. In practice, the initialization values can [be determined](#exec-initvals) beforehand by staging module allocation such that first, the module’s own [function instances](#syntax-funcinst) are pre-allocated in the store, then the initializer expressions are evaluated in order, allocating globals on the way, then the rest of the module instance is allocated, and finally the new function instances’ module fields are set to that module instance. This is possible because [validation](#valid-module) ensures that initialization expressions cannot actually call a function, only take their reference.

All failure conditions are checked before any observable mutation of the store takes place. Store mutation is not atomic; it happens in individual steps that may be interleaved with other threads.

[Evaluation](#exec-expr) of [constant expressions](#valid-constant) does not affect the store.

#### 4.7.3. Invocation[](#invocation②)

Once a [module](#syntax-module) has been [instantiated](#exec-instantiation), any exported function can be _invoked_ externally via its [function address](#syntax-funcaddr) [funcaddr](#syntax-funcaddr) in the [store](#syntax-store) s and an appropriate list [val](#syntax-val)∗ of argument [values](#syntax-val).

Invocation may _fail_ with an error if the arguments do not fit the [function type](#syntax-functype). Invocation can also result in an [exception](#exception) or [trap](#trap). It is up to the [embedder](#embedder) to define how such conditions are reported.

Note

If the [embedder](#embedder) API performs type checks itself, either statically or dynamically, before performing an invocation, then no failure other than traps or exceptions can occur.

##### 4.7.3.1. [invoke](#exec-invocation)(s,[funcaddr](#syntax-funcaddr),[val](#syntax-val)∗)[](#-hrefexec-invocationmathrminvoke-s-hrefsyntax-funcaddrmathitfuncaddr-hrefsyntax-valmathitvalast)

1.  Assert: Due to validation, the [expansion](#aux-expand-deftype) of s.[funcs](#syntax-store)\[[funcaddr](#syntax-funcaddr)\].[type](#syntax-funcinst) is some [func](#syntax-comptype) [resulttype](#syntax-resulttype)[→](#syntax-comptype)[resulttype](#syntax-resulttype).
    
2.  Let ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​) be the destructuring of the [expansion](#aux-expand-deftype) of s.[funcs](#syntax-store)\[[funcaddr](#syntax-funcaddr)\].[type](#syntax-funcinst).
    
3.  If ∣t1∗​∣\=∣[val](#syntax-val)∗∣, then:
    
    1.  Fail.
        
4.  For all t1​ in t1∗​, and corresponding [val](#syntax-val) in [val](#syntax-val)∗:
    
    1.  If [val](#syntax-val) is not [valid](#valid-val) with type t1​, then:
        
        1.  Fail.
            
5.  Let k be the length of t2∗​.
    
6.  Let F be the frame {[module](#syntax-frame) {}} whose arity is k.
    
7.  Push the frame F.
    
8.  Push the values [val](#syntax-val)∗ to the stack.
    
9.  Push the value ([ref.func](#syntax-ref) [funcaddr](#syntax-funcaddr)) to the stack.
    
10.  Execute the instruction ([call\_ref](#syntax-instr-control) s.[funcs](#syntax-store)\[[funcaddr](#syntax-funcaddr)\].[type](#syntax-funcinst)).
    
11.  Pop the values [val](#syntax-val)′k from the stack.
    
12.  Pop the frame from the stack.
    
13.  Return [val](#syntax-val)′k.
    

[invoke](#exec-invocation)(s,[funcaddr](#syntax-funcaddr),[val](#syntax-val)∗)​\=​s;{[module](#syntax-frame) {}};[val](#syntax-val)∗ ([ref.func](#syntax-ref) [funcaddr](#syntax-funcaddr)) ([call\_ref](#syntax-instr-control) s.[funcs](#syntax-store)\[[funcaddr](#syntax-funcaddr)\].[type](#syntax-funcinst))if s.[funcs](#syntax-store)\[[funcaddr](#syntax-funcaddr)\].[type](#syntax-funcinst)[≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​∧ (s[⊢](#valid-val)[val](#syntax-val):t1​)∗​​​

5\. Binary Format[](#binary-format①)
------------------------------------

### 5.1. Conventions[](#conventions③①)

The binary format for WebAssembly [modules](#module) is a dense linear _encoding_ of their [abstract syntax](#syntax-module). [\[1\]](#compression)

The format is defined by an _attribute grammar_ whose only terminal symbols are [bytes](#syntax-byte). A byte sequence is a well-formed encoding of a module if and only if it is generated by the grammar.

Each production of this grammar has exactly one synthesized attribute: the abstract syntax that the respective byte sequence encodes. Thus, the attribute grammar implicitly defines a _decoding_ function (i.e., a parsing function for the binary format).

Except for a few exceptions, the binary grammar closely mirrors the grammar of the abstract syntax.

Note

Some phrases of abstract syntax have multiple possible encodings in the binary format. For example, numbers may be encoded as if they had optional leading zeros. Implementations of decoders must support all possible alternatives; implementations of encoders can pick any allowed encoding.

The recommended extension for files containing WebAssembly modules in binary format is “.wasm” and the recommended [Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml) is “application/wasm”.

\[[1](#id1)\]

Additional encoding layers – for example, introducing compression – may be defined on top of the basic representation defined here. However, such layers are outside the scope of the current specification.

#### 5.1.1. Grammar[](#grammar②)

The following conventions are adopted in defining grammar rules for the binary format. They mirror the conventions used for [abstract syntax](#grammar). In order to distinguish symbols of the binary syntax from symbols of the abstract syntax, typewriter font is adopted for the former.

*   Terminal symbols are [bytes](#syntax-byte) expressed in hexadecimal notation: 0x0F.
    
*   Nonterminal symbols are written in typewriter font: [valtype](#binary-valtype), [instr](#binary-instr).
    
*   Bn is a sequence of n≥0 iterations of B.
    
*   B∗ is a possibly empty sequence of iterations of B. (This is a shorthand for Bn used where n is not relevant.)
    
*   B? is an optional occurrence of B. (This is a shorthand for Bn where n≤1.)
    
*   x:B denotes the same language as the nonterminal B, but also binds the variable x to the attribute synthesized for B. A pattern may also be used instead of a variable, e.g., 7:B.
    
*   Productions are written ​sym​::=​B1​ ⇒ A1​ ∣ … ∣ Bn​ ⇒ An​​, where each Ai​ is the attribute that is synthesized for sym in the given case, usually from attribute variables bound in Bi​.
    
*   Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, ​sym​::=​B1​​, and starting continuations with ellipses, ​sym​::=​… ∣ B2​​.
    
*   Some productions are augmented by side conditions in parentheses, which restrict the applicability of the production. They provide a shorthand for a combinatorial expansion of the production into many separate cases.
    
*   If the same meta variable or non-terminal symbol appears multiple times in a production (in the syntax or in an attribute), then all those occurrences must have the same instantiation. (This is a shorthand for a side condition requiring multiple different variables to be equal.)
    

Note

For example, the [binary grammar](#binary-numtype) for [number types](#syntax-numtype) is given as follows:

​[numtype](#binary-numtype)​::=∣∣∣​0x7C0x7D0x7E0x7F​⇒⇒⇒⇒​[f64](#syntax-numtype)[f32](#syntax-numtype)[i64](#syntax-numtype)[i32](#syntax-numtype)​​

Consequently, the byte 0x7F encodes the type [i32](#syntax-numtype), 0x7E encodes the type [i64](#syntax-numtype), and so forth. No other byte value is allowed as the encoding of a number type.

The [binary grammar](#binary-limits) for [limits](#syntax-limits) is defined as follows:

​[limits](#binary-limits)​::=∣∣∣​0x00 n:[u64](#binary-int)0x01 n:[u64](#binary-int) m:[u64](#binary-int)0x04 n:[u64](#binary-int)0x05 n:[u64](#binary-int) m:[u64](#binary-int)​⇒⇒⇒⇒​([i32](#syntax-numtype),\[n[..](#syntax-limits)ϵ\])([i32](#syntax-numtype),\[n[..](#syntax-limits)m\])([i64](#syntax-numtype),\[n[..](#syntax-limits)ϵ\])([i64](#syntax-numtype),\[n[..](#syntax-limits)m\])​​

That is, a limits pair is encoded as either the byte 0x00 followed by the encoding of a [u64](#syntax-int) value, or the byte 0x01 followed by two such encodings. The variables n and m name the attributes of the respective [u64](#binary-int) nonterminals, which in this case are the actual [unsigned integers](#syntax-uint) those decode into. The attribute of the complete production then is the abstract syntax for the limit, expressed in terms of the former values.

#### 5.1.2. Auxiliary Notation[](#auxiliary-notation③)

When dealing with binary encodings the following notation is also used:

*   ϵ denotes the empty byte sequence.
    
*   ∣∣B∣∣ is the length of the byte sequence generated from the production B in a derivation.
    

#### 5.1.3. Lists[](#lists③)

[Lists](#syntax-list) are encoded with their [u32](#binary-int) length followed by the encoding of their element sequence.

​[list](#binary-list)(X)​::=​n:[u32](#binary-int) (el:X)n​⇒​eln​​

### 5.2. Values[](#values⑧)

#### 5.2.1. Bytes[](#bytes③)

[Bytes](#syntax-byte) encode themselves.

​[byte](#binary-byte)​::=​0x00 ∣ … ∣ 0xFF​​

#### 5.2.2. Integers[](#integers⑤)

All [integers](#syntax-int) are encoded using the [LEB128](https://en.wikipedia.org/wiki/LEB128) variable-length integer encoding, in either unsigned or signed variant.

[Unsigned integers](#syntax-uint) are encoded in [unsigned LEB128](https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128) format. As an additional constraint, the total number of bytes encoding a [u](#syntax-int)N value must not exceed ceil(N/7) bytes.

​[u](#binary-int)N​::=∣​n:[byte](#binary-byte)n:[byte](#binary-byte) m:[u](#binary-int)(N−7)​⇒⇒​n27⋅m+(n−27)​if n<27∧n<2Nif n≥27∧N\>7​​

[Signed integers](#syntax-sint) are encoded in [signed LEB128](https://en.wikipedia.org/wiki/LEB128#Signed_LEB128) format, which uses a two’s complement representation. As an additional constraint, the total number of bytes encoding an [s](#syntax-int)N value must not exceed ceil(N/7) bytes.

​[s](#binary-int)N​::=∣∣​n:[byte](#binary-byte)n:[byte](#binary-byte)n:[byte](#binary-byte) i:[s](#binary-int)(N−7)​⇒⇒⇒​nn−2727⋅i+(n−27)​if n<26∧n<2N−1if 26≤n<27∧n≥27−2N−1if n≥27∧N\>7​​

[Uninterpreted integers](#syntax-int) are encoded as signed integers.

​[i](#binary-int)N​::=​i:[s](#binary-int)N​⇒​[signed](#aux-signed)N−1​(i)​​

Note

The side conditions N\>7 in the productions for non-terminal bytes of the [u](#syntax-int)N and [s](#syntax-int)N encodings restrict the encoding’s length. However, “trailing zeros” are still allowed within these bounds. For example, 0x03 and 0x83 0x00 are both well-formed encodings for the value 3 as a [u8](#syntax-int). Similarly, either of 0x7E and 0xFE 0x7F and 0xFE 0xFF 0x7F are well-formed encodings of the value −2 as an s16.

The side conditions on the value n of terminal bytes further enforce that any unused bits in these bytes must be 0 for positive values and 1 for negative ones. For example, 0x83 0x10 is malformed as a [u8](#syntax-int) encoding. Similarly, both 0x83 0x3E and 0xFF 0x7B are malformed as s8 encodings.

#### 5.2.3. Floating-Point[](#floating-point⑤)

[Floating-point](#syntax-float) values are encoded directly by their [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") (Section 3.4) bit pattern in [little endian](https://en.wikipedia.org/wiki/Endianness#Little-endian) byte order:

​[f](#binary-float)N​::=​b∗:[byte](#binary-byte)N/8​⇒​[bytes](#aux-bytes)[f](#syntax-numtype)N−1​(b∗)​​

#### 5.2.4. Names[](#names③)

[Names](#syntax-name) are encoded as a [list](#binary-list) of bytes containing the [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 3.9) UTF-8 encoding of the name’s character sequence.

​[name](#binary-name)​::=​b∗:[list](#binary-list)([byte](#binary-byte))​⇒​[name](#syntax-name)​if [utf8](#binary-utf8)([name](#syntax-name))\=b∗​​

The auxiliary [utf8](#binary-utf8) function expressing this encoding is defined as follows:

[utf8](#binary-utf8)(ch∗)[utf8](#binary-utf8)(ch)[utf8](#binary-utf8)(ch)[utf8](#binary-utf8)(ch)[utf8](#binary-utf8)(ch)​\=\=\=\=\=​[⨁](#notation-concat)[utf8](#binary-utf8)(ch)∗bb1​ b2​b1​ b2​ b3​b1​ b2​ b3​ b4​​if ch<U+80∧ ch\=b​if U+80≤ch<U+0800∧ ch\=26⋅(b1​−0xC0)+cont(b2​)​if U+0800≤ch<U+D800∨U+E000≤ch<U+10000∧ ch\=212⋅(b1​−0xE0)+26⋅cont(b2​)+cont(b3​)​if U+10000≤ch<U+11000∧ ch\=218⋅(b1​−0xF0)+212⋅cont(b2​)+26⋅cont(b3​)+cont(b4​)​​​

where cont(b)​\=​b−0x80​if (0x80<b<0xC0)​

Note

Unlike in some other formats, name strings are not 0-terminated.

### 5.3. Types[](#types①③)

Note

In some places, possible types include both type constructors or types denoted by [type indices](#syntax-typeidx). Thus, the binary format for type constructors corresponds to the encodings of small negative [s](#syntax-int)N values, such that they can unambiguously occur in the same place as (positive) type indices.

#### 5.3.1. Number Types[](#number-types⑦)

[Number types](#syntax-numtype) are encoded by a single byte.

​[numtype](#binary-numtype)​::=∣∣∣​0x7C0x7D0x7E0x7F​⇒⇒⇒⇒​[f64](#syntax-numtype)[f32](#syntax-numtype)[i64](#syntax-numtype)[i32](#syntax-numtype)​​

#### 5.3.2. Vector Types[](#vector-types⑦)

[Vector types](#syntax-vectype) are also encoded by a single byte.

​[vectype](#binary-vectype)​::=​0x7B​⇒​[v128](#syntax-vectype)​​

#### 5.3.3. Heap Types[](#heap-types⑦)

[Heap types](#syntax-reftype) are encoded as either a single byte, or as a [type index](#binary-typeidx) encoded as a positive [signed integer](#binary-sint).

​[absheaptype](#binary-absheaptype)​::=∣∣∣∣∣∣∣∣∣∣∣∣​0x690x6A0x6B0x6C0x6D0x6E0x6F0x700x710x720x730x74x:[s33](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[exn](#syntax-heaptype)[array](#syntax-heaptype)[struct](#syntax-heaptype)[i31](#syntax-heaptype)[eq](#syntax-heaptype)[any](#syntax-heaptype)[extern](#syntax-heaptype)[func](#syntax-heaptype)[none](#syntax-heaptype)[noextern](#syntax-heaptype)[nofunc](#syntax-heaptype)[noexn](#syntax-heaptype)0.8ex\]x​[heaptype](#binary-heaptype)if x≥0​::=​ht:[absheaptype](#binary-absheaptype)​⇒​ht​​

Note

The heap type [bot](#syntax-valtype-ext) cannot occur in a module.

#### 5.3.4. Reference Types[](#reference-types⑦)

[Reference types](#syntax-reftype) are either encoded by a single byte followed by a [heap type](#binary-heaptype), or, as a short form, directly as an [abstract heap type](#binary-absheaptype).

​[reftype](#binary-reftype)​::=∣∣​0x63 ht:[heaptype](#binary-heaptype)0x64 ht:[heaptype](#binary-heaptype)ht:[absheaptype](#binary-absheaptype)​⇒⇒⇒​[ref](#syntax-reftype) [null](#syntax-reftype) ht[ref](#syntax-reftype) ht[ref](#syntax-reftype) [null](#syntax-reftype) ht​​

#### 5.3.5. Value Types[](#value-types⑦)

[Value types](#syntax-valtype) are encoded with their respective encoding as a [number type](#binary-numtype), [vector type](#binary-vectype), or [reference type](#binary-reftype).

​[valtype](#binary-valtype)​::=∣∣​nt:[numtype](#binary-numtype)vt:[vectype](#binary-vectype)rt:[reftype](#binary-reftype)​⇒⇒⇒​ntvtrt​​

Note

The value type [bot](#syntax-valtype-ext) cannot occur in a module.

Value types can occur in contexts where [type indices](#syntax-typeidx) are also allowed, such as in the case of [block types](#binary-blocktype). Thus, the binary format for types corresponds to the [signed LEB128](https://en.wikipedia.org/wiki/LEB128#Signed_LEB128) [encoding](#binary-sint) of small negative [s](#syntax-int)N values, so that they can coexist with (positive) type indices in the future.

#### 5.3.6. Result Types[](#result-types⑦)

[Result types](#syntax-resulttype) are encoded by the respective [lists](#binary-list) of [value types](#binary-valtype).

​[resulttype](#binary-resulttype)​::=​t∗:[list](#binary-list)([valtype](#binary-valtype))​⇒​t∗​​

#### 5.3.7. Composite Types[](#composite-types⑦)

[Composite types](#syntax-comptype) are encoded by a distinct byte followed by a type encoding of the respective form.

​[mut](#binary-mut)​::=∣∣∣∣∣​0x000x010x5F ft∗:[list](#binary-list)([fieldtype](#binary-fieldtype))0x60 t1∗​:[resulttype](#binary-resulttype) t2∗​:[resulttype](#binary-resulttype)pt:[packtype](#binary-packtype)0x78​⇒⇒⇒⇒⇒⇒​ϵ[mut](#syntax-mut)0.8ex\][struct](#syntax-comptype) ft∗[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​0.8ex\]pt0.8ex\][i8](#syntax-storagetype)​[comptype](#binary-comptype)[fieldtype](#binary-fieldtype)[packtype](#binary-packtype)​::=::=::=​0x5E ft:[fieldtype](#binary-fieldtype)zt:[storagetype](#binary-storagetype) [mut](#syntax-mut)?:[mut](#binary-mut)0x77​⇒⇒⇒​[array](#syntax-comptype) ft[mut](#syntax-mut)? zt0.8ex\][i16](#syntax-storagetype)​[storagetype](#binary-storagetype)​::=​t:[valtype](#binary-valtype)​⇒​t​​

#### 5.3.8. Recursive Types[](#recursive-types⑤)

[Recursive types](#syntax-rectype) are encoded by the byte 0x4E followed by a [list](#binary-list) of [sub types](#syntax-subtype). Additional shorthands are recognized for unary recursions and sub types without super types.

​[rectype](#binary-rectype)​::=∣∣∣​0x4E st∗:[list](#binary-list)([subtype](#binary-subtype))st:[subtype](#binary-subtype)0x50 x∗:[list](#binary-list)([typeidx](#binary-typeidx)) ct:[comptype](#binary-comptype)ct:[comptype](#binary-comptype)​⇒⇒⇒⇒​[rec](#syntax-rectype) st∗[rec](#syntax-rectype) st0.8ex\][sub](#syntax-subtype) x∗ ct[sub](#syntax-subtype) [final](#syntax-subtype) ϵ ct​[subtype](#binary-subtype)::=0x4F x∗:[list](#binary-list)([typeidx](#binary-typeidx)) ct:[comptype](#binary-comptype)⇒[sub](#syntax-subtype) [final](#syntax-subtype) x∗ ct​

#### 5.3.9. Limits[](#limits⑦)

[Limits](#syntax-limits) are encoded with a preceding flag indicating whether a maximum is present, and a flag for the [address type](#syntax-addrtype).

​[limits](#binary-limits)​::=∣∣∣​0x00 n:[u64](#binary-int)0x01 n:[u64](#binary-int) m:[u64](#binary-int)0x04 n:[u64](#binary-int)0x05 n:[u64](#binary-int) m:[u64](#binary-int)​⇒⇒⇒⇒​([i32](#syntax-numtype),\[n[..](#syntax-limits)ϵ\])([i32](#syntax-numtype),\[n[..](#syntax-limits)m\])([i64](#syntax-numtype),\[n[..](#syntax-limits)ϵ\])([i64](#syntax-numtype),\[n[..](#syntax-limits)m\])​​

#### 5.3.10. Tag Types[](#tag-types⑦)

[Tag types](#syntax-tagtype) are encoded by a [type index](#syntax-typeidx) denoting a [function type](#syntax-functype).

​[tagtype](#binary-tagtype)​::=​0x00 x:[typeidx](#binary-typeidx)​⇒​x​​

Note

In future versions of WebAssembly, the preceding zero byte may encode additional attributes.

#### 5.3.11. Global Types[](#global-types⑦)

[Global types](#syntax-globaltype) are encoded by their [value type](#binary-valtype) and a flag for their [mutability](#syntax-mut).

​[globaltype](#binary-globaltype)​::=​t:[valtype](#binary-valtype) [mut](#syntax-mut)?:[mut](#binary-mut)​⇒​[mut](#syntax-mut)? t​​

#### 5.3.12. Memory Types[](#memory-types⑦)

[Memory types](#syntax-memtype) are encoded with their [limits](#binary-limits).

​[memtype](#binary-memtype)​::=​(at,lim):[limits](#binary-limits)​⇒​at lim [page](#syntax-memtype)​​

#### 5.3.13. Table Types[](#table-types⑦)

[Table types](#syntax-tabletype) are encoded with their [limits](#binary-limits) and the encoding of their element [reference type](#syntax-reftype).

​[tabletype](#binary-tabletype)​::=​rt:[reftype](#binary-reftype) (at,lim):[limits](#binary-limits)​⇒​at lim rt​​

#### 5.3.14. External Types[](#external-types⑦)

[External types](#syntax-externtype) are encoded by a distiguishing byte followed by an encoding of the respective form of type.

​[externtype](#binary-externtype)​::=∣∣∣∣​0x00 x:[typeidx](#binary-typeidx)0x01 tt:[tabletype](#binary-tabletype)0x02 mt:[memtype](#binary-memtype)0x03 gt:[globaltype](#binary-globaltype)0x04 jt:[tagtype](#binary-tagtype)​⇒⇒⇒⇒⇒​[func](#syntax-externtype) x[table](#syntax-externtype) tt[mem](#syntax-externtype) mt[global](#syntax-externtype) gt[tag](#syntax-externtype) jt​​

### 5.4. Instructions[](#instructions⑦)

[Instructions](#syntax-instr) are encoded by _opcodes_. Each opcode is represented by a single byte, and is followed by the instruction’s immediate arguments, where present. The only exception are [structured control instructions](#binary-instr-control), which consist of several opcodes bracketing their nested instruction sequences.

Note

The byte codes chosen to encode instructions are historical and do not follow a consistent pattern. In this section, instructions are hence not presented in opcode order, but instead grouped consistently with other sections in this document. An instruction index ordered by opcode can be found in the [Appendix](#index-instr).

Gaps in the byte code ranges are reserved for future extensions.

#### 5.4.1. Parametric Instructions[](#parametric-instructions⑦)

[Parametric instructions](#syntax-instr-parametric) are represented by single byte codes, possibly followed by a type annotation.

​[instr](#binary-instr)​::=∣∣∣∣​0x000x010x1A0x1B0x1C t∗:[list](#binary-list)([valtype](#binary-valtype))​⇒⇒⇒⇒⇒​[unreachable](#syntax-instr-control)[nop](#syntax-instr-control)[drop](#syntax-instr-parametric)[select](#syntax-instr-parametric)[select](#syntax-instr-parametric) t∗​​

#### 5.4.2. Control Instructions[](#control-instructions⑦)

[Control instructions](#syntax-instr-control) have varying encodings. For structured instructions, the instruction sequences forming nested blocks are delimited with explicit opcodes for end and else.

[Block types](#syntax-blocktype) are encoded in special compressed form, by either the byte 0x40 indicating the empty type, as a single [value type](#binary-valtype), or as a [type index](#binary-typeidx) encoded as a positive [signed integer](#binary-sint).

​[blocktype](#binary-blocktype)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​0x40t:[valtype](#binary-valtype)i:[s33](#binary-int)0x02 bt:[blocktype](#binary-blocktype) (in:[instr](#binary-instr))∗ 0x0B0x03 bt:[blocktype](#binary-blocktype) (in:[instr](#binary-instr))∗ 0x0B0x04 bt:[blocktype](#binary-blocktype) (in:[instr](#binary-instr))∗ 0x0B0x04 bt:[blocktype](#binary-blocktype) (in1​:[instr](#binary-instr))∗0x05 (in2​:[instr](#binary-instr))∗ 0x0B​0x08 x:[tagidx](#binary-tagidx)0x0A0x0C l:[labelidx](#binary-labelidx)0x0D l:[labelidx](#binary-labelidx)0x0E l∗:[list](#binary-list)([labelidx](#binary-labelidx)) ln​:[labelidx](#binary-labelidx)0x0F0x10 x:[funcidx](#binary-funcidx)0x11 y:[typeidx](#binary-typeidx) x:[tableidx](#binary-tableidx)0x12 x:[funcidx](#binary-funcidx)0x13 y:[typeidx](#binary-typeidx) x:[tableidx](#binary-tableidx)0x14 x:[typeidx](#binary-typeidx)0x15 x:[typeidx](#binary-typeidx)0x1F bt:[blocktype](#binary-blocktype) c∗:[list](#binary-list)([catch](#binary-catch)) (in:[instr](#binary-instr))∗ 0x0B0xD5 l:[labelidx](#binary-labelidx)0xD6 l:[labelidx](#binary-labelidx)0xFB 24:[u32](#binary-int) ([null](#syntax-reftype)1?​,[null](#syntax-reftype)2?​):[castop](#binary-castop)l:[labelidx](#binary-labelidx) ht1​:[heaptype](#binary-heaptype) ht2​:[heaptype](#binary-heaptype)​0xFB 25:[u32](#binary-int) ([null](#syntax-reftype)1?​,[null](#syntax-reftype)2?​):[castop](#binary-castop)l:[labelidx](#binary-labelidx) ht1​:[heaptype](#binary-heaptype) ht2​:[heaptype](#binary-heaptype)​0x01 x:[tagidx](#binary-tagidx) l:[labelidx](#binary-labelidx)0x02 l:[labelidx](#binary-labelidx)0x03 l:[labelidx](#binary-labelidx)0x010x020x03​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​ϵti[block](#syntax-instr-control) bt in∗[loop](#syntax-instr-control) bt in∗[if](#syntax-instr-control) bt in∗ [else](#syntax-instr-control) ϵ[if](#syntax-instr-control) bt in1∗​ [else](#syntax-instr-control) in2∗​[throw](#syntax-instr-control) x[throw\_ref](#syntax-instr-control)[br](#syntax-instr-control) l[br\_if](#syntax-instr-control) l[br\_table](#syntax-instr-control) l∗ ln​[return](#syntax-instr-control)[call](#syntax-instr-control) x[call\_indirect](#syntax-instr-control) x y[return\_call](#syntax-instr-control) x[return\_call\_indirect](#syntax-instr-control) x y[call\_ref](#syntax-instr-control) x[return\_call\_ref](#syntax-instr-control) x[try\_table](#syntax-instr-control) bt c∗ in∗[br\_on\_null](#syntax-instr-control) l[br\_on\_non\_null](#syntax-instr-control) l[br\_on\_cast](#syntax-instr-control) l ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​) ([ref](#syntax-reftype) [null](#syntax-reftype)2?​ ht2​)[br\_on\_cast\_fail](#syntax-instr-control) l ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​) ([ref](#syntax-reftype) [null](#syntax-reftype)2?​ ht2​)0.8ex\][catch\_ref](#syntax-instr-control) x l[catch\_all](#syntax-instr-control) l[catch\_all\_ref](#syntax-instr-control) l0.8ex\]([null](#syntax-reftype),ϵ)(ϵ,[null](#syntax-reftype))([null](#syntax-reftype),[null](#syntax-reftype))​if i≥00.8ex\][catch](#binary-catch)[castop](#binary-castop)​[instr](#binary-instr)::=::=​::=0x00 x:[tagidx](#binary-tagidx) l:[labelidx](#binary-labelidx)0x00​…⇒⇒​[catch](#syntax-instr-control) x l(ϵ,ϵ)​​

Note

The else opcode 0x05 in the encoding of an if instruction can be omitted if the following instruction sequence is empty.

Unlike any [other occurrence](#binary-typeidx), the [type index](#syntax-typeidx) in a [block type](#syntax-blocktype) is encoded as a positive [signed integer](#syntax-sint), so that its signed LEB128 bit pattern cannot collide with the encoding of [value types](#binary-valtype) or the special code 0x40, which correspond to the LEB128 encoding of negative integers. To avoid any loss in the range of allowed indices, it is treated as a 33 bit signed integer.

#### 5.4.3. Variable Instructions[](#variable-instructions⑦)

[Variable instructions](#syntax-instr-variable) are represented by byte codes followed by the encoding of the respective [index](#syntax-index).

​[instr](#binary-instr)​::=∣∣∣∣∣​…0x20 x:[localidx](#binary-localidx)0x21 x:[localidx](#binary-localidx)0x22 x:[localidx](#binary-localidx)0x23 x:[globalidx](#binary-globalidx)0x24 x:[globalidx](#binary-globalidx)​⇒⇒⇒⇒⇒​[local.get](#syntax-instr-variable) x[local.set](#syntax-instr-variable) x[local.tee](#syntax-instr-variable) x[global.get](#syntax-instr-variable) x[global.set](#syntax-instr-variable) x​​

#### 5.4.4. Table Instructions[](#table-instructions⑦)

[Table instructions](#syntax-instr-table) are represented either by a single byte or a one byte prefix followed by a variable-length [unsigned integer](#binary-uint).

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣​…0x25 x:[tableidx](#binary-tableidx)0x26 x:[tableidx](#binary-tableidx)0xFC 12:[u32](#binary-int) y:[elemidx](#binary-elemidx) x:[tableidx](#binary-tableidx)0xFC 13:[u32](#binary-int) x:[elemidx](#binary-elemidx)0xFC 14:[u32](#binary-int) x1​:[tableidx](#binary-tableidx) x2​:[tableidx](#binary-tableidx)0xFC 15:[u32](#binary-int) x:[tableidx](#binary-tableidx)0xFC 16:[u32](#binary-int) x:[tableidx](#binary-tableidx)0xFC 17:[u32](#binary-int) x:[tableidx](#binary-tableidx)​⇒⇒⇒⇒⇒⇒⇒⇒​[table.get](#syntax-instr-table) x[table.set](#syntax-instr-table) x[table.init](#syntax-instr-table) x y[elem.drop](#syntax-instr-table) x[table.copy](#syntax-instr-table) x1​ x2​[table.grow](#syntax-instr-table) x[table.size](#syntax-instr-table) x[table.fill](#syntax-instr-table) x​​

#### 5.4.5. Memory Instructions[](#memory-instructions⑦)

Each variant of [memory instruction](#syntax-instr-memory) is encoded with a different byte code. Loads and stores are followed by the encoding of their [memarg](#syntax-memarg) immediate, which includes the [memory index](#binary-memidx) if bit 6 of the flags field containing alignment is set; the memory index defaults to 0 otherwise.

​[memarg](#binary-memarg)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​n:[u32](#binary-int) m:[u64](#binary-int)n:[u32](#binary-int) x:[memidx](#binary-memidx) m:[u64](#binary-int)0x28 (x,ao):[memarg](#binary-memarg)0x29 (x,ao):[memarg](#binary-memarg)0x2A (x,ao):[memarg](#binary-memarg)0x2B (x,ao):[memarg](#binary-memarg)0x2C (x,ao):[memarg](#binary-memarg)0x2D (x,ao):[memarg](#binary-memarg)0x2E (x,ao):[memarg](#binary-memarg)0x2F (x,ao):[memarg](#binary-memarg)0x30 (x,ao):[memarg](#binary-memarg)0x31 (x,ao):[memarg](#binary-memarg)0x32 (x,ao):[memarg](#binary-memarg)0x33 (x,ao):[memarg](#binary-memarg)0x34 (x,ao):[memarg](#binary-memarg)0x35 (x,ao):[memarg](#binary-memarg)0x36 (x,ao):[memarg](#binary-memarg)0x37 (x,ao):[memarg](#binary-memarg)0x38 (x,ao):[memarg](#binary-memarg)0x39 (x,ao):[memarg](#binary-memarg)0x3A (x,ao):[memarg](#binary-memarg)0x3B (x,ao):[memarg](#binary-memarg)0x3C (x,ao):[memarg](#binary-memarg)0x3D (x,ao):[memarg](#binary-memarg)0x3E (x,ao):[memarg](#binary-memarg)0x3F x:[memidx](#binary-memidx)0x40 x:[memidx](#binary-memidx)0xFC 8:[u32](#binary-int) y:[dataidx](#binary-dataidx) x:[memidx](#binary-memidx)0xFC 9:[u32](#binary-int) x:[dataidx](#binary-dataidx)0xFC 10:[u32](#binary-int) x1​:[memidx](#binary-memidx) x2​:[memidx](#binary-memidx)0xFC 11:[u32](#binary-int) x:[memidx](#binary-memidx)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​(0,{[align](#syntax-instr-memory) n,[offset](#syntax-instr-memory) m})(x,{[align](#syntax-instr-memory) (n−26),[offset](#syntax-instr-memory) m})[i32](#syntax-numtype).[load](#syntax-instr-memory) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory) x ao[f32](#syntax-numtype).[load](#syntax-instr-memory) x ao[f64](#syntax-numtype).[load](#syntax-instr-memory) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[s](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)16\_[s](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)16\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)8\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)16\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)16\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)32\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)32\_[u](#syntax-sx) x ao[i32](#syntax-numtype).[store](#syntax-instr-memory) x ao[i64](#syntax-numtype).[store](#syntax-instr-memory) x ao[f32](#syntax-numtype).[store](#syntax-instr-memory) x ao[f64](#syntax-numtype).[store](#syntax-instr-memory) x ao[i32](#syntax-numtype).[store](#syntax-instr-memory)8 x ao[i32](#syntax-numtype).[store](#syntax-instr-memory)16 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)8 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)16 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)32 x ao[memory.size](#syntax-instr-memory) x[memory.grow](#syntax-instr-memory) x[memory.init](#syntax-instr-memory) x y[data.drop](#syntax-instr-memory) x[memory.copy](#syntax-instr-memory) x1​ x2​[memory.fill](#syntax-instr-memory) x​if n<26if 26≤n<270.8ex\][instr](#binary-instr)::=…​

#### 5.4.6. Reference Instructions[](#reference-instructions⑦)

Generic [reference instructions](#syntax-instr-ref) are represented by single byte codes, others use prefixes and type operands.

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣​…0xD0 ht:[heaptype](#binary-heaptype)0xD10xD2 x:[funcidx](#binary-funcidx)0xD30xD40xFB 20:[u32](#binary-int) ht:[heaptype](#binary-heaptype)0xFB 21:[u32](#binary-int) ht:[heaptype](#binary-heaptype)0xFB 22:[u32](#binary-int) ht:[heaptype](#binary-heaptype)0xFB 23:[u32](#binary-int) ht:[heaptype](#binary-heaptype)​⇒⇒⇒⇒⇒⇒⇒⇒⇒​[ref.null](#syntax-instr-ref) ht[ref.is\_null](#syntax-instr-ref)[ref.func](#syntax-instr-ref) x[ref.eq](#syntax-instr-ref)[ref.as\_non\_null](#syntax-instr-ref)[ref.test](#syntax-instr-ref) ([ref](#syntax-reftype) ht)[ref.test](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) ht)[ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) ht)[ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) ht)​​

#### 5.4.7. Aggregate Instructions[](#aggregate-instructions③)

[Aggregate instructions](#syntax-instr-aggr) all use a prefix.

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFB 0:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 1:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 2:[u32](#binary-int) x:[typeidx](#binary-typeidx) i:[u32](#binary-int)0xFB 3:[u32](#binary-int) x:[typeidx](#binary-typeidx) i:[u32](#binary-int)0xFB 4:[u32](#binary-int) x:[typeidx](#binary-typeidx) i:[u32](#binary-int)0xFB 5:[u32](#binary-int) x:[typeidx](#binary-typeidx) i:[u32](#binary-int)0xFB 6:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 7:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 8:[u32](#binary-int) x:[typeidx](#binary-typeidx) n:[u32](#binary-int)0xFB 9:[u32](#binary-int) x:[typeidx](#binary-typeidx) y:[dataidx](#binary-dataidx)0xFB 10:[u32](#binary-int) x:[typeidx](#binary-typeidx) y:[elemidx](#binary-elemidx)0xFB 11:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 12:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 13:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 14:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 15:[u32](#binary-int)0xFB 16:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 17:[u32](#binary-int) x1​:[typeidx](#binary-typeidx) x2​:[typeidx](#binary-typeidx)0xFB 18:[u32](#binary-int) x:[typeidx](#binary-typeidx) y:[dataidx](#binary-dataidx)0xFB 19:[u32](#binary-int) x:[typeidx](#binary-typeidx) y:[elemidx](#binary-elemidx)0xFB 26:[u32](#binary-int)0xFB 27:[u32](#binary-int)0xFB 28:[u32](#binary-int)0xFB 29:[u32](#binary-int)0xFB 30:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[struct.new](#syntax-instr-struct) x[struct.new\_default](#syntax-instr-struct) x[struct.get](#syntax-instr-struct) x i[struct.get](#syntax-instr-struct)\_[s](#syntax-sx) x i[struct.get](#syntax-instr-struct)\_[u](#syntax-sx) x i[struct.set](#syntax-instr-struct) x i[array.new](#syntax-instr-array) x[array.new\_default](#syntax-instr-array) x[array.new\_fixed](#syntax-instr-array) x n[array.new\_data](#syntax-instr-array) x y[array.new\_elem](#syntax-instr-array) x y[array.get](#syntax-instr-array) x[array.get](#syntax-instr-array)\_[s](#syntax-sx) x[array.get](#syntax-instr-array)\_[u](#syntax-sx) x[array.set](#syntax-instr-array) x[array.len](#syntax-instr-array)[array.fill](#syntax-instr-array) x[array.copy](#syntax-instr-array) x1​ x2​[array.init\_data](#syntax-instr-array) x y[array.init\_elem](#syntax-instr-array) x y[any.convert\_extern](#syntax-instr-extern)[extern.convert\_any](#syntax-instr-extern)[ref.i31](#syntax-instr-i31)[i31.get](#syntax-instr-i31)\_[s](#syntax-sx)[i31.get](#syntax-instr-i31)\_[u](#syntax-sx)​​

#### 5.4.8. Numeric Instructions[](#numeric-instructions⑦)

All variants of [numeric instructions](#syntax-instr-numeric) are represented by separate byte codes.

The const instructions are followed by the respective literal.

​[instr](#binary-instr)​::=∣∣∣∣​…0x41 i:[i32](#binary-int)0x42 i:[i64](#binary-int)0x43 p:[f32](#binary-float)0x44 p:[f64](#binary-float)​⇒⇒⇒⇒​[i32](#syntax-numtype).[const](#syntax-instr-numeric) i[i64](#syntax-numtype).[const](#syntax-instr-numeric) i[f32](#syntax-numtype).[const](#syntax-instr-numeric) p[f64](#syntax-numtype).[const](#syntax-instr-numeric) p​​

All other numeric instructions are plain opcodes without any immediates.

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0x450x460x470x480x490x4A0x4B0x4C0x4D0x4E0x4F0x500x510x520x530x540x550x560x570x580x590x5A​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[eqz](#syntax-instr-numeric)[i32](#syntax-numtype).[eq](#syntax-instr-numeric)[i32](#syntax-numtype).[ne](#syntax-instr-numeric)[i32](#syntax-numtype).[lt](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[lt](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[gt](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[gt](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[le](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[le](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[ge](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[ge](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[eqz](#syntax-instr-numeric)[i64](#syntax-numtype).[eq](#syntax-instr-numeric)[i64](#syntax-numtype).[ne](#syntax-instr-numeric)[i64](#syntax-numtype).[lt](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[lt](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[gt](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[gt](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[le](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[le](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[ge](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[ge](#syntax-instr-numeric)\_[u](#syntax-sx)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣​…0x5B0x5C0x5D0x5E0x5F0x600x610x620x630x640x650x66​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype).[eq](#syntax-instr-numeric)[f32](#syntax-numtype).[ne](#syntax-instr-numeric)[f32](#syntax-numtype).[lt](#syntax-instr-numeric)[f32](#syntax-numtype).[gt](#syntax-instr-numeric)[f32](#syntax-numtype).[le](#syntax-instr-numeric)[f32](#syntax-numtype).[ge](#syntax-instr-numeric)[f64](#syntax-numtype).[eq](#syntax-instr-numeric)[f64](#syntax-numtype).[ne](#syntax-instr-numeric)[f64](#syntax-numtype).[lt](#syntax-instr-numeric)[f64](#syntax-numtype).[gt](#syntax-instr-numeric)[f64](#syntax-numtype).[le](#syntax-instr-numeric)[f64](#syntax-numtype).[ge](#syntax-instr-numeric)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0x670x680x690x6A0x6B0x6C0x6D0x6E0x6F0x700x710x720x730x740x750x760x770x780x790x7A0x7B0x7C0x7D0x7E0x7F0x800x810x820x830x840x850x860x870x880x890x8A​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[clz](#syntax-instr-numeric)[i32](#syntax-numtype).[ctz](#syntax-instr-numeric)[i32](#syntax-numtype).[popcnt](#syntax-instr-numeric)[i32](#syntax-numtype).[add](#syntax-instr-numeric)[i32](#syntax-numtype).[sub](#syntax-instr-numeric)[i32](#syntax-numtype).[mul](#syntax-instr-numeric)[i32](#syntax-numtype).[div](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[div](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[rem](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[rem](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[and](#syntax-instr-numeric)[i32](#syntax-numtype).[or](#syntax-instr-numeric)[i32](#syntax-numtype).[xor](#syntax-instr-numeric)[i32](#syntax-numtype).[shl](#syntax-instr-numeric)[i32](#syntax-numtype).[shr](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[shr](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[rotl](#syntax-instr-numeric)[i32](#syntax-numtype).[rotr](#syntax-instr-numeric)[i64](#syntax-numtype).[clz](#syntax-instr-numeric)[i64](#syntax-numtype).[ctz](#syntax-instr-numeric)[i64](#syntax-numtype).[popcnt](#syntax-instr-numeric)[i64](#syntax-numtype).[add](#syntax-instr-numeric)[i64](#syntax-numtype).[sub](#syntax-instr-numeric)[i64](#syntax-numtype).[mul](#syntax-instr-numeric)[i64](#syntax-numtype).[div](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[div](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[rem](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[rem](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[and](#syntax-instr-numeric)[i64](#syntax-numtype).[or](#syntax-instr-numeric)[i64](#syntax-numtype).[xor](#syntax-instr-numeric)[i64](#syntax-numtype).[shl](#syntax-instr-numeric)[i64](#syntax-numtype).[shr](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[shr](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[rotl](#syntax-instr-numeric)[i64](#syntax-numtype).[rotr](#syntax-instr-numeric)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0x8B0x8C0x8D0x8E0x8F0x900x910x920x930x940x950x960x970x980x990x9A0x9B0x9C0x9D0x9E0x9F0xA00xA10xA20xA30xA40xA50xA6​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype).[abs](#syntax-instr-numeric)[f32](#syntax-numtype).[neg](#syntax-instr-numeric)[f32](#syntax-numtype).[ceil](#syntax-instr-numeric)[f32](#syntax-numtype).[floor](#syntax-instr-numeric)[f32](#syntax-numtype).[trunc](#syntax-instr-numeric)[f32](#syntax-numtype).[nearest](#syntax-instr-numeric)[f32](#syntax-numtype).[sqrt](#syntax-instr-numeric)[f32](#syntax-numtype).[add](#syntax-instr-numeric)[f32](#syntax-numtype).[sub](#syntax-instr-numeric)[f32](#syntax-numtype).[mul](#syntax-instr-numeric)[f32](#syntax-numtype).[div](#syntax-instr-numeric)[f32](#syntax-numtype).[min](#syntax-instr-numeric)[f32](#syntax-numtype).[max](#syntax-instr-numeric)[f32](#syntax-numtype).[copysign](#syntax-instr-numeric)[f64](#syntax-numtype).[abs](#syntax-instr-numeric)[f64](#syntax-numtype).[neg](#syntax-instr-numeric)[f64](#syntax-numtype).[ceil](#syntax-instr-numeric)[f64](#syntax-numtype).[floor](#syntax-instr-numeric)[f64](#syntax-numtype).[trunc](#syntax-instr-numeric)[f64](#syntax-numtype).[nearest](#syntax-instr-numeric)[f64](#syntax-numtype).[sqrt](#syntax-instr-numeric)[f64](#syntax-numtype).[add](#syntax-instr-numeric)[f64](#syntax-numtype).[sub](#syntax-instr-numeric)[f64](#syntax-numtype).[mul](#syntax-instr-numeric)[f64](#syntax-numtype).[div](#syntax-instr-numeric)[f64](#syntax-numtype).[min](#syntax-instr-numeric)[f64](#syntax-numtype).[max](#syntax-instr-numeric)[f64](#syntax-numtype).[copysign](#syntax-instr-numeric)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xA70xA80xA90xAA0xAB0xAC0xAD0xAE0xAF0xB00xB10xB20xB30xB40xB50xB60xB70xB80xB90xBA0xBB0xBC0xBD0xBE0xBF​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[wrap](#syntax-instr-numeric)\_[i64](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i64](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i64](#syntax-numtype)[f32](#syntax-numtype).[demote](#syntax-instr-numeric)\_[f64](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i64](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i64](#syntax-numtype)[f64](#syntax-numtype).[promote](#syntax-instr-numeric)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[f64](#syntax-numtype)[f32](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[i64](#syntax-numtype)​​

​[instr](#binary-instr)​::=∣∣∣∣∣​…0xC00xC10xC20xC30xC4​⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[extend](#syntax-instr-numeric)8\_[s](#syntax-sx)[i32](#syntax-numtype).[extend](#syntax-instr-numeric)16\_[s](#syntax-sx)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)8\_[s](#syntax-sx)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)16\_[s](#syntax-sx)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)32\_[s](#syntax-sx)​​

The saturating truncation instructions all have a one byte prefix, whereas the actual opcode is encoded by a variable-length [unsigned integer](#binary-uint).

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣​…0xFC 0:[u32](#binary-int)0xFC 1:[u32](#binary-int)0xFC 2:[u32](#binary-int)0xFC 3:[u32](#binary-int)0xFC 4:[u32](#binary-int)0xFC 5:[u32](#binary-int)0xFC 6:[u32](#binary-int)0xFC 7:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)​​

#### 5.4.9. Vector Instructions[](#vector-instructions⑦)

All variants of [vector instructions](#syntax-instr-vec) are represented by separate byte codes. They all have a one byte prefix, whereas the actual opcode is encoded by a variable-length [unsigned integer](#binary-uint).

Vector loads and stores are followed by the encoding of their [memarg](#syntax-memarg) immediate.

​[laneidx](#binary-laneidx)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​l:[byte](#binary-byte)0xFD 0:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 1:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 2:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 3:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 4:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 5:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 6:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 7:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 8:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 9:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 10:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 11:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 84:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 85:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 86:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 87:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 88:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 89:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 90:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 91:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 92:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 93:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​l0.8ex\][v128](#syntax-vectype).[load](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8[x](#syntax-shape)8\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8[x](#syntax-shape)8\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16[x](#syntax-shape)4\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16[x](#syntax-shape)4\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32[x](#syntax-shape)2\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32[x](#syntax-shape)2\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[store](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)16\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)8\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)16\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)32\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)64\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[zero](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[zero](#syntax-instr-memory) x ao​[instr](#binary-instr)::=…​

The const instruction for vectors is followed by 16 immediate bytes, which are converted into an u128 in [littleendian](#aux-littleendian) byte order:

​[instr](#binary-instr)​::=∣​…0xFD 12:[u32](#binary-int) (b:[byte](#binary-byte))16​⇒​[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​((b)16)​​

The shuffle instruction is also followed by the encoding of 16 [laneidx](#syntax-laneidx) immediates.

​[instr](#binary-instr)​::=∣∣∣​…0xFD 13:[u32](#binary-int) (l:[laneidx](#binary-laneidx))160xFD 14:[u32](#binary-int)0xFD 256:[u32](#binary-int)​⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[shuffle](#syntax-instr-vec) l16[i8](#syntax-storagetype)[x](#syntax-shape)16.[swizzle](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[relaxed\_swizzle](#syntax-instr-vec)​​

Lane instructions are followed by the encoding of a [laneidx](#syntax-laneidx) immediate.

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 21:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 22:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 23:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 24:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 25:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 26:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 27:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 28:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 29:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 30:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 31:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 32:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 33:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 34:[u32](#binary-int) l:[laneidx](#binary-laneidx)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[extract\_lane](#syntax-instr-vec)\_[s](#syntax-sx) l[i8](#syntax-storagetype)[x](#syntax-shape)16.[extract\_lane](#syntax-instr-vec)\_[u](#syntax-sx) l[i8](#syntax-storagetype)[x](#syntax-shape)16.[replace\_lane](#syntax-instr-vec) l[i16](#syntax-storagetype)[x](#syntax-shape)8.[extract\_lane](#syntax-instr-vec)\_[s](#syntax-sx) l[i16](#syntax-storagetype)[x](#syntax-shape)8.[extract\_lane](#syntax-instr-vec)\_[u](#syntax-sx) l[i16](#syntax-storagetype)[x](#syntax-shape)8.[replace\_lane](#syntax-instr-vec) l[i32](#syntax-numtype)[x](#syntax-shape)4.[extract\_lane](#syntax-instr-vec) l[i32](#syntax-numtype)[x](#syntax-shape)4.[replace\_lane](#syntax-instr-vec) l[i64](#syntax-numtype)[x](#syntax-shape)2.[extract\_lane](#syntax-instr-vec) l[i64](#syntax-numtype)[x](#syntax-shape)2.[replace\_lane](#syntax-instr-vec) l[f32](#syntax-numtype)[x](#syntax-shape)4.[extract\_lane](#syntax-instr-vec) l[f32](#syntax-numtype)[x](#syntax-shape)4.[replace\_lane](#syntax-instr-vec) l[f64](#syntax-numtype)[x](#syntax-shape)2.[extract\_lane](#syntax-instr-vec) l[f64](#syntax-numtype)[x](#syntax-shape)2.[replace\_lane](#syntax-instr-vec) l​​

All other vector instructions are plain opcodes without any immediates.

​[instr](#binary-instr)​::=∣∣∣∣∣∣​…0xFD 15:[u32](#binary-int)0xFD 16:[u32](#binary-int)0xFD 17:[u32](#binary-int)0xFD 18:[u32](#binary-int)0xFD 19:[u32](#binary-int)0xFD 20:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[splat](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[splat](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[splat](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[splat](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[splat](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[splat](#syntax-instr-vec)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 35:[u32](#binary-int)0xFD 36:[u32](#binary-int)0xFD 37:[u32](#binary-int)0xFD 38:[u32](#binary-int)0xFD 39:[u32](#binary-int)0xFD 40:[u32](#binary-int)0xFD 41:[u32](#binary-int)0xFD 42:[u32](#binary-int)0xFD 43:[u32](#binary-int)0xFD 44:[u32](#binary-int)0xFD 45:[u32](#binary-int)0xFD 46:[u32](#binary-int)0xFD 47:[u32](#binary-int)0xFD 48:[u32](#binary-int)0xFD 49:[u32](#binary-int)0xFD 50:[u32](#binary-int)0xFD 51:[u32](#binary-int)0xFD 52:[u32](#binary-int)0xFD 53:[u32](#binary-int)0xFD 54:[u32](#binary-int)0xFD 55:[u32](#binary-int)0xFD 56:[u32](#binary-int)0xFD 57:[u32](#binary-int)0xFD 58:[u32](#binary-int)0xFD 59:[u32](#binary-int)0xFD 60:[u32](#binary-int)0xFD 61:[u32](#binary-int)0xFD 62:[u32](#binary-int)0xFD 63:[u32](#binary-int)0xFD 64:[u32](#binary-int)0xFD 214:[u32](#binary-int)0xFD 215:[u32](#binary-int)0xFD 216:[u32](#binary-int)0xFD 217:[u32](#binary-int)0xFD 218:[u32](#binary-int)0xFD 219:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[eq](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ne](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[eq](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ne](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[eq](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[ne](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[eq](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[ne](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[ge](#syntax-instr-vec)\_[s](#syntax-sx)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 65:[u32](#binary-int)0xFD 66:[u32](#binary-int)0xFD 67:[u32](#binary-int)0xFD 68:[u32](#binary-int)0xFD 69:[u32](#binary-int)0xFD 70:[u32](#binary-int)0xFD 71:[u32](#binary-int)0xFD 72:[u32](#binary-int)0xFD 73:[u32](#binary-int)0xFD 74:[u32](#binary-int)0xFD 75:[u32](#binary-int)0xFD 76:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype)[x](#syntax-shape)4.[eq](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[ne](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[eq](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[ne](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[lt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[gt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[le](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[ge](#syntax-instr-vec)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣​…0xFD 77:[u32](#binary-int)0xFD 78:[u32](#binary-int)0xFD 79:[u32](#binary-int)0xFD 80:[u32](#binary-int)0xFD 81:[u32](#binary-int)0xFD 82:[u32](#binary-int)0xFD 83:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒​[v128](#syntax-vectype).[not](#syntax-instr-vec)[v128](#syntax-vectype).[and](#syntax-instr-vec)[v128](#syntax-vectype).[andnot](#syntax-instr-vec)[v128](#syntax-vectype).[or](#syntax-instr-vec)[v128](#syntax-vectype).[xor](#syntax-instr-vec)[v128](#syntax-vectype).[bitselect](#syntax-instr-vec)[v128](#syntax-vectype).[any\_true](#syntax-instr-vec)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 96:[u32](#binary-int)0xFD 97:[u32](#binary-int)0xFD 98:[u32](#binary-int)0xFD 99:[u32](#binary-int)0xFD 100:[u32](#binary-int)0xFD 101:[u32](#binary-int)0xFD 102:[u32](#binary-int)0xFD 107:[u32](#binary-int)0xFD 108:[u32](#binary-int)0xFD 109:[u32](#binary-int)0xFD 110:[u32](#binary-int)0xFD 111:[u32](#binary-int)0xFD 112:[u32](#binary-int)0xFD 113:[u32](#binary-int)0xFD 114:[u32](#binary-int)0xFD 115:[u32](#binary-int)0xFD 118:[u32](#binary-int)0xFD 119:[u32](#binary-int)0xFD 120:[u32](#binary-int)0xFD 121:[u32](#binary-int)0xFD 123:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[abs](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[neg](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[popcnt](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[all\_true](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[bitmask](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[narrow](#syntax-instr-vec)\_[i16](#syntax-storagetype)[x](#syntax-shape)8\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[narrow](#syntax-instr-vec)\_[i16](#syntax-storagetype)[x](#syntax-shape)8\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shl](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[avgr](#syntax-instr-vec)\_[u](#syntax-sx)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 124:[u32](#binary-int)0xFD 125:[u32](#binary-int)0xFD 128:[u32](#binary-int)0xFD 129:[u32](#binary-int)0xFD 131:[u32](#binary-int)0xFD 132:[u32](#binary-int)0xFD 133:[u32](#binary-int)0xFD 134:[u32](#binary-int)0xFD 135:[u32](#binary-int)0xFD 136:[u32](#binary-int)0xFD 137:[u32](#binary-int)0xFD 138:[u32](#binary-int)0xFD 139:[u32](#binary-int)0xFD 140:[u32](#binary-int)0xFD 141:[u32](#binary-int)0xFD 130:[u32](#binary-int)0xFD 142:[u32](#binary-int)0xFD 143:[u32](#binary-int)0xFD 144:[u32](#binary-int)0xFD 145:[u32](#binary-int)0xFD 146:[u32](#binary-int)0xFD 147:[u32](#binary-int)0xFD 149:[u32](#binary-int)0xFD 150:[u32](#binary-int)0xFD 151:[u32](#binary-int)0xFD 152:[u32](#binary-int)0xFD 153:[u32](#binary-int)0xFD 155:[u32](#binary-int)0xFD 273:[u32](#binary-int)0xFD 156:[u32](#binary-int)0xFD 157:[u32](#binary-int)0xFD 158:[u32](#binary-int)0xFD 159:[u32](#binary-int)0xFD 274:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i16](#syntax-storagetype)[x](#syntax-shape)8.[extadd\_pairwise](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extadd\_pairwise](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[abs](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[neg](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[all\_true](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[bitmask](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[narrow](#syntax-instr-vec)\_[i32](#syntax-numtype)[x](#syntax-shape)4\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[narrow](#syntax-instr-vec)\_[i32](#syntax-numtype)[x](#syntax-shape)4\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[shl](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[q15mulr\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[mul](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[avgr](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[relaxed\_q15mulr](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[relaxed\_dot](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 126:[u32](#binary-int)0xFD 127:[u32](#binary-int)0xFD 160:[u32](#binary-int)0xFD 161:[u32](#binary-int)0xFD 163:[u32](#binary-int)0xFD 164:[u32](#binary-int)0xFD 167:[u32](#binary-int)0xFD 168:[u32](#binary-int)0xFD 169:[u32](#binary-int)0xFD 170:[u32](#binary-int)0xFD 171:[u32](#binary-int)0xFD 172:[u32](#binary-int)0xFD 173:[u32](#binary-int)0xFD 174:[u32](#binary-int)0xFD 177:[u32](#binary-int)0xFD 181:[u32](#binary-int)0xFD 182:[u32](#binary-int)0xFD 183:[u32](#binary-int)0xFD 184:[u32](#binary-int)0xFD 185:[u32](#binary-int)0xFD 186:[u32](#binary-int)0xFD 188:[u32](#binary-int)0xFD 189:[u32](#binary-int)0xFD 190:[u32](#binary-int)0xFD 191:[u32](#binary-int)0xFD 275:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype)[x](#syntax-shape)4.[extadd\_pairwise](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extadd\_pairwise](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[abs](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[neg](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[all\_true](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[bitmask](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[shl](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[add](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[sub](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[mul](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[dot](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_dot\_add](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 192:[u32](#binary-int)0xFD 193:[u32](#binary-int)0xFD 195:[u32](#binary-int)0xFD 196:[u32](#binary-int)0xFD 199:[u32](#binary-int)0xFD 200:[u32](#binary-int)0xFD 201:[u32](#binary-int)0xFD 202:[u32](#binary-int)0xFD 203:[u32](#binary-int)0xFD 204:[u32](#binary-int)0xFD 205:[u32](#binary-int)0xFD 206:[u32](#binary-int)0xFD 209:[u32](#binary-int)0xFD 213:[u32](#binary-int)0xFD 220:[u32](#binary-int)0xFD 221:[u32](#binary-int)0xFD 222:[u32](#binary-int)0xFD 223:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i64](#syntax-numtype)[x](#syntax-shape)2.[abs](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[neg](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[all\_true](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[bitmask](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[shl](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[add](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[sub](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[mul](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 103:[u32](#binary-int)0xFD 104:[u32](#binary-int)0xFD 105:[u32](#binary-int)0xFD 106:[u32](#binary-int)0xFD 224:[u32](#binary-int)0xFD 225:[u32](#binary-int)0xFD 227:[u32](#binary-int)0xFD 228:[u32](#binary-int)0xFD 229:[u32](#binary-int)0xFD 230:[u32](#binary-int)0xFD 231:[u32](#binary-int)0xFD 232:[u32](#binary-int)0xFD 233:[u32](#binary-int)0xFD 234:[u32](#binary-int)0xFD 235:[u32](#binary-int)0xFD 269:[u32](#binary-int)0xFD 270:[u32](#binary-int)0xFD 261:[u32](#binary-int)0xFD 262:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype)[x](#syntax-shape)4.[ceil](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[floor](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[trunc](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[nearest](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[abs](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[neg](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[sqrt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[add](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[sub](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[mul](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[div](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[pmin](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[pmax](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_min](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_max](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_madd](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_nmadd](#syntax-instr-vec)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 116:[u32](#binary-int)0xFD 117:[u32](#binary-int)0xFD 122:[u32](#binary-int)0xFD 148:[u32](#binary-int)0xFD 236:[u32](#binary-int)0xFD 237:[u32](#binary-int)0xFD 239:[u32](#binary-int)0xFD 240:[u32](#binary-int)0xFD 241:[u32](#binary-int)0xFD 242:[u32](#binary-int)0xFD 243:[u32](#binary-int)0xFD 244:[u32](#binary-int)0xFD 245:[u32](#binary-int)0xFD 246:[u32](#binary-int)0xFD 247:[u32](#binary-int)0xFD 271:[u32](#binary-int)0xFD 272:[u32](#binary-int)0xFD 263:[u32](#binary-int)0xFD 264:[u32](#binary-int)0xFD 265:[u32](#binary-int)0xFD 266:[u32](#binary-int)0xFD 267:[u32](#binary-int)0xFD 268:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f64](#syntax-numtype)[x](#syntax-shape)2.[ceil](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[floor](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[trunc](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[nearest](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[abs](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[neg](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[sqrt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[add](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[sub](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[mul](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[div](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[min](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[max](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[pmin](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[pmax](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_min](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_max](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_madd](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_nmadd](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[relaxed\_laneselect](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[relaxed\_laneselect](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_laneselect](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_laneselect](#syntax-instr-vec)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 94:[u32](#binary-int)0xFD 95:[u32](#binary-int)0xFD 248:[u32](#binary-int)0xFD 249:[u32](#binary-int)0xFD 250:[u32](#binary-int)0xFD 251:[u32](#binary-int)0xFD 252:[u32](#binary-int)0xFD 253:[u32](#binary-int)0xFD 254:[u32](#binary-int)0xFD 255:[u32](#binary-int)0xFD 257:[u32](#binary-int)0xFD 258:[u32](#binary-int)0xFD 259:[u32](#binary-int)0xFD 260:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype)[x](#syntax-shape)4.[demote](#syntax-instr-vec)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[f64](#syntax-numtype)[x](#syntax-shape)2.[promote](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[f32](#syntax-numtype)[x](#syntax-shape)4.[convert](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f32](#syntax-numtype)[x](#syntax-shape)4.[convert](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[s](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[u](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[f64](#syntax-numtype)[x](#syntax-shape)2.[convert](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f64](#syntax-numtype)[x](#syntax-shape)2.[convert](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[s](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[u](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2​​

#### 5.4.10. Expressions[](#expressions⑦)

[Expressions](#syntax-expr) are encoded by their instruction sequence terminated with an explicit 0x0B opcode for end.

​[expr](#binary-expr)​::=​(in:[instr](#binary-instr))∗ 0x0B​⇒​in∗​​

### 5.5. Modules[](#modules⑨)

The binary encoding of modules is organized into _sections_. Most sections correspond to one component of a [module](#syntax-module) record, except that [function definitions](#syntax-func) are split into two sections, separating their type declarations in the [function section](#binary-funcsec) from their bodies in the [code section](#binary-codesec).

Note

This separation enables _parallel_ and _streaming_ compilation of the functions in a module.

#### 5.5.1. Indices[](#indices③)

All basic [indices](#syntax-index) are encoded with their respective value.

​[typeidx](#binary-typeidx)[funcidx](#binary-funcidx)[tableidx](#binary-tableidx)[memidx](#binary-memidx)[globalidx](#binary-globalidx)[tagidx](#binary-tagidx)[elemidx](#binary-elemidx)[dataidx](#binary-dataidx)[localidx](#binary-localidx)[labelidx](#binary-labelidx)​::=::=::=::=::=::=::=::=::=::=​x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)l:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​xxxxxxxxxl​​

[External indices](#syntax-externidx) are encoded by a distiguishing byte followed by an encoding of their respective value.

​[externidx](#binary-externidx)​::=∣∣∣∣​0x00 x:[funcidx](#binary-funcidx)0x01 x:[tableidx](#binary-tableidx)0x02 x:[memidx](#binary-memidx)0x03 x:[globalidx](#binary-globalidx)0x04 x:[tagidx](#binary-tagidx)​⇒⇒⇒⇒⇒​[func](#syntax-externidx) x[table](#syntax-externidx) x[memory](#syntax-externidx) x[global](#syntax-externidx) x[tag](#syntax-externidx) x​​

#### 5.5.2. Sections[](#sections①)

Each section consists of

*   a one-byte section _id_,
    
*   the [u32](#syntax-int) _length_ of the contents, in bytes,
    
*   the actual _contents_, whose structure is dependent on the section id.
    

Every section is optional; an omitted section is equivalent to the section being present with empty contents.

The following parameterized grammar rule defines the generic structure of a section with id N and contents described by the grammar X.

​[section](#binary-section)N​(X)​::=∣​N:[byte](#binary-byte) len:[u32](#binary-int) en∗:Xϵ​⇒⇒​en∗ϵ​if len\=∣∣X∣∣​

For most sections, the contents X encodes a [list](#binary-list). In these cases, the empty result ϵ is interpreted as the empty list.

Note

Other than for unknown [custom sections](#binary-customsec), the size is not required for decoding, but can be used to skip sections when navigating through a binary. The module is malformed if the size does not match the length of the binary contents X.

The following section ids are used:

Id

Section

0

[custom section](#binary-customsec)

1

[type section](#binary-typesec)

2

[import section](#binary-importsec)

3

[function section](#binary-funcsec)

4

[table section](#binary-tablesec)

5

[memory section](#binary-memsec)

6

[global section](#binary-globalsec)

7

[export section](#binary-exportsec)

8

[start section](#binary-startsec)

9

[element section](#binary-elemsec)

10

[code section](#binary-codesec)

11

[data section](#binary-datasec)

12

[data count section](#binary-datacntsec)

13

[tag section](#binary-tagsec)

Note

Section ids do not always correspond to the [order of sections](#binary-module) in the encoding of a module.

#### 5.5.3. Custom Section[](#custom-section①)

_Custom sections_ have the id 0. They are intended to be used for debugging information or third-party extensions, and are ignored by the WebAssembly semantics. Their contents consist of a [name](#syntax-name) further identifying the custom section, followed by an uninterpreted sequence of bytes for custom use.

​[customsec](#binary-customsec)[custom](#binary-customsec)​::=::=​[section](#binary-section)0​([custom](#binary-customsec))[name](#binary-name) [byte](#binary-byte)∗​​

Note

If an implementation interprets the data of a custom section, then errors in that data, or the placement of the section, must not invalidate the module.

#### 5.5.4. Type Section[](#type-section①)

The _type section_ has the id 1. It decodes into the list of [recursive types](#syntax-rectype) of a [module](#syntax-module).

​[typesec](#binary-typesec)[type](#binary-type)​::=::=​ty∗:[section](#binary-section)1​([list](#binary-list)([type](#binary-type)))qt:[rectype](#binary-rectype)​⇒⇒​ty∗[type](#syntax-type) qt​​

#### 5.5.5. Import Section[](#import-section①)

The _import section_ has the id 2. It decodes into the list of [imports](#syntax-import) of a [module](#syntax-module).

​[importsec](#binary-importsec)[import](#binary-import)​::=::=​im∗:[section](#binary-section)2​([list](#binary-list)([import](#binary-import)))nm1​:[name](#binary-name) nm2​:[name](#binary-name) xt:[externtype](#binary-externtype)​⇒⇒​im∗[import](#syntax-import) nm1​ nm2​ xt​​

#### 5.5.6. Function Section[](#function-section①)

The _function section_ has the id 3. It decodes into a list of [type indices](#syntax-typeidx) that classify the [functions](#syntax-func) defined by a [module](#syntax-module). The bodies of the respective functions are encoded separately in the [code section](#binary-codesec).

​[funcsec](#binary-funcsec)​::=​x∗:[section](#binary-section)3​([list](#binary-list)([typeidx](#binary-typeidx)))​⇒​x∗​​

#### 5.5.7. Table Section[](#table-section①)

The _table section_ has the id 4. It decodes into the list of [tables](#syntax-table) defined by a [module](#syntax-module).

​[tablesec](#binary-tablesec)[table](#binary-table)​::=::=∣​tab∗:[section](#binary-section)4​([list](#binary-list)([table](#binary-table)))tt:[tabletype](#binary-tabletype)0x40 0x00 tt:[tabletype](#binary-tabletype) e:[expr](#binary-expr)​⇒⇒⇒​tab∗[table](#syntax-table) tt ([ref.null](#syntax-instr-ref) ht)[table](#syntax-table) tt e​if tt\=at lim ([ref](#syntax-reftype) [null](#syntax-reftype)? ht)​​

Note

The encoding of a table type cannot start with byte 0x40, hence decoding is unambiguous. The zero byte following it is reserved for future extensions.

#### 5.5.8. Memory Section[](#memory-section①)

The _memory section_ has the id 5. It decodes into the list of [memories](#syntax-mem) defined by a [module](#syntax-module).

​[memsec](#binary-memsec)[mem](#binary-mem)​::=::=​[mem](#syntax-mem)∗:[section](#binary-section)5​([list](#binary-list)([mem](#binary-mem)))mt:[memtype](#binary-memtype)​⇒⇒​[mem](#syntax-mem)∗[memory](#syntax-mem) mt​​

#### 5.5.9. Global Section[](#global-section①)

The _global section_ has the id 6. It decodes into the list of [globals](#syntax-global) defined by a [module](#syntax-module).

​[globalsec](#binary-globalsec)[global](#binary-global)​::=::=​glob∗:[section](#binary-section)6​([list](#binary-list)([global](#binary-global)))gt:[globaltype](#binary-globaltype) e:[expr](#binary-expr)​⇒⇒​glob∗[global](#syntax-global) gt e​​

#### 5.5.10. Export Section[](#export-section①)

The _export section_ has the id 7. It decodes into the list of [exports](#syntax-export) of a [module](#syntax-module).

​[exportsec](#binary-exportsec)[export](#binary-export)​::=::=​ex∗:[section](#binary-section)7​([list](#binary-list)([export](#binary-export)))nm:[name](#binary-name) xx:[externidx](#binary-externidx)​⇒⇒​ex∗[export](#syntax-export) nm xx​​

#### 5.5.11. Start Section[](#start-section①)

The _start section_ has the id 8. It decodes into the optional [start function](#syntax-start) of a [module](#syntax-module).

​[startsec](#binary-startsec)[start](#binary-start)​::=::=​[start](#syntax-start)?:[section](#binary-section)8​([start](#binary-start))x:[funcidx](#binary-funcidx)​⇒⇒​[start](#syntax-start)?([start](#syntax-start) x)​​

#### 5.5.12. Element Section[](#element-section①)

The _element section_ has the id 9. It decodes into the list of [element segments](#syntax-elem) defined by a [module](#syntax-module).

​[elemsec](#binary-elemsec)[elemkind](#binary-elemkind)[elem](#binary-elem)​::=::=::=∣∣∣∣∣∣∣​[elem](#syntax-elem)∗:[section](#binary-section)9​([list](#binary-list)([elem](#binary-elem)))0x000:[u32](#binary-int) eo​:[expr](#binary-expr) y∗:[list](#binary-list)([funcidx](#binary-funcidx))[elem](#syntax-elem) ([ref](#syntax-reftype) [func](#syntax-heaptype)) ([ref.func](#syntax-instr-ref) y)∗ ([active](#syntax-elemmode) 0 eo​)​1:[u32](#binary-int) rt:[elemkind](#binary-elemkind) y∗:[list](#binary-list)([funcidx](#binary-funcidx))[elem](#syntax-elem) rt ([ref.func](#syntax-instr-ref) y)∗ [passive](#syntax-elemmode)​2:[u32](#binary-int) x:[tableidx](#binary-tableidx) e:[expr](#binary-expr) rt:[elemkind](#binary-elemkind) y∗:[list](#binary-list)([funcidx](#binary-funcidx))[elem](#syntax-elem) rt ([ref.func](#syntax-instr-ref) y)∗ ([active](#syntax-elemmode) x e)​3:[u32](#binary-int) rt:[elemkind](#binary-elemkind) y∗:[list](#binary-list)([funcidx](#binary-funcidx))[elem](#syntax-elem) rt ([ref.func](#syntax-instr-ref) y)∗ [declare](#syntax-elemmode)​4:[u32](#binary-int) eo​:[expr](#binary-expr) e∗:[list](#binary-list)([expr](#binary-expr))[elem](#syntax-elem) ([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)) e∗ ([active](#syntax-elemmode) 0 eo​)​5:[u32](#binary-int) rt:[reftype](#binary-reftype) e∗:[list](#binary-list)([expr](#binary-expr))[elem](#syntax-elem) rt e∗ [passive](#syntax-elemmode)​6:[u32](#binary-int) x:[tableidx](#binary-tableidx) eo​:[expr](#binary-expr) e∗:[list](#binary-list)([expr](#binary-expr))[elem](#syntax-elem) ([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)) e∗ ([active](#syntax-elemmode) x eo​)​7:[u32](#binary-int) rt:[reftype](#binary-reftype) e∗:[list](#binary-list)([expr](#binary-expr))[elem](#syntax-elem) rt e∗ [declare](#syntax-elemmode)​​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[elem](#syntax-elem)∗[ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)​​​

Note

The initial integer can be interpreted as a bitfield. Bit 0 distinguishes a passive or declarative segment from an active segment, bit 1 indicates the presence of an explicit table index for an active segment and otherwise distinguishes passive from declarative segments, bit 2 indicates the use of element type and element [expressions](#binary-expr) instead of element kind and element indices.

Additional element kinds may be added in future versions of WebAssembly.

#### 5.5.13. Code Section[](#code-section①)

The _code section_ has the id 10. It decodes into the list of _code_ entries that are pairs of lists of [locals](#syntax-list) and [expressions](#syntax-expr). They represent the body of the [functions](#syntax-func) defined by a [module](#syntax-module). The types of the respective functions are encoded separately in the [function section](#binary-funcsec).

The encoding of each code entry consists of

*   the [u32](#syntax-int) _length_ of the function code in bytes,
    
*   the actual _function code_, which in turn consists of
    
    *   the declaration of _locals_,
        
    *   the function _body_ as an [expression](#binary-expr).
        

Local declarations are compressed into a list whose entries consist of

*   a [u32](#syntax-int) _count_,
    
*   a [value type](#binary-valtype),
    

denoting _count_ locals of the same value type.

​[codesec](#binary-codesec)[code](#binary-code)[func](#binary-func)[locals](#binary-local)​::=::=::=::=​code∗:[section](#binary-section)10​([list](#binary-list)([code](#binary-code)))len:[u32](#binary-int) code:[func](#binary-func)loc∗∗:[list](#binary-list)([locals](#binary-local)) e:[expr](#binary-expr)n:[u32](#binary-int) t:[valtype](#binary-valtype)​⇒⇒⇒⇒​code∗code([⨁](#notation-concat)loc∗∗,e)([local](#syntax-local) t)n​if len\=∣∣[func](#binary-func)∣∣if ∣[⨁](#notation-concat)loc∗∗∣<232​​

Here, code ranges over pairs ([local](#syntax-local)∗,[expr](#syntax-expr)). Any code for which the length of the resulting sequence is out of bounds of the maximum size of a [list](#syntax-list) is malformed.

Note

Like with [sections](#binary-section), the code size is not needed for decoding, but can be used to skip functions when navigating through a binary. The module is malformed if a size does not match the length of the respective function code.

#### 5.5.14. Data Section[](#data-section①)

The _data section_ has the id 11. It decodes into the list of [data segments](#syntax-data) defined by a [module](#syntax-module).

​[datasec](#binary-datasec)[data](#binary-data)​::=::=∣∣​[data](#syntax-data)∗:[section](#binary-section)11​([list](#binary-list)([data](#binary-data)))0:[u32](#binary-int) e:[expr](#binary-expr) b∗:[list](#binary-list)([byte](#binary-byte))1:[u32](#binary-int) b∗:[list](#binary-list)([byte](#binary-byte))2:[u32](#binary-int) x:[memidx](#binary-memidx) e:[expr](#binary-expr) b∗:[list](#binary-list)([byte](#binary-byte))​⇒⇒⇒⇒​[data](#syntax-data)∗[data](#syntax-data) b∗ ([active](#syntax-datamode) 0 e)[data](#syntax-data) b∗ [passive](#syntax-datamode)[data](#syntax-data) b∗ ([active](#syntax-datamode) x e)​​

Note

The initial integer can be interpreted as a bitfield. Bit 0 indicates a passive segment, bit 1 indicates the presence of an explicit memory index for an active segment.

#### 5.5.15. Data Count Section[](#data-count-section①)

The _data count section_ has the id 12. It decodes into an optional [u32](#syntax-int) count that represents the number of [data segments](#syntax-data) in the [data section](#binary-datasec). If this count does not match the length of the data segment list, the module is malformed.

​[datacntsec](#binary-datacntsec)[datacnt](#binary-datacnt)​::=::=​n?:[section](#binary-section)12​([datacnt](#binary-datacnt))n:[u32](#binary-int)​⇒⇒​n?n​​

Note

The data count section is used to simplify single-pass validation. Since the data section occurs after the code section, the memory.init and data.drop instructions would not be able to check whether the data segment index is valid until the data section is read. The data count section occurs before the code section, so a single-pass validator can use this count instead of deferring validation.

#### 5.5.16. Tag Section[](#tag-section①)

The _tag section_ has the id 13. It decodes into the list of [tags](#syntax-tag) defined by a [module](#syntax-module).

​[tagsec](#binary-tagsec)[tag](#binary-tag)​::=::=​[tag](#syntax-tag)∗:[section](#binary-section)13​([list](#binary-list)([tag](#binary-tag)))jt:[tagtype](#binary-tagtype)​⇒⇒​[tag](#syntax-tag)∗[tag](#syntax-tag) jt​​

#### 5.5.17. Modules[](#modules①⓪)

The encoding of a [module](#syntax-module) starts with a preamble containing a 4-byte magic number (the string ‘\\0asm’) and a version field. The current version of the WebAssembly binary format is 1.

The preamble is followed by a sequence of [sections](#binary-section). [Custom sections](#binary-customsec) may be inserted at any place in this sequence, while other sections must occur at most once and in the prescribed order. All sections can be empty.

The lengths of lists produced by the (possibly empty) [function](#binary-funcsec) and [code](#binary-codesec) section must match up.

Similarly, the optional data count must match the length of the [data segment](#binary-datasec) list. Furthermore, it must be present if any [data index](#syntax-dataidx) occurs in the code section.

​[magic](#binary-magic)[version](#binary-version)[module](#binary-module)​::=::=::=​0x00 0x61 0x73 0x6D0x01 0x00 0x00 0x00[magic](#binary-magic) [version](#binary-version)[customsec](#binary-customsec)∗ [type](#syntax-rectype)∗:[typesec](#binary-typesec)[customsec](#binary-customsec)∗ [import](#syntax-import)∗:[importsec](#binary-importsec)[customsec](#binary-customsec)∗ [typeidx](#syntax-typeidx)∗:[funcsec](#binary-funcsec)[customsec](#binary-customsec)∗ [table](#syntax-table)∗:[tablesec](#binary-tablesec)[customsec](#binary-customsec)∗ [mem](#syntax-mem)∗:[memsec](#binary-memsec)[customsec](#binary-customsec)∗ [tag](#syntax-tag)∗:[tagsec](#binary-tagsec)[customsec](#binary-customsec)∗ [global](#syntax-global)∗:[globalsec](#binary-globalsec)[customsec](#binary-customsec)∗ [export](#syntax-export)∗:[exportsec](#binary-exportsec)[customsec](#binary-customsec)∗ [start](#syntax-start)?:[startsec](#binary-startsec)[customsec](#binary-customsec)∗ [elem](#syntax-elem)∗:[elemsec](#binary-elemsec)[customsec](#binary-customsec)∗ n?:[datacntsec](#binary-datacntsec)[customsec](#binary-customsec)∗ ([local](#syntax-local)∗,[expr](#syntax-expr))∗:[codesec](#binary-codesec)[customsec](#binary-customsec)∗ [data](#syntax-data)∗:[datasec](#binary-datasec)[customsec](#binary-customsec)∗​[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗if (n\=∣[data](#syntax-data)∗∣)?∧ (n?\=ϵ∨[dataidx](#syntax-dataidx)([func](#syntax-func)∗)\=ϵ)∧ ([func](#syntax-func)\=[func](#syntax-func) [typeidx](#syntax-typeidx) [local](#syntax-local)∗ [expr](#syntax-expr))∗​​​​⇒​​​​

Note

The version of the WebAssembly binary format may increase in the future if backward-incompatible changes have to be made to the format. However, such changes are expected to occur very infrequently, if ever. The binary format is intended to be extensible, such that future features can be added without incrementing its version.

6\. Text Format[](#text-format①)
--------------------------------

### 6.1. Conventions[](#conventions③③)

The textual format for WebAssembly [modules](#module) is a rendering of their [abstract syntax](#syntax-module) into [S-expressions](https://en.wikipedia.org/wiki/S-expression).

Like the [binary format](#binary), the text format is defined by an _attribute grammar_. A text string is a well-formed description of a module if and only if it is generated by the grammar. Each production of this grammar has at most one synthesized attribute: the abstract syntax that the respective character sequence expresses. Thus, the attribute grammar implicitly defines a _parsing_ function. Some productions also take a [context](#text-context) as an inherited attribute that records bound [identifiers](#text-id).

Except for a few exceptions, the core of the text grammar closely mirrors the grammar of the abstract syntax. However, it also defines a number of _abbreviations_ that are “syntactic sugar” over the core syntax.

The recommended extension for files containing WebAssembly modules in text format is “`.wat`”. Files with this extension are assumed to be encoded in UTF-8, as per [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 2.5).

#### 6.1.1. Grammar[](#grammar④)

The following conventions are adopted in defining grammar rules of the text format. They mirror the conventions used for [abstract syntax](#grammar) and for the [binary format](#binary). In order to distinguish symbols of the textual syntax from symbols of the abstract syntax, typewriter font is adopted for the former.

*   Terminal symbols are either literal strings of characters enclosed in quotes or expressed as [\[UNICODE\]](#biblio-unicode "The Unicode Standard") scalar values: ‘module’, U+0A. (All characters written literally are unambiguously drawn from the 7-bit [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d) subset of Unicode.)
    
*   Nonterminal symbols are written in typewriter font: valtype, instr.
    
*   Tn is a sequence of n≥0 iterations of T.
    
*   T∗ is a possibly empty sequence of iterations of T. (This is a shorthand for Tn used where n is not relevant.)
    
*   T+ is a possibly empty sequence of iterations of T. (This is a shorthand for Tn used where n is not relevant.)
    
*   T? is an optional occurrence of T. (This is a shorthand for Tn where n≤1.)
    
*   x:T denotes the same language as the nonterminal T, but also binds the variable x to the attribute synthesized for T. A pattern may also be used instead of a variable, e.g., 7:T.
    
*   Productions are written ​sym​::=​T1​ ⇒ A1​ ∣ … ∣ Tn​ ⇒ An​​, where each Ai​ is the attribute that is synthesized for sym in the given case, usually from attribute variables bound in Ti​.
    
*   Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, ​sym​::=​B1​​, and starting continuations with ellipses, ​sym​::=​… ∣ B2​​.
    
*   Some productions are augmented by side conditions in parentheses, which restrict the applicability of the production. They provide a shorthand for a combinatorial expansion of the production into many separate cases.
    
*   If the same meta variable or non-terminal symbol appears multiple times in a production (in the syntax or in an attribute), then all those occurrences must have the same instantiation.
    

*   A distinction is made between _lexical_ and _syntactic_ productions. For the latter, arbitrary [white space](#text-space) is allowed in any place where the grammar contains spaces. The productions defining [lexical syntax](#text-lexical) and the syntax of [values](#text-value) are considered lexical, all others are syntactic.
    

Note

For example, the [textual grammar](#text-numtype) for [number types](#syntax-numtype) is given as follows:

​[numtype](#text-numtype)​::=∣∣∣​‘i32’‘i64’‘f32’‘f64’​⇒⇒⇒⇒​[i32](#syntax-numtype)[i64](#syntax-numtype)[f32](#syntax-numtype)[f64](#syntax-numtype)​​

The [textual grammar](#text-limits) for [limits](#syntax-limits) is defined as follows:

​[limits](#text-limits)​::=∣​n:[u64](#text-int)n:[u64](#text-int) m:[u64](#text-int)​⇒⇒​\[n[..](#syntax-limits)ϵ\]\[n[..](#syntax-limits)m\]​​

The variables n and m name the attributes of the respective [u64](#text-int) nonterminals, which in this case are the actual [unsigned integers](#syntax-uint) those parse into. The attribute of the complete production then is the abstract syntax for the limit, expressed in terms of the former values.

#### 6.1.2. Abbreviations[](#abbreviations①)

In addition to the core grammar, which corresponds directly to the [abstract syntax](#syntax), the textual syntax also defines a number of _abbreviations_ that can be used for convenience and readability.

Abbreviations are defined by _rewrite rules_ specifying their expansion into the core syntax:

​sym​::=​abbreviated syntax​≡​expanded syntax​​

These expansions are assumed to be applied, recursively and in order of appearance, before applying the core grammar rules to construct the abstract syntax.

#### 6.1.3. Contexts[](#contexts③)

The text format allows the use of symbolic [identifiers](#text-id) in place of [indices](#syntax-index). To resolve these identifiers into concrete indices, some grammar productions are indexed by an _identifier context_ [I](#text-context) as a synthesized attribute that records the declared identifiers in each [index space](#syntax-index). In addition, the context records the types defined in the module, so that [parameter](#text-param) indices can be computed for [functions](#text-func).

It is convenient to define identifier contexts as [records](#notation-record) [I](#text-context) with abstract syntax as follows:

​[I](#text-context)​::=​{[types](#text-context) ([name](#syntax-name)?)∗[tags](#text-context) ([name](#syntax-name)?)∗[globals](#text-context) ([name](#syntax-name)?)∗[mems](#text-context) ([name](#syntax-name)?)∗[tables](#text-context) ([name](#syntax-name)?)∗[funcs](#text-context) ([name](#syntax-name)?)∗[datas](#text-context) ([name](#syntax-name)?)∗[elems](#text-context) ([name](#syntax-name)?)∗[locals](#text-context) ([name](#syntax-name)?)∗[labels](#text-context) ([name](#syntax-name)?)∗[fields](#text-context) (([name](#syntax-name)?)∗)∗[typedefs](#text-context) ([deftype](#syntax-deftype)?)∗}​​​

For each index space, such a context contains the list of [names](#syntax-name) assigned to the defined indices, which were denoted by the corresponding [identifiers](#text-id). Unnamed indices are associated with empty (ϵ) entries in these lists. Fields have _dependent_ name spaces, and hence a separate list of field identifiers per type.

In addition, the field typedefs records the [defined type](#syntax-deftype) associated with each [type index](#syntax-typeidx). They are needed to look up the number of parameters of [function types](#syntax-functype) when used in a [function definition](#text-func), in order to produce the correct indices for [locals](#syntax-local).

An identifier context is _well-formed_ if no index space contains duplicate identifiers. For fields, names need only be unique within a single type.

##### 6.1.3.1. Conventions[](#conventions③④)

To avoid unnecessary clutter, empty components are omitted when writing out identifier contexts. For example, the record {} is shorthand for an [identifier context](#text-context) whose components are all empty.

#### 6.1.4. Lists[](#lists⑤)

[Lists](#syntax-list) are written as plain sequences, but with a restriction on the length of these sequence.

​[list](#text-list)(X)​::=​(el:X)∗​⇒​el∗​if ∣el∗∣<232​​

### 6.2. Lexical Format[](#lexical-format①)

#### 6.2.1. Characters[](#characters①)

The text format assigns meaning to _source text_, which consists of a sequence of _characters_. Characters are assumed to be represented as valid [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 2.4) _scalar values_.

​[source](#text-source)​::=​[char](#text-char)∗0.8ex\]​[char](#text-char)​::=​U+00 ∣ … ∣ U+D7FF ∣ U+E000 ∣ … ∣ U+10FFFF​​

Note

While source text may contain any Unicode character in [comments](#text-comment) or [string](#text-string) literals, the rest of the grammar is formed exclusively from the characters supported by the 7-bit [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d) subset of Unicode.

#### 6.2.2. Tokens[](#tokens①)

The character stream in the source text is divided, from left to right, into a sequence of _tokens_, as defined by the following grammar.

​[token](#text-token)​::=​[keyword](#text-keyword) ∣ [u](#text-int) ∣ [s](#text-int) ∣ [f](#text-int) ∣ [string](#text-string) ∣ [id](#text-id) ∣ ‘(’ ∣ ‘)’ ∣ [reserved](#text-reserved)0.8ex\]​[keyword](#text-keyword)​::=​(‘a’ ∣ … ∣ ‘z’) [idchar](#text-idchar)∗0.8ex\]​[reserved](#text-reserved)​::=​([idchar](#text-idchar) ∣ [string](#text-string) ∣ ‘,’ ∣ ‘;’ ∣ ‘\[’ ∣ ‘\]’ ∣ ‘{’ ∣ ‘}’)+​​

Tokens are formed from the input character stream according to the _longest match_ rule. That is, the next token always consists of the longest possible sequence of characters that is recognized by the above lexical grammar. Tokens can be separated by [white space](#text-space), but except for strings, they cannot themselves contain whitespace.

_Keyword_ tokens always start with a lower-case letter. The set of keywords is defined implicitly: only those tokens are defined to be keywords that occur as a [terminal symbol](#text-grammar) in literal form, such as ‘keyword’, in a [syntactic](#text-syntactic) production of this chapter.

Any token that does not fall into any of the other categories is considered _reserved_, and cannot occur in source text.

Note

The effect of defining the set of reserved tokens is that all tokens must be separated by either parentheses, [white space](#text-space), or [comments](#text-comment). For example, ‘0$x’ is a single reserved token, as is ‘’’a’’’’b’’’. Consequently, they are not recognized as two separate tokens ‘0’ and ‘$x’, or ‘’’a’’’ and ‘’’b’’’, respectively, but instead disallowed. This property of tokenization is not affected by the fact that the definition of reserved tokens overlaps with other token classes.

#### 6.2.3. White Space[](#white-space①)

_White space_ is any sequence of literal space characters, formatting characters, [comments](#text-comment), or [annotations](#text-annot). The allowed formatting characters correspond to a subset of the [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d) _format effectors_, namely, _horizontal tabulation_ (U+09), _line feed_ (U+0A), and _carriage return_ (U+0D).

​[space](#text-space)​::=​(‘’ ∣ [format](#text-format) ∣ [comment](#text-comment) ∣ [annot](#text-annot))∗0.8ex\]​[format](#text-format)​::=​[newline](#text-newline) ∣ U+090.8ex\]​[newline](#text-newline)​::=​U+0A ∣ U+0D ∣ U+0D U+0A​​

The only relevance of white space is to separate [tokens](#text-token). It is otherwise ignored.

#### 6.2.4. Comments[](#comments①)

A _comment_ can either be a _line comment_, started with a double semicolon ‘;;’ and extending to the end of the line, or a _block comment_, enclosed in delimiters ‘(;’…‘;)’. Block comments can be nested.

​[comment](#text-comment)[linechar](#text-comment)[blockchar](#text-comment)​::=::=::=∣∣∣​[linecomment](#text-comment) ∣ [blockcomment](#text-comment)0.8ex\]c:[char](#text-char)c:[char](#text-char)‘;’+ c:[char](#text-char)‘(’+ c:[char](#text-char)[blockcomment](#text-comment)​[linecomment](#text-comment)if c\=U+0A∧c\=U+0D0.8ex\]if c\=‘;’∧c\=‘(’if c\=‘;’∧c\=‘)’if c\=‘;’∧c\=‘(’​::=[blockcomment](#text-comment)‘;;’ [linechar](#text-comment)∗ ([newline](#text-newline) ∣ [eof](#text-eof))::=‘(;’ [blockchar](#text-comment)∗ ‘;)’​

Here, the pseudo token [eof](#text-eof) indicates the end of the input. The _look-ahead_ restrictions on the productions for [blockchar](#text-comment) disambiguate the grammar such that only well-bracketed uses of block comment delimiters are allowed.

Note

Any formatting and control characters are allowed inside comments.

#### 6.2.5. Annotations[](#annotations①)

An _annotation_ is a bracketed token sequence headed by an _annotation id_ of the form ‘@id’ or ‘@’’...’’’. No [space](#text-space) is allowed between the opening parenthesis and this id. Annotations are intended to be used for third-party extensions; they can appear anywhere in a program but are ignored by the WebAssembly semantics itself, which treats them as [white space](#text-space).

Annotations can contain other parenthesized token sequences (including nested annotations), as long as they are well-nested. [String literals](#text-string) and [comments](#text-comment) occurring in an annotation must also be properly nested and closed.

​[annot](#text-annot)​::=​‘(@’ [annotid](#text-annot) ([space](#text-space) ∣ [token](#text-token))∗ ‘)’0.8ex\]​[annotid](#text-annot)​::=​[idchar](#text-idchar)+ ∣ [name](#text-name)​​

Note

The annotation id is meant to be an identifier categorising the extension, and plays a role similar to the name of a [custom section](#binary-customsec). By convention, annotations corresponding to a custom section should use the custom section’s name as an id.

Implementations are expected to ignore annotations with ids that they do not recognize. On the other hand, they may impose restrictions on annotations that they do recognize, e.g., requiring a specific structure by superimposing a more concrete grammar. It is up to an implementation how it deals with errors in such annotations.

### 6.3. Values[](#values①⓪)

The grammar productions in this section define _lexical syntax_, hence no [white space](#text-space) is allowed.

#### 6.3.1. Integers[](#integers⑦)

All [integers](#syntax-int) can be written in either decimal or hexadecimal notation. In both cases, digits can optionally be separated by underscores.

​[sign](#text-sign)[hexdigit](#text-hexdigit)[hexnum](#text-hexnum)​::=::=∣∣∣::=∣​ϵ ⇒ +1 ∣ ‘+’ ⇒ +1 ∣ ‘\-’ ⇒ −10.8ex\]d:[digit](#text-digit) ⇒ d‘A’ ⇒ 10 ∣ … ∣ ‘F’ ⇒ 15‘a’ ⇒ 10 ∣ … ∣ ‘f’ ⇒ 150.8ex\]n:[num](#text-num) ‘\_’? d:[digit](#text-digit)h:[hexdigit](#text-hexdigit)n:[hexnum](#text-hexnum) ‘\_’? h:[hexdigit](#text-hexdigit)​[digit](#text-digit)[num](#text-num)⇒⇒⇒​::=::=10n+dh16n+h​‘0’ ⇒ 0 ∣ … ∣ ‘9’ ⇒ 9d:[digit](#text-digit)​⇒​d​​

The allowed syntax for integer literals depends on size and signedness. Moreover, their value must lie within the range of the respective type.

​[u](#text-int)N[s](#text-int)N​::=∣::=​n:[num](#text-num)‘0x’ n:[hexnum](#text-hexnum)s:[sign](#text-sign) n:[u](#text-int)N​⇒⇒⇒​nns⋅n​if n<2Nif n<2Nif −2N−1≤s⋅n<2N−1​​

[Uninterpreted integers](#syntax-int) can be written as either signed or unsigned, and are normalized to unsigned in the abstract syntax.

​[i](#text-int)N​::=∣​n:[u](#text-int)Ni:[s](#text-int)N​⇒⇒​n[signed](#aux-signed)N−1​(i)​​

#### 6.3.2. Floating-Point[](#floating-point⑦)

[Floating-point](#syntax-float) values can be represented in either decimal or hexadecimal notation.

​[frac](#text-frac)[hexfrac](#text-hexfrac)[hexmant](#text-hexmant)[hexfloat](#text-hexfloat)​::=∣::=∣∣::=∣::=​d:[digit](#text-digit)d:[digit](#text-digit) ‘\_’? p:[frac](#text-frac)h:[hexdigit](#text-hexdigit)h:[hexdigit](#text-hexdigit) ‘\_’? p:[hexfrac](#text-hexfrac)p:[num](#text-num) ‘.’ q:[frac](#text-frac)p:[hexnum](#text-hexnum) ‘.’?p:[hexnum](#text-hexnum) ‘.’ q:[hexfrac](#text-hexfrac)‘0x’ p:[hexmant](#text-hexmant) (‘P’ ∣ ‘p’) s:[sign](#text-sign) e:[num](#text-num)​⇒⇒⇒⇒⇒⇒⇒⇒​d/10(d+p/10)/10h/16(h+p/16)/160.8ex\]p+qpp+q0.8ex\]p⋅2s⋅e​[mant](#text-mant)[float](#text-float)​::=::=​p:[num](#text-num) ‘.’?p:[mant](#text-mant) (‘E’ ∣ ‘e’) s:[sign](#text-sign) e:[num](#text-num)​⇒⇒​pp⋅10s⋅e​​

The value of a literal must not lie outside the representable range of the corresponding [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") type (that is, a numeric value must not overflow to ±∞), but it may be [rounded](#aux-ieee) to the nearest representable value.

Note

Rounding can be prevented by using hexadecimal notation with no more significant bits than supported by the required type.

Floating-point values may also be written as constants for _infinity_ or _canonical NaN_ (_not a number_). Furthermore, arbitrary NaN values may be expressed by providing an explicit payload value.

​[f](#text-int)N[fNmag](#text-float)​::=∣::=∣∣∣∣​(+1):[sign](#text-sign) q:[fNmag](#text-float)(−1):[sign](#text-sign) q:[fNmag](#text-float)q:[float](#text-float)q:[hexfloat](#text-hexfloat)‘inf’‘nan’‘nan:0x’ n:[hexnum](#text-hexnum)​⇒⇒⇒⇒⇒⇒⇒​+q−q[float](#aux-ieee)N​(q)[float](#aux-ieee)N​(q)∞[nan](#syntax-float)([canon](#aux-canon)N​)[nan](#syntax-float)(n)​if [float](#aux-ieee)N​(q)\=∞if [float](#aux-ieee)N​(q)\=∞if 1≤n<2[signif](#aux-signif)(N)​​

#### 6.3.3. Strings[](#strings①)

_Strings_ denote sequences of bytes that can represent both textual and binary data. They are enclosed in quotation marks and may contain any character other than [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d) control characters, quotation marks (‘’’’), or backslash (‘\\’), except when expressed with an _escape sequence_.

​[string](#text-string)​::=∣​‘’’’ (b∗:[stringelem](#text-string))∗ ‘’’’‘\\’ h1​:[hexdigit](#text-hexdigit) h2​:[hexdigit](#text-hexdigit)​⇒⇒​[⨁](#notation-concat)b∗∗16h1​+h2​​if ∣[⨁](#notation-concat)b∗∗∣<2320.8ex\][stringelem](#text-string)::=c:[stringchar](#text-string)⇒[utf8](#binary-utf8)(c)​

Each character in a string literal represents the byte sequence corresponding to its UTF-8 [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 2.5) encoding, except for hexadecimal escape sequences ‘\\hh’, which represent raw bytes of the respective value.

​[stringchar](#text-string)​::=∣∣∣∣∣∣∣​c:[char](#text-char)‘\\t’‘\\n’‘\\r’‘\\’’’‘\\’’‘\\\\’‘\\u{’ n:[hexnum](#text-hexnum) ‘}’​⇒⇒⇒⇒⇒⇒⇒⇒​cU+09U+0AU+0DU+22U+27U+5Cn​if c≥U+20∧c\=U+7F∧c\=‘’’’∧c\=‘\\’if n<0xD800∨0xE800≤n<0x110000​​

#### 6.3.4. Names[](#names⑤)

[Names](#syntax-name) are strings denoting a literal character sequence. A name string must form a valid UTF-8 encoding as defined by [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 2.5) and is interpreted as a string of Unicode scalar values.

​[name](#text-name)​::=​b∗:[string](#text-string)​⇒​c∗​if b∗\=[utf8](#binary-utf8)(c∗)​​

Note

Presuming the source text is itself encoded correctly, strings that do not contain any uses of hexadecimal byte escapes are always valid names.

#### 6.3.5. Identifiers[](#identifiers①)

[Indices](#syntax-index) can be given in both numeric and symbolic form. Symbolic _identifiers_ that stand in lieu of indices start with ‘$’, followed by either a sequence of printable [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d) characters that does not contain a space, quotation mark, comma, semicolon, or bracket, or by a quoted [name](#text-name).

​[id](#text-id)[idchar](#text-idchar)​::=∣::=∣∣∣∣​‘$’ c∗:[idchar](#text-idchar)+‘$’ c∗:[name](#text-name)‘0’ ∣ … ∣ ‘9’‘A’ ∣ … ∣ ‘Z’‘a’ ∣ … ∣ ‘z’‘!’ ∣ ‘#’ ∣ ‘$’ ∣ ‘%’ ∣ ‘&’ ∣ ‘’’ ∣ ‘\*’ ∣ ‘+’ ∣ ‘\-’ ∣ ‘.’ ∣ ‘/’‘:’ ∣ ‘<’ ∣ ‘\=’ ∣ ‘\>’ ∣ ‘?’ ∣ ‘@’ ∣ ‘\\’ ∣ ‘ ^’ ∣ ‘\_’ ∣ ‘ ˋ’ ∣ ‘|’ ∣ ‘ ~’​⇒⇒c∗c∗if ∣c∗∣\>0​

Note

The value of an identifier character is the Unicode codepoint denoting it.

##### 6.3.5.1. Conventions[](#conventions③⑥)

The expansion rules of some abbreviations require insertion of a _fresh_ identifier. That may be any syntactically valid identifier that does not already occur in the given source text.

### 6.4. Types[](#types①⑤)

#### 6.4.1. Number Types[](#number-types⑨)

​[numtype](#text-numtype)​::=∣∣∣​‘i32’‘i64’‘f32’‘f64’​⇒⇒⇒⇒​[i32](#syntax-numtype)[i64](#syntax-numtype)[f32](#syntax-numtype)[f64](#syntax-numtype)​​

#### 6.4.2. Vector Types[](#vector-types⑨)

​[vectype](#text-vectype)​::=​‘v128’​⇒​[v128](#syntax-vectype)​​

#### 6.4.3. Heap Types[](#heap-types⑨)

​[absheaptype](#text-absheaptype)​::=∣∣∣∣∣∣∣∣∣∣∣∣​‘any’‘eq’‘i31’‘struct’‘array’‘none’‘func’‘nofunc’‘exn’‘noexn’‘extern’‘noextern’x:[typeidx](#text-typeidx)[I](#text-context)​​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[any](#syntax-heaptype)[eq](#syntax-heaptype)[i31](#syntax-heaptype)[struct](#syntax-heaptype)[array](#syntax-heaptype)[none](#syntax-heaptype)[func](#syntax-heaptype)[nofunc](#syntax-heaptype)[exn](#syntax-heaptype)[noexn](#syntax-heaptype)[extern](#syntax-heaptype)[noextern](#syntax-heaptype)0.8ex\]x​[heaptype](#text-heaptype)[I](#text-context)​​::=​ht:[absheaptype](#text-absheaptype)​⇒​ht​​

#### 6.4.4. Reference Types[](#reference-types⑨)

​[null](#text-null)​::=​‘null’​⇒​[null](#syntax-reftype)0.8ex\]​[reftype](#text-reftype)[I](#text-context)​​::=​‘(’ ‘ref’ [null](#syntax-reftype)?:[null](#text-null)? ht:[heaptype](#text-heaptype)[I](#text-context)​ ‘)’​⇒​[ref](#syntax-reftype) [null](#syntax-reftype)? ht​​

##### 6.4.4.1. Abbreviations[](#abbreviations③)

There are shorthands for references to abstract heap types.

​[reftype](#text-reftype)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣​…‘anyref’‘eqref’‘i31ref’‘structref’‘arrayref’‘nullref’‘funcref’‘nullfuncref’‘exnref’‘nullexnref’‘externref’‘nullexternref’​≡≡≡≡≡≡≡≡≡≡≡≡​‘(’ ‘ref’ ‘null’ ‘any’ ‘)’‘(’ ‘ref’ ‘null’ ‘eq’ ‘)’‘(’ ‘ref’ ‘null’ ‘i31’ ‘)’‘(’ ‘ref’ ‘null’ ‘struct’ ‘)’‘(’ ‘ref’ ‘null’ ‘array’ ‘)’‘(’ ‘ref’ ‘null’ ‘none’ ‘)’‘(’ ‘ref’ ‘null’ ‘func’ ‘)’‘(’ ‘ref’ ‘null’ ‘nofunc’ ‘)’‘(’ ‘ref’ ‘null’ ‘exn’ ‘)’‘(’ ‘ref’ ‘null’ ‘noexn’ ‘)’‘(’ ‘ref’ ‘null’ ‘extern’ ‘)’‘(’ ‘ref’ ‘null’ ‘noextern’ ‘)’​​

#### 6.4.5. Value Types[](#value-types⑨)

​[valtype](#text-valtype)[I](#text-context)​​::=∣∣​nt:[numtype](#text-numtype)vt:[vectype](#text-vectype)rt:[reftype](#text-reftype)[I](#text-context)​​⇒⇒⇒​ntvtrt​​

#### 6.4.6. Composite Types[](#composite-types⑨)

Composite types are parsed into their respective abstract representation, paired with the local [identifier context](#text-context) generated by their bound field or parameter identifiers:

​[comptype](#text-comptype)[I](#text-context)​[param](#text-comptype)[I](#text-context)​[result](#text-comptype)[I](#text-context)​​::=∣∣::=::=∣∣∣​‘(’ ‘struct’ (ft,id?)∗:[list](#text-list)([field](#text-comptype)[I](#text-context)​) ‘)’‘(’ ‘array’ ft:[fieldtype](#text-fieldtype)[I](#text-context)​ ‘)’‘(’ ‘func’ (t1​,id?)∗:[list](#text-list)([param](#text-comptype)[I](#text-context)​) t2∗​:[list](#text-list)([result](#text-comptype)[I](#text-context)​) ‘)’‘(’ ‘param’ id?:[id](#text-id)? t:[valtype](#text-valtype)[I](#text-context)​ ‘)’‘(’ ‘result’ t:[valtype](#text-valtype)[I](#text-context)​ ‘)’‘(’ ‘mut’ zt:[storagetype](#text-storagetype)[I](#text-context)​ ‘)’pt:[packtype](#text-packtype)‘i16’​⇒⇒⇒⇒⇒⇒⇒⇒​([struct](#syntax-comptype) ft∗,{[fields](#text-context) (id?)∗})([array](#syntax-comptype) ft,{})([func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​,{})0.8ex\](t,id?)t0.8ex\][mut](#syntax-mut) zt0.8ex\]pt0.8ex\][i16](#syntax-storagetype)​[field](#text-comptype)[I](#text-context)​[fieldtype](#text-fieldtype)[I](#text-context)​[storagetype](#text-storagetype)[I](#text-context)​[packtype](#text-packtype)​::=::=::=::=​‘(’ ‘field’ id?:[id](#text-id)? ft:[fieldtype](#text-fieldtype)[I](#text-context)​ ‘)’zt:[storagetype](#text-storagetype)[I](#text-context)​t:[valtype](#text-valtype)[I](#text-context)​‘i8’​⇒⇒⇒⇒​(ft,id?)ztt[i8](#syntax-storagetype)​​

Note

The optional identifier names for parameters in a function type only have documentation purpose. They cannot be referenced from anywhere.

##### 6.4.6.1. Abbreviations[](#abbreviations④)

Multiple anonymous structure fields or parameters or multiple results may be combined into a single declaration:

​[field](#text-comptype)[I](#text-context)​[param](#text-comptype)[I](#text-context)​[result](#text-comptype)[I](#text-context)​​::=::=::=​… ∣ ‘(’ ‘field’ [fieldtype](#text-fieldtype)[I](#text-context)∗​ ‘)’… ∣ ‘(’ ‘param’ [valtype](#text-valtype)[I](#text-context)∗​ ‘)’… ∣ ‘(’ ‘result’ [valtype](#text-valtype)[I](#text-context)∗​ ‘)’​≡≡≡​(‘(’ ‘field’ [fieldtype](#text-fieldtype)[I](#text-context)​ ‘)’)∗(‘(’ ‘param’ [valtype](#text-valtype)[I](#text-context)​ ‘)’)∗(‘(’ ‘param’ [valtype](#text-valtype)[I](#text-context)​ ‘)’)∗​​

#### 6.4.7. Recursive Types[](#recursive-types⑦)

Recursive types are parsed into their respective abstract representation, paired with the [identifier context](#text-context) generated by their bound identifiers:

​[final](#text-final)​::=​‘final’​⇒​[final](#syntax-subtype)0.8ex\]​[subtype](#text-subtype)[I](#text-context)​​::=​‘(’ ‘sub’ fin?:[final](#text-final)? x∗:[list](#text-list)([typeidx](#text-typeidx)[I](#text-context)​) (ct,[I](#text-context)′):[comptype](#text-comptype)[I](#text-context)​ ‘)’​⇒​([sub](#syntax-subtype) fin? x∗ ct,[I](#text-context)′)0.8ex\]​[typedef](#text-typedef)[I](#text-context)​​::=​‘(’ ‘type’ id?:[id](#text-id)? (st,[I](#text-context)′):[subtype](#text-subtype)[I](#text-context)​ ‘)’​⇒​(st,[I](#text-context)′⊕{[types](#text-context) (id?)})0.8ex\]​[rectype](#text-rectype)[I](#text-context)​​::=​‘(’ ‘rec’ (st,[I](#text-context)′)∗:[list](#text-list)([typedef](#text-typedef)[I](#text-context)​) ‘)’​⇒​([rec](#syntax-rectype) st∗,[⨁](#notation-concat)[I](#text-context)′∗)​​

##### 6.4.7.1. Abbreviations[](#abbreviations⑤)

Final sub types with no super-types can omit the ‘sub’ keyword and its arguments:

​[subtype](#text-subtype)[I](#text-context)​​::=​… ∣ [comptype](#text-comptype)[I](#text-context)​​≡​‘(’ ‘sub’ ‘final’ [comptype](#text-comptype)[I](#text-context)​ ‘)’​​

Similarly, singular recursive types can omit the ‘rec’ keyword:

​[rectype](#text-rectype)[I](#text-context)​​::=​… ∣ [typedef](#text-typedef)[I](#text-context)​​≡​‘(’ ‘rec’ [typedef](#text-typedef)[I](#text-context)​ ‘)’​​

#### 6.4.8. Address Types[](#address-types③)

​[addrtype](#text-addrtype)​::=∣​‘i32’‘i64’​⇒⇒​[i32](#syntax-numtype)[i64](#syntax-numtype)​​

##### 6.4.8.1. Abbreviations[](#abbreviations⑥)

The address type can be omitted, in which case it defaults [i32](#syntax-numtype):

​[addrtype](#text-addrtype)​::=​… ∣ ϵ​≡​‘i32’​​

#### 6.4.9. Limits[](#limits⑨)

​[limits](#text-limits)​::=∣​n:[u64](#text-int)n:[u64](#text-int) m:[u64](#text-int)​⇒⇒​\[n[..](#syntax-limits)ϵ\]\[n[..](#syntax-limits)m\]​​

#### 6.4.10. Tag Types[](#tag-types⑨)

​[tagtype](#text-tagtype)[I](#text-context)​​::=​(x,[I](#text-context)′):[typeuse](#text-typeuse)[I](#text-context)​​⇒​x​​

#### 6.4.11. Global Types[](#global-types⑨)

​[globaltype](#text-globaltype)[I](#text-context)​​::=∣​t:[valtype](#text-valtype)[I](#text-context)​‘(’ ‘mut’ t:[valtype](#text-valtype)[I](#text-context)​ ‘)’​⇒⇒​t[mut](#syntax-mut) t​​

#### 6.4.12. Memory Types[](#memory-types⑨)

​[memtype](#text-memtype)[I](#text-context)​​::=​at:[addrtype](#text-addrtype) lim:[limits](#text-limits)​⇒​at lim [page](#syntax-memtype)​​

#### 6.4.13. Table Types[](#table-types⑨)

​[tabletype](#text-tabletype)[I](#text-context)​​::=​at:[addrtype](#text-addrtype) lim:[limits](#text-limits) rt:[reftype](#text-reftype)[I](#text-context)​​⇒​at lim rt​​

#### 6.4.14. External Types[](#external-types⑨)

​[externtype](#text-externtype)[I](#text-context)​​::=∣∣∣∣​‘(’ ‘tag’ id?:[id](#text-id)? jt:[tagtype](#text-tagtype)[I](#text-context)​ ‘)’‘(’ ‘global’ id?:[id](#text-id)? gt:[globaltype](#text-globaltype)[I](#text-context)​ ‘)’‘(’ ‘memory’ id?:[id](#text-id)? mt:[memtype](#text-memtype)[I](#text-context)​ ‘)’‘(’ ‘table’ id?:[id](#text-id)? tt:[tabletype](#text-tabletype)[I](#text-context)​ ‘)’‘(’ ‘func’ id?:[id](#text-id)? (x,[I](#text-context)′):[typeuse](#text-typeuse)[I](#text-context)​ ‘)’​⇒⇒⇒⇒⇒​([tag](#syntax-externtype) jt,{[tags](#text-context) (id?)})([global](#syntax-externtype) gt,{[globals](#text-context) (id?)})([mem](#syntax-externtype) mt,{[mems](#text-context) (id?)})([table](#syntax-externtype) tt,{[tables](#text-context) (id?)})([func](#syntax-externtype) x,{[funcs](#text-context) (id?)})​​

#### 6.4.15. Type Uses[](#type-uses⑤)

A _type use_ is a reference to a [type definition](#text-type). Where it is required to reference a [function type](#text-functype), it may optionally be augmented by explicit inlined [parameter](#text-param) and [result](#text-result) declarations. That allows binding symbolic [identifiers](#text-id) to name the [local indices](#text-localidx) of parameters. If inline declarations are given, then their types must match the referenced [function type](#text-type).

​[typeuse](#text-typeuse)[I](#text-context)​​::=∣​‘(’ ‘type’ x:[typeidx](#text-typeidx)[I](#text-context)​ ‘)’if [I](#text-context).[typedefs](#text-context)\[x\]\=([rec](#syntax-rectype) st∗).i∧ st∗\[i\]\=[sub](#syntax-subtype) [final](#syntax-subtype) ([func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​)∧ [I](#text-context)′\={[locals](#text-context) (ϵ)∣t1∗​∣}​‘(’ ‘type’ x:[typeidx](#text-typeidx)[I](#text-context)​ ‘)’ (t1​,id?)∗:[param](#text-comptype)[I](#text-context)∗​ t2∗​:[result](#text-comptype)[I](#text-context)∗​if [I](#text-context).[typedefs](#text-context)\[x\]\=([rec](#syntax-rectype) st∗).i∧ st∗\[i\]\=[sub](#syntax-subtype) [final](#syntax-subtype) ([func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​)∧ [I](#text-context)′\={[locals](#text-context) (id?)∗}∧ ⊢[I](#text-context)′:ok​​⇒⇒​(x,[I](#text-context)′)(x,[I](#text-context)′)​​​

Note

If inline declarations are given, their types must be _syntactically_ equal to the types from the indexed definition; possible type [substitutions](#notation-subst) from other definitions that might make them equal are not taken into account. This is to simplify syntactic pre-processing.

The synthesized attribute of a typeuse is a pair consisting of both the used [type index](#syntax-typeidx) and the local [identifier context](#text-context) containing possible parameter identifiers.

Note

Both productions overlap for the case that the function type is [func](#syntax-comptype) ϵ[→](#syntax-comptype)ϵ. However, in that case, they also produce the same results, so that the choice is immaterial.

The [well-formedness](#text-context-wf) condition on [I](#text-context)′ ensures that the parameters do not contain duplicate identifiers.

##### 6.4.15.1. Abbreviations[](#abbreviations⑦)

A type use may also be replaced entirely by inline [parameter](#text-param) and [result](#text-result) declarations. In that case, a [type index](#syntax-typeidx) is automatically inserted:

​[typeuse](#text-typeuse)[I](#text-context)​​::=​… ∣ (t1​,id?)∗:[param](#text-comptype)[I](#text-context)∗​ t2∗​:[result](#text-comptype)[I](#text-context)∗​if [I](#text-context).[typedefs](#text-context)\[x\]\=([rec](#syntax-rectype) ([sub](#syntax-subtype) [final](#syntax-subtype) ([func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​))).0∧ ([I](#text-context).[typedefs](#text-context)\[i\]\=([rec](#syntax-rectype) ([sub](#syntax-subtype) [final](#syntax-subtype) ([func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​))).0)i<x​​≡‘(’ ‘type’ x:[typeidx](#text-typeidx)[I](#text-context)​ ‘)’ [param](#text-comptype)[I](#text-context)∗​ [result](#text-comptype)[I](#text-context)∗​​

where x is the smallest existing [type index](#syntax-typeidx) whose [recursive type](#syntax-rectype) definition parses into a singular, final [function type](#syntax-functype) with the same parameters and results. If no such index exists, then a new [recursive type](#text-rectype) of the same form is inserted at the end of the module.

Abbreviations are expanded in the order they appear, such that previously inserted type definitions are reused by consecutive expansions.

### 6.5. Instructions[](#instructions⑨)

Instructions are syntactically distinguished into _plain_ and _structured_ instructions.

​[instr](#text-instr)[I](#text-context)​[instrs](#text-instrs)[I](#text-context)​​::=∣::=​in:[plaininstr](#text-plaininstr)[I](#text-context)​in:[blockinstr](#text-blockinstr)[I](#text-context)​in∗:[instr](#text-instr)[I](#text-context)∗​​⇒⇒⇒​ininin∗​​

In addition, as a syntactic abbreviation, instructions can be written as S-expressions in [folded](#text-foldedinstr) form, to group them visually.

#### 6.5.1. Labels[](#labels③)

[Structured control instructions](#text-instr-control) can be annotated with a symbolic [label identifier](#text-id). They are the only [symbolic identifiers](#text-index) that can be bound locally in an instruction sequence. The following grammar handles the corresponding update to the [identifier context](#text-context) by [composing](#notation-compose) the context with an additional label entry.

​[label](#text-label)[I](#text-context)​​::=∣∣​ϵid:[id](#text-id)id:[id](#text-id)​⇒⇒⇒​(ϵ,{[labels](#text-context) ϵ}⊕[I](#text-context))(id,{[labels](#text-context) id}⊕[I](#text-context))(id,{[labels](#text-context) id}⊕[I](#text-context)\[.[labels](#text-context)\[x\]\=ϵ\])​if id∈/[I](#text-context).[labels](#text-context)if id\=[I](#text-context).[labels](#text-context)\[x\]​​

Note

The new label entry is inserted at the _beginning_ of the label list in the identifier context. This effectively shifts all existing labels up by one, mirroring the fact that control instructions are indexed relatively not absolutely.

If a label with the same name already exists, then it is shadowed and the earlier label becomes inaccessible.

#### 6.5.2. Parametric Instructions[](#parametric-instructions⑨)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣​‘unreachable’‘nop’‘drop’‘select’ (t∗:[result](#text-comptype)[I](#text-context)∗​)?​⇒⇒⇒⇒​[unreachable](#syntax-instr-control)[nop](#syntax-instr-control)[drop](#syntax-instr-parametric)[select](#syntax-instr-parametric) (t∗)?​​

#### 6.5.3. Control Instructions[](#control-instructions⑨)

[Structured control instructions](#syntax-instr-control) can bind an optional symbolic [label identifier](#text-label). The same label identifier may optionally be repeated after the corresponding ‘end’ or ‘else’ keywords, to indicate the matching delimiters.

Their [block type](#syntax-blocktype) is given as a [type use](#text-typeuse), analogous to the type of [functions](#text-func). However, the special case of a type use that is syntactically empty or consists of only a single [result](#text-result) is not regarded as an [abbreviation](#text-typeuse-abbrev) for an inline [function type](#syntax-functype), but is parsed directly into an optional [value type](#syntax-valtype).

​[blocktype](#text-blocktype)[I](#text-context)​​::=∣∣∣∣∣∣∣​t?:[result](#text-comptype)[I](#text-context)?​(x,[I](#text-context)′):[typeuse](#text-typeuse)[I](#text-context)​if [I](#text-context)′\={[locals](#text-context) (ϵ)∗}0.8ex\]if id′?\=ϵ∨id′?\=id?‘loop’ (id?,[I](#text-context)′):[label](#text-label)[I](#text-context)​ bt:[blocktype](#text-blocktype)[I](#text-context)​in∗:[instrs](#text-instrs)[I](#text-context)′​‘end’ id′?:[id](#text-id)?​if id′?\=ϵ∨id′?\=id?‘if’ (id?,[I](#text-context)′):[label](#text-label)[I](#text-context)​ bt:[blocktype](#text-blocktype)[I](#text-context)​in1∗​:[instrs](#text-instrs)[I](#text-context)′​‘else’ id1?​:[id](#text-id)?in2∗​:[instrs](#text-instrs)[I](#text-context)′​‘end’ id2?​:[id](#text-id)?​if (id1?​\=ϵ∨id1?​\=id?)∧(id2?​\=ϵ∨id2?​\=id?)‘try\_table’ (id?,[I](#text-context)′):[label](#text-label)[I](#text-context)​ bt:[blocktype](#text-blocktype)[I](#text-context)​c∗:[catch](#text-catch)[I](#text-context)∗​in∗:[instrs](#text-instrs)[I](#text-context)′​‘end’ id′?:[id](#text-id)?​if id′?\=ϵ∨id′?\=id?0.8ex\]‘(’ ‘catch\_ref’ x:[tagidx](#text-tagidx)[I](#text-context)​ l:[labelidx](#text-labelidx)[I](#text-context)​ ‘)’‘(’ ‘catch\_all’ l:[labelidx](#text-labelidx)[I](#text-context)​ ‘)’‘(’ ‘catch\_all\_ref’ l:[labelidx](#text-labelidx)[I](#text-context)​ ‘)’​⇒⇒[blockinstr](#text-blockinstr)[I](#text-context)​⇒⇒⇒[catch](#text-catch)[I](#text-context)​⇒⇒⇒​t?x::=[loop](#syntax-instr-control) bt in∗[if](#syntax-instr-control) bt in1∗​ [else](#syntax-instr-control) in2∗​[try\_table](#syntax-instr-control) bt c∗ in∗::=[catch\_ref](#syntax-instr-control) x l[catch\_all](#syntax-instr-control) l[catch\_all\_ref](#syntax-instr-control) l​‘block’ (id?,[I](#text-context)′):[label](#text-label)[I](#text-context)​ bt:[blocktype](#text-blocktype)[I](#text-context)​in∗:[instrs](#text-instrs)[I](#text-context)′​‘end’ id′?:[id](#text-id)?​‘(’ ‘catch’ x:[tagidx](#text-tagidx)[I](#text-context)​ l:[labelidx](#text-labelidx)[I](#text-context)​ ‘)’​⇒⇒​[block](#syntax-instr-control) bt in∗[catch](#syntax-instr-control) x l​​

Note

The side condition stating that the [identifier context](#text-context) [I](#text-context)′ must only contain unnamed entries in the rule for typeuse block types enforces that no identifier can be bound in any param declaration for a block type.

All other control instruction are represented verbatim.

Note

The side condition stating that the [identifier context](#text-context) [I](#text-context)′ must only contain unnamed entries in the rule for [call\_indirect](#syntax-instr-control) enforces that no identifier can be bound in any [param](#text-comptype) declaration appearing in the type annotation.

##### 6.5.3.1. Abbreviations[](#abbreviations⑨)

The ‘else’ keyword of an ‘if’ instruction can be omitted if the following instruction sequence is empty.

​[blockinstr](#text-blockinstr)[I](#text-context)​​::=∣​…‘if’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)​ ‘end’ [id](#text-id)?‘if’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)​ ‘else’ ‘end’ [id](#text-id)?​​≡​​​​

Also, for backwards compatibility, the table index to ‘call\_indirect’ and ‘return\_call\_indirect’ can be omitted, defaulting to 0.

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣​…‘call\_indirect’ [typeuse](#text-typeuse)[I](#text-context)​‘return\_call\_indirect’ [typeuse](#text-typeuse)[I](#text-context)​​≡≡​‘call\_indirect’ ‘0’ [typeuse](#text-typeuse)[I](#text-context)​‘return\_call\_indirect’ ‘0’ [typeuse](#text-typeuse)[I](#text-context)​​​

#### 6.5.4. Variable Instructions[](#variable-instructions⑨)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣​…‘local.get’ x:[localidx](#text-localidx)[I](#text-context)​‘local.set’ x:[localidx](#text-localidx)[I](#text-context)​‘local.tee’ x:[localidx](#text-localidx)[I](#text-context)​‘global.get’ x:[globalidx](#text-globalidx)[I](#text-context)​‘global.set’ x:[globalidx](#text-globalidx)[I](#text-context)​​⇒⇒⇒⇒⇒​[local.get](#syntax-instr-variable) x[local.set](#syntax-instr-variable) x[local.tee](#syntax-instr-variable) x[global.get](#syntax-instr-variable) x[global.set](#syntax-instr-variable) x​​

#### 6.5.5. Table Instructions[](#table-instructions⑨)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣​…‘table.get’ x:[tableidx](#text-tableidx)[I](#text-context)​‘table.set’ x:[tableidx](#text-tableidx)[I](#text-context)​‘table.size’ x:[tableidx](#text-tableidx)[I](#text-context)​‘table.grow’ x:[tableidx](#text-tableidx)[I](#text-context)​‘table.fill’ x:[tableidx](#text-tableidx)[I](#text-context)​‘table.copy’ x1​:[tableidx](#text-tableidx)[I](#text-context)​ x2​:[tableidx](#text-tableidx)[I](#text-context)​‘table.init’ x:[tableidx](#text-tableidx)[I](#text-context)​ y:[elemidx](#text-elemidx)[I](#text-context)​‘elem.drop’ x:[elemidx](#text-elemidx)[I](#text-context)​​⇒⇒⇒⇒⇒⇒⇒⇒​[table.get](#syntax-instr-table) x[table.set](#syntax-instr-table) x[table.size](#syntax-instr-table) x[table.grow](#syntax-instr-table) x[table.fill](#syntax-instr-table) x[table.copy](#syntax-instr-table) x1​ x2​[table.init](#syntax-instr-table) x y[elem.drop](#syntax-instr-table) x​​

##### 6.5.5.1. Abbreviations[](#abbreviations①⓪)

For backwards compatibility, all [table indices](#syntax-tableidx) may be omitted from table instructions, defaulting to 0.

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣​…‘table.get’‘table.set’‘table.size’‘table.grow’‘table.fill’‘table.copy’‘table.init’ [elemidx](#text-elemidx)[I](#text-context)​​≡≡≡≡≡≡≡​‘table.get’ ‘0’‘table.set’ ‘0’‘table.size’ ‘0’‘table.grow’ ‘0’‘table.fill’ ‘0’‘table.copy’ ‘0’ ‘0’‘table.init’ ‘0’ [elemidx](#text-elemidx)[I](#text-context)​​​

#### 6.5.6. Memory Instructions[](#memory-instructions⑨)

The offset and alignment immediates to memory instructions are optional. The offset defaults to 0, the alignment to the storage size of the respective memory access, which is its _natural alignment_. Lexically, an [offset](#text-memarg) or [align](#text-memarg) phrase is considered a single [keyword token](#text-keyword), so no [white space](#text-space) is allowed around the ‘\=’.

​[memarg](#text-memarg)N​[offset](#text-memarg)[align](#text-memarg)N​[laneidx](#text-laneidx)[plaininstr](#text-plaininstr)[I](#text-context)​​::=::=∣::=∣::=::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​n:[offset](#text-memarg) m:[align](#text-memarg)N​‘offset\=’ n:[u64](#text-int)ϵ‘align\=’ m:[u64](#text-int)ϵi:[u8](#text-int)…‘i32.load’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘i64.load’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘f32.load’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘f64.load’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘i32.load8\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i32.load8\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i32.load16\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i32.load16\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i64.load8\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i64.load8\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i64.load16\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i64.load16\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i64.load32\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘i64.load32\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘v128.load’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)16​‘v128.load8x8\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load8x8\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load16x4\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load16x4\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load32x2\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load32x2\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load8\_splat’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘v128.load16\_splat’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘v128.load32\_splat’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘v128.load64\_splat’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load32\_zero’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘v128.load64\_zero’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load8\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​ i:[laneidx](#text-laneidx)‘v128.load16\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​ i:[laneidx](#text-laneidx)‘v128.load32\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​ i:[laneidx](#text-laneidx)‘v128.load64\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​ i:[laneidx](#text-laneidx)‘i32.store’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘i64.store’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘f32.store’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘f64.store’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘i32.store8’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i32.store16’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i64.store8’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i64.store16’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i64.store32’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘v128.store’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)16​‘v128.store8\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​ i:[laneidx](#text-laneidx)‘v128.store16\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​ i:[laneidx](#text-laneidx)‘v128.store32\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​ i:[laneidx](#text-laneidx)‘v128.store64\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​ i:[laneidx](#text-laneidx)‘memory.size’ x:[memidx](#text-memidx)[I](#text-context)​‘memory.grow’ x:[memidx](#text-memidx)[I](#text-context)​‘memory.fill’ x:[memidx](#text-memidx)[I](#text-context)​‘memory.copy’ x1​:[memidx](#text-memidx)[I](#text-context)​ x2​:[memidx](#text-memidx)[I](#text-context)​‘memory.init’ x:[memidx](#text-memidx)[I](#text-context)​ y:[dataidx](#text-dataidx)[I](#text-context)​‘data.drop’ x:[dataidx](#text-dataidx)[I](#text-context)​​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​{[align](#syntax-instr-memory) n,[offset](#syntax-instr-memory) m}n0mNi[i32](#syntax-numtype).[load](#syntax-instr-memory) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory) x ao[f32](#syntax-numtype).[load](#syntax-instr-memory) x ao[f64](#syntax-numtype).[load](#syntax-instr-memory) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[s](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)16\_[s](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)16\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)8\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)16\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)16\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)32\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)32\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8[x](#syntax-shape)8\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8[x](#syntax-shape)8\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16[x](#syntax-shape)4\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16[x](#syntax-shape)4\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32[x](#syntax-shape)2\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32[x](#syntax-shape)2\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[zero](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[zero](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)16\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[lane](#syntax-instr-memory) x ao i[i32](#syntax-numtype).[store](#syntax-instr-memory) x ao[i64](#syntax-numtype).[store](#syntax-instr-memory) x ao[f32](#syntax-numtype).[store](#syntax-instr-memory) x ao[f64](#syntax-numtype).[store](#syntax-instr-memory) x ao[i32](#syntax-numtype).[store](#syntax-instr-memory)8 x ao[i32](#syntax-numtype).[store](#syntax-instr-memory)16 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)8 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)16 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)32 x ao[v128](#syntax-vectype).[store](#syntax-instr-memory) x ao[v128](#syntax-vectype).[store](#syntax-instr-memory)8\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)16\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)32\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)64\_[lane](#syntax-instr-memory) x ao i[memory.size](#syntax-instr-memory) x[memory.grow](#syntax-instr-memory) x[memory.fill](#syntax-instr-memory) x[memory.copy](#syntax-instr-memory) x1​ x2​[memory.init](#syntax-instr-memory) x y[data.drop](#syntax-instr-memory) x​if m\=2n​

##### 6.5.6.1. Abbreviations[](#abbreviations①①)

As an abbreviation, the memory index can be omitted in all memory instructions, defaulting to 0.

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i32.load’ [memarg](#text-memarg)4​‘i64.load’ [memarg](#text-memarg)8​‘f32.load’ [memarg](#text-memarg)4​‘f64.load’ [memarg](#text-memarg)8​‘i32.load8\_s’ [memarg](#text-memarg)1​‘i32.load8\_u’ [memarg](#text-memarg)1​‘i32.load16\_s’ [memarg](#text-memarg)2​‘i32.load16\_u’ [memarg](#text-memarg)2​‘i64.load8\_s’ [memarg](#text-memarg)1​‘i64.load8\_u’ [memarg](#text-memarg)1​‘i64.load16\_s’ [memarg](#text-memarg)2​‘i64.load16\_u’ [memarg](#text-memarg)2​‘i64.load32\_s’ [memarg](#text-memarg)4​‘i64.load32\_u’ [memarg](#text-memarg)4​‘v128.load’ [memarg](#text-memarg)16​‘v128.load8x8\_s’ [memarg](#text-memarg)8​‘v128.load8x8\_u’ [memarg](#text-memarg)8​‘v128.load16x4\_s’ [memarg](#text-memarg)8​‘v128.load16x4\_u’ [memarg](#text-memarg)8​‘v128.load32x2\_s’ [memarg](#text-memarg)8​‘v128.load32x2\_u’ [memarg](#text-memarg)8​‘v128.load8\_splat’ [memarg](#text-memarg)1​‘v128.load16\_splat’ [memarg](#text-memarg)2​‘v128.load32\_splat’ [memarg](#text-memarg)4​‘v128.load64\_splat’ [memarg](#text-memarg)8​‘v128.load32\_zero’ [memarg](#text-memarg)4​‘v128.load64\_zero’ [memarg](#text-memarg)8​‘v128.load8\_lane’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.load16\_lane’ [memarg](#text-memarg)2​ [laneidx](#text-laneidx)‘v128.load32\_lane’ [memarg](#text-memarg)4​ [laneidx](#text-laneidx)‘v128.load64\_lane’ [memarg](#text-memarg)8​ [laneidx](#text-laneidx)‘i32.store’ [memarg](#text-memarg)4​‘i64.store’ [memarg](#text-memarg)8​‘f32.store’ [memarg](#text-memarg)4​‘f64.store’ [memarg](#text-memarg)8​‘i32.store8’ [memarg](#text-memarg)1​‘i32.store16’ [memarg](#text-memarg)2​‘i64.store8’ [memarg](#text-memarg)1​‘i64.store16’ [memarg](#text-memarg)2​‘i64.store32’ [memarg](#text-memarg)4​‘v128.store’ [memarg](#text-memarg)16​‘v128.store8\_lane’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.store16\_lane’ [memarg](#text-memarg)2​ [laneidx](#text-laneidx)‘v128.store32\_lane’ [memarg](#text-memarg)4​ [laneidx](#text-laneidx)‘v128.store64\_lane’ [memarg](#text-memarg)8​ [laneidx](#text-laneidx)‘memory.size’‘memory.grow’‘memory.fill’‘memory.copy’‘memory.init’ [dataidx](#text-dataidx)[I](#text-context)​​≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡​‘i32.load’ ‘0’ [memarg](#text-memarg)4​‘i64.load’ ‘0’ [memarg](#text-memarg)8​‘f32.load’ ‘0’ [memarg](#text-memarg)4​‘f64.load’ ‘0’ [memarg](#text-memarg)8​‘i32.load8\_s’ ‘0’ [memarg](#text-memarg)1​‘i32.load8\_u’ ‘0’ [memarg](#text-memarg)1​‘i32.load16\_s’ ‘0’ [memarg](#text-memarg)2​‘i32.load16\_u’ ‘0’ [memarg](#text-memarg)2​‘i64.load8\_s’ ‘0’ [memarg](#text-memarg)1​‘i64.load8\_u’ ‘0’ [memarg](#text-memarg)1​‘i64.load16\_s’ ‘0’ [memarg](#text-memarg)2​‘i64.load16\_u’ ‘0’ [memarg](#text-memarg)2​‘i64.load32\_s’ ‘0’ [memarg](#text-memarg)4​‘i64.load32\_u’ ‘0’ [memarg](#text-memarg)4​‘v128.load’ ‘0’ [memarg](#text-memarg)16​‘v128.load8x8\_s’ ‘0’ [memarg](#text-memarg)8​‘v128.load8x8\_u’ ‘0’ [memarg](#text-memarg)8​‘v128.load16x4\_s’ ‘0’ [memarg](#text-memarg)8​‘v128.load16x4\_u’ ‘0’ [memarg](#text-memarg)8​‘v128.load32x2\_s’ ‘0’ [memarg](#text-memarg)8​‘v128.load32x2\_u’ ‘0’ [memarg](#text-memarg)8​‘v128.load8\_splat’ ‘0’ [memarg](#text-memarg)1​‘v128.load16\_splat’ ‘0’ [memarg](#text-memarg)2​‘v128.load32\_splat’ ‘0’ [memarg](#text-memarg)4​‘v128.load64\_splat’ ‘0’ [memarg](#text-memarg)8​‘v128.load32\_zero’ ‘0’ [memarg](#text-memarg)4​‘v128.load64\_zero’ ‘0’ [memarg](#text-memarg)8​‘v128.load8\_lane’ ‘0’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.load16\_lane’ ‘0’ [memarg](#text-memarg)2​ [laneidx](#text-laneidx)‘v128.load32\_lane’ ‘0’ [memarg](#text-memarg)4​ [laneidx](#text-laneidx)‘v128.load64\_lane’ ‘0’ [memarg](#text-memarg)8​ [laneidx](#text-laneidx)‘i32.store’ ‘0’ [memarg](#text-memarg)4​‘i64.store’ ‘0’ [memarg](#text-memarg)8​‘f32.store’ ‘0’ [memarg](#text-memarg)4​‘f64.store’ ‘0’ [memarg](#text-memarg)8​‘i32.store8’ ‘0’ [memarg](#text-memarg)1​‘i32.store16’ ‘0’ [memarg](#text-memarg)2​‘i64.store8’ ‘0’ [memarg](#text-memarg)1​‘i64.store16’ ‘0’ [memarg](#text-memarg)2​‘i64.store32’ ‘0’ [memarg](#text-memarg)4​‘v128.store’ ‘0’ [memarg](#text-memarg)16​‘v128.store8\_lane’ ‘0’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.store16\_lane’ ‘0’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.store32\_lane’ ‘0’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.store64\_lane’ ‘0’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘memory.size’ ‘0’‘memory.grow’ ‘0’‘memory.fill’ ‘0’‘memory.copy’ ‘0’ ‘0’‘memory.init’ ‘0’ [dataidx](#text-dataidx)[I](#text-context)​​​

#### 6.5.7. Reference Instructions[](#reference-instructions⑨)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣​…‘ref.null’ ht:[heaptype](#text-heaptype)[I](#text-context)​‘ref.func’ x:[funcidx](#text-funcidx)[I](#text-context)​‘ref.is\_null’‘ref.as\_non\_null’‘ref.eq’‘ref.test’ rt:[reftype](#text-reftype)[I](#text-context)​‘ref.cast’ rt:[reftype](#text-reftype)[I](#text-context)​​⇒⇒⇒⇒⇒⇒⇒​[ref.null](#syntax-instr-ref) ht[ref.func](#syntax-instr-ref) x[ref.is\_null](#syntax-instr-ref)[ref.as\_non\_null](#syntax-instr-ref)[ref.eq](#syntax-instr-ref)[ref.test](#syntax-instr-ref) rt[ref.cast](#syntax-instr-ref) rt​​

#### 6.5.8. Aggregate Instructions[](#aggregate-instructions⑤)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘ref.i31’‘i31.get\_s’‘i31.get\_u’‘struct.new’ x:[typeidx](#text-typeidx)[I](#text-context)​‘struct.new\_default’ x:[typeidx](#text-typeidx)[I](#text-context)​‘struct.get’ x:[typeidx](#text-typeidx)[I](#text-context)​ i:[fieldidx](#text-fieldidx)[I](#text-context),x​‘struct.get\_s’ x:[typeidx](#text-typeidx)[I](#text-context)​ i:[fieldidx](#text-fieldidx)[I](#text-context),x​‘struct.get\_u’ x:[typeidx](#text-typeidx)[I](#text-context)​ i:[fieldidx](#text-fieldidx)[I](#text-context),x​‘struct.set’ x:[typeidx](#text-typeidx)[I](#text-context)​ i:[fieldidx](#text-fieldidx)[I](#text-context),x​‘array.new’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.new\_default’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.new\_fixed’ x:[typeidx](#text-typeidx)[I](#text-context)​ n:[u32](#text-int)‘array.new\_data’ x:[typeidx](#text-typeidx)[I](#text-context)​ y:[dataidx](#text-dataidx)[I](#text-context)​‘array.new\_elem’ x:[typeidx](#text-typeidx)[I](#text-context)​ y:[elemidx](#text-elemidx)[I](#text-context)​‘array.get’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.get\_s’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.get\_u’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.set’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.len’‘array.fill’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.copy’ x1​:[typeidx](#text-typeidx)[I](#text-context)​ x2​:[typeidx](#text-typeidx)[I](#text-context)​‘array.init\_data’ x:[typeidx](#text-typeidx)[I](#text-context)​ y:[dataidx](#text-dataidx)[I](#text-context)​‘array.init\_elem’ x:[typeidx](#text-typeidx)[I](#text-context)​ y:[elemidx](#text-elemidx)[I](#text-context)​‘any.convert\_extern’‘extern.convert\_any’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[ref.i31](#syntax-instr-i31)[i31.get](#syntax-instr-i31)\_[s](#syntax-sx)[i31.get](#syntax-instr-i31)\_[u](#syntax-sx)[struct.new](#syntax-instr-struct) x[struct.new\_default](#syntax-instr-struct) x[struct.get](#syntax-instr-struct) x i[struct.get](#syntax-instr-struct)\_[s](#syntax-sx) x i[struct.get](#syntax-instr-struct)\_[u](#syntax-sx) x i[struct.set](#syntax-instr-struct) x i[array.new](#syntax-instr-array) x[array.new\_default](#syntax-instr-array) x[array.new\_fixed](#syntax-instr-array) x n[array.new\_data](#syntax-instr-array) x y[array.new\_elem](#syntax-instr-array) x y[array.get](#syntax-instr-array) x[array.get](#syntax-instr-array)\_[s](#syntax-sx) x[array.get](#syntax-instr-array)\_[u](#syntax-sx) x[array.set](#syntax-instr-array) x[array.len](#syntax-instr-array)[array.fill](#syntax-instr-array) x[array.copy](#syntax-instr-array) x1​ x2​[array.init\_data](#syntax-instr-array) x y[array.init\_elem](#syntax-instr-array) x y[any.convert\_extern](#syntax-instr-extern)[extern.convert\_any](#syntax-instr-extern)​​

#### 6.5.9. Numeric Instructions[](#numeric-instructions⑨)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣​…‘i32.const’ c:[i32](#text-int)‘i64.const’ c:[i64](#text-int)‘f32.const’ c:[f32](#text-float)‘f64.const’ c:[f64](#text-float)​⇒⇒⇒⇒​[i32](#syntax-numtype).[const](#syntax-instr-numeric) c[i64](#syntax-numtype).[const](#syntax-instr-numeric) c[f32](#syntax-numtype).[const](#syntax-instr-numeric) c[f64](#syntax-numtype).[const](#syntax-instr-numeric) c​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i32.eqz’‘i32.eq’‘i32.ne’‘i32.lt\_s’‘i32.lt\_u’‘i32.gt\_s’‘i32.gt\_u’‘i32.le\_s’‘i32.le\_u’‘i32.ge\_s’‘i32.ge\_u’‘i32.clz’‘i32.ctz’‘i32.popcnt’‘i32.extend8\_s’‘i32.extend16\_s’‘i32.add’‘i32.sub’‘i32.mul’‘i32.div\_s’‘i32.div\_u’‘i32.rem\_s’‘i32.rem\_u’‘i32.and’‘i32.or’‘i32.xor’‘i32.shl’‘i32.shr\_s’‘i32.shr\_u’‘i32.rotl’‘i32.rotr’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[eqz](#syntax-instr-numeric)[i32](#syntax-numtype).[eq](#syntax-instr-numeric)[i32](#syntax-numtype).[ne](#syntax-instr-numeric)[i32](#syntax-numtype).[lt](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[lt](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[gt](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[gt](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[le](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[le](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[ge](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[ge](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[clz](#syntax-instr-numeric)[i32](#syntax-numtype).[ctz](#syntax-instr-numeric)[i32](#syntax-numtype).[popcnt](#syntax-instr-numeric)[i32](#syntax-numtype).[extend](#syntax-instr-numeric)8\_[s](#syntax-sx)[i32](#syntax-numtype).[extend](#syntax-instr-numeric)16\_[s](#syntax-sx)[i32](#syntax-numtype).[add](#syntax-instr-numeric)[i32](#syntax-numtype).[sub](#syntax-instr-numeric)[i32](#syntax-numtype).[mul](#syntax-instr-numeric)[i32](#syntax-numtype).[div](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[div](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[rem](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[rem](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[and](#syntax-instr-numeric)[i32](#syntax-numtype).[or](#syntax-instr-numeric)[i32](#syntax-numtype).[xor](#syntax-instr-numeric)[i32](#syntax-numtype).[shl](#syntax-instr-numeric)[i32](#syntax-numtype).[shr](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[shr](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[rotl](#syntax-instr-numeric)[i32](#syntax-numtype).[rotr](#syntax-instr-numeric)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i64.eqz’‘i64.eq’‘i64.ne’‘i64.lt\_s’‘i64.lt\_u’‘i64.gt\_s’‘i64.gt\_u’‘i64.le\_s’‘i64.le\_u’‘i64.ge\_s’‘i64.ge\_u’‘i64.clz’‘i64.ctz’‘i64.popcnt’‘i64.extend8\_s’‘i64.extend16\_s’‘i64.extend32\_s’‘i64.add’‘i64.sub’‘i64.mul’‘i64.div\_s’‘i64.div\_u’‘i64.rem\_s’‘i64.rem\_u’‘i64.and’‘i64.or’‘i64.xor’‘i64.shl’‘i64.shr\_s’‘i64.shr\_u’‘i64.rotl’‘i64.rotr’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i64](#syntax-numtype).[eqz](#syntax-instr-numeric)[i64](#syntax-numtype).[eq](#syntax-instr-numeric)[i64](#syntax-numtype).[ne](#syntax-instr-numeric)[i64](#syntax-numtype).[lt](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[lt](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[gt](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[gt](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[le](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[le](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[ge](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[ge](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[clz](#syntax-instr-numeric)[i64](#syntax-numtype).[ctz](#syntax-instr-numeric)[i64](#syntax-numtype).[popcnt](#syntax-instr-numeric)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)8\_[s](#syntax-sx)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)16\_[s](#syntax-sx)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)32\_[s](#syntax-sx)[i64](#syntax-numtype).[add](#syntax-instr-numeric)[i64](#syntax-numtype).[sub](#syntax-instr-numeric)[i64](#syntax-numtype).[mul](#syntax-instr-numeric)[i64](#syntax-numtype).[div](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[div](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[rem](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[rem](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[and](#syntax-instr-numeric)[i64](#syntax-numtype).[or](#syntax-instr-numeric)[i64](#syntax-numtype).[xor](#syntax-instr-numeric)[i64](#syntax-numtype).[shl](#syntax-instr-numeric)[i64](#syntax-numtype).[shr](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[shr](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[rotl](#syntax-instr-numeric)[i64](#syntax-numtype).[rotr](#syntax-instr-numeric)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘f32.eq’‘f32.ne’‘f32.lt’‘f32.gt’‘f32.le’‘f32.ge’‘f32.abs’‘f32.neg’‘f32.sqrt’‘f32.ceil’‘f32.floor’‘f32.trunc’‘f32.nearest’‘f32.add’‘f32.sub’‘f32.mul’‘f32.div’‘f32.min’‘f32.max’‘f32.copysign’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype).[eq](#syntax-instr-numeric)[f32](#syntax-numtype).[ne](#syntax-instr-numeric)[f32](#syntax-numtype).[lt](#syntax-instr-numeric)[f32](#syntax-numtype).[gt](#syntax-instr-numeric)[f32](#syntax-numtype).[le](#syntax-instr-numeric)[f32](#syntax-numtype).[ge](#syntax-instr-numeric)[f32](#syntax-numtype).[abs](#syntax-instr-numeric)[f32](#syntax-numtype).[neg](#syntax-instr-numeric)[f32](#syntax-numtype).[sqrt](#syntax-instr-numeric)[f32](#syntax-numtype).[ceil](#syntax-instr-numeric)[f32](#syntax-numtype).[floor](#syntax-instr-numeric)[f32](#syntax-numtype).[trunc](#syntax-instr-numeric)[f32](#syntax-numtype).[nearest](#syntax-instr-numeric)[f32](#syntax-numtype).[add](#syntax-instr-numeric)[f32](#syntax-numtype).[sub](#syntax-instr-numeric)[f32](#syntax-numtype).[mul](#syntax-instr-numeric)[f32](#syntax-numtype).[div](#syntax-instr-numeric)[f32](#syntax-numtype).[min](#syntax-instr-numeric)[f32](#syntax-numtype).[max](#syntax-instr-numeric)[f32](#syntax-numtype).[copysign](#syntax-instr-numeric)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘f64.eq’‘f64.ne’‘f64.lt’‘f64.gt’‘f64.le’‘f64.ge’‘f64.abs’‘f64.neg’‘f64.sqrt’‘f64.ceil’‘f64.floor’‘f64.trunc’‘f64.nearest’‘f64.add’‘f64.sub’‘f64.mul’‘f64.div’‘f64.min’‘f64.max’‘f64.copysign’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f64](#syntax-numtype).[eq](#syntax-instr-numeric)[f64](#syntax-numtype).[ne](#syntax-instr-numeric)[f64](#syntax-numtype).[lt](#syntax-instr-numeric)[f64](#syntax-numtype).[gt](#syntax-instr-numeric)[f64](#syntax-numtype).[le](#syntax-instr-numeric)[f64](#syntax-numtype).[ge](#syntax-instr-numeric)[f64](#syntax-numtype).[abs](#syntax-instr-numeric)[f64](#syntax-numtype).[neg](#syntax-instr-numeric)[f64](#syntax-numtype).[sqrt](#syntax-instr-numeric)[f64](#syntax-numtype).[ceil](#syntax-instr-numeric)[f64](#syntax-numtype).[floor](#syntax-instr-numeric)[f64](#syntax-numtype).[trunc](#syntax-instr-numeric)[f64](#syntax-numtype).[nearest](#syntax-instr-numeric)[f64](#syntax-numtype).[add](#syntax-instr-numeric)[f64](#syntax-numtype).[sub](#syntax-instr-numeric)[f64](#syntax-numtype).[mul](#syntax-instr-numeric)[f64](#syntax-numtype).[div](#syntax-instr-numeric)[f64](#syntax-numtype).[min](#syntax-instr-numeric)[f64](#syntax-numtype).[max](#syntax-instr-numeric)[f64](#syntax-numtype).[copysign](#syntax-instr-numeric)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i32.wrap\_i64’‘i32.trunc\_f32\_s’‘i32.trunc\_f32\_u’‘i32.trunc\_f64\_s’‘i32.trunc\_f64\_u’‘i32.trunc\_sat\_f32\_s’‘i32.trunc\_sat\_f32\_u’‘i32.trunc\_sat\_f64\_s’‘i32.trunc\_sat\_f64\_u’‘i64.extend\_i64\_s’‘i64.extend\_i64\_u’‘i64.trunc\_f32\_s’‘i64.trunc\_f32\_u’‘i64.trunc\_f64\_s’‘i64.trunc\_f64\_u’‘i64.trunc\_sat\_f32\_s’‘i64.trunc\_sat\_f32\_u’‘i64.trunc\_sat\_f64\_s’‘i64.trunc\_sat\_f64\_u’‘f32.demote\_f64’‘f32.convert\_i32\_s’‘f32.convert\_i32\_u’‘f32.convert\_i64\_s’‘f32.convert\_i64\_u’‘f64.promote\_f32’‘f64.convert\_i32\_s’‘f64.convert\_i32\_u’‘f64.convert\_i64\_s’‘f64.convert\_i64\_u’‘i32.reinterpret\_f32’‘i64.reinterpret\_f64’‘f32.reinterpret\_i32’‘f64.reinterpret\_i64’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[wrap](#syntax-instr-numeric)\_[i64](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i64](#syntax-numtype)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i64](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[f32](#syntax-numtype).[demote](#syntax-instr-numeric)\_[f64](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i64](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i64](#syntax-numtype)[f64](#syntax-numtype).[promote](#syntax-instr-numeric)\_[f32](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i64](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i64](#syntax-numtype)[i32](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[f64](#syntax-numtype)[f32](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[i64](#syntax-numtype)​​

#### 6.5.10. Vector Instructions[](#vector-instructions⑨)

Vector constant instructions have a mandatory [shape](#syntax-shape) descriptor, which determines how the following values are parsed.

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣​…‘v128.const’ ‘i8x16’ c∗:[i8](#text-int)16‘v128.const’ ‘i16x8’ c∗:[i16](#text-int)8‘v128.const’ ‘i32x4’ c∗:[i32](#text-int)4‘v128.const’ ‘i64x2’ c∗:[i64](#text-int)2‘v128.const’ ‘f32x4’ c∗:[f32](#text-float)4‘v128.const’ ‘f64x2’ c∗:[f64](#text-float)2​⇒⇒⇒⇒⇒⇒​[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[i](#syntax-numtype)8​(c)∗)[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[i](#syntax-numtype)16​(c)∗)[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[i](#syntax-numtype)32​(c)∗)[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[i](#syntax-numtype)64​(c)∗)[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[f](#syntax-numtype)32​(c)∗)[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[f](#syntax-numtype)64​(c)∗)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i8x16.shuffle’ i∗:[laneidx](#text-laneidx)16‘i8x16.swizzle’‘i8x16.relaxed\_swizzle’‘i8x16.splat’‘i16x8.splat’‘i32x4.splat’‘i64x2.splat’‘f32x4.splat’‘f64x2.splat’‘i8x16.extract\_lane\_s’ i:[laneidx](#text-laneidx)‘i8x16.extract\_lane\_u’ i:[laneidx](#text-laneidx)‘i16x8.extract\_lane\_s’ i:[laneidx](#text-laneidx)‘i16x8.extract\_lane\_u’ i:[laneidx](#text-laneidx)‘i32x4.extract\_lane’ i:[laneidx](#text-laneidx)‘i64x2.extract\_lane’ i:[laneidx](#text-laneidx)‘f32x4.extract\_lane’ i:[laneidx](#text-laneidx)‘f64x2.extract\_lane’ i:[laneidx](#text-laneidx)‘i8x16.replace\_lane’ i:[laneidx](#text-laneidx)‘i16x8.replace\_lane’ i:[laneidx](#text-laneidx)‘i32x4.replace\_lane’ i:[laneidx](#text-laneidx)‘i64x2.replace\_lane’ i:[laneidx](#text-laneidx)‘f32x4.replace\_lane’ i:[laneidx](#text-laneidx)‘f64x2.replace\_lane’ i:[laneidx](#text-laneidx)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[shuffle](#syntax-instr-vec) i∗[i8](#syntax-storagetype)[x](#syntax-shape)16.[swizzle](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[relaxed\_swizzle](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[splat](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[splat](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[splat](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[splat](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[splat](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[splat](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[extract\_lane](#syntax-instr-vec)\_[s](#syntax-sx) i[i8](#syntax-storagetype)[x](#syntax-shape)16.[extract\_lane](#syntax-instr-vec)\_[u](#syntax-sx) i[i16](#syntax-storagetype)[x](#syntax-shape)8.[extract\_lane](#syntax-instr-vec)\_[s](#syntax-sx) i[i16](#syntax-storagetype)[x](#syntax-shape)8.[extract\_lane](#syntax-instr-vec)\_[u](#syntax-sx) i[i32](#syntax-numtype)[x](#syntax-shape)4.[extract\_lane](#syntax-instr-vec) i[i64](#syntax-numtype)[x](#syntax-shape)2.[extract\_lane](#syntax-instr-vec) i[f32](#syntax-numtype)[x](#syntax-shape)4.[extract\_lane](#syntax-instr-vec) i[f64](#syntax-numtype)[x](#syntax-shape)2.[extract\_lane](#syntax-instr-vec) i[i8](#syntax-storagetype)[x](#syntax-shape)16.[replace\_lane](#syntax-instr-vec) i[i16](#syntax-storagetype)[x](#syntax-shape)8.[replace\_lane](#syntax-instr-vec) i[i32](#syntax-numtype)[x](#syntax-shape)4.[replace\_lane](#syntax-instr-vec) i[i64](#syntax-numtype)[x](#syntax-shape)2.[replace\_lane](#syntax-instr-vec) i[f32](#syntax-numtype)[x](#syntax-shape)4.[replace\_lane](#syntax-instr-vec) i[f64](#syntax-numtype)[x](#syntax-shape)2.[replace\_lane](#syntax-instr-vec) i​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣​…‘v128.any\_true’‘v128.not’‘v128.and’‘v128.andnot’‘v128.or’‘v128.xor’‘v128.bitselect’​⇒⇒⇒⇒⇒⇒⇒​[v128](#syntax-vectype).[any\_true](#syntax-instr-vec)[v128](#syntax-vectype).[not](#syntax-instr-vec)[v128](#syntax-vectype).[and](#syntax-instr-vec)[v128](#syntax-vectype).[andnot](#syntax-instr-vec)[v128](#syntax-vectype).[or](#syntax-instr-vec)[v128](#syntax-vectype).[xor](#syntax-instr-vec)[v128](#syntax-vectype).[bitselect](#syntax-instr-vec)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i8x16.all\_true’‘i8x16.eq’‘i8x16.ne’‘i8x16.lt\_s’‘i8x16.lt\_u’‘i8x16.gt\_s’‘i8x16.gt\_u’‘i8x16.le\_s’‘i8x16.le\_u’‘i8x16.ge\_s’‘i8x16.ge\_u’‘i8x16.abs’‘i8x16.neg’‘i8x16.popcnt’‘i8x16.add’‘i8x16.add\_sat\_s’‘i8x16.add\_sat\_u’‘i8x16.sub’‘i8x16.sub\_sat\_s’‘i8x16.sub\_sat\_u’‘i8x16.min\_s’‘i8x16.min\_u’‘i8x16.max\_s’‘i8x16.max\_u’‘i8x16.avgr\_u’‘i8x16.relaxed\_laneselect’‘i8x16.shl’‘i8x16.shr\_s’‘i8x16.shr\_u’‘i8x16.bitmask’‘i8x16.narrow\_i16x8\_s’‘i8x16.narrow\_i16x8\_u’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[all\_true](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[eq](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ne](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[abs](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[neg](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[popcnt](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[avgr](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[relaxed\_laneselect](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shl](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[bitmask](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[narrow](#syntax-instr-vec)\_[i16](#syntax-storagetype)[x](#syntax-shape)8\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[narrow](#syntax-instr-vec)\_[i16](#syntax-storagetype)[x](#syntax-shape)8\_[u](#syntax-sx)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i16x8.all\_true’‘i16x8.eq’‘i16x8.ne’‘i16x8.lt\_s’‘i16x8.lt\_u’‘i16x8.gt\_s’‘i16x8.gt\_u’‘i16x8.le\_s’‘i16x8.le\_u’‘i16x8.ge\_s’‘i16x8.ge\_u’‘i16x8.abs’‘i16x8.neg’‘i16x8.add’‘i16x8.add\_sat\_s’‘i16x8.add\_sat\_u’‘i16x8.sub’‘i16x8.sub\_sat\_s’‘i16x8.sub\_sat\_u’‘i16x8.mul’‘i16x8.min\_s’‘i16x8.min\_u’‘i16x8.max\_s’‘i16x8.max\_u’‘i16x8.avgr\_u’‘i16x8.q15mulr\_sat\_s’‘i16x8.relaxed\_q15mulr\_s’‘i16x8.relaxed\_laneselect’‘i16x8.shl’‘i16x8.shr\_s’‘i16x8.shr\_u’‘i16x8.bitmask’‘i16x8.narrow\_i32x4\_s’‘i16x8.narrow\_i32x4\_u’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i16](#syntax-storagetype)[x](#syntax-shape)8.[all\_true](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[eq](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ne](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[abs](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[neg](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[mul](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[avgr](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[q15mulr\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[relaxed\_q15mulr](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[relaxed\_laneselect](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[shl](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[bitmask](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[narrow](#syntax-instr-vec)\_[i32](#syntax-numtype)[x](#syntax-shape)4\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[narrow](#syntax-instr-vec)\_[i32](#syntax-numtype)[x](#syntax-shape)4\_[u](#syntax-sx)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i32x4.all\_true’‘i32x4.eq’‘i32x4.ne’‘i32x4.lt\_s’‘i32x4.lt\_u’‘i32x4.gt\_s’‘i32x4.gt\_u’‘i32x4.le\_s’‘i32x4.le\_u’‘i32x4.ge\_s’‘i32x4.ge\_u’‘i32x4.abs’‘i32x4.neg’‘i32x4.add’‘i32x4.sub’‘i32x4.mul’‘i32x4.min\_s’‘i32x4.min\_u’‘i32x4.max\_s’‘i32x4.max\_u’‘i32x4.relaxed\_laneselect’‘i32x4.shl’‘i32x4.shr\_s’‘i32x4.shr\_u’‘i32x4.bitmask’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype)[x](#syntax-shape)4.[all\_true](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[eq](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[ne](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[abs](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[neg](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[add](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[sub](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[mul](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_laneselect](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[shl](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[bitmask](#syntax-instr-vec)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i64x2.all\_true’‘i64x2.eq’‘i64x2.ne’‘i64x2.lt\_s’‘i64x2.gt\_s’‘i64x2.le\_s’‘i64x2.ge\_s’‘i64x2.abs’‘i64x2.neg’‘i64x2.add’‘i64x2.sub’‘i64x2.mul’‘i64x2.relaxed\_laneselect’‘i64x2.shl’‘i64x2.shr\_s’‘i64x2.shr\_u’‘i64x2.bitmask’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i64](#syntax-numtype)[x](#syntax-shape)2.[all\_true](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[eq](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[ne](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[abs](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[neg](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[add](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[sub](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[mul](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_laneselect](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[shl](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[bitmask](#syntax-instr-vec)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘f32x4.eq’‘f32x4.ne’‘f32x4.lt’‘f32x4.gt’‘f32x4.le’‘f32x4.ge’‘f32x4.abs’‘f32x4.neg’‘f32x4.sqrt’‘f32x4.ceil’‘f32x4.floor’‘f32x4.trunc’‘f32x4.nearest’‘f32x4.add’‘f32x4.sub’‘f32x4.mul’‘f32x4.div’‘f32x4.min’‘f32x4.max’‘f32x4.pmin’‘f32x4.pmax’‘f32x4.relaxed\_min’‘f32x4.relaxed\_max’‘f32x4.relaxed\_madd’‘f32x4.relaxed\_nmadd’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype)[x](#syntax-shape)4.[eq](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[ne](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[abs](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[neg](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[sqrt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[ceil](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[floor](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[trunc](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[nearest](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[add](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[sub](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[mul](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[div](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[pmin](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[pmax](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_min](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_max](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_madd](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_nmadd](#syntax-instr-vec)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘f64x2.eq’‘f64x2.ne’‘f64x2.lt’‘f64x2.gt’‘f64x2.le’‘f64x2.ge’‘f64x2.abs’‘f64x2.neg’‘f64x2.sqrt’‘f64x2.ceil’‘f64x2.floor’‘f64x2.trunc’‘f64x2.nearest’‘f64x2.add’‘f64x2.sub’‘f64x2.mul’‘f64x2.div’‘f64x2.min’‘f64x2.max’‘f64x2.pmin’‘f64x2.pmax’‘f64x2.relaxed\_min’‘f64x2.relaxed\_max’‘f64x2.relaxed\_madd’‘f64x2.relaxed\_nmadd’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f64](#syntax-numtype)[x](#syntax-shape)2.[eq](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[ne](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[lt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[gt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[le](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[ge](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[abs](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[neg](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[sqrt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[ceil](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[floor](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[trunc](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[nearest](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[add](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[sub](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[mul](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[div](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[min](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[max](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[pmin](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[pmax](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_min](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_max](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_madd](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_nmadd](#syntax-instr-vec)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i16x8.extend\_low\_i8x16\_s’‘i16x8.extend\_low\_i8x16\_u’‘i16x8.extend\_high\_i8x16\_s’‘i16x8.extend\_high\_i8x16\_u’‘i32x4.extend\_low\_i16x8\_s’‘i32x4.extend\_low\_i16x8\_u’‘i32x4.extend\_high\_i16x8\_s’‘i32x4.extend\_high\_i16x8\_u’‘i32x4.trunc\_sat\_f32x4\_s’‘i32x4.trunc\_sat\_f32x4\_u’‘i32x4.trunc\_sat\_f64x2\_s\_zero’‘i32x4.trunc\_sat\_f64x2\_u\_zero’‘i32x4.relaxed\_trunc\_f32x4\_s’‘i32x4.relaxed\_trunc\_f32x4\_u’‘i32x4.relaxed\_trunc\_f64x2\_s\_zero’‘i32x4.relaxed\_trunc\_f64x2\_u\_zero’‘i64x2.extend\_low\_i32x4\_s’‘i64x2.extend\_low\_i32x4\_u’‘i64x2.extend\_high\_i32x4\_s’‘i64x2.extend\_high\_i32x4\_u’‘f32x4.demote\_f64x2\_zero’‘f32x4.convert\_i32x4\_s’‘f32x4.convert\_i32x4\_u’‘f64x2.promote\_low\_f32x4’‘f64x2.convert\_low\_i32x4\_s’‘f64x2.convert\_low\_i32x4\_u’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[s](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[u](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[s](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[u](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f32](#syntax-numtype)[x](#syntax-shape)4.[demote](#syntax-instr-vec)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[f32](#syntax-numtype)[x](#syntax-shape)4.[convert](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f32](#syntax-numtype)[x](#syntax-shape)4.[convert](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f64](#syntax-numtype)[x](#syntax-shape)2.[promote](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[f32](#syntax-numtype)[x](#syntax-shape)4[f64](#syntax-numtype)[x](#syntax-shape)2.[convert](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f64](#syntax-numtype)[x](#syntax-shape)2.[convert](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i16x8.extadd\_pairwise\_i8x16\_s’‘i16x8.extadd\_pairwise\_i8x16\_u’‘i16x8.extmul\_low\_i8x16\_s’‘i16x8.extmul\_low\_i8x16\_u’‘i16x8.extmul\_high\_i8x16\_s’‘i16x8.extmul\_high\_i8x16\_u’‘i32x4.extadd\_pairwise\_i16x8\_s’‘i32x4.extadd\_pairwise\_i16x8\_u’‘i32x4.extmul\_low\_i16x8\_s’‘i32x4.extmul\_low\_i16x8\_u’‘i32x4.extmul\_high\_i16x8\_s’‘i32x4.extmul\_high\_i16x8\_u’‘i32x4.dot\_i16x8\_s’‘i64x2.extmul\_low\_i32x4\_s’‘i64x2.extmul\_low\_i32x4\_u’‘i64x2.extmul\_high\_i32x4\_s’‘i64x2.extmul\_high\_i32x4\_u’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i16](#syntax-storagetype)[x](#syntax-shape)8.[extadd\_pairwise](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extadd\_pairwise](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i32](#syntax-numtype)[x](#syntax-shape)4.[extadd\_pairwise](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extadd\_pairwise](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[dot](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4​​

#### 6.5.11. Folded Instructions[](#folded-instructions①)

Instructions can be written as S-expressions by grouping them into _folded_ form. In that notation, an instruction is wrapped in parentheses and optionally includes nested folded instructions to indicate its operands.

In the case of [block instructions](#text-instr-block), the folded form omits the ‘end’ delimiter. For if instructions, both branches have to be wrapped into nested S-expressions, headed by the keywords ‘then’ and ‘else’.

The set of all phrases defined by the following abbreviations recursively forms the auxiliary syntactic class foldedinstr. Such a folded instruction can appear anywhere a regular instruction can.

​[foldedinstr](#text-foldedinstr)[I](#text-context)​​::=∣∣∣∣​‘(’ [plaininstr](#text-plaininstr)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)​ ‘)’[instrs](#text-instrs)[I](#text-context)​ [plaininstr](#text-plaininstr)[I](#text-context)​​‘(’ ‘block’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)′​ ‘)’‘block’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)′​ ‘end’​‘(’ ‘loop’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)′​ ‘)’‘loop’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)′​ ‘end’​‘(’ ‘if’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [foldedinstr](#text-foldedinstr)[I](#text-context)∗​‘(’ ‘then’ in1∗​:[instrs](#text-instrs)[I](#text-context)′​ ‘)’ (‘(’ ‘else’ in2∗​:[instrs](#text-instrs)[I](#text-context)′​ ‘)’)? ‘)’​[foldedinstr](#text-foldedinstr)[I](#text-context)∗​ ‘if’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ in1∗​:[instrs](#text-instrs)[I](#text-context)′​ (‘else’ in2∗​:[instrs](#text-instrs)[I](#text-context)′​)? ‘end’​‘(’ ‘try\_table’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [catch](#text-catch)[I](#text-context)∗​ [instrs](#text-instrs)[I](#text-context)′​ ‘)’‘try\_table’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [catch](#text-catch)[I](#text-context)∗​ [instrs](#text-instrs)[I](#text-context)′​ ‘end’​​≡≡≡≡≡​​​​

Note

For example, the instruction sequence

(local.get $x) (i32.const 2) i32.add (i32.const 3) i32.mul

can be folded into

(i32.mul (i32.add (local.get $x) (i32.const 2)) (i32.const 3))

Folded instructions are solely syntactic sugar, no additional syntactic or type-based checking is implied.

#### 6.5.12. Expressions[](#expressions⑨)

Expressions are written as instruction sequences.

​[expr](#text-expr)[I](#text-context)​​::=​in∗:[instrs](#text-instrs)[I](#text-context)​​⇒​in∗​​

### 6.6. Modules[](#modules①②)

Modules consist of a sequence of [declarations](#text-decl). The grammar rules for each declaration construct produce a pair, consisting of not just the abstract syntax representing the respective declaration, but also an [identifier context](#text-context) recording the new symbolic [identifiers](#text-id) bound by the construct, for use in the remainder of the module.

#### 6.6.1. Indices[](#indices⑤)

[Indices](#syntax-index) can be given either in raw numeric form or as symbolic [identifiers](#text-id) when bound by a respective construct. Such identifiers are looked up in the suitable space of the [identifier context](#text-context) [I](#text-context).

​[idx](#text-idx)ids​[tagidx](#text-tagidx)[I](#text-context)​[globalidx](#text-globalidx)[I](#text-context)​[memidx](#text-memidx)[I](#text-context)​[tableidx](#text-tableidx)[I](#text-context)​[funcidx](#text-funcidx)[I](#text-context)​[dataidx](#text-dataidx)[I](#text-context)​[elemidx](#text-elemidx)[I](#text-context)​[localidx](#text-localidx)[I](#text-context)​[labelidx](#text-labelidx)[I](#text-context)​[fieldidx](#text-fieldidx)[I](#text-context),x​​::=∣::=::=::=::=::=::=::=::=::=::=​x:[u32](#text-int)id:[id](#text-id)[idx](#text-idx)[I](#text-context).[tags](#text-context)​[idx](#text-idx)[I](#text-context).[globals](#text-context)​[idx](#text-idx)[I](#text-context).[mems](#text-context)​[idx](#text-idx)[I](#text-context).[tables](#text-context)​[idx](#text-idx)[I](#text-context).[funcs](#text-context)​[idx](#text-idx)[I](#text-context).[datas](#text-context)​[idx](#text-idx)[I](#text-context).[elems](#text-context)​[idx](#text-idx)[I](#text-context).[locals](#text-context)​[idx](#text-idx)[I](#text-context).[labels](#text-context)​[idx](#text-idx)[I](#text-context).[fields](#text-context)\[x\]​​⇒⇒xxif ids\[x\]\=id0.8ex\][typeidx](#text-typeidx)[I](#text-context)​::=[idx](#text-idx)[I](#text-context).[types](#text-context)​​

#### 6.6.2. Types[](#types①⑦)

A type definition consists of a [recursive type](#text-rectype). The [identifier context](#text-context) produced for the local bindings is further extended with the respective sequence of [defined types](#syntax-deftype) that the recursive type generates.

​[type](#text-type)[I](#text-context)​​::=​(qt,[I](#text-context)′):[rectype](#text-rectype)[I](#text-context)​​⇒​([type](#syntax-type) qt,[I](#text-context)′⊕[I](#text-context)′′)​if qt\=[rec](#syntax-rectype) stn∧ [I](#text-context)′′\={[typedefs](#text-context) (qt.i)i<n}​​​

#### 6.6.3. Tags[](#tags⑨)

A tag definition can bind a symbolic [tag identifier](#text-id).

​[tag](#text-tag)[I](#text-context)​​::=​‘(’ ‘tag’ id?:[id](#text-id)? jt:[tagtype](#text-tagtype)[I](#text-context)​ ‘)’​⇒​([tag](#syntax-tag) jt,{[tags](#text-context) (id?)})​​

##### 6.6.3.1. Abbreviations[](#abbreviations①③)

Tags can be defined as [imports](#text-import) or [exports](#text-export) inline:

​[import](#text-import)[I](#text-context)​​::=∣​…‘(’ ‘tag’ [id](#text-id)? ‘(’ ‘import’ [name](#text-name)2 ‘)’ [tagtype](#text-tagtype)[I](#text-context)​ ‘)’‘(’ ‘import’ [name](#text-name)2 ‘(’ ‘tag’ [id](#text-id)? [tagtype](#text-tagtype)[I](#text-context)​ ‘)’ ‘)’​0.8ex\]‘(’ ‘tag’ id′:[id](#text-id) … ‘)’‘(’ ‘export’ [name](#text-name) ‘(’ ‘tag’ [id](#text-id) ‘)’ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[tags](#text-context)​​​​​≡[export](#text-export)[I](#text-context)​::=‘(’ ‘tag’ id?:[id](#text-id)? ‘(’ ‘export’ [name](#text-name) ‘)’ … ‘)’≡​

Note

The latter abbreviation can be applied repeatedly, if “…” contains additional export clauses. Consequently, a memory declaration can contain any number of exports, possibly followed by an import.

#### 6.6.4. Globals[](#globals⑨)

Global definitions can bind a symbolic [global identifier](#text-id).

​[global](#text-global)[I](#text-context)​​::=​‘(’ ‘global’ id?:[id](#text-id)? gt:[globaltype](#text-globaltype)[I](#text-context)​ e:[expr](#text-expr)[I](#text-context)​ ‘)’​⇒​([global](#syntax-global) gt e,{[globals](#text-context) (id?)})​​

##### 6.6.4.1. Abbreviations[](#abbreviations①④)

Globals can be defined as [imports](#text-import) or [exports](#text-export) inline:

​[import](#text-import)[I](#text-context)​​::=∣​…‘(’ ‘global’ [id](#text-id)? ‘(’ ‘import’ [name](#text-name)2 ‘)’ [globaltype](#text-globaltype)[I](#text-context)​ ‘)’‘(’ ‘import’ [name](#text-name)2 ‘(’ ‘global’ [id](#text-id)? [globaltype](#text-globaltype)[I](#text-context)​ ‘)’ ‘)’​0.8ex\]‘(’ ‘global’ id′:[id](#text-id) … ‘)’‘(’ ‘export’ [name](#text-name) ‘(’ ‘global’ [id](#text-id) ‘)’ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[globals](#text-context)​​​​​≡[export](#text-export)[I](#text-context)​::=‘(’ ‘global’ id?:[id](#text-id)? ‘(’ ‘export’ [name](#text-name) ‘)’ … ‘)’≡​

Note

The latter abbreviation can be applied repeatedly, if “…” contains additional export clauses. Consequently, a global declaration can contain any number of exports, possibly followed by an import.

#### 6.6.5. Memories[](#memories⑨)

Memory definitions can bind a symbolic [memory identifier](#text-id).

​[mem](#text-mem)[I](#text-context)​​::=​‘(’ ‘memory’ id?:[id](#text-id)? mt:[memtype](#text-memtype)[I](#text-context)​ ‘)’​⇒​([memory](#syntax-mem) mt,{[mems](#text-context) (id?)})​​

##### 6.6.5.1. Abbreviations[](#abbreviations①⑤)

A [data segment](#text-data) can be given inline with a memory definition, in which case its offset is 0 and the [limits](#text-limits) of the [memory type](#text-memtype) are inferred from the length of the data, rounded up to [page size](#page-size):

​[mem](#text-mem)[I](#text-context)​​::=​‘(’ ‘memory’ id?:[id](#text-id)? at?:[addrtype](#text-addrtype)? ‘(’ ‘data’ b∗:[datastring](#text-datastring) ‘)’ ‘)’‘(’ ‘memory’ id′:[id](#text-id) at?:[addrtype](#text-addrtype)? n:[u64](#text-int) n:[u64](#text-int) ‘)’‘(’ ‘data’ ‘(’ ‘memory’ id′:[id](#text-id) ‘)’ ‘(’ at′:[addrtype](#text-addrtype) ‘.const’ ‘0’ ‘)’ [datastring](#text-datastring) ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[mems](#text-context)∧ at?\=at′∨at?\=ϵ∧at′\=[i32](#syntax-numtype)∧ n\=ceil(∣b∗∣/64⋅Ki)​​​​≡​

Memories can be defined as [imports](#text-import) or [exports](#text-export) inline:

​[import](#text-import)[I](#text-context)​​::=∣​…‘(’ ‘memory’ [id](#text-id)? ‘(’ ‘import’ [name](#text-name)2 ‘)’ [memtype](#text-memtype)[I](#text-context)​ ‘)’‘(’ ‘import’ [name](#text-name)2 ‘(’ ‘memory’ [id](#text-id)? [memtype](#text-memtype)[I](#text-context)​ ‘)’ ‘)’​0.8ex\]‘(’ ‘memory’ id′:[id](#text-id) … ‘)’‘(’ ‘export’ [name](#text-name) ‘(’ ‘memory’ [id](#text-id) ‘)’ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[mems](#text-context)​​​​​≡[export](#text-export)[I](#text-context)​::=‘(’ ‘memory’ id?:[id](#text-id)? ‘(’ ‘export’ [name](#text-name) ‘)’ … ‘)’≡​

Note

The latter abbreviation can be applied repeatedly, if “…” contains additional export clauses. Consequently, a memory declaration can contain any number of exports, possibly followed by an import.

#### 6.6.6. Tables[](#tables⑨)

Table definitions can bind a symbolic [table identifier](#text-id).

​[table](#text-table)[I](#text-context)​​::=​‘(’ ‘table’ id?:[id](#text-id)? tt:[tabletype](#text-tabletype)[I](#text-context)​ e:[expr](#text-expr)[I](#text-context)​ ‘)’​⇒​([table](#syntax-table) tt e,{[tables](#text-context) (id?)})​​

##### 6.6.6.1. Abbreviations[](#abbreviations①⑥)

A table’s initialization [expression](#text-expr) can be omitted, in which case it defaults to ref.null:

​[table](#text-table)[I](#text-context)​​::=∣​…‘(’ ‘table’ [id](#text-id)? tt:[tabletype](#text-tabletype)[I](#text-context)​ ‘)’‘(’ ‘table’ [id](#text-id)? tt:[tabletype](#text-tabletype)[I](#text-context)​ ‘(’ ‘ref.null’ ht:[heaptype](#text-heaptype)[I](#text-context)​ ‘)’ ‘)’if tt\=at lim ([ref](#syntax-reftype) [null](#syntax-reftype)? ht)​​​≡​

An [element segment](#text-elem) can be given inline with a table definition, in which case its offset is 0 and the [limits](#text-limits) of the [table type](#text-tabletype) are inferred from the length of the given segment:

​[table](#text-table)[I](#text-context)​​::=​‘(’ ‘table’ id?:[id](#text-id)? at?:[addrtype](#text-addrtype)? [reftype](#text-reftype)[I](#text-context)​ ‘(’ ‘elem’ (rt,e∗):[elemlist](#text-elemlist)[I](#text-context)​ ‘)’ ‘)’‘(’ ‘table’ id′:[id](#text-id) at?:[addrtype](#text-addrtype)? n:[u64](#text-int) n:[u64](#text-int) [reftype](#text-reftype)[I](#text-context)​ ‘)’‘(’ ‘elem’ ‘(’ ‘table’ id′:[id](#text-id) ‘)’ ‘(’ at′:[addrtype](#text-addrtype) ‘.const’ ‘0’ ‘)’ [elemlist](#text-elemlist)[I](#text-context)​ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[tables](#text-context)∧ at?\=at′∨at?\=ϵ∧at′\=[i32](#syntax-numtype)∧ n\=∣e∗∣​​​​≡​

Tables can be defined as [imports](#text-import) or [exports](#text-export) inline:

​[import](#text-import)[I](#text-context)​​::=∣​…‘(’ ‘table’ [id](#text-id)? ‘(’ ‘import’ [name](#text-name)2 ‘)’ [tabletype](#text-tabletype)[I](#text-context)​ ‘)’‘(’ ‘import’ [name](#text-name)2 ‘(’ ‘table’ [id](#text-id)? [tabletype](#text-tabletype)[I](#text-context)​ ‘)’ ‘)’​0.8ex\]‘(’ ‘table’ id′:[id](#text-id) … ‘)’‘(’ ‘export’ [name](#text-name) ‘(’ ‘table’ [id](#text-id) ‘)’ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[tables](#text-context)​​​​​≡[export](#text-export)[I](#text-context)​::=‘(’ ‘table’ id?:[id](#text-id)? ‘(’ ‘export’ [name](#text-name) ‘)’ … ‘)’≡​

Note

The latter abbreviation can be applied repeatedly, if “…” contains additional export clauses. Consequently, a table declaration can contain any number of exports, possibly followed by an import.

#### 6.6.7. Functions[](#functions⑨)

Function definitions can bind a symbolic [function identifier](#text-id), and [local identifiers](#text-id) for its [parameters](#text-typeuse) and locals.

​[func](#text-func)[I](#text-context)​​::=​‘(’ ‘func’ id?:[id](#text-id)? (x,[I](#text-context)1​):[typeuse](#text-typeuse)[I](#text-context)​ ((loc∗,[I](#text-context)2​):[local](#text-local)[I](#text-context)​)∗ e:[expr](#text-expr)[I](#text-context)′​ ‘)’([func](#syntax-func) x ([⨁](#notation-concat)loc∗∗) e,{[funcs](#text-context) (id?)})if [I](#text-context)′\=[I](#text-context)⊕[I](#text-context)1​⊕[⨁](#notation-concat)[I](#text-context)2∗​∧ ⊢[I](#text-context)′:ok​​​​⇒​

​[local](#text-local)[I](#text-context)​​::=​‘(’ ‘local’ id?:[id](#text-id)? t:[valtype](#text-valtype)[I](#text-context)​ ‘)’([local](#syntax-local) t,{[locals](#text-context) (id?)})​​⇒​

Note

The [well-formedness](#text-context-wf) condition on [I](#text-context)′ ensures that parameters and locals do not contain duplicate identifiers.

##### 6.6.7.1. Abbreviations[](#abbreviations①⑦)

Multiple anonymous locals may be combined into a single declaration:

​[local](#text-local)[I](#text-context)​​::=​… ∣ ‘(’ ‘local’ t:[valtype](#text-valtype)[I](#text-context)∗​ ‘)’​≡​(‘(’ ‘local’ t:[valtype](#text-valtype)[I](#text-context)​ ‘)’)∗​​

Functions can be defined as [imports](#text-import) or [exports](#text-export) inline:

​[import](#text-import)[I](#text-context)​​::=∣​…‘(’ ‘func’ [id](#text-id)? ‘(’ ‘import’ [name](#text-name)2 ‘)’ [typeuse](#text-typeuse)[I](#text-context)​ ‘)’‘(’ ‘import’ [name](#text-name)2 ‘(’ ‘func’ [id](#text-id)? [typeuse](#text-typeuse)[I](#text-context)​ ‘)’ ‘)’​0.8ex\]‘(’ ‘func’ id′:[id](#text-id) … ‘)’‘(’ ‘export’ [name](#text-name) ‘(’ ‘func’ [id](#text-id) ‘)’ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[funcs](#text-context)​​​​​≡[export](#text-export)[I](#text-context)​::=‘(’ ‘func’ id?:[id](#text-id)? ‘(’ ‘export’ [name](#text-name) ‘)’ … ‘)’≡​

Note

The latter abbreviation can be applied repeatedly, if “…” contains additional export clauses. Consequently, a function declaration can contain any number of exports, possibly followed by an import.

#### 6.6.8. Data Segments[](#data-segments⑦)

Data segments allow for an optional [memory index](#text-memidx) to identify the memory to initialize. The data is written as a [string](#text-string), which may be split up into a possibly empty sequence of individual string literals.

​[data](#text-data)[I](#text-context)​[offset](#text-memarg)[I](#text-context)​​::=∣::=​‘(’ ‘data’ id?:[id](#text-id)? b∗:[datastring](#text-datastring) ‘)’([data](#syntax-data) b∗ [passive](#syntax-datamode),{[datas](#text-context) (id?)})​‘(’ ‘data’ id?:[id](#text-id)? x:[memuse](#text-memuse)[I](#text-context)​ e:[offset](#text-memarg)[I](#text-context)​ b∗:[datastring](#text-datastring) ‘)’([data](#syntax-data) b∗ ([active](#syntax-datamode) x e),{[datas](#text-context) (id?)})​0.8ex\]‘(’ ‘offset’ e:[expr](#text-expr)[I](#text-context)​ ‘)’​⇒⇒[datastring](#text-datastring)⇒​::=e​b∗∗:[string](#text-string)∗​⇒​[⨁](#notation-concat)b∗∗0.8ex\]​[memuse](#text-memuse)[I](#text-context)​​::=​‘(’ ‘memory’ x:[memidx](#text-memidx)[I](#text-context)​ ‘)’​⇒​x​​

Note

In the current version of WebAssembly, the only valid memory index is 0 or a symbolic [memory identifier](#text-id) resolving to the same value.

##### 6.6.8.1. Abbreviations[](#abbreviations①⑧)

As an abbreviation, a single [folded instruction](#text-foldedinstr) may occur in place of the offset of an active segment:

​[offset](#text-memarg)[I](#text-context)​​::=​… ∣ [foldedinstr](#text-foldedinstr)[I](#text-context)​​≡​‘(’ ‘offset’ [foldedinstr](#text-foldedinstr)[I](#text-context)​ ‘)’​​

Also, a memory use can be omitted, defaulting to 0.

​[memuse](#text-memuse)[I](#text-context)​​::=​… ∣ ϵ​≡​‘(’ ‘memory’ ‘0’ ‘)’​​

As another abbreviation, data segments may also be specified inline with [memory](#text-mem) definitions; see the respective section.

#### 6.6.9. Element Segments[](#element-segments⑦)

Element segments allow for an optional [table index](#text-tableidx) to identify the table to initialize.

​[elem](#text-elem)[I](#text-context)​[elemexpr](#text-elemexpr)[I](#text-context)​​::=∣∣::=​‘(’ ‘elem’ id?:[id](#text-id)? (rt,e∗):[elemlist](#text-elemlist)[I](#text-context)​ ‘)’([elem](#syntax-elem) rt e∗ [passive](#syntax-elemmode),{[elems](#text-context) (id?)})​‘(’ ‘elem’ id?:[id](#text-id)? x:[tableuse](#text-tableuse)[I](#text-context)​ e′:[offset](#text-memarg)[I](#text-context)​ (rt,e∗):[elemlist](#text-elemlist)[I](#text-context)​ ‘)’([elem](#syntax-elem) rt e∗ ([active](#syntax-elemmode) x e′),{[elems](#text-context) (id?)})​‘(’ ‘elem’ id?:[id](#text-id)? ‘declare’ (rt,e∗):[elemlist](#text-elemlist)[I](#text-context)​ ‘)’([elem](#syntax-elem) rt e∗ [declare](#syntax-elemmode),{[elems](#text-context) (id?)})​0.8ex\]‘(’ ‘item’ e:[expr](#text-expr)[I](#text-context)​ ‘)’​⇒⇒⇒[elemlist](#text-elemlist)[I](#text-context)​⇒​::=e0.8ex\]​rt:[reftype](#text-reftype)[I](#text-context)​ e∗:[list](#text-list)([expr](#text-expr)[I](#text-context)​)[tableuse](#text-tableuse)[I](#text-context)​​⇒::=​(rt,e∗)‘(’ ‘table’ x:[tableidx](#text-tableidx)[I](#text-context)​ ‘)’​⇒​x​​

##### 6.6.9.1. Abbreviations[](#abbreviations①⑨)

As an abbreviation, a single [folded instruction](#text-foldedinstr) may occur in place of the offset of an active element segment or as an element expression:

​[elemexpr](#text-elemexpr)[I](#text-context)​​::=​… ∣ [foldedinstr](#text-foldedinstr)[I](#text-context)​​≡​‘(’ ‘item’ [foldedinstr](#text-foldedinstr)[I](#text-context)​ ‘)’​​

Also, the element list may be written as just a sequence of [function indices](#text-funcidx):

​[elemlist](#text-elemlist)[I](#text-context)​​::=​… ∣ ‘func’ x∗:[funcidx](#text-funcidx)[I](#text-context)∗​​≡​‘(’ ‘ref’ ‘func’ ‘)’ (‘(’ ‘ref.func’ [funcidx](#text-funcidx)[I](#text-context)​ ‘)’)∗​​

A table use can be omitted, defaulting to 0.

​[tableuse](#text-tableuse)[I](#text-context)​​::=​… ∣ ϵ​≡​‘(’ ‘table’ ‘0’ ‘)’​​

Furthermore, for backwards compatibility with earlier versions of WebAssembly, if the table use is omitted, the ‘func’ keyword can be omitted as well.

​[elem](#text-elem)[I](#text-context)​​::=∣​…‘(’ ‘elem’ e′:[offset](#text-memarg)[I](#text-context)​ [list](#text-list)([funcidx](#text-funcidx)[I](#text-context)​) ‘)’‘(’ ‘elem’ e′:[offset](#text-memarg)[I](#text-context)​ ‘func’ [list](#text-list)([funcidx](#text-funcidx)[I](#text-context)​) ‘)’​​≡​​​​

As yet another abbreviation, element segments may also be specified inline with [table](#text-table) definitions; see the respective section.

#### 6.6.10. Start Function[](#start-function⑤)

A [start function](#syntax-start) is defined in terms of its index.

​[start](#text-start)[I](#text-context)​​::=​‘(’ ‘start’ x:[funcidx](#text-funcidx)[I](#text-context)​ ‘)’​⇒​([start](#syntax-start) x,{})​​

Note

At most one start function may occur in a module, which is ensured by a suitable side condition on the [module](#text-module) grammar.

#### 6.6.11. Imports[](#imports⑤)

The [external type](#syntax-externtype) in imports can bind a symbolic tag, global, memory, or function [identifier](#text-id).

​[import](#text-import)[I](#text-context)​​::=​‘(’ ‘import’ nm1​:[name](#text-name) nm2​:[name](#text-name) (xt,[I](#text-context)′):[externtype](#text-externtype)[I](#text-context)​ ‘)’​⇒​([import](#syntax-import) nm1​ nm2​ xt,[I](#text-context)′)​​

##### 6.6.11.1. Abbreviations[](#abbreviations②⓪)

As an abbreviation, imports may also be specified inline with [tag](#text-tag), [global](#text-global), [memory](#text-mem), [table](#text-table), or [function](#text-func) definitions; see the respective sections.

#### 6.6.12. Exports[](#exports⑤)

The syntax for exports mirrors their [abstract syntax](#syntax-export) directly.

​[export](#text-export)[I](#text-context)​​::=∣∣∣∣​‘(’ ‘export’ nm:[name](#text-name) xx:[externidx](#text-externidx)[I](#text-context)​ ‘)’‘(’ ‘global’ x:[globalidx](#text-globalidx)[I](#text-context)​ ‘)’‘(’ ‘memory’ x:[memidx](#text-memidx)[I](#text-context)​ ‘)’‘(’ ‘table’ x:[tableidx](#text-tableidx)[I](#text-context)​ ‘)’‘(’ ‘func’ x:[funcidx](#text-funcidx)[I](#text-context)​ ‘)’​⇒⇒⇒⇒⇒​([export](#syntax-export) nm xx,{})0.8ex\][global](#syntax-externidx) x[memory](#syntax-externidx) x[table](#syntax-externidx) x[func](#syntax-externidx) x​[externidx](#text-externidx)[I](#text-context)​::=‘(’ ‘tag’ x:[tagidx](#text-tagidx)[I](#text-context)​ ‘)’⇒[tag](#syntax-externidx) x​

##### 6.6.12.1. Abbreviations[](#abbreviations②①)

As an abbreviation, exports may also be specified inline with [tag](#text-tag), [global](#text-global), [memory](#text-mem), [table](#text-table), or [function](#text-func) definitions; see the respective sections.

#### 6.6.13. Modules[](#modules①③)

A module consists of a sequence of _declarations_ that can occur in any order.

​[decl](#syntax-decl)​::=​[type](#syntax-rectype) ∣ [import](#syntax-import) ∣ [tag](#syntax-tag) ∣ [global](#syntax-global) ∣ [mem](#syntax-mem) ∣ [table](#syntax-table) ∣ [func](#syntax-func) ∣ [data](#syntax-data) ∣ [elem](#syntax-elem) ∣ [start](#syntax-start) ∣ [export](#syntax-export)​​

All declarations and their respective bound [identifiers](#text-id) scope over the entire module, including the text preceding them. A module itself may optionally bind an [identifier](#text-id) that names the module. The name serves a documentary role only.

Note

Tools may include the module name in the [name section](#binary-namesec) of the [binary format](#binary).

​[decl](#text-decl)[I](#text-context)​​::=∣​[type](#text-type)[I](#text-context)​ ∣ [import](#text-import)[I](#text-context)​ ∣ [tag](#text-tag)[I](#text-context)​ ∣ [global](#text-global)[I](#text-context)​ ∣ [mem](#text-mem)[I](#text-context)​ ∣ [table](#text-table)[I](#text-context)​[func](#text-func)[I](#text-context)​ ∣ [data](#text-data)[I](#text-context)​ ∣ [elem](#text-elem)[I](#text-context)​ ∣ [start](#text-start)[I](#text-context)​ ∣ [export](#text-export)[I](#text-context)​​​

​[module](#text-module)​::=​‘(’ ‘module’ [id](#text-id)? ([decl](#syntax-decl),[I](#text-context))∗:[decl](#text-decl)[I](#text-context)′∗​ ‘)’[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗if [I](#text-context)′\=[⨁](#notation-concat)[I](#text-context)∗∧ ⊢[I](#text-context)′:ok∧ [type](#syntax-rectype)∗\=[types](#syntax-decl)([decl](#syntax-decl)∗)∧ [import](#syntax-import)∗\=[imports](#syntax-decl)([decl](#syntax-decl)∗)∧ [tag](#syntax-tag)∗\=[tags](#syntax-decl)([decl](#syntax-decl)∗)∧ [global](#syntax-global)∗\=[globals](#syntax-decl)([decl](#syntax-decl)∗)∧ [mem](#syntax-mem)∗\=[mems](#syntax-decl)([decl](#syntax-decl)∗)∧ [table](#syntax-table)∗\=[tables](#syntax-decl)([decl](#syntax-decl)∗)∧ [func](#syntax-func)∗\=[funcs](#syntax-decl)([decl](#syntax-decl)∗)∧ [data](#syntax-data)∗\=[datas](#syntax-decl)([decl](#syntax-decl)∗)∧ [elem](#syntax-elem)∗\=[elems](#syntax-decl)([decl](#syntax-decl)∗)∧ [start](#syntax-start)?\=[starts](#syntax-decl)([decl](#syntax-decl)∗)∧ [export](#syntax-export)∗\=[exports](#syntax-decl)([decl](#syntax-decl)∗)∧ [ordered](#aux-ordered)([decl](#syntax-decl)∗)​​​​⇒​

where types([decl](#syntax-decl)∗), imports([decl](#syntax-decl)∗), tags([decl](#syntax-decl)∗), etc., extract the sequence of [types](#syntax-type), [imports](#syntax-import), [tags](#syntax-tag), etc., contained in [decl](#syntax-decl)∗, respectively. The auxiliary predicate [ordered](#aux-ordered) checks that no imports occur after the first definition of a [tag](#syntax-tag), [global](#syntax-global), [memory](#syntax-mem), [table](#syntax-table), or [function](#syntax-func) in a sequence of declarations:

[ordered](#aux-ordered)([decl](#syntax-decl)′∗)[ordered](#aux-ordered)([decl](#syntax-decl)1∗​ [import](#syntax-import) [decl](#syntax-decl)2∗​)[imports](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ∧[tags](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ∧[globals](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ∧[mems](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ∧[tables](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ∧[funcs](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ​​\=\=​true​if [imports](#syntax-decl)([decl](#syntax-decl)′∗)\=ϵ​​

##### 6.6.13.1. Abbreviations[](#abbreviations②②)

In a source file, the toplevel ‘(’ ‘module’ decldots ‘)’ surrounding the module body may be omitted.

​[module](#text-module)​::=​… ∣ [decl](#text-decl)[I](#text-context)∗​​≡​‘(’ ‘module’ [decl](#text-decl)[I](#text-context)∗​ ‘)’​​

A Appendix[](#a-appendix)
-------------------------

### A.1 Embedding[](#a1-embedding)

A WebAssembly implementation will typically be _embedded_ into a _host_ environment. An _embedder_ implements the connection between such a host environment and the WebAssembly semantics as defined in the main body of this specification. An embedder is expected to interact with the semantics in well-defined ways.

This section defines a suitable interface to the WebAssembly semantics in the form of entry points through which an embedder can access it. The interface is intended to be complete, in the sense that an embedder does not need to reference other functional parts of the WebAssembly specification directly.

Note

On the other hand, an embedder does not need to provide the host environment with access to all functionality defined in this interface. For example, an implementation may not support [parsing](#embed-module-parse) of the [text format](#text).

#### Types[](#types①⑨)

In the description of the embedder interface, syntactic classes from the [abstract syntax](#syntax) and the [runtime’s abstract machine](#syntax-runtime) are used as names for variables that range over the possible objects from that class. Hence, these syntactic classes can also be interpreted as types.

For numeric parameters, notation like i:[u64](#syntax-int) is used to specify a symbolic name in addition to the respective value range.

#### Booleans[](#booleans①)

Interface operation that are predicates return Boolean values:

​[bool](#embed-bool)​::=​[false](#embed-bool) ∣ [true](#embed-bool)​​

#### Exceptions and Errors[](#exceptions-and-errors①)

Invoking an exported function may throw or propagate exceptions, expressed by an auxiliary syntactic class:

​[exception](#embed-error)​::=​[exception](#embed-error) [exnaddr](#syntax-exnaddr)​​

The exception address exnaddr identifies the exception thrown.

Failure of an interface operation is also indicated by an auxiliary syntactic class:

​[error](#embed-error)​::=​[error](#embed-error)​​

In addition to the error conditions specified explicitly in this section, such as invalid arguments or [exceptions](#exception) and [traps](#trap) resulting from [execution](#exec), implementations may also return errors when specific [implementation limitations](#impl) are reached.

Note

Errors are abstract and unspecific with this definition. Implementations can refine it to carry suitable classifications and diagnostic messages.

#### Pre- and Post-Conditions[](#pre--and-post-conditions)

Some operations state _pre-conditions_ about their arguments or _post-conditions_ about their results. It is the embedder’s responsibility to meet the pre-conditions. If it does, the post conditions are guaranteed by the semantics.

In addition to pre- and post-conditions explicitly stated with each operation, the specification adopts the following conventions for [runtime objects](#syntax-runtime) ([store](#syntax-store), [moduleinst](#syntax-moduleinst), [addresses](#syntax-addr)):

*   Every runtime object passed as a parameter must be [valid](#valid-store) per an implicit pre-condition.
    
*   Every runtime object returned as a result is [valid](#valid-store) per an implicit post-condition.
    

Note

As long as an embedder treats runtime objects as abstract and only creates and manipulates them through the interface defined here, all implicit pre-conditions are automatically met.

#### Store[](#store③)

##### store\_init():[store](#syntax-store)[](#-mathrmstore_init--hrefsyntax-storemathitstore)

1.  Return the empty [store](#syntax-store).
    

store\_init()​\=​{}​​

#### Modules[](#modules①⑤)

##### module\_decode([byte](#syntax-byte)∗):[module](#syntax-module) ∣ [error](#embed-error)[](#-mathrmmodule_decode-hrefsyntax-bytemathitbyteast--hrefsyntax-modulemathitmodule--hrefembed-errormathiterror)

1.  If there exists a derivation for the [byte](#syntax-byte) sequence [byte](#syntax-byte)∗ as a [module](#binary-module) according to the [binary grammar for modules](#binary-module), yielding a [module](#syntax-module) m, then return m.
    
2.  Else, return [error](#embed-error).
    

module\_decode(b∗)module\_decode(b∗)​\=\=​m[error](#embed-error)​​(if[module](#binary-module)⟹∗​m:b∗)(otherwise)​​

##### module\_parse([char](#syntax-name)∗):[module](#syntax-module) ∣ [error](#embed-error)[](#-mathrmmodule_parse-hrefsyntax-namemathitcharast--hrefsyntax-modulemathitmodule--hrefembed-errormathiterror)

1.  If there exists a derivation for the [source](#text-source) [char](#syntax-name)∗ as a [module](#text-module) according to the [text grammar for modules](#text-module), yielding a [module](#syntax-module) m, then return m.
    
2.  Else, return [error](#embed-error).
    

module\_parse(c∗)module\_parse(c∗)​\=\=​m[error](#embed-error)​​(if[module](#text-module)⟹∗​m:c∗)(otherwise)​​

##### module\_validate([module](#syntax-module)):[error](#embed-error)?[](#-mathrmmodule_validate-hrefsyntax-modulemathitmodule--hrefembed-errormathiterror)

1.  If [module](#syntax-module) is [valid](#valid-module), then return nothing.
    
2.  Else, return [error](#embed-error).
    

module\_validate(m)module\_validate(m)​\=\=​ϵ[error](#embed-error)​​(if[⊢](#valid-module)m:[externtype](#syntax-externtype)∗→[externtype](#syntax-externtype)′∗)(otherwise)​​

##### module\_instantiate([store](#syntax-store),[module](#syntax-module),[externaddr](#syntax-externaddr)∗):([store](#syntax-store),[moduleinst](#syntax-moduleinst) ∣ [exception](#embed-error) ∣ [error](#embed-error))[](#-mathrmmodule_instantiate-hrefsyntax-storemathitstore-hrefsyntax-modulemathitmodule-hrefsyntax-externaddrmathitexternaddrast--hrefsyntax-storemathitstore-hrefsyntax-moduleinstmathitmoduleinst--hrefembed-errormathitexception--hrefembed-errormathiterror)

1.  Try [instantiating](#exec-instantiation) [module](#syntax-module) in [store](#syntax-store) with [external addresses](#syntax-externaddr) [externaddr](#syntax-externaddr)∗ as imports:
    

> 1.  If it succeeds with a [module instance](#syntax-moduleinst) [moduleinst](#syntax-moduleinst), then let result be [moduleinst](#syntax-moduleinst).
>     
> 2.  Else, let result be [error](#embed-error).
>     

2.  Return the new store paired with result.
    

module\_instantiate(S,m,ev∗)module\_instantiate(S,m,ev∗)​\=\=​(S′,F.[module](#syntax-frame))(S′,[error](#embed-error))​​(if[instantiate](#exec-instantiation)(S,m,ev∗)[↪](#exec-notation)∗S′;F;ϵ)(otherwise,if[instantiate](#exec-instantiation)(S,m,ev∗)[↪](#exec-notation)∗S′;F;[result](#syntax-result))​​

Note

The store may be modified even in case of an error.

##### module\_imports([module](#syntax-module)):([name](#syntax-name),[name](#syntax-name),[externtype](#syntax-externtype))∗[](#-mathrmmodule_imports-hrefsyntax-modulemathitmodule--hrefsyntax-namemathitname-hrefsyntax-namemathitname-hrefsyntax-externtypemathitexterntypeast)

1.  Pre-condition: [module](#syntax-module) is [valid](#valid-module) with the external import types [externtype](#syntax-externtype)∗ and external export types [externtype](#syntax-externtype)′∗.
    
2.  Let [import](#syntax-import)∗ be the [imports](#syntax-import) of [module](#syntax-module).
    
3.  Assert: the length of [import](#syntax-import)∗ equals the length of [externtype](#syntax-externtype)∗.
    
4.  For each [import](#syntax-import)i​ in [import](#syntax-import)∗ and corresponding [externtype](#syntax-externtype)i​ in [externtype](#syntax-externtype)∗, do:
    

> 1.  Let [import](#syntax-import) nmi1​ nmi2​ xti​ be the deconstruction of [import](#syntax-import)i​.
>     
> 2.  Let resulti​ be the triple (nmi1​,nmi2​,[externtype](#syntax-externtype)i​).
>     

5.  Return the concatenation of all resulti​, in index order.
    
6.  Post-condition: each [externtype](#syntax-externtype)i​ is [valid](#valid-externtype) under the empty [context](#context).
    

module\_imports(m)​\=​(nm1​,nm2​,[externtype](#syntax-externtype))∗(if([import](#syntax-import) nm1​ nm2​ xt∗)∗∈m∧[⊢](#valid-module)m:[externtype](#syntax-externtype)∗→[externtype](#syntax-externtype)′∗)​​

##### module\_exports([module](#syntax-module)):([name](#syntax-name),[externtype](#syntax-externtype))∗[](#-mathrmmodule_exports-hrefsyntax-modulemathitmodule--hrefsyntax-namemathitname-hrefsyntax-externtypemathitexterntypeast)

1.  Pre-condition: [module](#syntax-module) is [valid](#valid-module) with the external import types [externtype](#syntax-externtype)∗ and external export types [externtype](#syntax-externtype)′∗.
    
2.  Let [export](#syntax-export)∗ be the [exports](#syntax-export) of [module](#syntax-module).
    
3.  Assert: the length of [export](#syntax-export)∗ equals the length of [externtype](#syntax-externtype)′∗.
    
4.  For each [export](#syntax-export)i​ in [export](#syntax-export)∗ and corresponding [externtype](#syntax-externtype)i′​ in [externtype](#syntax-externtype)′∗, do:
    

> 1.  Let [export](#syntax-export) nmi​ [externidx](#syntax-externidx)i​ be the deconstruction of [export](#syntax-export)i​.
>     
> 2.  Let resulti​ be the pair (nmi​,[externtype](#syntax-externtype)i′​).
>     

5.  Return the concatenation of all resulti​, in index order.
    
6.  Post-condition: each [externtype](#syntax-externtype)i′​ is [valid](#valid-externtype) under the empty [context](#context).
    

module\_exports(m)mathitnm,[externtype](#syntax-externtype)′)∗​\=​((if([export](#syntax-export) nm xt∗)∗∈m∧[⊢](#valid-module)m:[externtype](#syntax-externtype)∗→[externtype](#syntax-externtype)′∗)​​

#### Module Instances[](#module-instances③)

##### instance\_export([moduleinst](#syntax-moduleinst),[name](#syntax-name)):[externaddr](#syntax-externaddr) ∣ [error](#embed-error)[](#-mathrminstance_export-hrefsyntax-moduleinstmathitmoduleinst-hrefsyntax-namemathitname--hrefsyntax-externaddrmathitexternaddr--hrefembed-errormathiterror)

1.  Assert: due to [validity](#valid-moduleinst) of the [module instance](#syntax-moduleinst) [moduleinst](#syntax-moduleinst), all its [export names](#syntax-exportinst) are different.
    
2.  If there exists an [exportinst](#syntax-exportinst)i​ in [moduleinst](#syntax-moduleinst).[exports](#syntax-moduleinst) such that [name](#syntax-name) [exportinst](#syntax-exportinst)i​.[name](#syntax-exportinst) equals [name](#syntax-name), then:
    
    1.  Return the [external address](#syntax-externaddr) [exportinst](#syntax-exportinst)i​.[addr](#syntax-exportinst).
        
3.  Else, return [error](#embed-error).
    

instance\_export(m,[name](#syntax-name))instance\_export(m,[name](#syntax-name))​\=\=​m.[exports](#syntax-moduleinst)\[i\].[addr](#syntax-exportinst)[error](#embed-error)​​(ifm.[exports](#syntax-moduleinst)\[i\].[name](#syntax-exportinst)\=[name](#syntax-name))(otherwise)​​

#### Functions[](#functions①①)

##### func\_alloc([store](#syntax-store),[deftype](#syntax-deftype),[hostfunc](#syntax-hostfunc)):([store](#syntax-store),[funcaddr](#syntax-funcaddr))[](#-mathrmfunc_alloc-hrefsyntax-storemathitstore-hrefsyntax-deftypemathitdeftype-hrefsyntax-hostfuncmathithostfunc--hrefsyntax-storemathitstore-hrefsyntax-funcaddrmathitfuncaddr)

1.  Pre-condition: the [defined type](#syntax-deftype) [deftype](#syntax-deftype) is [valid](#valid-deftype) under the empty [context](#context) and [expands](#aux-expand-deftype) to a [function type](#syntax-functype).
    
2.  Let [funcaddr](#syntax-funcaddr) be the result of [allocating a host function](#alloc-func) in [store](#syntax-store) with [defined type](#syntax-deftype) [deftype](#syntax-deftype), host function code [hostfunc](#syntax-hostfunc) and an empty [module instance](#syntax-moduleinst).
    
3.  Return the new store paired with [funcaddr](#syntax-funcaddr).
    

func\_alloc(S,dt,code)​\=​(S′,a)​​(if[allocfunc](#alloc-func)(S,dt,code,{})\=S′,a)​​​

Note

This operation assumes that [hostfunc](#syntax-hostfunc) satisfies the [pre- and post-conditions](#exec-invoke-host) required for a function instance with type [deftype](#syntax-deftype).

Regular (non-host) function instances can only be created indirectly through [module instantiation](#embed-module-instantiate).

##### func\_type([store](#syntax-store),[funcaddr](#syntax-funcaddr)):[deftype](#syntax-deftype)[](#-mathrmfunc_type-hrefsyntax-storemathitstore-hrefsyntax-funcaddrmathitfuncaddr--hrefsyntax-deftypemathitdeftype)

1.  Let [deftype](#syntax-deftype) be the [definedn type](#syntax-deftype) S.[funcs](#syntax-store)\[a\].[type](#syntax-funcinst).
    
2.  Return [deftype](#syntax-deftype).
    
3.  Post-condition: the returned [defined type](#syntax-deftype) is [valid](#valid-deftype) and [expands](#aux-expand-deftype) to a [function type](#syntax-functype).
    

func\_type(S,a)​\=​S.[funcs](#syntax-store)\[a\].[type](#syntax-funcinst)​​

##### func\_invoke([store](#syntax-store),[funcaddr](#syntax-funcaddr),[val](#syntax-val)∗):([store](#syntax-store),[val](#syntax-val)∗ ∣ [exception](#embed-error) ∣ [error](#embed-error))[](#-mathrmfunc_invoke-hrefsyntax-storemathitstore-hrefsyntax-funcaddrmathitfuncaddr-hrefsyntax-valmathitvalast--hrefsyntax-storemathitstore-hrefsyntax-valmathitvalast--hrefembed-errormathitexception--hrefembed-errormathiterror)

1.  Try [invoking](#exec-invocation) the function [funcaddr](#syntax-funcaddr) in [store](#syntax-store) with [values](#syntax-val) [val](#syntax-val)∗ as arguments:
    

> 1.  If it succeeds with [values](#syntax-val) [val](#syntax-val)′∗ as results, then let result be [val](#syntax-val)′∗.
>     
> 2.  Else if the outcome is an exception with a thrown [exception](#exec-throw-ref) [ref.exn](#syntax-ref) [exnaddr](#syntax-exnaddr) as the result, then let result be [exception](#embed-error) [exnaddr](#syntax-exnaddr)
>     
> 3.  Else it has trapped, hence let result be [error](#embed-error).
>     

2.  Return the new store paired with result.
    

func\_invoke(S,a,v∗)func\_invoke(S,a,v∗)func\_invoke(S,a,v∗)​\=\=\=​(S′,v′∗)(S′,[exception](#embed-error) a′)(S′,[error](#embed-error))​​(if[invoke](#exec-invocation)(S,a,v∗)[↪](#exec-notation)∗S′;F;v′∗)(if[invoke](#exec-invocation)(S,a,v∗)[↪](#exec-notation)∗S′;F;([ref.exn](#syntax-ref) a′) [throw\_ref](#syntax-instr-control)(if[invoke](#exec-invocation)(S,a,v∗)[↪](#exec-notation)∗S′;F;[trap](#syntax-trap))​​

Note

The store may be modified even in case of an error.

#### Tables[](#tables①①)

##### table\_alloc([store](#syntax-store),[tabletype](#syntax-tabletype),[ref](#syntax-ref)):([store](#syntax-store),[tableaddr](#syntax-tableaddr))[](#-mathrmtable_alloc-hrefsyntax-storemathitstore-hrefsyntax-tabletypemathittabletype-hrefsyntax-refmathitref--hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr)

1.  Pre-condition: the [tabletype](#syntax-tabletype) is [valid](#valid-tabletype) under the empty [context](#context).
    
2.  Let [tableaddr](#syntax-tableaddr) be the result of [allocating a table](#alloc-table) in [store](#syntax-store) with [table type](#syntax-tabletype) [tabletype](#syntax-tabletype) and initialization value [ref](#syntax-ref).
    
3.  Return the new store paired with [tableaddr](#syntax-tableaddr).
    

table\_alloc(S,tt,r)​\=​(S′,a)​​(if[alloctable](#alloc-table)(S,tt,r)\=S′,a)​​

##### table\_type([store](#syntax-store),[tableaddr](#syntax-tableaddr)):[tabletype](#syntax-tabletype)[](#-mathrmtable_type-hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr--hrefsyntax-tabletypemathittabletype)

1.  Return S.[tables](#syntax-store)\[a\].[type](#syntax-tableinst).
    
2.  Post-condition: the returned [table type](#syntax-tabletype) is [valid](#valid-tabletype) under the empty [context](#context).
    

table\_type(S,a)​\=​S.[tables](#syntax-store)\[a\].[type](#syntax-tableinst)​​

##### table\_read([store](#syntax-store),[tableaddr](#syntax-tableaddr),i:[u64](#syntax-int)):[ref](#syntax-ref) ∣ [error](#embed-error)[](#-mathrmtable_read-hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr-ihrefsyntax-intmathituscriptstylekern-01em64--hrefsyntax-refmathitref--hrefembed-errormathiterror)

1.  Let ti be the [table instance](#syntax-tableinst) [store](#syntax-store).[tables](#syntax-store)\[[tableaddr](#syntax-tableaddr)\].
    
2.  If i is larger than or equal to the length of ti.[refs](#syntax-tableinst), then return [error](#embed-error).
    
3.  Else, return the [reference value](#syntax-ref) ti.[refs](#syntax-tableinst)\[i\].
    

table\_read(S,a,i)table\_read(S,a,i)​\=\=​r[error](#embed-error)​​(ifS.[tables](#syntax-store)\[a\].[refs](#syntax-tableinst)\[i\]\=r)(otherwise)​​

##### table\_write([store](#syntax-store),[tableaddr](#syntax-tableaddr),i:[u64](#syntax-int),[ref](#syntax-ref)):[store](#syntax-store) ∣ [error](#embed-error)[](#-mathrmtable_write-hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr-ihrefsyntax-intmathituscriptstylekern-01em64-hrefsyntax-refmathitref--hrefsyntax-storemathitstore--hrefembed-errormathiterror)

1.  Let ti be the [table instance](#syntax-tableinst) [store](#syntax-store).[tables](#syntax-store)\[[tableaddr](#syntax-tableaddr)\].
    
2.  If i is larger than or equal to the length of ti.[refs](#syntax-tableinst), then return [error](#embed-error).
    
3.  Replace ti.[refs](#syntax-tableinst)\[i\] with the [reference value](#syntax-ref) [ref](#syntax-ref).
    
4.  Return the updated store.
    

table\_write(S,a,i,r)table\_write(S,a,i,r)​\=\=​S′[error](#embed-error)​​(ifS′\=S[with](#notation-replace)[tables](#syntax-store)\[a\].[refs](#syntax-tableinst)\[i\]\=r)(otherwise)​​

##### table\_size([store](#syntax-store),[tableaddr](#syntax-tableaddr)):[u64](#syntax-int)[](#-mathrmtable_size-hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr--hrefsyntax-intmathituscriptstylekern-01em64)

1.  Return the length of [store](#syntax-store).[tables](#syntax-store)\[[tableaddr](#syntax-tableaddr)\].[refs](#syntax-tableinst).
    

table\_size(S,a)​\=​n​​(if∣S.[tables](#syntax-store)\[a\].[refs](#syntax-tableinst)∣\=n)​​

##### table\_grow([store](#syntax-store),[tableaddr](#syntax-tableaddr),n:[u64](#syntax-int),[ref](#syntax-ref)):[store](#syntax-store) ∣ [error](#embed-error)[](#-mathrmtable_grow-hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr-nhrefsyntax-intmathituscriptstylekern-01em64-hrefsyntax-refmathitref--hrefsyntax-storemathitstore--hrefembed-errormathiterror)

1.  Try [growing](#grow-table) the [table instance](#syntax-tableinst) [store](#syntax-store).[tables](#syntax-store)\[[tableaddr](#syntax-tableaddr)\] by n elements with initialization value [ref](#syntax-ref):
    
    1.  If it succeeds, return the updated store.
        
    2.  Else, return [error](#embed-error).
        

table\_grow(S,a,n,r)table\_grow(S,a,n,r)​\=\=​S′[error](#embed-error)​​(ifS′\=S[with](#notation-replace)[tables](#syntax-store)\[a\]\=[growtable](#grow-table)(S.[tables](#syntax-store)\[a\],n,r))(otherwise)​​

#### Memories[](#memories①①)

##### mem\_alloc([store](#syntax-store),[memtype](#syntax-memtype)):([store](#syntax-store),[memaddr](#syntax-memaddr))[](#-mathrmmem_alloc-hrefsyntax-storemathitstore-hrefsyntax-memtypemathitmemtype--hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr)

1.  Pre-condition: the [memtype](#syntax-memtype) is [valid](#valid-memtype) under the empty [context](#context).
    
2.  Let [memaddr](#syntax-memaddr) be the result of [allocating a memory](#alloc-mem) in [store](#syntax-store) with [memory type](#syntax-memtype) [memtype](#syntax-memtype).
    
3.  Return the new store paired with [memaddr](#syntax-memaddr).
    

mem\_alloc(S,mt)​\=​(S′,a)​​(if[allocmem](#alloc-mem)(S,mt)\=S′,a)​​

##### mem\_type([store](#syntax-store),[memaddr](#syntax-memaddr)):[memtype](#syntax-memtype)[](#-mathrmmem_type-hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr--hrefsyntax-memtypemathitmemtype)

1.  Return S.[mems](#syntax-store)\[a\].[type](#syntax-meminst).
    
2.  Post-condition: the returned [memory type](#syntax-memtype) is [valid](#valid-memtype) under the empty [context](#context).
    

mem\_type(S,a)​\=​S.[mems](#syntax-store)\[a\].[type](#syntax-meminst)​​

##### mem\_read([store](#syntax-store),[memaddr](#syntax-memaddr),i:[u64](#syntax-int)):[byte](#syntax-byte) ∣ [error](#embed-error)[](#-mathrmmem_read-hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr-ihrefsyntax-intmathituscriptstylekern-01em64--hrefsyntax-bytemathitbyte--hrefembed-errormathiterror)

1.  Let mi be the [memory instance](#syntax-meminst) [store](#syntax-store).[mems](#syntax-store)\[[memaddr](#syntax-memaddr)\].
    
2.  If i is larger than or equal to the length of mi.[bytes](#syntax-meminst), then return [error](#embed-error).
    
3.  Else, return the [byte](#syntax-byte) mi.[bytes](#syntax-meminst)\[i\].
    

mem\_read(S,a,i)mem\_read(S,a,i)​\=\=​b[error](#embed-error)​​(ifS.[mems](#syntax-store)\[a\].[bytes](#syntax-meminst)\[i\]\=b)(otherwise)​​

##### mem\_write([store](#syntax-store),[memaddr](#syntax-memaddr),i:[u64](#syntax-int),[byte](#syntax-byte)):[store](#syntax-store) ∣ [error](#embed-error)[](#-mathrmmem_write-hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr-ihrefsyntax-intmathituscriptstylekern-01em64-hrefsyntax-bytemathitbyte--hrefsyntax-storemathitstore--hrefembed-errormathiterror)

1.  Let mi be the [memory instance](#syntax-meminst) [store](#syntax-store).[mems](#syntax-store)\[[memaddr](#syntax-memaddr)\].
    
2.  If i is larger than or equal to the length of mi.[bytes](#syntax-meminst), then return [error](#embed-error).
    
3.  Replace mi.[bytes](#syntax-meminst)\[i\] with [byte](#syntax-byte).
    
4.  Return the updated store.
    

mem\_write(S,a,i,b)mem\_write(S,a,i,b)​\=\=​S′[error](#embed-error)​​(ifS′\=S[with](#notation-replace)[mems](#syntax-store)\[a\].[bytes](#syntax-meminst)\[i\]\=b)(otherwise)​​

##### mem\_size([store](#syntax-store),[memaddr](#syntax-memaddr)):[u64](#syntax-int)[](#-mathrmmem_size-hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr--hrefsyntax-intmathituscriptstylekern-01em64)

1.  Return the length of [store](#syntax-store).[mems](#syntax-store)\[[memaddr](#syntax-memaddr)\].[bytes](#syntax-meminst) divided by the [page size](#page-size).
    

mem\_size(S,a)​\=​n​​(if∣S.[mems](#syntax-store)\[a\].[bytes](#syntax-meminst)∣\=n⋅64Ki)​​

##### mem\_grow([store](#syntax-store),[memaddr](#syntax-memaddr),n:[u64](#syntax-int)):[store](#syntax-store) ∣ [error](#embed-error)[](#-mathrmmem_grow-hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr-nhrefsyntax-intmathituscriptstylekern-01em64--hrefsyntax-storemathitstore--hrefembed-errormathiterror)

1.  Try [growing](#grow-mem) the [memory instance](#syntax-meminst) [store](#syntax-store).[mems](#syntax-store)\[[memaddr](#syntax-memaddr)\] by n [pages](#page-size):
    
    1.  If it succeeds, return the updated store.
        
    2.  Else, return [error](#embed-error).
        

mem\_grow(S,a,n)mem\_grow(S,a,n)​\=\=​S′[error](#embed-error)​​(ifS′\=S[with](#notation-replace)[mems](#syntax-store)\[a\]\=[growmem](#grow-mem)(S.[mems](#syntax-store)\[a\],n))(otherwise)​​

#### Tags[](#tags①①)

##### tag\_alloc([store](#syntax-store),[tagtype](#syntax-tagtype)):([store](#syntax-store),[tagaddr](#syntax-tagaddr))[](#-mathrmtag_alloc-hrefsyntax-storemathitstore-hrefsyntax-tagtypemathittagtype--hrefsyntax-storemathitstore-hrefsyntax-tagaddrmathittagaddr)

1.  Pre-condition: tagtype is [valid](#valid-tagtype).
    
2.  Let [tagaddr](#syntax-tagaddr) be the result of [allocating a tag](#alloc-tag) in [store](#syntax-store) with [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype).
    
3.  Return the new store paired with [tagaddr](#syntax-tagaddr).
    

tag\_alloc(S,tt)​\=​(S′,a)​​(if[alloctag](#alloc-tag)(S,tt)\=S′,a)​​

##### tag\_type([store](#syntax-store),[tagaddr](#syntax-tagaddr)):[tagtype](#syntax-tagtype)[](#-mathrmtag_type-hrefsyntax-storemathitstore-hrefsyntax-tagaddrmathittagaddr--hrefsyntax-tagtypemathittagtype)

1.  Return S.[tags](#syntax-store)\[a\].[type](#syntax-taginst).
    
2.  Post-condition: the returned [tag type](#syntax-tagtype) is [valid](#valid-tagtype).
    

tag\_type(S,a)​\=​S.[tags](#syntax-store)\[a\].[type](#syntax-taginst)​​

#### Exceptions[](#exceptions①)

##### exn\_alloc([store](#syntax-store),[tagaddr](#syntax-tagaddr),[val](#syntax-val)∗):([store](#syntax-store),[exnaddr](#syntax-exnaddr))[](#-mathrmexn_alloc-hrefsyntax-storemathitstore-hrefsyntax-tagaddrmathittagaddr-hrefsyntax-valmathitvalast--hrefsyntax-storemathitstore-hrefsyntax-exnaddrmathitexnaddr)

1.  Pre-condition: [tagaddr](#syntax-tagaddr) is an allocated [tag address](#syntax-tagaddr).
    
2.  Let [exnaddr](#syntax-exnaddr) be the result of [allocating an exception instance](#syntax-exninst) in [store](#syntax-store) with [tag address](#syntax-tagaddr) [tagaddr](#syntax-tagaddr) and initialization values [val](#syntax-val)∗.
    
3.  Return the new store paired with [exnaddr](#syntax-exnaddr).
    

exn\_alloc(S,[tagaddr](#syntax-tagaddr),[val](#syntax-val)∗)​\=​(S[⊕](#notation-compose){[exns](#syntax-store) [exninst](#syntax-exninst)},∣S.[exns](#syntax-store)∣)​(if[exninst](#syntax-exninst)\={[tag](#syntax-exninst) [tagaddr](#syntax-tagaddr),[fields](#syntax-exninst) [val](#syntax-val)∗}​​

##### exn\_tag([store](#syntax-store),[exnaddr](#syntax-exnaddr)):[tagaddr](#syntax-tagaddr)[](#-mathrmexn_tag-hrefsyntax-storemathitstore-hrefsyntax-exnaddrmathitexnaddr--hrefsyntax-tagaddrmathittagaddr)

1.  Let [exninst](#syntax-exninst) be the [exception instance](#syntax-exninst) [store](#syntax-store).[exns](#syntax-store)\[[exnaddr](#syntax-exnaddr)\].
    
2.  Return the [tag address](#syntax-tagaddr) [exninst](#syntax-exninst).[tag](#syntax-exninst).
    

exn\_tag(S,a)​\=​[exninst](#syntax-exninst).[tag](#syntax-exninst)​(if[exninst](#syntax-exninst)\=S.[exns](#syntax-store)\[a\])​​

##### exn\_read([store](#syntax-store),[exnaddr](#syntax-exnaddr)):[val](#syntax-val)∗[](#-mathrmexn_read-hrefsyntax-storemathitstore-hrefsyntax-exnaddrmathitexnaddr--hrefsyntax-valmathitvalast)

1.  Let [exninst](#syntax-exninst) be the [exception instance](#syntax-exninst) [store](#syntax-store).[exns](#syntax-store)\[[exnaddr](#syntax-exnaddr)\].
    
2.  Return the [values](#syntax-val) [exninst](#syntax-exninst).[fields](#syntax-exninst).
    

exn\_read(S,a)​\=​[exninst](#syntax-exninst).[fields](#syntax-exninst)​(if[exninst](#syntax-exninst)\=S.[exns](#syntax-store)\[a\])​​

#### Globals[](#globals①①)

##### global\_alloc([store](#syntax-store),[globaltype](#syntax-globaltype),[val](#syntax-val)):([store](#syntax-store),[globaladdr](#syntax-globaladdr))[](#-mathrmglobal_alloc-hrefsyntax-storemathitstore-hrefsyntax-globaltypemathitglobaltype-hrefsyntax-valmathitval--hrefsyntax-storemathitstore-hrefsyntax-globaladdrmathitglobaladdr)

1.  Pre-condition: the [globaltype](#syntax-globaltype) is [valid](#valid-globaltype) under the empty [context](#context).
    
2.  Let [globaladdr](#syntax-globaladdr) be the result of [allocating a global](#alloc-global) in [store](#syntax-store) with [global type](#syntax-globaltype) [globaltype](#syntax-globaltype) and initialization value [val](#syntax-val).
    
3.  Return the new store paired with [globaladdr](#syntax-globaladdr).
    

global\_alloc(S,gt,v)​\=​(S′,a)​​(if[allocglobal](#alloc-global)(S,gt,v)\=S′,a)​​

##### global\_type([store](#syntax-store),[globaladdr](#syntax-globaladdr)):[globaltype](#syntax-globaltype)[](#-mathrmglobal_type-hrefsyntax-storemathitstore-hrefsyntax-globaladdrmathitglobaladdr--hrefsyntax-globaltypemathitglobaltype)

1.  Return S.[globals](#syntax-store)\[a\].[type](#syntax-globalinst).
    
2.  Post-condition: the returned [global type](#syntax-globaltype) is [valid](#valid-globaltype) under the empty [context](#context).
    

global\_type(S,a)​\=​S.[globals](#syntax-store)\[a\].[type](#syntax-globalinst)​​

##### global\_read([store](#syntax-store),[globaladdr](#syntax-globaladdr)):[val](#syntax-val)[](#-mathrmglobal_read-hrefsyntax-storemathitstore-hrefsyntax-globaladdrmathitglobaladdr--hrefsyntax-valmathitval)

1.  Let gi be the [global instance](#syntax-globalinst) [store](#syntax-store).[globals](#syntax-store)\[[globaladdr](#syntax-globaladdr)\].
    
2.  Return the [value](#syntax-val) gi.[value](#syntax-globalinst).
    

global\_read(S,a)​\=​v​​(ifS.[globals](#syntax-store)\[a\].[value](#syntax-globalinst)\=v)​​

##### global\_write([store](#syntax-store),[globaladdr](#syntax-globaladdr),[val](#syntax-val)):[store](#syntax-store) ∣ [error](#embed-error)[](#-mathrmglobal_write-hrefsyntax-storemathitstore-hrefsyntax-globaladdrmathitglobaladdr-hrefsyntax-valmathitval--hrefsyntax-storemathitstore--hrefembed-errormathiterror)

1.  Let gi be the [global instance](#syntax-globalinst) [store](#syntax-store).[globals](#syntax-store)\[[globaladdr](#syntax-globaladdr)\].
    
2.  Let [mut](#syntax-mut) t be the structure of the [global type](#syntax-globaltype) gi.[type](#syntax-globalinst).
    
3.  If [mut](#syntax-mut) is empty, then return [error](#embed-error).
    
4.  Replace gi.[value](#syntax-globalinst) with the [value](#syntax-val) [val](#syntax-val).
    
5.  Return the updated store.
    

global\_write(S,a,v)global\_write(S,a,v)​\=\=​S′[error](#embed-error)​​(ifS.[globals](#syntax-store)\[a\].[type](#syntax-globalinst)\=[mut](#syntax-mut) t∧S′\=S[with](#notation-replace)[globals](#syntax-store)\[a\].[value](#syntax-globalinst)\=v)(otherwise)​​

#### Values[](#values①②)

##### ref\_type([store](#syntax-store),[ref](#syntax-ref)):[reftype](#syntax-reftype)[](#-mathrmref_type-hrefsyntax-storemathitstore-hrefsyntax-refmathitref--hrefsyntax-reftypemathitreftype)

1.  Pre-condition: the [reference](#syntax-ref) [ref](#syntax-ref) is [valid](#valid-val) under store S.
    
2.  Return the [reference type](#syntax-reftype) t with which [ref](#syntax-ref) is valid.
    
3.  Post-condition: the returned [reference type](#syntax-reftype) is [valid](#valid-reftype) under the empty [context](#context).
    

ref\_type(S,r)​\=​t​​(ifS[⊢](#valid-val)r:t)​​

Note

In future versions of WebAssembly, not all references may carry precise type information at run time. In such cases, this function may return a less precise supertype.

##### val\_default([valtype](#syntax-valtype)):[val](#syntax-val)[](#-mathrmval_default-hrefsyntax-valtypemathitvaltype--hrefsyntax-valmathitval)

1.  If [default](#aux-default)valtype​ is not defined, then return [error](#embed-error).
    

1.  Else, return the [value](#syntax-val) [default](#aux-default)valtype​.
    

val\_default(t)val\_default(t)​\=\=​v[error](#embed-error)​​(if[default](#aux-default)t​\=v)(if[default](#aux-default)t​\=ϵ)​​

#### Matching[](#matching③)

##### match\_valtype([valtype](#syntax-valtype)1​,[valtype](#syntax-valtype)2​):[bool](#embed-bool)[](#-mathrmmatch_valtype-hrefsyntax-valtypemathitvaltype_1-hrefsyntax-valtypemathitvaltype_2--hrefembed-boolmathitbool)

1.  Pre-condition: the [value types](#syntax-valtype) [valtype](#syntax-valtype)1​ and [valtype](#syntax-valtype)2​ are [valid](#valid-valtype) under the empty [context](#context).
    
2.  If [valtype](#syntax-valtype)1​ [matches](#match-valtype) [valtype](#syntax-valtype)2​, then return [true](#embed-bool).
    
3.  Else, return [false](#embed-bool).
    

match\_reftype(t1​,t2​)match\_reftype(t1​,t2​)​\=\=​[true](#embed-bool)[false](#embed-bool)​​(if[⊢](#match-valtype)t1​[≤](#match-valtype)t2​)(otherwise)​​

##### match\_externtype([externtype](#syntax-externtype)1​,[externtype](#syntax-externtype)2​):[bool](#embed-bool)[](#-mathrmmatch_externtype-hrefsyntax-externtypemathitexterntype_1-hrefsyntax-externtypemathitexterntype_2--hrefembed-boolmathitbool)

1.  Pre-condition: the [extern types](#syntax-externtype) [externtype](#syntax-externtype)1​ and [externtype](#syntax-externtype)2​ are [valid](#valid-externtype) under the empty [context](#context).
    
2.  If [externtype](#syntax-externtype)1​ [matches](#match-externtype) [externtype](#syntax-externtype)2​, then return [true](#embed-bool).
    
3.  Else, return [false](#embed-bool).
    

match\_externtype(et1​,et2​)match\_externtype(et1​,et2​)​\=\=​[true](#embed-bool)[false](#embed-bool)​​(if[⊢](#match-externtype)et1​[≤](#match-externtype)et2​)(otherwise)​​

### A.2 Profiles[](#a2-profiles)

To enable the use of WebAssembly in as many environments as possible, _profiles_ specify coherent language subsets that fit constraints imposed by common classes of host environments. A host platform can thereby decide to support the language only under a restricted profile, or even the intersection of multiple profiles.

#### Conventions[](#conventions③⑧)

A profile modification is specified by decorating selected rules in the main body of this specification with a _profile annotation_ that defines them as conditional on the choice of profile.

For that purpose, every profile defines a _profile marker_, an alphanumeric short-hand like ABC. A profile annotation of the form \[!ABC XYZ\] on a rule indicates that this rule is _excluded_ for either of the profiles whose marker is ABC or XYZ.

There are two ways of subsetting the language in a profile:

*   _Syntactic_, by _omitting_ a feature, in which case certain constructs are removed from the syntax altogether.
    
*   _Semantic_, by _restricting_ a feature, in which case certain constructs are still present but some behaviours are ruled out.
    

##### Syntax Annotations[](#syntax-annotations①)

To omit a construct from a profile syntactically, respective productions in the grammar of the [abstract syntax](#syntax) are annotated with an associated profile marker. This is defined to have the following implications:

1.  Any production in the [binary](#binary) or [textual](#text) syntax that produces abstract syntax with a marked construct is omitted by extension.
    
2.  Any [validation](#valid) or [execution](#exec) rule that handles a marked construct is omitted by extension.
    

The overall effect is that the respective construct is no longer part of the language under a respective profile.

Note

For example, a “busy” profile marked BUSY could rule out the [nop](#syntax-instr-control) instruction by marking the production for it in the abstract syntax as follows:

​[instr](#syntax-instr)\[!BUSY\]​::=∣∣​…[nop](#syntax-instr-control)[unreachable](#syntax-instr-control)​​

A rule may be annotated by multiple markers, which could be the case if a construct is in the intersection of multiple features.

##### Semantics Annotations[](#semantics-annotations①)

To restrict certain behaviours in a profile, individual [validation](#valid) or [reduction](#exec) rules or auxiliary definitions are annotated with an associated marker.

This has the consequence that the respective rule is no longer applicable under the given profile.

Note

For example, an “infinite” profile marked INF could define that growing memory never fails:

​S;F;([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) [memory.grow](#syntax-instr-memory) x​[↪](#exec-notation)​S′;F;([i32](#syntax-numtype).[const](#syntax-instr-numeric) sz)(if∧∧​F.[module](#syntax-frame).[mems](#syntax-moduleinst)\[x\]\=asz\=∣S.[mems](#syntax-store)\[a\].[datas](#syntax-moduleinst)∣/64KiS′\=S[with](#notation-replace)[mems](#syntax-store)\[a\]\=[growmem](#grow-mem)(S.[mems](#syntax-store)\[a\],n))​1ex\]\[!INF\]​S;F;([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) [memory.grow](#syntax-instr-memory) x​[↪](#exec-notation)​S;F;([i32](#syntax-numtype).[const](#syntax-instr-numeric) [signed](#aux-signed)32−1​(−1))​​

##### Properties[](#properties①)

All profiles are defined such that the following properties are preserved:

*   All profiles represent syntactic and semantic subsets of the [full profile](#profile-full), i.e., they do not _add_ syntax or _alter_ behaviour.
    
*   All profiles are mutually compatible, i.e., no two profiles subset semantic behaviour in inconsistent or ambiguous ways, and any intersection of profiles preserves the properties described here.
    
*   Profiles do not violate [soundness](#soundness), i.e., all [configurations](#syntax-config) valid under that profile still have well-defined execution behaviour.
    

Note

Tools are generally expected to handle and produce code for the full profile by default. In particular, producers should not generate code that _depends_ on specific profiles. Instead, all code should preserve correctness when executed under the full profile.

Moreover, profiles should be considered static and fixed for a given platform or ecosystem. Runtime conditioning on the “current” profile is not intended and should be avoided.

#### Defined Profiles[](#defined-profiles①)

Note

The number of defined profiles is expected to remain small in the future. Profiles are intended for broad and permanent use cases only. In particular, profiles are not intended for language versioning.

##### Full Profile (FUL)[](#full-profile--smallmathrmful)

The _full_ profile contains the complete language and all possible behaviours. It imposes no restrictions, i.e., all rules and definitions are active. All other profiles define sub-languages of this profile.

##### Deterministic Profile (DET)[](#deterministic-profile--smallmathrmdet)

The _deterministic_ profile excludes all rules marked \[![DET](#profile-deterministic)\]. It defines a sub-language that does not exhibit any incidental non-deterministic behaviour:

*   All [NaN](#syntax-nan) values [generated](#aux-nans) by [floating-point instructions](#syntax-instr-numeric) are canonical and positive.
    
*   All [relaxed vector instructions](#syntax-instr-vec-relaxed) have a fixed behaviour that does not depend on the implementation.
    

Even under this profile, the [memory.grow](#syntax-instr-memory) and [table.grow](#syntax-instr-table) instructions technically remain [non-deterministic](#exec-memory-grow), in order to be able to indicate resource exhaustion.

Note

In future versions of WebAssembly, new non-deterministic behaviour may be added to the language, such that the deterministic profile will induce additional restrictions.

### A.3 Implementation Limitations[](#a3-implementation-limitations)

Implementations typically impose additional restrictions on a number of aspects of a WebAssembly module or execution. These may stem from:

*   physical resource limits,
    
*   constraints imposed by the embedder or its environment,
    
*   limitations of selected implementation strategies.
    

This section lists allowed limitations. Where restrictions take the form of numeric limits, no minimum requirements are given, nor are the limits assumed to be concrete, fixed numbers. However, it is expected that all implementations have “reasonably” large limits to enable common applications.

Note

A conforming implementation is not allowed to leave out individual _features_. However, designated subsets of WebAssembly may be specified in the future.

#### Syntactic Limits[](#syntactic-limits①)

##### Structure[](#structure③)

An implementation may impose restrictions on the following dimensions of a module:

*   the number of [types](#syntax-type) in a [module](#syntax-module)
    
*   the number of [functions](#syntax-func) in a [module](#syntax-module), including imports
    
*   the number of [tables](#syntax-table) in a [module](#syntax-module), including imports
    
*   the number of [memories](#syntax-mem) in a [module](#syntax-module), including imports
    
*   the number of [globals](#syntax-global) in a [module](#syntax-module), including imports
    
*   the number of [tags](#syntax-tag) in a [module](#syntax-module), including imports
    
*   the number of [element segments](#syntax-elem) in a [module](#syntax-module)
    
*   the number of [data segments](#syntax-data) in a [module](#syntax-module)
    
*   the number of [imports](#syntax-import) to a [module](#syntax-module)
    
*   the number of [exports](#syntax-export) from a [module](#syntax-module)
    
*   the number of [sub types](#syntax-subtype) in a [recursive type](#syntax-rectype)
    
*   the subtyping depth of a [sub type](#syntax-subtype)
    
*   the number of fields in a [structure type](#syntax-structtype)
    
*   the number of parameters in a [function type](#syntax-functype)
    
*   the number of results in a [function type](#syntax-functype)
    
*   the number of parameters in a [block type](#syntax-blocktype)
    
*   the number of results in a [block type](#syntax-blocktype)
    
*   the number of [locals](#syntax-local) in a [function](#syntax-func)
    
*   the number of [instructions](#syntax-instr) in a [function](#syntax-func) body
    
*   the number of [instructions](#syntax-instr) in a [structured control instruction](#syntax-instr-control)
    
*   the number of [structured control instructions](#syntax-instr-control) in a [function](#syntax-func)
    
*   the nesting depth of [structured control instructions](#syntax-instr-control)
    
*   the number of [label indices](#syntax-labelidx) in a [br\_table](#syntax-instr-control) instruction
    
*   the number of instructions in a [constant](#valid-constant) [expression](#syntax-expr)
    
*   the length of the array in a [array.new\_fixed](#syntax-instr-array) instruction
    
*   the length of an [element segment](#syntax-elem)
    
*   the length of a [data segment](#syntax-data)
    
*   the length of a [name](#syntax-name)
    
*   the range of [characters](#syntax-char) in a [name](#syntax-name)
    

If the limits of an implementation are exceeded for a given module, then the implementation may reject the [validation](#valid), compilation, or [instantiation](#exec-instantiation) of that module with an embedder-specific error.

Note

The last item allows [embedders](#embedder) that operate in limited environments without support for [\[UNICODE\]](#biblio-unicode "The Unicode Standard") to limit the names of [imports](#syntax-import) and [exports](#syntax-export) to common subsets like [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d).

##### Binary Format[](#binary-format③)

For a module given in [binary format](#binary), additional limitations may be imposed on the following dimensions:

*   the size of a [module](#binary-module)
    
*   the size of any [section](#binary-section)
    
*   the size of an individual [function](#syntax-func)’s [code](#binary-code)
    
*   the size of a [structured control instruction](#syntax-instr-control)
    
*   the size of an individual [constant](#valid-constant) [expression](#syntax-expr)’s instruction sequence
    
*   the number of [sections](#binary-section)
    

##### Text Format[](#text-format④)

For a module given in [text format](#text), additional limitations may be imposed on the following dimensions:

*   the size of the [source text](#source)
    
*   the size of any syntactic element
    
*   the size of an individual [token](#text-token)
    
*   the nesting depth of [folded instructions](#text-foldedinstr)
    
*   the length of symbolic [identifiers](#text-id)
    
*   the range of literal [characters](#text-char) allowed in the [source text](#source)
    

#### Validation[](#validation④)

An implementation may defer [validation](#valid) of individual [functions](#syntax-func) until they are first [invoked](#exec-invoke).

If a function turns out to be invalid, then the invocation, and every consecutive call to the same function, results in a [trap](#trap).

Note

This is to allow implementations to use interpretation or just-in-time compilation for functions. The function must still be fully validated before execution of its body begins.

#### Execution[](#execution④)

Restrictions on the following dimensions may be imposed during [execution](#exec) of a WebAssembly program:

*   the number of allocated [module instances](#syntax-moduleinst)
    
*   the number of allocated [function instances](#syntax-funcinst)
    
*   the number of allocated [table instances](#syntax-tableinst)
    
*   the number of allocated [memory instances](#syntax-meminst)
    
*   the number of allocated [global instances](#syntax-globalinst)
    
*   the number of allocated [tag instances](#syntax-taginst)
    
*   the number of allocated [structure instances](#syntax-structinst)
    
*   the number of allocated [array instances](#syntax-arrayinst)
    
*   the number of allocated [exception instances](#syntax-exninst)
    
*   the size of a [table instance](#syntax-tableinst)
    
*   the size of a [memory instance](#syntax-meminst)
    
*   the size of an [array instance](#syntax-arrayinst)
    
*   the number of [frames](#syntax-frame) on the [stack](#stack)
    
*   the number of [labels](#syntax-label) on the [stack](#stack)
    
*   the number of [values](#syntax-val) on the [stack](#stack)
    

If the runtime limits of an implementation are exceeded during execution of a computation, then it may terminate that computation and report an embedder-specific error to the invoking code.

Some of the above limits may already be verified during instantiation, in which case an implementation may report exceedance in the same manner as for [syntactic limits](#impl-syntax).

Note

Concrete limits are usually not fixed but may be dependent on specifics, interdependent, vary over time, or depend on other implementation- or embedder-specific situations or events.

### Type Soundness[](#type-soundness①)

The [type system](#type-system) of WebAssembly is _sound_, implying both _type safety_ and _memory safety_ with respect to the WebAssembly semantics. For example:

*   All types declared and derived during validation are respected at run time; e.g., every [local](#syntax-local) or [global](#syntax-global) variable will only contain type-correct values, every [instruction](#syntax-instr) will only be applied to operands of the expected type, and every [function](#syntax-func) [invocation](#exec-invocation) always evaluates to a result of the right type (if it does not diverge, throw an exception, or [trap](#trap)).
    
*   No memory location will be read or written except those explicitly defined by the program, i.e., as a [local](#syntax-local), a [global](#syntax-global), an element in a [table](#syntax-table), or a location within a linear [memory](#syntax-mem).
    
*   There is no undefined behavior, i.e., the [execution rules](#exec) cover all possible cases that can occur in a [valid](#valid) program, and the rules are mutually consistent.
    

Soundness also is instrumental in ensuring additional properties, most notably, _encapsulation_ of function and module scopes: no [locals](#syntax-local) can be accessed outside their own function and no [module](#syntax-module) components can be accessed outside their own module unless they are explicitly [exported](#syntax-export) or [imported](#syntax-import).

The typing rules defining WebAssembly [validation](#valid) only cover the _static_ components of a WebAssembly program. In order to state and prove soundness precisely, the typing rules must be extended to the _dynamic_ components of the abstract [runtime](#syntax-runtime), that is, the [store](#syntax-store), [configurations](#syntax-config), and [administrative instructions](#syntax-instr-admin). [\[1\]](#cite-pldi2017)

#### Contexts[](#contexts⑤)

In order to check [rolled up](#aux-roll-rectype) recursive types, the [context](#context) is locally extended with an additional component that records the [sub type](#syntax-subtype) corresponding to each [recursive type index](#syntax-rectypeidx) within the current [recursive type](#syntax-rectype):

​C​::=​{ …,[recs](#context-ext) [subtype](#syntax-subtype)∗ }​​

#### Types[](#types②①)

Well-formedness for [extended type forms](#type-ext) is defined as follows.

##### [Heap Type](#syntax-heaptype-ext) [bot](#syntax-heaptype-ext)[](#heap-type--hrefsyntax-heaptype-extmathsfbot)

*   The heap type is valid.
    

C[⊢](#valid-heaptype)[bot](#syntax-heaptype-ext):[ok](#valid-heaptype)​

##### [Heap Type](#syntax-heaptype-ext) [rec](#syntax-heaptype) i[](#heap-type--hrefsyntax-heaptypemathsfreci)

*   The recursive type index i must exist in C.[recs](#context-ext).
    
*   Then the heap type is valid.
    

C[⊢](#valid-heaptype)[rec](#syntax-heaptype) i:[ok](#valid-heaptype)C.[recs](#context-ext)\[i\]\=[subtype](#syntax-subtype)​

##### [Value Type](#syntax-valtype-ext) [bot](#syntax-valtype-ext)[](#value-type--hrefsyntax-valtype-extmathsfbot)

*   The value type is valid.
    

C[⊢](#valid-valtype)[bot](#syntax-valtype-ext):[ok](#valid-valtype)​

##### [Recursive Types](#syntax-rectype) [rec](#syntax-rectype) [subtype](#syntax-subtype)∗[](#recursive-types--hrefsyntax-rectypemathsfrechrefsyntax-subtypemathitsubtypeast)

*   Let C′ be the current [context](#context) C, but where [recs](#context-ext) is [subtype](#syntax-subtype)∗.
    
*   There must be a [type index](#syntax-typeidx) x, such that for each [sub type](#syntax-subtype) [subtype](#syntax-subtype)i​ in [subtype](#syntax-subtype)∗:
    
    *   Under the context C′, the [sub type](#syntax-subtype) [subtype](#syntax-subtype)i​ must be [valid](#valid-subtype) for [type index](#syntax-typeidx) x+i and [recursive type index](#syntax-rectypeidx) i.
        
*   Then the recursive type is valid for the [type index](#syntax-typeidx) x.
    

C[⊢](#valid-rectype)[rec](#syntax-rectype) [subtype](#syntax-subtype)∗:[ok](#valid-rectype)(x)C,[recs](#context-ext) [subtype](#syntax-subtype)∗[⊢](#valid-rectype)[rec](#syntax-rectype) [subtype](#syntax-subtype)∗:[ok](#valid-rectype)(x,0)​

C[⊢](#valid-rectype)[rec](#syntax-rectype) ϵ:[ok](#valid-rectype)(x,i)​C[⊢](#valid-rectype)[rec](#syntax-rectype) [subtype](#syntax-subtype) [subtype](#syntax-subtype)′∗:[ok](#valid-rectype)(x,i)C[⊢](#valid-subtype)[subtype](#syntax-subtype):[ok](#valid-subtype)(x,i)C[⊢](#valid-rectype)[rec](#syntax-rectype) [subtype](#syntax-subtype)′∗:[ok](#valid-rectype)(x+1,i+1)​

Note

These rules are a generalisation of the ones [previously given](#valid-rectype).

##### [Sub types](#syntax-subtype) [sub](#syntax-subtype) [final](#syntax-subtype)? ht∗ [comptype](#syntax-comptype)[](#sub-types--hrefsyntax-subtypemathsfsubhrefsyntax-subtypemathsffinalmathithtasthrefsyntax-comptypemathitcomptype)

*   The [composite type](#syntax-comptype) [comptype](#syntax-comptype) must be [valid](#valid-comptype).
    
*   The sequence ht∗ may be no longer than 1.
    
*   For every [heap type](#syntax-heaptype) htk​ in ht∗:
    
    *   The [heap type](#syntax-heaptype) htk​ must be ordered before a [type index](#syntax-typeidx) x and [recursive type index](#syntax-rectypeidx) a i, meaning:
        
        *   Either htk​ is a [defined type](#syntax-deftype).
            
        *   Or htk​ is a [type index](#syntax-typeidx) yk​ that is smaller than x.
            
        *   Or htk​ is a [recursive type index](#syntax-rectypeidx) [rec](#syntax-heaptype) jk​ where jk​ is smaller than i.
            
    *   Let [sub type](#syntax-subtype) [subtype](#syntax-subtype)k​ be the [unrolling](#aux-unroll-heaptype) of the [heap type](#syntax-heaptype) htk​, meaning:
        
        *   Either htk​ is a [defined type](#syntax-deftype) [deftype](#syntax-deftype)k​, then [subtype](#syntax-subtype)k​ must be the [unrolling](#aux-unroll-deftype) of [deftype](#syntax-deftype)k​.
            
        *   Or htk​ is a [type index](#syntax-typeidx) yk​, then [subtype](#syntax-subtype)k​ must be the [unrolling](#aux-unroll-deftype) of the [defined type](#syntax-deftype) C.[types](#context)\[yk​\].
            
        *   Or htk​ is a [recursive type index](#syntax-rectypeidx) [rec](#syntax-heaptype) jk​, then [subtype](#syntax-subtype)k​ must be C.[recs](#context-ext)\[jk​\].
            
    *   The [sub type](#syntax-subtype) [subtype](#syntax-subtype)k​ must not contain [final](#syntax-subtype).
        
    *   Let [comptype](#syntax-comptype)k′​ be the [composite type](#syntax-comptype) in [subtype](#syntax-subtype)k​.
        
    *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype) must [match](#match-comptype) [comptype](#syntax-comptype)k′​.
        
*   Then the sub type is valid for the [type index](#syntax-typeidx) x and [recursive type index](#syntax-rectypeidx) i.
    

C[⊢](#valid-subtype)[sub](#syntax-subtype) [final](#syntax-subtype)? ht∗ [comptype](#syntax-comptype):[ok](#valid-subtype)(x,i)∣ht∗∣≤1(ht≺x,i)∗([unroll](#aux-unroll-heaptype)C​(ht)\=[sub](#syntax-subtype) ht′∗ [comptype](#syntax-comptype)′)∗C[⊢](#valid-comptype)[comptype](#syntax-comptype):[ok](#valid-comptype)(C[⊢](#match-comptype)[comptype](#syntax-comptype)[≤](#match-comptype)[comptype](#syntax-comptype)′)∗​​​

where:

([deftype](#syntax-deftype)≺x,i)(y≺x,i)([rec](#syntax-heaptype) j≺x,i)\[2ex\][unroll](#aux-unroll-heaptype)C​([deftype](#syntax-deftype))[unroll](#aux-unroll-heaptype)C​(y)[unroll](#aux-unroll-heaptype)C​([rec](#syntax-heaptype) j)​\=\=\=\=\=\=​truey<xj<i[unroll](#aux-unroll-deftype)([deftype](#syntax-deftype))[unroll](#aux-unroll-deftype)(C.[types](#context)\[y\])C.[recs](#context-ext)\[j\]​​

Note

This rule is a generalisation of the ones [previously given](#valid-subtype), which only allowed type indices as supertypes.

##### [Defined types](#syntax-deftype) [rectype](#syntax-rectype).i[](#defined-types--hrefsyntax-rectypemathitrectypei)

The [defined type](#syntax-deftype) ([rectype](#syntax-rectype).i) is [valid](#valid-deftype) if:

> *   The [recursive type](#syntax-rectype) [rectype](#syntax-rectype) is [valid](#valid-rectype) for the type index x.
>     
> *   The [recursive type](#syntax-rectype) [rectype](#syntax-rectype) is of the form ([rec](#syntax-rectype) [subtype](#syntax-subtype)n).
>     
> *   i is less than n.
>     

C[⊢](#valid-deftype)[rectype](#syntax-rectype).i:[ok](#valid-deftype)C[⊢](#valid-rectype)[rectype](#syntax-rectype):[ok](#valid-subtype)(x)[rectype](#syntax-rectype)\=[rec](#syntax-rectype) [subtype](#syntax-subtype)ni<n​​

#### Subtyping[](#subtyping②)

In a [rolled-up](#aux-roll-rectype) [recursive type](#syntax-rectype), a [recursive type indices](#syntax-rectypeidx) [rec](#syntax-heaptype) i [matches](#match-heaptype) another [heap type](#syntax-heaptype) ht if:

*   Let [sub](#syntax-subtype) [final](#syntax-subtype)? ht′∗ [comptype](#syntax-comptype) be the [sub type](#syntax-subtype) C.[recs](#context-ext)\[i\].
    
*   The heap type ht is contained in ht′∗.
    

C[⊢](#match-heaptype)[rec](#syntax-heaptype) i[≤](#match-heaptype)htC.[recs](#context-ext)\[i\]\=[sub](#syntax-subtype) [final](#syntax-subtype)? (ht1∗​ ht ht2∗​) [comptype](#syntax-comptype)​

Note

This rule is only invoked when checking [validity](#valid-rectype-ext) of [rolled-up](#aux-roll-rectype) [recursive types](#syntax-rectype).

#### Results[](#results③)

[Results](#syntax-result) can be classified by [result types](#syntax-resulttype) as follows.

##### [Results](#syntax-result) [val](#syntax-val)∗[](#results--hrefsyntax-valmathitvalast)

*   For each [value](#syntax-val) [val](#syntax-val)i​ in [val](#syntax-val)∗:
    
    *   The value [val](#syntax-val)i​ is [valid](#valid-val) with some [value type](#syntax-valtype) ti​.
        
*   Let t∗ be the concatenation of all ti​.
    
*   Then the result is valid with [result type](#syntax-resulttype) \[t∗\].
    

S[⊢](#valid-result)[val](#syntax-val)∗:\[t∗\](S[⊢](#valid-val)[val](#syntax-val):t)∗​

##### [Results](#syntax-result) ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)[](#results--hrefsyntax-refmathsfrefexnahrefsyntax-instr-controlmathsfthrow_ref)

*   The value [ref.exn](#syntax-ref) a must be [valid](#valid-val).
    
*   Then the result is valid with [result type](#syntax-resulttype) \[t∗\], for any [valid](#valid-resulttype) [closed](#type-closed) [result types](#syntax-resulttype).
    

S[⊢](#valid-result)([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control):\[t∗\]S[⊢](#valid-val)[ref.exn](#syntax-ref) a:[ref](#syntax-reftype) [exn](#syntax-heaptype)[⊢](#valid-resulttype)\[t∗\]:[ok](#valid-resulttype)​

##### [Results](#syntax-result) [trap](#syntax-trap)[](#results--hrefsyntax-trapmathsftrap)

*   The result is valid with [result type](#syntax-resulttype) \[t∗\], for any [valid](#valid-resulttype) [closed](#type-closed) [result types](#syntax-resulttype).
    

S[⊢](#valid-result)[trap](#syntax-trap):\[t∗\][⊢](#valid-resulttype)\[t∗\]:[ok](#valid-resulttype)​

#### Store Validity[](#store-validity①)

The following typing rules specify when a runtime [store](#syntax-store) S is _valid_. A valid store must consist of [tag](#syntax-taginst), [global](#syntax-globalinst), [memory](#syntax-meminst), [table](#syntax-tableinst), [function](#syntax-funcinst), [data](#syntax-datainst), [element](#syntax-eleminst), [structure](#syntax-structinst), [array](#syntax-arrayinst), [exception](#syntax-exninst), and [module](#syntax-moduleinst) instances that are themselves valid, relative to S.

To that end, each kind of instance is classified by a respective [tag](#syntax-tagtype), [global](#syntax-globaltype), [memory](#syntax-memtype), [table](#syntax-tabletype), [function](#syntax-functype), or [element](#syntax-eleminst), type, or just ok in the case of [data](#syntax-datainst) [structures](#syntax-structinst), [arrays](#syntax-arrayinst), or [exceptions](#syntax-exninst). Module instances are classified by _module contexts_, which are regular [contexts](#context) repurposed as module types describing the [index spaces](#syntax-index) defined by a module.

##### [Store](#syntax-store) S[](#store--s)

*   Each [tag instance](#syntax-taginst) [taginst](#syntax-taginst)i​ in S.[tags](#syntax-store) must be [valid](#valid-taginst) with some [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype)i​.
    
*   Each [global instance](#syntax-globalinst) [globalinst](#syntax-globalinst)i​ in S.[globals](#syntax-store) must be [valid](#valid-globalinst) with some [global type](#syntax-globaltype) [globaltype](#syntax-globaltype)i​.
    
*   Each [memory instance](#syntax-meminst) [meminst](#syntax-meminst)i​ in S.[mems](#syntax-store) must be [valid](#valid-meminst) with some [memory type](#syntax-memtype) [memtype](#syntax-memtype)i​.
    
*   Each [table instance](#syntax-tableinst) [tableinst](#syntax-tableinst)i​ in S.[tables](#syntax-store) must be [valid](#valid-tableinst) with some [table type](#syntax-tabletype) [tabletype](#syntax-tabletype)i​.
    
*   Each [function instance](#syntax-funcinst) [funcinst](#syntax-funcinst)i​ in S.[funcs](#syntax-store) must be [valid](#valid-funcinst) with some [defined type](#syntax-deftype) [deftype](#syntax-deftype)i​.
    
*   Each [data instance](#syntax-datainst) [datainst](#syntax-datainst)i​ in S.[datas](#syntax-store) must be [valid](#valid-datainst).
    
*   Each [element instance](#syntax-eleminst) [eleminst](#syntax-eleminst)i​ in S.[elems](#syntax-store) must be [valid](#valid-eleminst) with some [reference type](#syntax-reftype) [reftype](#syntax-reftype)i​.
    
*   Each [structure instance](#syntax-structinst) [structinst](#syntax-structinst)i​ in S.[structs](#syntax-store) must be [valid](#valid-structinst).
    
*   Each [array instance](#syntax-arrayinst) [arrayinst](#syntax-arrayinst)i​ in S.[arrays](#syntax-store) must be [valid](#valid-arrayinst).
    
*   Each [exception instance](#syntax-exninst) [exninst](#syntax-exninst)i​ in S.[exns](#syntax-store) must be [valid](#valid-exninst).
    
*   No [reference](#syntax-ref) to a bound [structure address](#syntax-structaddr) must be reachable from itself through a path consisting only of indirections through immutable structure, or array [fields](#syntax-fieldtype) or fields of [exception instances](#syntax-exninst).
    
*   No [reference](#syntax-ref) to a bound [array address](#syntax-arrayaddr) must be reachable from itself through a path consisting only of indirections through immutable structure or array [fields](#syntax-fieldtype) or fields of [exception instances](#syntax-exninst).
    
*   No [reference](#syntax-ref) to a bound [exception address](#syntax-exnaddr) must be reachable from itself through a path consisting only of indirections through immutable structure or array [fields](#syntax-fieldtype) or fields of [exception instances](#syntax-exninst).
    
*   Then the store is valid.
    

−1ex\][⊢](#valid-store)S:[ok](#valid-store)(S[⊢](#valid-taginst)[taginst](#syntax-taginst):[tagtype](#syntax-tagtype))∗(S[⊢](#valid-globalinst)[globalinst](#syntax-globalinst):[globaltype](#syntax-globaltype))∗(S[⊢](#valid-meminst)[meminst](#syntax-meminst):[memtype](#syntax-memtype))∗(S[⊢](#valid-tableinst)[tableinst](#syntax-tableinst):[tabletype](#syntax-tabletype))∗(S[⊢](#valid-funcinst)[funcinst](#syntax-funcinst):[deftype](#syntax-deftype))∗(S[⊢](#valid-datainst)[datainst](#syntax-datainst):[ok](#valid-datainst))∗(S[⊢](#valid-eleminst)[eleminst](#syntax-eleminst):[reftype](#syntax-reftype))∗(S[⊢](#valid-structinst)[structinst](#syntax-structinst):[ok](#valid-structinst))∗(S[⊢](#valid-arrayinst)[arrayinst](#syntax-arrayinst):[ok](#valid-arrayinst))∗(S[⊢](#valid-exninst)[exninst](#syntax-exninst):[ok](#valid-exninst))∗S\={[tags](#syntax-store) [taginst](#syntax-taginst)∗,[globals](#syntax-store) [globalinst](#syntax-globalinst)∗,[mems](#syntax-store) [meminst](#syntax-meminst)∗,[tables](#syntax-store) [tableinst](#syntax-tableinst)∗,[funcs](#syntax-store) [funcinst](#syntax-funcinst)∗,[datas](#syntax-store) [datainst](#syntax-datainst)∗,[elems](#syntax-store) [eleminst](#syntax-eleminst)∗,[structs](#syntax-store) [structinst](#syntax-structinst)∗,[arrays](#syntax-store) [arrayinst](#syntax-arrayinst)∗,[exns](#syntax-store) [exninst](#syntax-exninst)∗}​(S.[structs](#syntax-store)\[as​\]\=[structinst](#syntax-structinst))∗(([ref.struct](#syntax-ref) as​)≫S+​([ref.struct](#syntax-ref) as​))∗(S.[arrays](#syntax-store)\[aa​\]\=[arrayinst](#syntax-arrayinst))∗(([ref.array](#syntax-ref) aa​)≫S+​([ref.array](#syntax-ref) aa​))∗(S.[exns](#syntax-store)\[ae​\]\=[exninst](#syntax-exninst))∗(([ref.exn](#syntax-ref) ae​)≫S+​([ref.exn](#syntax-ref) ae​))∗​​​

where [val](#syntax-val)1​≫S+​[val](#syntax-val)2​ denotes the transitive closure of the following _immutable reachability_ relation on [values](#syntax-val):

([ref.struct](#syntax-ref) a)([ref.array](#syntax-ref) a)([ref.exn](#syntax-ref) a)([ref.extern](#syntax-ref) [ref](#syntax-ref))​≫S​≫S​≫S​≫S​​S.[structs](#syntax-store)\[a\].[fields](#syntax-structinst)\[i\]S.[arrays](#syntax-store)\[a\].[fields](#syntax-arrayinst)\[i\]S.[exns](#syntax-store)\[a\].[fields](#syntax-exninst)\[i\][ref](#syntax-ref)​if[expand](#aux-expand-deftype)(S.[structs](#syntax-store)\[a\].[type](#syntax-structinst))\=[struct](#syntax-comptype) ft1i​ st ft2∗​if[expand](#aux-expand-deftype)(S.[arrays](#syntax-store)\[a\].[type](#syntax-arrayinst))\=[array](#syntax-comptype) st​

Note

The constraint on reachability through immutable fields prevents the presence of cyclic data structures that can not be constructed in the language. Cycles can only be formed using mutation.

##### [Tag Instances](#syntax-taginst) {[type](#syntax-taginst) [tagtype](#syntax-tagtype)}[](#tag-instances---hrefsyntax-taginstmathsftypehrefsyntax-tagtypemathittagtype)

*   The [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype) must be [valid](#valid-tagtype) under the empty [context](#context).
    
*   Then the tag instance is valid with [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype).
    

S[⊢](#valid-taginst){[type](#syntax-taginst) [tagtype](#syntax-tagtype)}:[tagtype](#syntax-tagtype)[⊢](#valid-tagtype)[tagtype](#syntax-tagtype):[ok](#valid-tagtype)​

##### [Global Instances](#syntax-globalinst) {[type](#syntax-globalinst) [mut](#syntax-mut) t,[value](#syntax-globalinst) [val](#syntax-val)}[](#global-instances---hrefsyntax-globalinstmathsftypehrefsyntax-mutmathitmutt-hrefsyntax-globalinstmathsfvaluehrefsyntax-valmathitval)

*   The [global type](#syntax-globaltype) [mut](#syntax-mut) t must be [valid](#valid-globaltype) under the empty [context](#context).
    
*   The [value](#syntax-val) [val](#syntax-val) must be [valid](#valid-val) with some [value type](#syntax-valtype) t′.
    
*   The [value type](#syntax-valtype) t′ must [match](#match-valtype) the [value type](#syntax-valtype) t.
    
*   Then the global instance is valid with [global type](#syntax-globaltype) [mut](#syntax-mut) t.
    

S[⊢](#valid-globalinst){[type](#syntax-globalinst) [mut](#syntax-mut) t,[value](#syntax-globalinst) [val](#syntax-val)}:[mut](#syntax-mut) t[⊢](#valid-globaltype)[mut](#syntax-mut) t:[ok](#valid-globaltype)S[⊢](#valid-val)[val](#syntax-val):t′[⊢](#match-valtype)t′[≤](#match-valtype)t​

##### [Memory Instances](#syntax-meminst) {[type](#syntax-meminst) ([addrtype](#syntax-addrtype) [limits](#syntax-limits)),[bytes](#syntax-meminst) b∗}[](#memory-instances---hrefsyntax-meminstmathsftype-hrefsyntax-addrtypemathitaddrtypehrefsyntax-limitsmathitlimits-hrefsyntax-meminstmathsfbytesbast)

*   The [memory type](#syntax-memtype) [addrtype](#syntax-addrtype) [limits](#syntax-limits) must be [valid](#valid-memtype) under the empty [context](#context).
    
*   Let [limits](#syntax-limits) be \[n..m\].
    
*   The length of b∗ must equal m multiplied by the [page size](#page-size) 64Ki.
    
*   Then the memory instance is valid with [memory type](#syntax-memtype) [addrtype](#syntax-addrtype) [limits](#syntax-limits).
    

S[⊢](#valid-meminst){[type](#syntax-meminst) ([addrtype](#syntax-addrtype) \[n..m\]),[bytes](#syntax-meminst) b∗}:[addrtype](#syntax-addrtype) \[n..m\][⊢](#valid-memtype)[addrtype](#syntax-addrtype) \[n..m\]:[ok](#valid-memtype)∣b∗∣\=n⋅64Ki​

##### [Table Instances](#syntax-tableinst) {[type](#syntax-tableinst) ([addrtype](#syntax-addrtype) [limits](#syntax-limits) t),[refs](#syntax-tableinst) [ref](#syntax-ref)∗}[](#table-instances---hrefsyntax-tableinstmathsftype-hrefsyntax-addrtypemathitaddrtypehrefsyntax-limitsmathitlimitst-hrefsyntax-tableinstmathsfrefshrefsyntax-refmathitrefast)

*   The [table type](#syntax-tabletype) [addrtype](#syntax-addrtype) [limits](#syntax-limits) t must be [valid](#valid-tabletype) under the empty [context](#context).
    
*   Let [limits](#syntax-limits) be \[n..m\].
    
*   The length of [ref](#syntax-ref)∗ must equal n.
    
*   For each [reference](#syntax-ref) [ref](#syntax-ref)i​ in the table’s elements [ref](#syntax-ref)n:
    
    *   The [reference](#syntax-ref) [ref](#syntax-ref)i​ must be [valid](#valid-ref) with some [reference type](#syntax-reftype) ti′​.
        
    *   The [reference type](#syntax-reftype) ti′​ must [match](#match-reftype) the [reference type](#syntax-reftype) t.
        
*   Then the table instance is valid with [table type](#syntax-tabletype) [addrtype](#syntax-addrtype) [limits](#syntax-limits) t.
    

S[⊢](#valid-tableinst){[type](#syntax-tableinst) ([addrtype](#syntax-addrtype) \[n..m\] t),[refs](#syntax-tableinst) [ref](#syntax-ref)∗}:[addrtype](#syntax-addrtype) \[n..m\] t[⊢](#valid-tabletype)[addrtype](#syntax-addrtype) \[n..m\] t:[ok](#valid-tabletype)∣[ref](#syntax-ref)∗∣\=n(S⊢[ref](#syntax-ref):t′)∗([⊢](#match-reftype)t′[≤](#match-valtype)t)∗​

##### [Function Instances](#syntax-funcinst) {[type](#syntax-funcinst) [deftype](#syntax-deftype),[module](#syntax-funcinst) [moduleinst](#syntax-moduleinst),[code](#syntax-funcinst) [func](#syntax-func)}[](#function-instances--hrefsyntax-funcinstmathsftypehrefsyntax-deftypemathitdeftype-hrefsyntax-funcinstmathsfmodulehrefsyntax-moduleinstmathitmoduleinst-hrefsyntax-funcinstmathsfcodehrefsyntax-funcmathitfunc)

*   The [defined type](#syntax-deftype) [deftype](#syntax-deftype) must be [valid](#valid-deftype) under an empty [context](#context).
    
*   The [module instance](#syntax-moduleinst) [moduleinst](#syntax-moduleinst) must be [valid](#valid-moduleinst) with some [context](#context) C.
    
*   Under [context](#context) C:
    
    *   The [function](#syntax-func) [func](#syntax-func) must be [valid](#valid-func) with some [defined type](#syntax-deftype) [deftype](#syntax-deftype)′.
        
    *   The [defined type](#syntax-deftype) [deftype](#syntax-deftype)′ must [match](#match-deftype) [deftype](#syntax-deftype).
        
*   Then the function instance is valid with [defined type](#syntax-deftype) [deftype](#syntax-deftype).
    

S[⊢](#valid-funcinst){[type](#syntax-funcinst) [deftype](#syntax-deftype),[module](#syntax-funcinst) [moduleinst](#syntax-moduleinst),[code](#syntax-funcinst) [func](#syntax-func)}:[deftype](#syntax-deftype)[⊢](#valid-deftype)[deftype](#syntax-deftype):[ok](#valid-deftype)S[⊢](#valid-moduleinst)[moduleinst](#syntax-moduleinst):CC[⊢](#valid-func)[func](#syntax-func):[deftype](#syntax-deftype)′C[⊢](#match-deftype)[deftype](#syntax-deftype)′[≤](#match-deftype)[deftype](#syntax-deftype)​​​

##### [Host Function Instances](#syntax-funcinst) {[type](#syntax-funcinst) [deftype](#syntax-deftype),[hostfunc](#syntax-funcinst) hf}[](#host-function-instances--hrefsyntax-funcinstmathsftypehrefsyntax-deftypemathitdeftype-hrefsyntax-funcinstmathsfhostfuncmathithf)

*   The [defined type](#syntax-deftype) [deftype](#syntax-deftype) must be [valid](#valid-deftype) under an empty [context](#context).
    
*   The [expansion](#aux-expand-deftype) of [defined type](#syntax-deftype) [deftype](#syntax-deftype) must be some [function type](#syntax-functype) [func](#syntax-comptype) \[t1∗​\][→](#syntax-comptype)\[t2∗​\].
    
*   For every [valid](#valid-store) [store](#syntax-store) S1​ [extending](#extend-store) S and every sequence [val](#syntax-val)∗ of [values](#syntax-val) whose [types](#valid-val) coincide with t1∗​:
    
    *   [Executing](#exec-invoke-host) hf in store S1​ with arguments [val](#syntax-val)∗ has a non-empty set of possible outcomes.
        
    *   For every element R of this set:
        
        *   Either R must be ⊥ (i.e., divergence).
            
        *   Or R consists of a [valid](#valid-store) [store](#syntax-store) S2​ [extending](#extend-store) S1​ and a [result](#syntax-result) [result](#syntax-result) whose [type](#valid-result) coincides with \[t2∗​\].
            
*   Then the function instance is valid with [defined type](#syntax-deftype) [deftype](#syntax-deftype).
    

S[⊢](#valid-funcinst){[type](#syntax-funcinst) [deftype](#syntax-deftype),[hostfunc](#syntax-funcinst) hf}:[deftype](#syntax-deftype)[⊢](#valid-deftype)[deftype](#syntax-deftype):[ok](#valid-deftype)[deftype](#syntax-deftype)≈[func](#syntax-comptype) \[t1∗​\][→](#syntax-comptype)\[t2∗​\]​∀S1​,[val](#syntax-val)∗, [⊢](#valid-store)S1​:[ok](#valid-store)∧[⊢](#extend-store)S[⪯](#extend)S1​∧S1​[⊢](#valid-result)[val](#syntax-val)∗:\[t1∗​\]⟹hf(S1​;[val](#syntax-val)∗)⊃∅∧∀R∈hf(S1​;[val](#syntax-val)∗), R\=⊥∨∃S2​,[result](#syntax-result), [⊢](#valid-store)S2​:[ok](#valid-store)∧[⊢](#extend-store)S1​[⪯](#extend)S2​∧S2​[⊢](#valid-result)[result](#syntax-result):\[t2∗​\]∧R\=(S2​;[result](#syntax-result))​​​

Note

This rule states that, if appropriate pre-conditions about store and arguments are satisfied, then executing the host function must satisfy appropriate post-conditions about store and results. The post-conditions match the ones in the [execution rule](#exec-invoke-host) for invoking host functions.

Any store under which the function is invoked is assumed to be an extension of the current store. That way, the function itself is able to make sufficient assumptions about future stores.

##### [Data Instances](#syntax-eleminst) {[bytes](#syntax-datainst) b∗}[](#data-instances---hrefsyntax-datainstmathsfbytesbast)

*   The data instance is valid.
    

S[⊢](#valid-datainst){[bytes](#syntax-datainst) b∗}:[ok](#valid-datainst)​

##### [Element Instances](#syntax-eleminst) {[type](#syntax-eleminst) t,[refs](#syntax-eleminst) [ref](#syntax-ref)∗}[](#element-instances---hrefsyntax-eleminstmathsftypet-hrefsyntax-eleminstmathsfrefshrefsyntax-refmathitrefast)

*   The [reference type](#syntax-reftype) t must be [valid](#valid-reftype) under the empty [context](#context).
    
*   For each [reference](#syntax-ref) [ref](#syntax-ref)i​ in the elements [ref](#syntax-ref)n:
    
    *   The [reference](#syntax-ref) [ref](#syntax-ref)i​ must be [valid](#valid-ref) with some [reference type](#syntax-reftype) ti′​.
        
    *   The [reference type](#syntax-reftype) ti′​ must [match](#match-reftype) the [reference type](#syntax-reftype) t.
        
*   Then the element instance is valid with [reference type](#syntax-reftype) t.
    

S[⊢](#valid-eleminst){[type](#syntax-eleminst) t,[refs](#syntax-eleminst) [ref](#syntax-ref)∗}:t[⊢](#valid-reftype)t:[ok](#valid-reftype)(S[⊢](#valid-val)[ref](#syntax-ref):t′)∗([⊢](#match-reftype)t′[≤](#match-valtype)t)∗​

##### [Structure Instances](#syntax-structinst) {[type](#syntax-structinst) [deftype](#syntax-deftype),[fields](#syntax-structinst) [fieldval](#syntax-fieldval)∗}[](#structure-instances---hrefsyntax-structinstmathsftypehrefsyntax-deftypemathitdeftype-hrefsyntax-structinstmathsffieldshrefsyntax-fieldvalmathitfieldvalast)

*   The [defined type](#syntax-deftype) [deftype](#syntax-deftype) must be [valid](#valid-deftype) under the empty [context](#context).
    
*   The [expansion](#aux-expand-deftype) of [deftype](#syntax-deftype) must be a [structure type](#syntax-structtype) [struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗.
    
*   The length of the sequence of [field values](#syntax-fieldval) [fieldval](#syntax-fieldval)∗ must be the same as the length of the sequence of [field types](#syntax-fieldtype) [fieldtype](#syntax-fieldtype)∗.
    
*   For each [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ in [fieldval](#syntax-fieldval)∗ and corresponding [field type](#syntax-fieldtype) [fieldtype](#syntax-fieldtype)i​ in [fieldtype](#syntax-fieldtype)∗:
    
    *   Let [fieldtype](#syntax-fieldtype)i​ be [mut](#syntax-mut) [storagetype](#syntax-storagetype)i​.
        
    *   The [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ must be [valid](#valid-fieldval) with [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)i​.
        
*   Then the structure instance is valid.
    

S[⊢](#valid-structinst){[type](#syntax-structinst) dt,[fields](#syntax-structinst) fv∗}:[ok](#valid-structinst)[⊢](#valid-deftype)dt:[ok](#valid-deftype)[expand](#aux-expand-deftype)(dt)\=[struct](#syntax-comptype) ([mut](#syntax-mut) st)∗(S[⊢](#valid-fieldval)fv:st)∗​

##### [Array Instances](#syntax-arrayinst) {[type](#syntax-arrayinst) [deftype](#syntax-deftype),[fields](#syntax-arrayinst) [fieldval](#syntax-fieldval)∗}[](#array-instances---hrefsyntax-arrayinstmathsftypehrefsyntax-deftypemathitdeftype-hrefsyntax-arrayinstmathsffieldshrefsyntax-fieldvalmathitfieldvalast)

*   The [defined type](#syntax-deftype) [deftype](#syntax-deftype) must be [valid](#valid-deftype) under the empty [context](#context).
    
*   The [expansion](#aux-expand-deftype) of [deftype](#syntax-deftype) must be an [array type](#syntax-arraytype) [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
    
*   Let [fieldtype](#syntax-fieldtype) be [mut](#syntax-mut) [storagetype](#syntax-storagetype).
    
*   For each [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ in [fieldval](#syntax-fieldval)∗:
    
    *   The [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ must be [valid](#valid-fieldval) with [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype).
        
*   Then the array instance is valid.
    

S[⊢](#valid-arrayinst){[type](#syntax-arrayinst) dt,[fields](#syntax-arrayinst) fv∗}:[ok](#valid-arrayinst)[⊢](#valid-deftype)dt:[ok](#valid-deftype)[expand](#aux-expand-deftype)(dt)\=[array](#syntax-comptype) ([mut](#syntax-mut) st)(S[⊢](#valid-fieldval)fv:st)∗​

##### [Field Values](#syntax-fieldval) [fieldval](#syntax-fieldval)[](#field-values--hrefsyntax-fieldvalmathitfieldval)

*   If [fieldval](#syntax-fieldval) is a [value](#syntax-val) [val](#syntax-val), then:
    
    *   The value [val](#syntax-val) must be [valid](#valid-val) with [value type](#syntax-valtype) t.
        
    *   Then the field value is valid with [value type](#syntax-valtype) t.
        
*   Else, [fieldval](#syntax-fieldval) is a [packed value](#syntax-packval) [packval](#syntax-packval):
    
    *   Let [packtype](#syntax-packtype).[pack](#syntax-packval) i be the field value [fieldval](#syntax-fieldval).
        
    *   Then the field value is valid with [packed type](#syntax-packtype) [packtype](#syntax-packtype).
        

S[⊢](#valid-packval)pt.[pack](#syntax-packval) i:pt​

##### [Exception Instances](#syntax-exninst) {[tag](#syntax-exninst) a,[fields](#syntax-exninst) [val](#syntax-val)∗}[](#exception-instances---hrefsyntax-exninstmathsftaga-hrefsyntax-exninstmathsffieldshrefsyntax-valmathitvalast)

*   The store entry S.[tags](#syntax-store)\[a\] must exist.
    
*   The [expansion](#aux-expand-deftype) of the [tag type](#syntax-tagtype) S.[tags](#syntax-store)\[a\].[type](#syntax-taginst) must be some [function type](#syntax-functype) [func](#syntax-comptype) \[t∗\][→](#syntax-comptype)\[t′∗\].
    
*   The [result type](#syntax-resulttype) \[t′∗\] must be empty.
    
*   The sequence [val](#syntax-val)ast of [values](#syntax-val) must have the same length as the sequence t∗ of [value types](#syntax-valtype).
    
*   For each value [val](#syntax-val)i​ in [val](#syntax-val)ast and corresponding value type ti​ in t∗, the value [val](#syntax-val)i​ must be valid with type ti​.
    
*   Then the exception instance is valid.
    

S[⊢](#valid-exninst){[tag](#syntax-exninst) a,[fields](#syntax-exninst) [val](#syntax-val)∗}:[ok](#valid-exninst)S.[tags](#syntax-store)\[a\].[type](#syntax-taginst)≈[func](#syntax-comptype) \[t∗\][→](#syntax-comptype)\[\](S[⊢](#valid-val)[val](#syntax-val):t)∗​

##### [Export Instances](#syntax-exportinst) {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) [externaddr](#syntax-externaddr)}[](#export-instances---hrefsyntax-exportinstmathsfnamehrefsyntax-namemathitname-hrefsyntax-exportinstmathsfaddrhrefsyntax-externaddrmathitexternaddr)

*   The [external address](#syntax-externaddr) [externaddr](#syntax-externaddr) must be [valid](#valid-externaddr) with some [external type](#syntax-externtype) [externtype](#syntax-externtype).
    
*   Then the export instance is valid.
    

S[⊢](#valid-exportinst){[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) [externaddr](#syntax-externaddr)}:[ok](#valid-exportinst)S[⊢](#valid-externaddr)[externaddr](#syntax-externaddr):[externtype](#syntax-externtype)​

##### [Module Instances](#syntax-moduleinst) [moduleinst](#syntax-moduleinst)[](#module-instances--hrefsyntax-moduleinstmathitmoduleinst)

*   Each [defined type](#syntax-deftype) [deftype](#syntax-deftype)i​ in [moduleinst](#syntax-moduleinst).[types](#syntax-moduleinst) must be [valid](#valid-deftype) under the empty [context](#context).
    
*   For each [tag address](#syntax-tagaddr) [tagaddr](#syntax-tagaddr)i​ in [moduleinst](#syntax-moduleinst).[tags](#syntax-moduleinst), the [external address](#syntax-externaddr) [tag](#syntax-externaddr) [tagaddr](#syntax-tagaddr)i​ must be [valid](#valid-externaddr-tag) with some [external type](#syntax-externtype) [tag](#syntax-externtype) [tagtype](#syntax-tagtype)i​.
    
*   For each [global address](#syntax-globaladdr) [globaladdr](#syntax-globaladdr)i​ in [moduleinst](#syntax-moduleinst).[globals](#syntax-moduleinst), the [external address](#syntax-externaddr) [global](#syntax-externaddr) [globaladdr](#syntax-globaladdr)i​ must be [valid](#valid-externaddr-global) with some [external type](#syntax-externtype) [global](#syntax-externtype) [globaltype](#syntax-globaltype)i​.
    
*   For each [memory address](#syntax-memaddr) [memaddr](#syntax-memaddr)i​ in [moduleinst](#syntax-moduleinst).[mems](#syntax-moduleinst), the [external address](#syntax-externaddr) [mem](#syntax-externaddr) [memaddr](#syntax-memaddr)i​ must be [valid](#valid-externaddr-mem) with some [external type](#syntax-externtype) [mem](#syntax-externtype) [memtype](#syntax-memtype)i​.
    
*   For each [table address](#syntax-tableaddr) [tableaddr](#syntax-tableaddr)i​ in [moduleinst](#syntax-moduleinst).[tables](#syntax-moduleinst), the [external address](#syntax-externaddr) [table](#syntax-externaddr) [tableaddr](#syntax-tableaddr)i​ must be [valid](#valid-externaddr-table) with some [external type](#syntax-externtype) [table](#syntax-externtype) [tabletype](#syntax-tabletype)i​.
    
*   For each [function address](#syntax-funcaddr) [funcaddr](#syntax-funcaddr)i​ in [moduleinst](#syntax-moduleinst).[funcs](#syntax-moduleinst), the [external address](#syntax-externaddr) [func](#syntax-externaddr) [funcaddr](#syntax-funcaddr)i​ must be [valid](#valid-externaddr-func) with some [external type](#syntax-externtype) [func](#syntax-externtype) [deftype](#syntax-deftype)Fi​.
    
*   For each [data address](#syntax-dataaddr) [dataaddr](#syntax-dataaddr)i​ in [moduleinst](#syntax-moduleinst).[datas](#syntax-moduleinst), the [data instance](#syntax-datainst) S.[datas](#syntax-store)\[[dataaddr](#syntax-dataaddr)i​\] must be [valid](#valid-datainst) with oki​.
    
*   For each [element address](#syntax-elemaddr) [elemaddr](#syntax-elemaddr)i​ in [moduleinst](#syntax-moduleinst).[elems](#syntax-moduleinst), the [element instance](#syntax-eleminst) S.[elems](#syntax-store)\[[elemaddr](#syntax-elemaddr)i​\] must be [valid](#valid-eleminst) with some [reference type](#syntax-reftype) [reftype](#syntax-reftype)i​.
    
*   Each [export instance](#syntax-exportinst) [exportinst](#syntax-exportinst)i​ in [moduleinst](#syntax-moduleinst).[exports](#syntax-moduleinst) must be [valid](#valid-exportinst).
    
*   For each [export instance](#syntax-exportinst) [exportinst](#syntax-exportinst)i​ in [moduleinst](#syntax-moduleinst).[exports](#syntax-moduleinst), the [name](#syntax-name) [exportinst](#syntax-exportinst)i​.[name](#syntax-exportinst) must be different from any other name occurring in [moduleinst](#syntax-moduleinst).[exports](#syntax-moduleinst).
    
*   Let [deftype](#syntax-deftype)∗ be the concatenation of all [deftype](#syntax-deftype)i​ in order.
    
*   Let [tagtype](#syntax-tagtype)∗ be the concatenation of all [tagtype](#syntax-tagtype)i​ in order.
    
*   Let [globaltype](#syntax-globaltype)∗ be the concatenation of all [globaltype](#syntax-globaltype)i​ in order.
    
*   Let [memtype](#syntax-memtype)∗ be the concatenation of all [memtype](#syntax-memtype)i​ in order.
    
*   Let [tabletype](#syntax-tabletype)∗ be the concatenation of all [tabletype](#syntax-tabletype)i​ in order.
    
*   Let [deftype](#syntax-deftype)F∗​ be the concatenation of all [deftype](#syntax-deftype)Fi​ in order.
    
*   Let [reftype](#syntax-reftype)∗ be the concatenation of all [reftype](#syntax-reftype)i​ in order.
    
*   Let ok∗ be the concatenation of all oki​ in order.
    
*   Let m be the length of [moduleinst](#syntax-moduleinst).[funcs](#syntax-moduleinst).
    
*   Let x∗ be the sequence of [function indices](#syntax-funcidx) from 0 to m−1.
    
*   Then the module instance is valid with [context](#context) {[types](#context) [deftype](#syntax-deftype)∗, [tags](#context) [tagtype](#syntax-tagtype)∗, [globals](#context) [globaltype](#syntax-globaltype)∗, [mems](#context) [memtype](#syntax-memtype)∗, [tables](#context) [tabletype](#syntax-tabletype)∗, [funcs](#context) [deftype](#syntax-deftype)F∗​, [datas](#context) ok∗, [elems](#context) [reftype](#syntax-reftype)∗, [refs](#context) x∗}.
    

−1ex\]S[⊢](#valid-moduleinst){[types](#syntax-moduleinst)[tags](#syntax-moduleinst)[globals](#syntax-moduleinst)[mems](#syntax-moduleinst)[tables](#syntax-moduleinst)[funcs](#syntax-moduleinst)[datas](#syntax-moduleinst)[elems](#syntax-moduleinst)[exports](#syntax-moduleinst)​[deftype](#syntax-deftype)∗,[tagaddr](#syntax-tagaddr)∗,[globaladdr](#syntax-globaladdr)∗,[memaddr](#syntax-memaddr)∗,[tableaddr](#syntax-tableaddr)∗,[funcaddr](#syntax-funcaddr)∗,[dataaddr](#syntax-dataaddr)∗,[elemaddr](#syntax-elemaddr)∗,[exportinst](#syntax-exportinst)∗ }:{[types](#context)[tags](#context)[globals](#context)[mems](#context)[tables](#context)[funcs](#context)[datas](#context)[elems](#context)[refs](#context)​[deftype](#syntax-deftype)∗,[tagtype](#syntax-tagtype)∗,[globaltype](#syntax-globaltype)∗,[memtype](#syntax-memtype)∗,[tabletype](#syntax-tabletype)∗,[deftype](#syntax-deftype)F∗​,ok∗,[reftype](#syntax-reftype)∗,0…(∣[funcaddr](#syntax-funcaddr)∗∣−1) }​​([⊢](#valid-deftype)[deftype](#syntax-deftype):[ok](#valid-deftype))∗(S[⊢](#valid-externaddr)[tag](#syntax-externaddr) [tagaddr](#syntax-tagaddr):[tag](#syntax-externtype) [tagtype](#syntax-tagtype))∗(S[⊢](#valid-externaddr)[global](#syntax-externaddr) [globaladdr](#syntax-globaladdr):[global](#syntax-externtype) [globaltype](#syntax-globaltype))∗(S[⊢](#valid-externaddr)[func](#syntax-externaddr) [funcaddr](#syntax-funcaddr):[func](#syntax-externtype) [deftype](#syntax-deftype)F​)∗(S[⊢](#valid-externaddr)[mem](#syntax-externaddr) [memaddr](#syntax-memaddr):[mem](#syntax-externtype) [memtype](#syntax-memtype))∗(S[⊢](#valid-externaddr)[table](#syntax-externaddr) [tableaddr](#syntax-tableaddr):[table](#syntax-externtype) [tabletype](#syntax-tabletype))∗(S[⊢](#valid-datainst)S.[datas](#syntax-store)\[[dataaddr](#syntax-dataaddr)\]:ok)∗(S[⊢](#valid-eleminst)S.[elems](#syntax-store)\[[elemaddr](#syntax-elemaddr)\]:[reftype](#syntax-reftype))∗(S[⊢](#valid-exportinst)[exportinst](#syntax-exportinst):[ok](#valid-exportinst))∗([exportinst](#syntax-exportinst).[name](#syntax-exportinst))∗ disjoint​​​

#### Configuration Validity[](#configuration-validity①)

To relate the WebAssembly [type system](#valid) to its [execution semantics](#exec), the [typing rules for instructions](#valid-instr) must be extended to [configurations](#syntax-config) S;T, which relates the [store](#syntax-store) to execution [threads](#syntax-thread).

Configurations and threads are classified by their [result type](#syntax-resulttype). In addition to the store S, threads are typed under a _return type_ [resulttype](#syntax-resulttype)?, which controls whether and with which type a [return](#syntax-instr-control) instruction is allowed. This type is absent (ϵ) except for instruction sequences inside an administrative [frame](#syntax-frame) instruction.

Finally, [frames](#syntax-frame) are classified with _frame contexts_, which extend the [module contexts](#module-context) of a frame’s associated [module instance](#syntax-moduleinst) with the [locals](#syntax-local) that the frame contains.

##### [Configurations](#syntax-config) S;T[](#configurations--st)

*   The [store](#syntax-store) S must be [valid](#valid-store).
    
*   Under no allowed return type, the [thread](#syntax-thread) T must be [valid](#valid-thread) with some [result type](#syntax-resulttype) \[t∗\].
    
*   Then the configuration is valid with the [result type](#syntax-resulttype) \[t∗\].
    

[⊢](#valid-config)S;T:\[t∗\][⊢](#valid-store)S:[ok](#valid-store)S;ϵ[⊢](#valid-thread)T:\[t∗\]​

##### [Threads](#syntax-thread) F;[instr](#syntax-instr)∗[](#threads--fhrefsyntax-instrmathitinstrast)

*   Let [resulttype](#syntax-resulttype)? be the current allowed return type.
    
*   The [frame](#syntax-frame) F must be [valid](#valid-frame) with a [context](#context) C.
    
*   Let C′ be the same [context](#context) as C, but with [return](#context) set to [resulttype](#syntax-resulttype)?.
    
*   Under context C′, the instruction sequence [instr](#syntax-instr)∗ must be [valid](#valid-instrs) with some type \[\][→](#syntax-instrtype)\[t∗\].
    
*   Then the thread is valid with the [result type](#syntax-resulttype) \[t∗\].
    

S;[resulttype](#syntax-resulttype)?[⊢](#valid-thread)F;[instr](#syntax-instr)∗:\[t∗\]S[⊢](#valid-frame)F:CS;C,[return](#context) [resulttype](#syntax-resulttype)?[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[\][→](#syntax-instrtype)\[t∗\]​

##### [Frames](#syntax-frame) {[locals](#syntax-frame) [val](#syntax-val)∗,[module](#syntax-frame) [moduleinst](#syntax-moduleinst)}[](#frames--hrefsyntax-framemathsflocalshrefsyntax-valmathitvalast-hrefsyntax-framemathsfmodulehrefsyntax-moduleinstmathitmoduleinst)

*   The [module instance](#syntax-moduleinst) [moduleinst](#syntax-moduleinst) must be [valid](#valid-moduleinst) with some [module context](#module-context) C.
    
*   Each [value](#syntax-val) [val](#syntax-val)i​ in [val](#syntax-val)∗ must be [valid](#valid-val) with some [value type](#syntax-valtype) ti​.
    
*   Let t∗ be the concatenation of all ti​ in order.
    
*   Let C′ be the same [context](#context) as C, but with the [value types](#syntax-valtype) t∗ prepended to the [locals](#context) list.
    
*   Then the frame is valid with [frame context](#frame-context) C′.
    

S[⊢](#valid-frame){[locals](#syntax-frame) [val](#syntax-val)∗,[module](#syntax-frame) [moduleinst](#syntax-moduleinst)}:(C,[locals](#context) t∗)S[⊢](#valid-moduleinst)[moduleinst](#syntax-moduleinst):C(S[⊢](#valid-val)[val](#syntax-val):t)∗​

#### Administrative Instructions[](#administrative-instructions③)

Typing rules for [administrative instructions](#syntax-instr-admin) are specified as follows. In addition to the [context](#context) C, typing of these instructions is defined under a given [store](#syntax-store) S.

To that end, all previous typing judgements C⊢prop are generalized to include the store, as in S;C⊢prop, by implicitly adding S to all rules – S is never modified by the pre-existing rules, but it is accessed in the extra rules for [administrative instructions](#valid-instr-admin) given below.

##### [trap](#syntax-trap)[](#-hrefsyntax-trapmathsftrap)

*   The instruction is valid with any [valid](#valid-instrtype) [instruction type](#syntax-instrtype) of the form \[t1∗​\][→](#syntax-instrtype)\[t2∗​\].
    

S;C[⊢](#valid-instr-admin)[trap](#syntax-trap):\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]C[⊢](#valid-instrtype)\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]:[ok](#valid-instrtype)​

##### [val](#syntax-val)[](#-hrefsyntax-valmathitval)

*   The value [val](#syntax-val) must be valid with [value type](#syntax-valtype) t.
    
*   Then it is valid as an instruction with type \[\][→](#syntax-instrtype)\[t\].
    

S;C[⊢](#valid-instr-admin)[val](#syntax-val):\[\][→](#syntax-instrtype)\[t\]S[⊢](#valid-val)[val](#syntax-val):t​

##### [label](#syntax-label)n​{[instr](#syntax-instr)0∗​} [instr](#syntax-instr)∗[](#-hrefsyntax-labelmathsflabel_nhrefsyntax-instrmathitinstr_0asthrefsyntax-instrmathitinstrast)

*   The instruction sequence [instr](#syntax-instr)0∗​ must be [valid](#valid-instrs) with some type \[t1n​\][→](#syntax-instrtype)x∗​\[t2∗​\].
    
*   Let C′ be the same [context](#context) as C, but with the [result type](#syntax-resulttype) \[t1n​\] prepended to the [labels](#context) list.
    
*   Under context C′, the instruction sequence [instr](#syntax-instr)∗ must be [valid](#valid-instrs) with type \[\][→](#syntax-instrtype)x′∗​\[t2∗​\].
    
*   Then the compound instruction is valid with type \[\][→](#syntax-instrtype)\[t2∗​\].
    

S;C[⊢](#valid-instr-admin)[label](#syntax-label)n​{[instr](#syntax-instr)0∗​} [instr](#syntax-instr)∗:\[\][→](#syntax-instrtype)\[t2∗​\]S;C[⊢](#valid-instrs)[instr](#syntax-instr)0∗​:\[t1n​\][→](#syntax-instrtype)x∗​\[t2∗​\]S;C,[labels](#context)\[t1n​\][⊢](#valid-instrs)[instr](#syntax-instr)∗:\[\][→](#syntax-instrtype)x′∗​\[t2∗​\]​

##### [frame](#syntax-frame)n​{F} [instr](#syntax-instr)∗[](#-hrefsyntax-framemathsfframe_nfhrefsyntax-instrmathitinstrast)

*   Under the [valid](#valid-resulttype) return type \[tn\], the [thread](#syntax-frame) F;[instr](#syntax-instr)∗ must be [valid](#valid-frame) with [result type](#syntax-resulttype) \[tn\].
    
*   Then the compound instruction is valid with type \[\][→](#syntax-instrtype)\[tn\].
    

S;C[⊢](#valid-instr-admin)[frame](#syntax-frame)n​{F} [instr](#syntax-instr)∗:\[\][→](#syntax-instrtype)\[tn\]C[⊢](#valid-resulttype)\[tn\]:[ok](#valid-resulttype)S;\[tn\][⊢](#valid-instrs)F;[instr](#syntax-instr)∗:\[tn\]​

##### [handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [instr](#syntax-instr)∗[](#-hrefsyntax-handlermathsfhandler_nhrefsyntax-catchmathitcatchasthrefsyntax-instrmathitinstrast)

*   For every [catch clause](#syntax-catch) [catch](#syntax-catch)i​ in [catch](#syntax-catch)∗, [catch](#syntax-catch)i​ must be [valid](#valid-catch).
    
*   The instruction sequence [instr](#syntax-instr)∗ must be [valid](#valid-instrs) with some type \[t1∗​\][→](#syntax-instrtype)\[t2∗​\].
    
*   Then the compound instruction is valid with type \[t1∗​\][→](#syntax-instrtype)\[t2∗​\].
    

S;C[⊢](#valid-instr-admin)[handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)\[t2∗​\](C[⊢](#valid-catch)[catch](#syntax-catch):[ok](#valid-catch))∗S;C[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]​​​

#### Store Extension[](#store-extension①)

Programs can mutate the [store](#syntax-store) and its contained instances. Any such modification must respect certain invariants, such as not removing allocated instances or changing immutable definitions. While these invariants are inherent to the execution semantics of WebAssembly [instructions](#exec-instr) and [modules](#exec-instantiation), [host functions](#syntax-hostfunc) do not automatically adhere to them. Consequently, the required invariants must be stated as explicit constraints on the [invocation](#exec-invoke-host) of host functions. Soundness only holds when the [embedder](#embedder) ensures these constraints.

The necessary constraints are codified by the notion of store _extension_: a store state S′ extends state S, written S[⪯](#extend)S′, when the following rules hold.

Note

Extension does not imply that the new store is valid, which is defined separately [above](#valid-store).

##### [Store](#syntax-store) S[](#store--s①)

*   The length of S.[tags](#syntax-store) must not shrink.
    
*   The length of S.[globals](#syntax-store) must not shrink.
    
*   The length of S.[mems](#syntax-store) must not shrink.
    
*   The length of S.[tables](#syntax-store) must not shrink.
    
*   The length of S.[funcs](#syntax-store) must not shrink.
    
*   The length of S.[datas](#syntax-store) must not shrink.
    
*   The length of S.[elems](#syntax-store) must not shrink.
    
*   The length of S.[structs](#syntax-store) must not shrink.
    
*   The length of S.[arrays](#syntax-store) must not shrink.
    
*   The length of S.[exns](#syntax-store) must not shrink.
    
*   For each [tag instance](#syntax-taginst) [taginst](#syntax-taginst)i​ in the original S.[tags](#syntax-store), the new tag instance must be an [extension](#extend-taginst) of the old.
    
*   For each [global instance](#syntax-globalinst) [globalinst](#syntax-globalinst)i​ in the original S.[globals](#syntax-store), the new global instance must be an [extension](#extend-globalinst) of the old.
    
*   For each [memory instance](#syntax-meminst) [meminst](#syntax-meminst)i​ in the original S.[mems](#syntax-store), the new memory instance must be an [extension](#extend-meminst) of the old.
    
*   For each [table instance](#syntax-tableinst) [tableinst](#syntax-tableinst)i​ in the original S.[tables](#syntax-store), the new table instance must be an [extension](#extend-tableinst) of the old.
    
*   For each [function instance](#syntax-funcinst) [funcinst](#syntax-funcinst)i​ in the original S.[funcs](#syntax-store), the new function instance must be an [extension](#extend-funcinst) of the old.
    
*   For each [data instance](#syntax-datainst) [datainst](#syntax-datainst)i​ in the original S.[datas](#syntax-store), the new data instance must be an [extension](#extend-datainst) of the old.
    
*   For each [element instance](#syntax-eleminst) [eleminst](#syntax-eleminst)i​ in the original S.[elems](#syntax-store), the new element instance must be an [extension](#extend-eleminst) of the old.
    
*   For each [structure instance](#syntax-structinst) [structinst](#syntax-structinst)i​ in the original S.[structs](#syntax-store), the new structure instance must be an [extension](#extend-structinst) of the old.
    
*   For each [array instance](#syntax-arrayinst) [arrayinst](#syntax-arrayinst)i​ in the original S.[arrays](#syntax-store), the new array instance must be an [extension](#extend-arrayinst) of the old.
    
*   For each [exception instance](#syntax-exninst) [exninst](#syntax-exninst)i​ in the original S.[exns](#syntax-store), the new exception instance must be an [extension](#extend-datainst) of the old.
    

[⊢](#extend-store)S1​[⪯](#extend)S2​S1​.[tags](#syntax-store)\=[taginst](#syntax-taginst)1∗​S1​.[globals](#syntax-store)\=[globalinst](#syntax-globalinst)1∗​S1​.[mems](#syntax-store)\=[meminst](#syntax-meminst)1∗​S1​.[tables](#syntax-store)\=[tableinst](#syntax-tableinst)1∗​S1​.[funcs](#syntax-store)\=[funcinst](#syntax-funcinst)1∗​S1​.[datas](#syntax-store)\=[datainst](#syntax-datainst)1∗​S1​.[elems](#syntax-store)\=[eleminst](#syntax-eleminst)1∗​S1​.[structs](#syntax-store)\=[structinst](#syntax-structinst)1∗​S1​.[arrays](#syntax-store)\=[arrayinst](#syntax-arrayinst)1∗​S1​.[exns](#syntax-store)\=[exninst](#syntax-exninst)1∗​​S2​.[tags](#syntax-store)\=[taginst](#syntax-taginst)1′​∗ [taginst](#syntax-taginst)2∗​S2​.[globals](#syntax-store)\=[globalinst](#syntax-globalinst)1′​∗ [globalinst](#syntax-globalinst)2∗​S2​.[mems](#syntax-store)\=[meminst](#syntax-meminst)1′​∗ [meminst](#syntax-meminst)2∗​S2​.[tables](#syntax-store)\=[tableinst](#syntax-tableinst)1′​∗ [tableinst](#syntax-tableinst)2∗​S2​.[funcs](#syntax-store)\=[funcinst](#syntax-funcinst)1′​∗ [funcinst](#syntax-funcinst)2∗​S2​.[datas](#syntax-store)\=[datainst](#syntax-datainst)1′​∗ [datainst](#syntax-datainst)2∗​S2​.[elems](#syntax-store)\=[eleminst](#syntax-eleminst)1′​∗ [eleminst](#syntax-eleminst)2∗​S2​.[structs](#syntax-store)\=[structinst](#syntax-structinst)1′​∗ [structinst](#syntax-structinst)2∗​S2​.[arrays](#syntax-store)\=[arrayinst](#syntax-arrayinst)1′​∗ [arrayinst](#syntax-arrayinst)2∗​S2​.[exns](#syntax-store)\=[exninst](#syntax-exninst)1′​∗ [exninst](#syntax-exninst)2∗​​([⊢](#extend-taginst)[taginst](#syntax-taginst)1​[⪯](#extend)[taginst](#syntax-taginst)1′​)∗([⊢](#extend-globalinst)[globalinst](#syntax-globalinst)1​[⪯](#extend)[globalinst](#syntax-globalinst)1′​)∗([⊢](#extend-meminst)[meminst](#syntax-meminst)1​[⪯](#extend)[meminst](#syntax-meminst)1′​)∗([⊢](#extend-tableinst)[tableinst](#syntax-tableinst)1​[⪯](#extend)[tableinst](#syntax-tableinst)1′​)∗([⊢](#extend-funcinst)[funcinst](#syntax-funcinst)1​[⪯](#extend)[funcinst](#syntax-funcinst)1′​)∗([⊢](#extend-datainst)[datainst](#syntax-datainst)1​[⪯](#extend)[datainst](#syntax-datainst)1′​)∗([⊢](#extend-eleminst)[eleminst](#syntax-eleminst)1​[⪯](#extend)[eleminst](#syntax-eleminst)1′​)∗([⊢](#extend-structinst)[structinst](#syntax-structinst)1​[⪯](#extend)[structinst](#syntax-structinst)1′​)∗([⊢](#extend-arrayinst)[arrayinst](#syntax-arrayinst)1​[⪯](#extend)[arrayinst](#syntax-arrayinst)1′​)∗([⊢](#extend-exninst)[exninst](#syntax-exninst)1​[⪯](#extend)[exninst](#syntax-exninst)1′​)∗​​​

##### [Tag Instance](#syntax-taginst) [taginst](#syntax-taginst)[](#tag-instance--hrefsyntax-taginstmathittaginst)

*   A tag instance must remain unchanged.
    

[⊢](#extend-taginst)[taginst](#syntax-taginst)[⪯](#extend)[taginst](#syntax-taginst)​

##### [Global Instance](#syntax-globalinst) [globalinst](#syntax-globalinst)[](#global-instance--hrefsyntax-globalinstmathitglobalinst)

*   The [global type](#syntax-globaltype) [globalinst](#syntax-globalinst).[type](#syntax-globalinst) must remain unchanged.
    
*   Let [mut](#syntax-mut) t be the structure of [globalinst](#syntax-globalinst).[type](#syntax-globalinst).
    
*   If [mut](#syntax-mut) is empty, then the [value](#syntax-val) [globalinst](#syntax-globalinst).[value](#syntax-globalinst) must remain unchanged.
    

[⊢](#extend-globalinst){[type](#syntax-globalinst) ([mut](#syntax-mut) t),[value](#syntax-globalinst) [val](#syntax-val)1​}[⪯](#extend){[type](#syntax-globalinst) ([mut](#syntax-mut) t),[value](#syntax-globalinst) [val](#syntax-val)2​}[mut](#syntax-mut)\=[mut](#syntax-mut)∨[val](#syntax-val)1​\=[val](#syntax-val)2​​

##### [Memory Instance](#syntax-meminst) [meminst](#syntax-meminst)[](#memory-instance--hrefsyntax-meminstmathitmeminst)

*   The [memory type](#syntax-memtype) [meminst](#syntax-meminst).[type](#syntax-meminst) must remain unchanged.
    
*   The length of [meminst](#syntax-meminst).[bytes](#syntax-meminst) must not shrink.
    

[⊢](#extend-meminst){[type](#syntax-meminst) mt,[bytes](#syntax-meminst) b1n1​​}[⪯](#extend){[type](#syntax-meminst) mt,[bytes](#syntax-meminst) b2n2​​}n1​≤n2​​

##### [Table Instance](#syntax-tableinst) [tableinst](#syntax-tableinst)[](#table-instance--hrefsyntax-tableinstmathittableinst)

*   The [table type](#syntax-tabletype) [tableinst](#syntax-tableinst).[type](#syntax-tableinst) must remain unchanged.
    
*   The length of [tableinst](#syntax-tableinst).[refs](#syntax-tableinst) must not shrink.
    

[⊢](#extend-tableinst){[type](#syntax-tableinst) tt,[refs](#syntax-tableinst) (fa1?​)n1​}[⪯](#extend){[type](#syntax-tableinst) tt,[refs](#syntax-tableinst) (fa2?​)n2​}n1​≤n2​​

##### [Function Instance](#syntax-funcinst) [funcinst](#syntax-funcinst)[](#function-instance--hrefsyntax-funcinstmathitfuncinst)

*   A function instance must remain unchanged.
    

[⊢](#extend-funcinst)[funcinst](#syntax-funcinst)[⪯](#extend)[funcinst](#syntax-funcinst)​

##### [Data Instance](#syntax-datainst) [datainst](#syntax-datainst)[](#data-instance--hrefsyntax-datainstmathitdatainst)

*   The list [datainst](#syntax-datainst).[bytes](#syntax-datainst) must:
    
    *   either remain unchanged,
        
    *   or shrink to length 0.
        

[⊢](#extend-datainst){[bytes](#syntax-datainst) b∗}[⪯](#extend){[bytes](#syntax-datainst) b∗}​

[⊢](#extend-datainst){[bytes](#syntax-datainst) b∗}[⪯](#extend){[bytes](#syntax-datainst) ϵ}​

##### [Element Instance](#syntax-eleminst) [eleminst](#syntax-eleminst)[](#element-instance--hrefsyntax-eleminstmathiteleminst)

*   The [reference type](#syntax-reftype) [eleminst](#syntax-eleminst).[type](#syntax-eleminst) must remain unchanged.
    
*   The list [eleminst](#syntax-eleminst).[refs](#syntax-eleminst) must:
    
    *   either remain unchanged,
        
    *   or shrink to length 0.
        

[⊢](#extend-eleminst){[type](#syntax-eleminst) t,[refs](#syntax-eleminst) a∗}[⪯](#extend){[type](#syntax-eleminst) t,[refs](#syntax-eleminst) a∗}​

[⊢](#extend-eleminst){[type](#syntax-eleminst) t,[refs](#syntax-eleminst) a∗}[⪯](#extend){[type](#syntax-eleminst) t,[refs](#syntax-eleminst) ϵ}​

##### [Structure Instance](#syntax-structinst) [structinst](#syntax-structinst)[](#structure-instance--hrefsyntax-structinstmathitstructinst)

*   The [defined type](#syntax-deftype) [structinst](#syntax-structinst).[type](#syntax-structinst) must remain unchanged.
    
*   Assert: due to [store well-formedness](#valid-structinst), the [expansion](#aux-expand-deftype) of [structinst](#syntax-structinst).[type](#syntax-structinst) is a [structure type](#syntax-structtype).
    
*   Let [struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗ be the [expansion](#aux-expand-deftype) of [structinst](#syntax-structinst).[type](#syntax-structinst).
    
*   The length of the list [structinst](#syntax-structinst).[fields](#syntax-structinst) must remain unchanged.
    
*   Assert: due to [store well-formedness](#valid-structinst), the length of [structinst](#syntax-structinst).[fields](#syntax-structinst) is the same as the length of [fieldtype](#syntax-fieldtype)∗.
    
*   For each [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ in [structinst](#syntax-structinst).[fields](#syntax-structinst) and corresponding [field type](#syntax-fieldtype) [fieldtype](#syntax-fieldtype)i​ in [fieldtype](#syntax-fieldtype)∗:
    
    *   Let [mut](#syntax-mut)i​ sti​ be the structure of [fieldtype](#syntax-fieldtype)i​.
        
    *   If [mut](#syntax-mut)i​ is empty, then the [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ must remain unchanged.
        

[⊢](#extend-structinst){[type](#syntax-structinst) ([mut](#syntax-mut) st)∗,[fields](#syntax-structinst) [fieldval](#syntax-fieldval)1∗​}[⪯](#extend){[type](#syntax-structinst) ([mut](#syntax-mut) st)∗,[fields](#syntax-structinst) [fieldval](#syntax-fieldval)2∗​}([mut](#syntax-mut)\=[mut](#syntax-mut)∨[fieldval](#syntax-fieldval)1​\=[fieldval](#syntax-fieldval)2​)∗​

##### [Array Instance](#syntax-arrayinst) [arrayinst](#syntax-arrayinst)[](#array-instance--hrefsyntax-arrayinstmathitarrayinst)

*   The [defined type](#syntax-deftype) [arrayinst](#syntax-arrayinst).[type](#syntax-arrayinst) must remain unchanged.
    
*   Assert: due to [store well-formedness](#valid-arrayinst), the [expansion](#aux-expand-deftype) of [arrayinst](#syntax-arrayinst).[type](#syntax-arrayinst) is an [array type](#syntax-arraytype).
    
*   Let [array](#syntax-comptype) [fieldtype](#syntax-fieldtype) be the [expansion](#aux-expand-deftype) of [arrayinst](#syntax-arrayinst).[type](#syntax-arrayinst).
    
*   The length of the list [arrayinst](#syntax-arrayinst).[fields](#syntax-arrayinst) must remain unchanged.
    
*   Let [mut](#syntax-mut) st be the structure of [fieldtype](#syntax-fieldtype).
    
*   If [mut](#syntax-mut) is empty, then the sequence of [field values](#syntax-fieldval) [arrayinst](#syntax-arrayinst).[fields](#syntax-arrayinst) must remain unchanged.
    

[⊢](#extend-arrayinst){[type](#syntax-arrayinst) ([mut](#syntax-mut) st),[fields](#syntax-arrayinst) [fieldval](#syntax-fieldval)1∗​}[⪯](#extend){[type](#syntax-arrayinst) ([mut](#syntax-mut) st),[fields](#syntax-arrayinst) [fieldval](#syntax-fieldval)2∗​}[mut](#syntax-mut)\=[mut](#syntax-mut)∨[fieldval](#syntax-fieldval)1∗​\=[fieldval](#syntax-fieldval)2∗​​

##### [Exception Instance](#syntax-exninst) [exninst](#syntax-exninst)[](#exception-instance--hrefsyntax-exninstmathitexninst)

*   An exception instance must remain unchanged.
    

[⊢](#extend-exninst)[exninst](#syntax-exninst)[⪯](#extend)[exninst](#syntax-exninst)​

#### Theorems[](#theorems①)

Given the definition of [valid configurations](#valid-config), the standard soundness theorems hold. [\[2\]](#cite-cpp2018) [\[3\]](#cite-fm2021)

**Theorem (Preservation).** If a [configuration](#syntax-config) S;T is [valid](#valid-config) with [result type](#syntax-resulttype) \[t∗\] (i.e., [⊢](#valid-config)S;T:\[t∗\]), and steps to S′;T′ (i.e., S;T[↪](#exec-notation)S′;T′), then S′;T′ is a valid configuration with the same result type (i.e., [⊢](#valid-config)S′;T′:\[t∗\]). Furthermore, S′ is an [extension](#extend-store) of S (i.e., [⊢](#extend-store)S[⪯](#extend)S′).

A _terminal_ [thread](#syntax-thread) is one whose sequence of [instructions](#syntax-instr) is a [result](#syntax-result). A terminal configuration is a configuration whose thread is terminal.

**Theorem (Progress).** If a [configuration](#syntax-config) S;T is [valid](#valid-config) (i.e., [⊢](#valid-config)S;T:\[t∗\] for some [result type](#syntax-resulttype) \[t∗\]), then either it is terminal, or it can step to some configuration S′;T′ (i.e., S;T[↪](#exec-notation)S′;T′).

From Preservation and Progress the soundness of the WebAssembly type system follows directly.

**Corollary (Soundness).** If a [configuration](#syntax-config) S;T is [valid](#valid-config) (i.e., [⊢](#valid-config)S;T:\[t∗\] for some [result type](#syntax-resulttype) \[t∗\]), then it either diverges or takes a finite number of steps to reach a terminal configuration S′;T′ (i.e., S;T[↪](#exec-notation)∗S′;T′) that is valid with the same result type (i.e., [⊢](#valid-config)S′;T′:\[t∗\]) and where S′ is an [extension](#extend-store) of S (i.e., [⊢](#extend-store)S[⪯](#extend)S′).

In other words, every thread in a valid configuration either runs forever, traps, throws an exception, or terminates with a result that has the expected type. Consequently, given a [valid store](#valid-store), no computation defined by [instantiation](#exec-instantiation) or [invocation](#exec-invocation) of a valid module can “crash” or otherwise (mis)behave in ways not covered by the [execution](#exec) semantics given in this specification.

\[[1](#id1)\]

The formalization and theorems are derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. [Bringing the Web up to Speed with WebAssembly](https://dl.acm.org/citation.cfm?doid=3062341.3062363). Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.

\[[2](#id3)\]

A machine-verified version of the formalization and soundness proof of the PLDI 2017 paper is described in the following article: Conrad Watt. [Mechanising and Verifying the WebAssembly Specification](https://dl.acm.org/citation.cfm?id=3167082). Proceedings of the 7th ACM SIGPLAN Conference on Certified Programs and Proofs (CPP 2018). ACM 2018.

\[[3](#id4)\]

Machine-verified formalizations and soundness proofs of the semantics from the official specification are described in the following article: Conrad Watt, Xiaojia Rao, Jean Pichon-Pharabod, Martin Bodin, Philippa Gardner. [Two Mechanisations of WebAssembly 1.0](https://link.springer.com/chapter/10.1007/978-3-030-90870-6_4). Proceedings of the 24th International Symposium on Formal Methods (FM 2021). Springer 2021.

### A.7 Type System Properties[](#a7-type-system-properties)

#### Principal Types[](#principal-types①)

The [type system](#type-system) of WebAssembly features both [subtyping](#match) and simple forms of [polymorphism](#polymorphism) for [instruction types](#syntax-instrtype). That has the effect that every instruction or instruction sequence can be classified with multiple different instruction types.

However, the typing rules still allow deriving _principal types_ for instruction sequences. That is, every valid instruction sequence has one particular type scheme, possibly containing some unconstrained place holder _type variables_, that is a subtype of all its valid instruction types, after substituting its type variables with suitable specific types.

Moreover, when deriving an instruction type in a “forward” manner, i.e., the _input_ of the instruction sequence is already fixed to specific types, then it has a principal _output_ type expressible without type variables, up to a possibly [polymorphic stack](#polymorphism) bottom representable with one single variable. In other words, “forward” principal types are effectively _closed_.

Note

For example, in isolation, the instruction [ref.as\_non\_null](#syntax-instr-ref) has the type \[([ref](#syntax-reftype) [null](#syntax-reftype) ht)\][→](#syntax-instrtype)\[([ref](#syntax-reftype) ht)\] for any choice of valid [heap type](#syntax-type) ht. Moreover, if the input type \[([ref](#syntax-reftype) [null](#syntax-reftype) ht)\] is already determined, i.e., a specific ht is given, then the output type \[([ref](#syntax-reftype) ht)\] is fully determined as well.

The implication of the latter property is that a validator for _complete_ instruction sequences (as they occur in valid modules) can be implemented with a simple left-to-right [algorithm](#algo-valid) that does not require the introduction of type variables.

A typing algorithm capable of handling _partial_ instruction sequences (as might be considered for program analysis or program manipulation) needs to introduce type variables and perform substitutions, but it does not need to perform backtracking or record any non-syntactic constraints on these type variables.

Technically, the [syntax](#syntax-type) of [heap](#syntax-heaptype), [value](#syntax-valtype), and [result](#syntax-resulttype) types can be enriched with type variables as follows:

​null[heaptype](#syntax-heaptype)[reftype](#syntax-reftype)[valtype](#syntax-valtype)[resulttype](#syntax-resulttype)​::=::=::=::=::=​[null](#syntax-reftype)? ∣ αnull​… ∣ α[heaptype](#syntax-heaptype)​[ref](#syntax-reftype) null [heaptype](#syntax-heaptype)… ∣ α[valtype](#syntax-valtype)​ ∣ αnumvectype​\[α[valtype](#syntax-valtype)∗?​ [valtype](#syntax-valtype)∗\]​​

where each αxyz​ ranges over a set of type variables for syntactic class xyz, respectively. The special class numvectype is defined as [numtype](#syntax-numtype) ∣ [vectype](#syntax-vectype) ∣ [bot](#syntax-valtype-ext), and is only needed to handle unannotated [select](#syntax-instr-parametric) instructions.

A type is _closed_ when it does not contain any type variables, and _open_ otherwise. A _type substitution_ σ is a finite mapping from type variables to closed types of the respective syntactic class. When applied to an open type, it replaces the type variables α from its domain with the respective σ(α).

**Theorem (Principal Types).** If an instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-config) with some closed [instruction type](#syntax-instrtype) [instrtype](#syntax-instrtype) (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)∗:[instrtype](#syntax-instrtype)), then it is also valid with a possibly open instruction type [instrtype](#syntax-instrtype)min​ (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)∗:[instrtype](#syntax-instrtype)min​), such that for _every_ closed type [instrtype](#syntax-instrtype)′ with which [instr](#syntax-instr)∗ is valid (i.e., for all C[⊢](#valid-instrs)[instr](#syntax-instr)∗:[instrtype](#syntax-instrtype)′), there exists a substitution σ, such that σ([instrtype](#syntax-instrtype)min​) is a subtype of [instrtype](#syntax-instrtype)′ (i.e., C[⊢](#match-instrtype)σ([instrtype](#syntax-instrtype)min​)[≤](#match-instrtype)[instrtype](#syntax-instrtype)′). Furthermore, [instrtype](#syntax-instrtype)min​ is unique up to the choice of type variables.

**Theorem (Closed Principal Forward Types).** If closed input type \[t1∗​\] is given and the instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-config) with [instruction type](#syntax-instrtype) \[t1∗​\][→](#syntax-instrtype)x∗​\[t2∗​\] (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)x∗​\[t2∗​\]), then it is also valid with instruction type \[t1∗​\][→](#syntax-instrtype)x∗​\[α[valtype](#syntax-valtype)∗​ t∗\] (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)x∗​\[α[valtype](#syntax-valtype)∗​ t∗\]), where all t∗ are closed, such that for _every_ closed result type \[t2′​∗\] with which [instr](#syntax-instr)∗ is valid (i.e., for all C[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)x∗​\[t2′​∗\]), there exists a substitution σ, such that \[t2′​∗\]\=\[σ(α[valtype](#syntax-valtype)∗​) t∗\].

#### Type Lattice[](#type-lattice①)

The [Principal Types](#principality) property depends on the existence of a _greatest lower bound_ for any pair of types.

**Theorem (Greatest Lower Bounds for Value Types).** For any two value types t1​ and t2​ that are [valid](#valid-valtype) (i.e., C[⊢](#valid-valtype)t1​:[ok](#valid-valtype) and C[⊢](#valid-valtype)t2​:[ok](#valid-valtype)), there exists a valid value type t that is a subtype of both t1​ and t2​ (i.e., C[⊢](#valid-valtype)t:[ok](#valid-valtype) and C[⊢](#match-valtype)t[≤](#match-valtype)t1​ and C[⊢](#match-valtype)t[≤](#match-valtype)t2​), such that _every_ valid value type t′ that also is a subtype of both t1​ and t2​ (i.e., for all C[⊢](#valid-valtype)t′:[ok](#valid-valtype) and C[⊢](#match-valtype)t′[≤](#match-valtype)t1​ and C[⊢](#match-valtype)t′[≤](#match-valtype)t2​), is a subtype of t (i.e., C[⊢](#match-valtype)t′[≤](#match-valtype)t).

Note

The greatest lower bound of two types may be [bot](#syntax-valtype-ext).

**Theorem (Conditional Least Upper Bounds for Value Types).** Any two value types t1​ and t2​ that are [valid](#valid-valtype) (i.e., C[⊢](#valid-valtype)t1​:[ok](#valid-valtype) and C[⊢](#valid-valtype)t2​:[ok](#valid-valtype)) either have no common supertype, or there exists a valid value type t that is a supertype of both t1​ and t2​ (i.e., C[⊢](#valid-valtype)t:[ok](#valid-valtype) and C[⊢](#match-valtype)t1​[≤](#match-valtype)t and C[⊢](#match-valtype)t2​[≤](#match-valtype)t), such that _every_ valid value type t′ that also is a supertype of both t1​ and t2​ (i.e., for all C[⊢](#valid-valtype)t′:[ok](#valid-valtype) and C[⊢](#match-valtype)t1​[≤](#match-valtype)t′ and C[⊢](#match-valtype)t2​[≤](#match-valtype)t′), is a supertype of t (i.e., C[⊢](#match-valtype)t[≤](#match-valtype)t′).

Note

If a top type was added to the type system, a least upper bound would exist for any two types.

**Corollary (Type Lattice).** Assuming the addition of a provisional top type, [value types](#syntax-valtype) form a lattice with respect to their [subtype](#match-valtype) relation.

Finally, value types can be partitioned into multiple disjoint hierarchies that are not related by subtyping, except through [bot](#syntax-valtype-ext).

**Theorem (Disjoint Subtype Hierarchies).** The greatest lower bound of two [value types](#syntax-valtype) is [bot](#syntax-valtype-ext) or [ref](#syntax-reftype) [bot](#syntax-valtype-ext) if and only if they do not have a least upper bound.

In other words, types that do not have common supertypes, do not have common subtypes either (other than [bot](#syntax-valtype-ext) or [ref](#syntax-reftype) [bot](#syntax-valtype-ext)), and vice versa.

Note

Types from disjoint hierarchies can safely be represented in mutually incompatible ways in an implementation, because their values can never flow to the same place.

#### Compositionality[](#compositionality①)

[Valid](#valid-instrs) [instruction sequences](#syntax-instr) can be freely _composed_, as long as their types match up.

**Theorem (Composition).** If two instruction sequences [instr](#syntax-instr)1∗​ and [instr](#syntax-instr)2∗​ are valid with types \[t1∗​\][→](#syntax-instrtype)x1∗​​\[t∗\] and \[t∗\][→](#syntax-instrtype)x2∗​​\[t2∗​\], respectively (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​:\[t1∗​\][→](#syntax-instrtype)x1∗​​\[t∗\] and C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​:\[t∗\][→](#syntax-instrtype)x2∗​​\[t2∗​\]), then the concatenated instruction sequence ([instr](#syntax-instr)1∗​[instr](#syntax-instr)2∗​) is valid with type \[t1∗​\][→](#syntax-instrtype)x1∗​x2∗​​\[t2∗​\] (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​[instr](#syntax-instr)2∗​:\[t1∗​\][→](#syntax-instrtype)x1∗​x2∗​​\[t2∗​\]).

Note

More generally, instead of a shared type \[t∗\], it suffices if the output type of [instr](#syntax-instr)1∗​ is a [subtype](#match-resulttype) of the input type of [instr](#syntax-instr)1∗​, since the subtype can always be weakened to its supertype by subsumption.

Inversely, valid instruction sequences can also freely be _decomposed_, that is, splitting them anywhere produces two instruction sequences that are both [valid](#valid-instrs).

**Theorem (Decomposition).** If an instruction sequence [instr](#syntax-instr)∗ that is valid with type \[t1∗​\][→](#syntax-instrtype)x∗​\[t2∗​\] (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)x∗​\[t2∗​\]) is split into two instruction sequences [instr](#syntax-instr)1∗​ and [instr](#syntax-instr)2∗​ at any point (i.e., [instr](#syntax-instr)∗\=[instr](#syntax-instr)1∗​[instr](#syntax-instr)2∗​), then these are separately valid with some types \[t1∗​\][→](#syntax-instrtype)x1∗​​\[t∗\] and \[t∗\][→](#syntax-instrtype)x2∗​​\[t2∗​\], respectively (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​:\[t1∗​\][→](#syntax-instrtype)x1∗​​\[t∗\] and C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​:\[t∗\][→](#syntax-instrtype)x2∗​​\[t2∗​\]), where x∗\=x1∗​x2∗​.

Note

This property holds because validation is required even for unreachable code. Without that, [instr](#syntax-instr)2∗​ might not be valid in isolation.

### A.4 Validation Algorithm[](#a4-validation-algorithm)

The specification of WebAssembly [validation](#valid) is purely _declarative_. It describes the constraints that must be met by a [module](#valid-module) or [instruction](#valid-instr) sequence to be valid.

This section sketches the skeleton of a sound and complete _algorithm_ for effectively validating code, i.e., sequences of [instructions](#syntax-instr). (Other aspects of validation are straightforward to implement.)

In fact, the algorithm is expressed over the flat sequence of opcodes as occurring in the [binary format](#binary), and performs only a single pass over it. Consequently, it can be integrated directly into a decoder.

The algorithm is expressed in typed pseudo code whose semantics is intended to be self-explanatory.

#### Data Structures[](#data-structures①)

##### Types[](#types②③)

Value types are representable as sets of enumerations:

type num\_type = I32 | I64 | F32 | F64
type vec\_type = V128
type heap\_type =
  Any | Eq | I31 | Struct | Array | None |
  Func | Nofunc | Exn | Noexn | Extern | Noextern | Bot |
  Def(def : def\_type)
type ref\_type = Ref(heap : heap\_type, null : bool)
type val\_type = num\_type | vec\_type | ref\_type | Bot

func is\_num(t : val\_type) : bool =
  return t = I32 || t = I64 || t = F32 || t = F64 || t = Bot

func is\_vec(t : val\_type) : bool =
  return t = V128 || t = Bot

func is\_ref(t : val\_type) : bool =
  return not (is\_num t || is\_vec t) || t = Bot

Similarly, [defined types](#syntax-deftype) `def_type` can be represented:

type pack\_type = I8 | I16
type field\_type = Field(val : val\_type | pack\_type, mut : bool)

type struct\_type = Struct(fields : list(field\_type))
type array\_type = Array(fields : field\_type)
type func\_type = Func(params : list(val\_type), results : list(val\_type))
type comp\_type = struct\_type | array\_type | func\_type

type sub\_type = Sub(super : list(def\_type), body : comp\_type, final : bool)
type rec\_type = Rec(types : list(sub\_type))

type def\_type = Def(rec : rec\_type, proj : int32)

func unpack\_field(t : field\_type) : val\_type =
  if (it = I8 || t = I16) return I32
  return t

func expand\_def(t : def\_type) : comp\_type =
  return t.rec.types\[t.proj\].body

These representations assume that all types have been [closed](#type-closed) by [substituting](#type-subst) all [type indices](#syntax-typeidx) (in [concrete heap types](#syntax-heaptype) and in [sub types](#syntax-subtype)) with their respective [defined types](#syntax-deftype). This includes _recursive_ references to enclosing [defined types](#syntax-deftype), such that type representations form graphs and may be _cyclic_ for [recursive types](#syntax-rectype).

We assume that all types have been _canonicalized_, such that equality on two type representations holds if and only if their [closures](#type-closure) are syntactically equivalent, making it a constant-time check.

Note

For the purpose of type canonicalization, recursive references from a [heap type](#syntax-heaptype) to an enclosing [recursive type](#syntax-reftype) (i.e., forward edges in the graph that form a cycle) need to be distinguished from references to previously defined types. However, this distinction does not otherwise affect validation, so is ignored here. In the graph representation, all recursive types are effectively infinitely [unrolled](#aux-unroll-rectype).

We further assume that [validation](#valid-valtype) and [subtyping](#match-valtype) checks are defined on value types, as well as a few auxiliary functions on composite types:

func validate\_val\_type(t : val\_type)
func validate\_ref\_type(t : ref\_type)

func matches\_val(t1 : val\_type, t2 : val\_type) : bool
func matches\_ref(t1 : val\_type, t2 : val\_type) : bool

func is\_func(t : comp\_type) : bool
func is\_struct(t : comp\_type) : bool
func is\_array(t : comp\_type) : bool

Finally, the following function computes the least precise supertype of a given [heap type](#syntax-heaptype) (its corresponding top type):

func top\_heap\_type(t : heap\_type) : heap\_type =
  switch (t)
    case (Any | Eq | I31 | Struct | Array | None)
      return Any
    case (Func | Nofunc)
      return Func
    case (Extern | Noextern)
      return Extern
    case (Def(dt))
      switch (dt.rec.types\[dt.proj\].body)
        case (Struct(\_) | Array(\_))
          return Any
        case (Func(\_))
          return Func
    case (Bot)
      raise CannotOccurInSource

##### Context[](#context②)

Validation requires a [context](#context) for checking uses of [indices](#syntax-index). For the purpose of presenting the algorithm, it is maintained in a set of global variables:

var return\_type : list(val\_type)
var types : array(def\_type)
var locals : array(val\_type)
var locals\_init : array(bool)
var globals : array(global\_type)
var funcs : array(func\_type)
var tables : array(table\_type)
var mems : array(mem\_type)

This assumes suitable representations for the various [types](#syntax-type) besides `val_type`, which are omitted here.

For locals, there is an additional array recording the initialization status of each local.

##### Stacks[](#stacks①)

The algorithm uses three separate stacks: the _value stack_, the _control stack_, and the _initialization stack_. The value stack tracks the [types](#syntax-valtype) of operand values on the [stack](#stack). The control stack tracks surrounding [structured control instructions](#syntax-instr-control) and their associated [blocks](#syntax-instr-control). The initialization stack records all [locals](#syntax-local) that have been initialized since the beginning of the function.

type val\_stack = stack(val\_type)
type init\_stack = stack(u32)

type ctrl\_stack = stack(ctrl\_frame)
type ctrl\_frame = {
  opcode : opcode
  start\_types : list(val\_type)
  end\_types : list(val\_type)
  val\_height : nat
  init\_height : nat
  unreachable : bool
}

For each entered block, the control stack records a _control frame_ with the originating opcode, the types on the top of the operand stack at the start and end of the block (used to check its result as well as branches), the height of the operand stack at the start of the block (used to check that operands do not underflow the current block), the height of the initialization stack at the start of the block (used to reset initialization status at the end of the block), and a flag recording whether the remainder of the block is unreachable (used to handle [stack-polymorphic](#polymorphism) typing after branches).

For the purpose of presenting the algorithm, these stacks are simply maintained as global variables:

var vals : val\_stack
var inits : init\_stack
var ctrls : ctrl\_stack

However, these variables are not manipulated directly by the main checking function, but through a set of auxiliary functions:

func push\_val(type : val\_type) =
  vals.push(type)

func pop\_val() : val\_type =
  if (vals.size() = ctrls\[0\].val\_height && ctrls\[0\].unreachable) return Bot
  error\_if(vals.size() = ctrls\[0\].val\_height)
  return vals.pop()

func pop\_val(expect : val\_type) : val\_type =
  let actual = pop\_val()
  error\_if(not matches\_val(actual, expect))
  return actual

func pop\_num() : num\_type | Bot =
  let actual = pop\_val()
  error\_if(not is\_num(actual))
  return actual

func pop\_ref() : ref\_type =
  let actual = pop\_val()
  error\_if(not is\_ref(actual))
  if (actual = Bot) return Ref(Bot, false)
  return actual

func push\_vals(types : list(val\_type)) = foreach (t in types) push\_val(t)
func pop\_vals(types : list(val\_type)) : list(val\_type) =
  var popped := \[\]
  foreach (t in reverse(types)) popped.prepend(pop\_val(t))
  return popped

Pushing an operand value simply pushes the respective type to the value stack.

Popping an operand value checks that the value stack does not underflow the current block and then removes one type. But first, a special case is handled where the block contains no known values, but has been marked as unreachable. That can occur after an unconditional branch, when the stack is typed [polymorphically](#polymorphism). In that case, the `Bot` type is returned, because that is a _principal_ choice trivially satisfying all use constraints.

A second function for popping an operand value takes an expected type, which the actual operand type is checked against. The types may differ by subtyping, including the case where the actual type is `Bot`, and thereby matches unconditionally. The function returns the actual type popped from the stack.

Finally, there are accumulative functions for pushing or popping multiple operand types.

Note

The notation `stack[i]` is meant to index the stack from the top, so that, e.g., `ctrls[0]` accesses the element pushed last.

The initialization stack and the initialization status of locals is manipulated through the following functions:

func get\_local(idx : u32) =
  error\_if(not locals\_init\[idx\])

func set\_local(idx : u32) =
  if (not locals\_init\[idx\])
    inits.push(idx)
    locals\_init\[idx\] := true

func reset\_locals(height : nat) =
  while (inits.size() > height)
    locals\_init\[inits.pop()\] := false

Getting a local verifies that it is known to be initialized. When a local is set that was not set already, then its initialization status is updated and the change is recorded in the initialization stack. Thus, the initialization status of all locals can be reset to a previous state by denoting a specific height in the initialization stack.

The size of the initialization stack is bounded by the number of (non-defaultable) locals in a function, so can be preallocated by an algorithm.

The control stack is likewise manipulated through auxiliary functions:

func push\_ctrl(opcode : opcode, in : list(val\_type), out : list(val\_type)) =
  let frame = ctrl\_frame(opcode, in, out, vals.size(), inits.size(), false)
  ctrls.push(frame)
  push\_vals(in)

func pop\_ctrl() : ctrl\_frame =
  error\_if(ctrls.is\_empty())
  let frame = ctrls\[0\]
  pop\_vals(frame.end\_types)
  error\_if(vals.size() =/= frame.val\_height)
  reset\_locals(frame.init\_height)
  ctrls.pop()
  return frame

func label\_types(frame : ctrl\_frame) : list(val\_types) =
  return (if (frame.opcode = loop) frame.start\_types else frame.end\_types)

func unreachable() =
  vals.resize(ctrls\[0\].val\_height)
  ctrls\[0\].unreachable := true

Pushing a control frame takes the types of the label and result values. It allocates a new frame record recording them along with the current height of the operand stack and marks the block as reachable.

Popping a frame first checks that the control stack is not empty. It then verifies that the operand stack contains the right types of values expected at the end of the exited block and pops them off the operand stack. Afterwards, it checks that the stack has shrunk back to its initial height. Finally, it undoes all changes to the initialization status of locals that happened inside the block.

The type of the [label](#syntax-label) associated with a control frame is either that of the stack at the start or the end of the frame, determined by the opcode that it originates from.

Finally, the current frame can be marked as unreachable. In that case, all existing operand types are purged from the value stack, in order to allow for the [stack-polymorphism](#polymorphism) logic in `pop_val` to take effect. Because every function has an implicit outermost label that corresponds to an implicit block frame, it is an invariant of the validation algorithm that there always is at least one frame on the control stack when validating an instruction, and hence, ctrls\[0\] is always defined.

Note

Even with the unreachable flag set, consecutive operands are still pushed to and popped from the operand stack. That is necessary to detect invalid [examples](#polymorphism) like ([unreachable](#syntax-instr-control) ([i32](#syntax-numtype).[const](#syntax-instr-numeric)) [i64](#syntax-numtype).[add](#syntax-instr-numeric)). However, a polymorphic stack cannot underflow, but instead generates `Bot` types as needed.

#### Validation of Opcode Sequences[](#validation-of-opcode-sequences①)

The following function shows the validation of a number of representative instructions that manipulate the stack. Other instructions are checked in a similar manner.

func validate(opcode) =
  switch (opcode)
    case (i32.add)
      pop\_val(I32)
      pop\_val(I32)
      push\_val(I32)

    case (drop)
      pop\_val()

    case (select)
      pop\_val(I32)
      let t1 = pop\_val()
      let t2 = pop\_val()
      error\_if(not (is\_num(t1) && is\_num(t2) || is\_vec(t1) && is\_vec(t2)))
      error\_if(t1 =/= t2 && t1 =/= Bot && t2 =/= Bot)
      push\_val(if (t1 = Bot) t2 else t1)

    case (select t)
      pop\_val(I32)
      pop\_val(t)
      pop\_val(t)
      push\_val(t)

    case (ref.is\_null)
      pop\_ref()
      push\_val(I32)

    case (ref.as\_non\_null)
      let rt = pop\_ref()
      push\_val(Ref(rt.heap, false))

    case (ref.test rt)
      validate\_ref\_type(rt)
      pop\_val(Ref(top\_heap\_type(rt), true))
      push\_val(I32)

    case (local.get x)
      get\_local(x)
      push\_val(locals\[x\])

    case (local.set x)
      pop\_val(locals\[x\])
      set\_local(x)

    case (unreachable)
      unreachable()

    case (block t1\*->t2\*)
      pop\_vals(\[t1\*\])
      push\_ctrl(block, \[t1\*\], \[t2\*\])

    case (loop t1\*->t2\*)
      pop\_vals(\[t1\*\])
      push\_ctrl(loop, \[t1\*\], \[t2\*\])

    case (if t1\*->t2\*)
      pop\_val(I32)
      pop\_vals(\[t1\*\])
      push\_ctrl(if, \[t1\*\], \[t2\*\])

    case (end)
      let frame = pop\_ctrl()
      push\_vals(frame.end\_types)

    case (else)
      let frame = pop\_ctrl()
      error\_if(frame.opcode =/= if)
      push\_ctrl(else, frame.start\_types, frame.end\_types)

    case (br n)
      error\_if(ctrls.size() < n)
      pop\_vals(label\_types(ctrls\[n\]))
      unreachable()

    case (br\_if n)
      error\_if(ctrls.size() < n)
      pop\_val(I32)
      pop\_vals(label\_types(ctrls\[n\]))
      push\_vals(label\_types(ctrls\[n\]))

    case (br\_table n\* m)
      pop\_val(I32)
      error\_if(ctrls.size() < m)
      let arity = label\_types(ctrls\[m\]).size()
      foreach (n in n\*)
        error\_if(ctrls.size() < n)
        error\_if(label\_types(ctrls\[n\]).size() =/= arity)
        push\_vals(pop\_vals(label\_types(ctrls\[n\])))
      pop\_vals(label\_types(ctrls\[m\]))
      unreachable()

    case (br\_on\_null n)
      error\_if(ctrls.size() < n)
      let rt = pop\_ref()
      pop\_vals(label\_types(ctrls\[n\]))
      push\_vals(label\_types(ctrls\[n\]))
      push\_val(Ref(rt.heap, false))

    case (br\_on\_cast n rt1 rt2)
      validate\_ref\_type(rt1)
      validate\_ref\_type(rt2)
      pop\_val(rt1)
      push\_val(rt2)
      pop\_vals(label\_types(ctrls\[n\]))
      push\_vals(label\_types(ctrls\[n\]))
      pop\_val(rt2)
      push\_val(diff\_ref\_type(rt2, rt1))

    case (return)
      pop\_vals(return\_types)
      unreachable()

    case (call\_ref x)
      let t = expand\_def(types\[x\])
      error\_if(not is\_func(t))
      pop\_vals(t.params)
      pop\_val(Ref(Def(types\[x\])))
      push\_vals(t.results)

    case (return\_call\_ref x)
      let t = expand\_def(types\[x\])
      error\_if(not is\_func(t))
      pop\_vals(t.params)
      pop\_val(Ref(Def(types\[x\])))
      error\_if(t.results.len() =/= return\_types.len())
      push\_vals(t.results)
      pop\_vals(return\_types)
      unreachable()

    case (struct.new x)
      let t = expand\_def(types\[x\])
      error\_if(not is\_struct(t))
      for (ti in reverse(t.fields))
        pop\_val(unpack\_field(ti))
      push\_val(Ref(Def(types\[x\])))

    case (struct.set x n)
      let t = expand\_def(types\[x\])
      error\_if(not is\_struct(t) || n >= t.fields.len())
      pop\_val(Ref(Def(types\[x\])))
      pop\_val(unpack\_field(st.fields\[n\]))

    case (throw x)
       pop\_vals(tags\[x\].type.params)
       unreachable()

    case (try\_table t1\*->t2\* handler\*)
      pop\_vals(\[t1\*\])
      foreach (handler in handler\*)
        error\_if(ctrls.size() < handler.label)
        push\_ctrl(catch, \[\], label\_types(ctrls\[handler.label\]))
        switch (handler.clause)
          case (catch x)
            push\_vals(tags\[x\].type.params)
          case (catch\_ref x)
            push\_vals(tags\[x\].type.params)
            push\_val(Exnref)
          case (catch\_all)
            skip
          case (catch\_all\_ref)
            push\_val(Exnref)
        pop\_ctrl()
      push\_ctrl(try\_table, \[t1\*\], \[t2\*\])

Note

It is an invariant under the current WebAssembly instruction set that an operand of `Bot` type is never duplicated on the stack. This would change if the language were extended with stack instructions like `dup`. Under such an extension, the above algorithm would need to be refined by replacing the `Bot` type with proper _type variables_ to ensure that all uses are consistent.

### Custom Sections and Annotations[](#custom-sections-and-annotations①)

This appendix defines dedicated [custom sections](#binary-customsec) for WebAssembly’s [binary format](#binary) and [annotations](#text-annot) for the text format. Such sections or annotations do not contribute to, or otherwise affect, the WebAssembly semantics, and may be ignored by an implementation. However, they provide useful meta data that implementations can make use of to improve user experience or take compilation hints.

#### Name Section[](#name-section①)

The _name section_ is a [custom section](#binary-customsec) whose name string is itself ‘name’. The name section should appear only once in a module, and only after the [data section](#binary-datasec).

The purpose of this section is to attach printable names to definitions in a module, which e.g. can be used by a debugger or when parts of the module are to be rendered in [text form](#text).

Note

All [names](#binary-name) are represented in [\[UNICODE\]](#biblio-unicode "The Unicode Standard") encoded in UTF-8. Names need not be unique.

##### Subsections[](#subsections①)

The [data](#binary-customsec) of a name section consists of a sequence of _subsections_. Each subsection consists of a

*   a one-byte subsection _id_,
    
*   the [u32](#syntax-int) _size_ of the contents, in bytes,
    
*   the actual _contents_, whose structure is dependent on the subsection id.
    

​[namesec](#binary-namesubsection)[namedata](#binary-namesubsection)[namesubsection](#binary-namesubsection)N​(B)​::=::=::=​[section](#binary-section)0​([namedata](#binary-namesubsection))n:[name](#binary-name)[modulenamesubsec](#binary-modulenamesec)?[funcnamesubsec](#binary-funcnamesec)?[localnamesubsec](#binary-localnamesec)?[typenamesubsec](#binary-typenamesec)?[fieldnamesubsec](#binary-fieldnamesec)?[tagnamesubsec](#binary-tagnamesec)?N:[byte](#binary-byte) size:[u32](#binary-int) B​(ifn\=‘name’)(ifsize\=∣∣B∣∣)​​

The following subsection ids are used:

Id

Subsection

0

[module name](#binary-modulenamesec)

1

[function names](#binary-funcnamesec)

2

[local names](#binary-localnamesec)

4

[type names](#binary-typenamesec)

10

[field names](#binary-fieldnamesec)

11

[tag names](#binary-tagnamesec)

Each subsection may occur at most once, and in order of increasing id.

##### Name Maps[](#name-maps①)

A _name map_ assigns [names](#syntax-name) to [indices](#syntax-index) in a given [index space](#syntax-index). It consists of a [list](#binary-list) of index/name pairs in order of increasing index value. Each index must be unique, but the assigned names need not be.

​[namemap](#binary-namemap)[nameassoc](#binary-namemap)​::=::=​[list](#binary-list)([nameassoc](#binary-namemap))[idx](#binary-index) [name](#binary-name)​​

An _indirect name map_ assigns [names](#syntax-name) to a two-dimensional [index space](#syntax-index), where secondary indices are _grouped_ by primary indices. It consists of a list of primary index/name map pairs in order of increasing index value, where each name map in turn maps secondary indices to names. Each primary index must be unique, and likewise each secondary index per individual name map.

​[indirectnamemap](#binary-indirectnamemap)[indirectnameassoc](#binary-indirectnamemap)​::=::=​[list](#binary-list)([indirectnameassoc](#binary-indirectnamemap))[idx](#binary-index) [namemap](#binary-namemap)​​

##### Module Names[](#module-names①)

The _module name subsection_ has the id 0. It simply consists of a single [name](#binary-name) that is assigned to the module itself.

​[modulenamesubsec](#binary-modulenamesec)​::=​[namesubsection](#binary-namesubsection)0​([name](#binary-name))​​

##### Function Names[](#function-names①)

The _function name subsection_ has the id 1. It consists of a [name map](#binary-namemap) assigning function names to [function indices](#syntax-funcidx).

​[funcnamesubsec](#binary-funcnamesec)​::=​[namesubsection](#binary-namesubsection)1​([namemap](#binary-namemap))​​

##### Local Names[](#local-names①)

The _local name subsection_ has the id 2. It consists of an [indirect name map](#binary-indirectnamemap) assigning local names to [local indices](#syntax-localidx) grouped by [function indices](#syntax-funcidx).

​[localnamesubsec](#binary-localnamesec)​::=​[namesubsection](#binary-namesubsection)2​([indirectnamemap](#binary-indirectnamemap))​​

##### Type Names[](#type-names①)

The _type name subsection_ has the id 4. It consists of a [name map](#binary-namemap) assigning type names to [type indices](#syntax-typeidx).

​[typenamesubsec](#binary-typenamesec)​::=​[namesubsection](#binary-namesubsection)4​([namemap](#binary-namemap))​​

##### Field Names[](#field-names①)

The _field name subsection_ has the id 10. It consists of an [indirect name map](#binary-indirectnamemap) assigning field names to [field indices](#syntax-fieldidx) grouped by the [type indices](#syntax-typeidx) of their respective [structure types](#syntax-structtype).

​[fieldnamesubsec](#binary-fieldnamesec)​::=​[namesubsection](#binary-namesubsection)10​([indirectnamemap](#binary-indirectnamemap))​​

##### Tag Names[](#tag-names①)

The _tag name subsection_ has the id 11. It consists of a [name map](#binary-namemap) assigning tag names to [tag indices](#syntax-tagidx).

​[tagnamesubsec](#binary-tagnamesec)​::=​[namesubsection](#binary-namesubsection)11​([namemap](#binary-namemap))​​

#### Name Annotations[](#name-annotations①)

_Name annotations_ are the textual analogue to the [name section](#binary-namesec) and provide a textual representation for it. Consequently, their id is @name.

Analogous to the name section, name annotations are allowed on [modules](#text-module), [functions](#text-func), and [locals](#text-local) (including [parameters](#text-param)). They can be placed where the text format allows binding occurrences of respective [identifiers](#text-id). If both an identifier and a name annotation are given, the annotation is expected _after_ the identifier. In that case, the annotation takes precedence over the identifier as a textual representation of the binding’s name. At most one name annotation may be given per binding.

All name annotations have the following format:

​[nameannot](#text-nameannot)​::=​‘(@name’ [string](#text-string) ‘)’​​

Note

All name annotations can be arbitrary UTF-8 [strings](#text-string). Names need not be unique.

##### Module Names[](#module-names②)

A _module name annotation_ must be placed on a [module](#text-module) definition, directly after the ‘module’ keyword, or if present, after the following module [identifier](#text-id).

​[modulenameannot](#text-modulenameannot)​::=​[nameannot](#text-nameannot)​​

##### Function Names[](#function-names②)

A _function name annotation_ must be placed on a [function](#text-func) definition or function [import](#text-import), directly after the ‘func’ keyword, or if present, after the following function [identifier](#text-id) or.

​[funcnameannot](#text-funcnameannot)​::=​[nameannot](#text-nameannot)​​

##### Parameter Names[](#parameter-names①)

A _parameter name annotation_ must be placed on a [parameter](#text-param) declaration, directly after the ‘param’ keyword, or if present, after the following parameter [identifier](#text-id). It may only be placed on a declaration that declares exactly one parameter.

​[paramnameannot](#text-paramnameannot)​::=​[nameannot](#text-nameannot)​​

##### Local Names[](#local-names②)

A _local name annotation_ must be placed on a [local](#text-param) declaration, directly after the ‘local’ keyword, or if present, after the following local [identifier](#text-id). It may only be placed on a declaration that declares exactly one local.

​[localnameannot](#text-localnameannot)​::=​[nameannot](#text-nameannot)​​

##### Type Names[](#type-names②)

A _type name annotation_ must be placed on a [type](#text-type) declaration, directly after the ‘type’ keyword, or if present, after the following type [identifier](#text-id).

​[typenameannot](#text-typenameannot)​::=​[nameannot](#text-nameannot)​​

##### Field Names[](#field-names②)

A _field name annotation_ must be placed on the field of a [structure type](#text-structtype), directly after the ‘field’ keyword, or if present, after the following field [identifier](#text-id). It may only be placed on a declaration that declares exactly one field.

​[fieldnameannot](#text-fieldnameannot)​::=​[nameannot](#text-nameannot)​​

##### Tag Names[](#tag-names②)

A _tag name annotation_ must be placed on a [tag declaration](#text-tag) or tag [import](#text-import), directly after the ‘tag’ keyword, or if present, after the following tag [identifier](#text-id).

​[tagnameannot](#text-tagnameannot)​::=​[nameannot](#text-nameannot)​​

#### Custom Annotations[](#custom-annotations①)

_Custom annotations_ are a generic textual representation for any [custom section](#binary-customsec). Their id is @custom. By generating custom annotations, tools converting between [binary format](#binary) and [text format](#text) can maintain and round-trip the content of custom sections even when they do not recognize them.

Custom annotations must be placed inside a [module](#text-module) definition. They must occur anywhere after the ‘module’ keyword, or if present, after the following module [identifier](#text-id). They must not be nested into other constructs.

​[customannot](#text-customannot)[customplace](#text-customannot)[sec](#text-customannot)​::=::=∣∣∣::=∣∣∣∣∣∣∣∣∣∣∣​‘(@custom’ [string](#text-string) [customplace](#text-customannot)? [datastring](#text-datastring) ‘)’‘(’ ‘before’ ‘first’ ‘)’‘(’ ‘before’ [sec](#text-customannot) ‘)’‘(’ ‘after’ [sec](#text-customannot) ‘)’‘(’ ‘after’ ‘last’ ‘)’‘type’‘import’‘func’‘table’‘memory’‘global’‘export’‘start’‘elem’‘code’‘data’‘datacount’​​

The first [string](#text-string) in a custom annotation denotes the name of the custom section it represents. The remaining strings collectively represent the section’s payload data, written as a [data string](#text-datastring), which can be split up into a possibly empty sequence of individual string literals (similar to [data segments](#text-data)).

An arbitrary number of custom annotations (even of the same name) may occur in a module, each defining a separate custom section when converting to [binary format](#binary). Placement of the sections in the binary can be customized via explicit _placement_ directives, that position them either directly before or directly after a known section. That section must exist and be non-empty in the binary encoding of the annotated module. The placements (before first) and (after last) denote virtual sections before the first and after the last known section, respectively. When the placement directive is omitted, it defaults to (after last).

If multiple placement directives appear for the same position, then the sections are all placed there, in order of their appearance in the text. For this purpose, the position after a section is considered different from the position before the consecutive section, and the former occurs before the latter.

Note

Future versions of WebAssembly may introduce additional sections between others or at the beginning or end of a module. Using first and last guarantees that placement will still go before or after any future section, respectively.

If a custom section with a specific section id is given as well as annotations representing the same custom section (e.g., @name [annotations](#text-nameannot) as well as a @custom annotation for a name [section](#binary-namesec)), then two sections are assumed to be created. Their relative placement will depend on the placement directive given for the @custom annotation as well as the implicit placement requirements of the custom section, which are applied to the other annotation.

Note

For example, the following module,

(module
  (@custom "A" "aaa")
  (type $t (func))
  (@custom "B" (after func) "bbb")
  (@custom "C" (before func) "ccc")
  (@custom "D" (after last) "ddd")
  (table 10 funcref)
  (func (type $t))
  (@custom "E" (after import) "eee")
  (@custom "F" (before type) "fff")
  (@custom "G" (after data) "ggg")
  (@custom "H" (after code) "hhh")
  (@custom "I" (after func) "iii")
  (@custom "J" (before func) "jjj")
  (@custom "K" (before first) "kkk")
)

will result in the following section ordering:

custom section "K"
custom section "F"
type section
custom section "E"
custom section "C"
custom section "J"
function section
custom section "B"
custom section "I"
table section
code section
custom section "H"
custom section "G"
custom section "A"
custom section "D"

### A.8 Change History[](#a8-change-history)

Since the original release 1.0 of the WebAssembly specification, a number of proposals for extensions have been integrated. The following sections provide an overview of what has changed.

All present and future versions of WebAssembly are intended to be _backwards-compatible_ with all previous versions. Concretely:

1.  All syntactically well-formed (in [binary](#binary) or [text](#text) format) and [valid](#valid) modules remain well-formed and valid with an equivalent [module type](#syntax-moduletype) (or a subtype).
    

> Note
> 
> This allows previously malformed or invalid modules to become legal, e.g., by adding new features or by relaxing typing rules.
> 
> It also allows reclassifying previously malformed modules as well-formed but invalid, or vice versa.
> 
> And it allows refining the typing of [imports](#syntax-import) and [exports](#syntax-export), such that previously unlinkable modules become linkable.
> 
> Historically, minor breaking changes to the _text format_ have been allowed that turned previously possible valid modules invalid, as long as they were unlikely to occur in practice.

2.  All non-[trapping](#trap) [executions](#exec) of a valid program retain their behaviour with an equivalent set of possible [results](#syntax-result) (or a non-empty subset).
    

> Note
> 
> This allows previously malformed or invalid programs to become executable.
> 
> It also allows program executions that previously trapped to execute successfully, although the intention is to only exercise this where the possibility of such an extension has been previously noted.
> 
> And it allows reducing the set of observable behaviours of a program execution, e.g., by reducing non-determinism.
> 
> In a program linking prior modules with modules using new features, a prior module may encounter new behaviours, e.g., new forms of control flow or side effects when calling into a latter module.

In addition, future versions of WebAssembly will not allocate the [opcode](#binary-instr) 0xFF to represent an instruction or instruction prefix.

#### Release 2.0[](#release-20)

##### Sign Extension Instructions[](#sign-extension-instructions①)

Added new numeric instructions for performing sign extension within integer representations. [\[1\]](#proposal-signext)

*   New [numeric instructions](#syntax-instr-numeric):
    
    *   inn.[extend](#syntax-instr-numeric)N\_s
        

##### Non-trapping Float-to-Int Conversions[](#non-trapping-float-to-int-conversions①)

Added new conversion instructions that avoid trapping when converting a floating-point number to an integer. [\[2\]](#proposal-cvtsat)

*   New [numeric instructions](#syntax-instr-numeric):
    
    *   inn.[trunc](#syntax-instr-numeric)\_sat\_fmm\_[sx](#syntax-sx)
        

##### Multiple Values[](#multiple-values①)

Generalized the result type of blocks and functions to allow for multiple values; in addition, introduced the ability to have block parameters. [\[3\]](#proposal-multivalue)

*   [Function types](#syntax-functype) allow more than one result
    
*   [Block types](#syntax-blocktype) can be arbitrary function types
    

##### Reference Types[](#reference-types①①)

Added [funcref](#syntax-reftype) and [externref](#syntax-reftype) as new value types and respective instructions. [\[4\]](#proposal-reftype)

*   New [reference](#syntax-reftype) [value types](#syntax-valtype):
    
    *   [funcref](#syntax-reftype)
        
    *   [externref](#syntax-reftype)
        
*   New [reference instructions](#syntax-instr-ref):
    
    *   [ref.null](#syntax-instr-ref)
        
    *   [ref.func](#syntax-instr-ref)
        
    *   [ref.is\_null](#syntax-instr-ref)
        
*   Extended [parametric instruction](#syntax-instr-parametric):
    
    *   [select](#syntax-instr-parametric) with optional type immediate
        
*   New [declarative](#syntax-elemmode) form of [element segment](#syntax-elem)
    

##### Table Instructions[](#table-instructions①①)

Added instructions to directly access and modify tables. [\[4\]](#proposal-reftype)

*   [Table types](#syntax-tabletype) allow any [reference type](#syntax-reftype) as element type
    
*   New [table instructions](#syntax-instr-table):
    
    *   [table.get](#syntax-instr-table)
        
    *   [table.set](#syntax-instr-table)
        
    *   [table.size](#syntax-instr-table)
        
    *   [table.grow](#syntax-instr-table)
        

##### Multiple Tables[](#multiple-tables①)

Added the ability to use multiple tables per module. [\[4\]](#proposal-reftype)

*   [Modules](#syntax-module) may
    
    *   [define](#syntax-table) multiple tables
        
    *   [import](#syntax-import) multiple tables
        
    *   [export](#syntax-export) multiple tables
        
*   [Table instructions](#syntax-instr-table) take a [table index](#syntax-tableidx) immediate:
    
    *   [table.get](#syntax-instr-table)
        
    *   [table.set](#syntax-instr-table)
        
    *   [table.size](#syntax-instr-table)
        
    *   [table.grow](#syntax-instr-table)
        
    *   [call\_indirect](#syntax-instr-control)
        
*   [Element segments](#syntax-elem) take a [table index](#syntax-tableidx)
    

##### Bulk Memory and Table Instructions[](#bulk-memory-and-table-instructions①)

Added instructions that modify ranges of memory or table entries. [\[4\]](#proposal-reftype) [\[5\]](#proposal-bulk)

*   New [memory instructions](#syntax-instr-memory):
    
    *   [memory.fill](#syntax-instr-memory)
        
    *   [memory.init](#syntax-instr-memory)
        
    *   [memory.copy](#syntax-instr-memory)
        
    *   [data.drop](#syntax-instr-memory)
        
*   New [table instructions](#syntax-instr-table):
    
    *   [table.fill](#syntax-instr-table)
        
    *   [table.init](#syntax-instr-table)
        
    *   [table.copy](#syntax-instr-table)
        
    *   [elem.drop](#syntax-instr-table)
        
*   New [passive](#syntax-datamode) form of [data segment](#syntax-data)
    
*   New [passive](#syntax-elemmode) form of [element segment](#syntax-elem)
    
*   New [data count section](#binary-datacntsec) in binary format
    
*   Active data and element segments boundaries are no longer checked at compile time but may trap instead
    

##### Vector Instructions[](#vector-instructions①①)

Added vector type and instructions that manipulate multiple numeric values in parallel (also known as _SIMD_, single instruction multiple data) [\[6\]](#proposal-vectype)

*   New [value type](#syntax-valtype):
    
    *   [v128](#syntax-vectype)
        
*   New [memory instructions](#syntax-instr-memory):
    
    *   v128.[load](#syntax-instr-memory)
        
    *   v128.[load](#syntax-instr-memory)NxM\_[sx](#syntax-sx)
        
    *   v128.[load](#syntax-instr-memory)N\_zero
        
    *   v128.[load](#syntax-instr-memory)N\_splat
        
    *   v128.[load](#syntax-instr-memory)N\_lane
        
    *   v128.[store](#syntax-instr-memory)
        
    *   v128.[store](#syntax-instr-memory)N\_lane
        
*   New constant [vector instruction](#syntax-instr-vec):
    
    *   v128.[const](#syntax-instr-vec)
        
*   New unary [vector instructions](#syntax-instr-vec):
    
    *   v128.not
        
    *   iNxM.abs
        
    *   iNxM.neg
        
    *   i8x16.popcnt
        
    *   fNxM.abs
        
    *   fNxM.neg
        
    *   fNxM.sqrt
        
    *   fNxM.ceil
        
    *   fNxM.floor
        
    *   fNxM.trunc
        
    *   fNxM.nearest
        
*   New binary [vector instructions](#syntax-instr-vec):
    
    *   v128.and
        
    *   v128.andnot
        
    *   v128.or
        
    *   v128.xor
        
    *   iNxM.add
        
    *   iNxM.sub
        
    *   iNxM.mul
        
    *   iNxM.add\_sat\_[sx](#syntax-sx)
        
    *   iNxM.sub\_sat\_[sx](#syntax-sx)
        
    *   iNxM.min\_[sx](#syntax-sx)
        
    *   iNxM.max\_[sx](#syntax-sx)
        
    *   iNxM.shl
        
    *   iNxM.shr\_[sx](#syntax-sx)
        
    *   fNxM.add
        
    *   fNxM.sub
        
    *   fNxM.mul
        
    *   fNxM.div
        
    *   i16x8.extadd\_pairwise\_i8x16\_[sx](#syntax-sx)
        
    *   i32x4.extadd\_pairwise\_i16x8\_[sx](#syntax-sx)
        
    *   iNxM.extmul\_[half](#syntax-half)\_iN′xM′\_[sx](#syntax-sx)
        
    *   i16x8.q15mulr\_sat\_s
        
    *   i32x4.dot\_i16x8\_s
        
    *   i8x16.avgr\_u
        
    *   i16x8.avgr\_u
        
    *   fNxM.min
        
    *   fNxM.max
        
    *   fNxM.pmin
        
    *   fNxM.pmax
        
*   New ternary [vector instruction](#syntax-instr-vec):
    
    *   v128.bitselect
        
*   New test [vector instructions](#syntax-instr-vec):
    
    *   v128.any\_true
        
    *   iNxM.all\_true
        
*   New relational [vector instructions](#syntax-instr-vec):
    
    *   iNxM.eq
        
    *   iNxM.ne
        
    *   iNxM.lt\_[sx](#syntax-sx)
        
    *   iNxM.gt\_[sx](#syntax-sx)
        
    *   iNxM.le\_[sx](#syntax-sx)
        
    *   iNxM.ge\_[sx](#syntax-sx)
        
    *   fNxM.eq
        
    *   fNxM.ne
        
    *   fNxM.lt
        
    *   fNxM.gt
        
    *   fNxM.le
        
    *   fNxM.ge
        
*   New conversion [vector instructions](#syntax-instr-vec):
    
    *   i32x4.trunc\_sat\_f32x4\_[sx](#syntax-sx)
        
    *   i32x4.trunc\_sat\_f64x2\_[sx](#syntax-sx)\_zero
        
    *   f32x4.convert\_i32x4\_[sx](#syntax-sx)
        
    *   f32x4.demote\_f64x2\_zero
        
    *   f64x2.convert\_low\_i32x4\_[sx](#syntax-sx)
        
    *   f64x2.promote\_low\_f32x4
        
*   New lane access [vector instructions](#syntax-instr-vec):
    
    *   iNxM.extract\_lane\_[sx](#syntax-sx)?
        
    *   iNxM.replace\_lane
        
    *   fNxM.extract\_lane
        
    *   fNxM.replace\_lane
        
*   New lane splitting/combining [vector instructions](#syntax-instr-vec):
    
    *   iNxM.extend\_[half](#syntax-half)\_iN′xM′\_[sx](#syntax-sx)
        
    *   i8x16.narrow\_i16x8\_[sx](#syntax-sx)
        
    *   i16x8.narrow\_i32x4\_[sx](#syntax-sx)
        
*   New byte reordering [vector instructions](#syntax-instr-vec):
    
    *   i8x16.shuffle
        
    *   i8x16.swizzle
        
*   New injection/projection [vector instructions](#syntax-instr-vec):
    
    *   iNxM.splat
        
    *   fNxM.splat
        
    *   iNxM.bitmask
        

\[[1](#id1)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/sign-extension-ops/](https://github.com/WebAssembly/spec/tree/main/proposals/sign-extension-ops/)

\[[2](#id2)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/nontrapping-float-to-int-conversion/](https://github.com/WebAssembly/spec/tree/main/proposals/nontrapping-float-to-int-conversion/)

\[[3](#id3)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/multi-value/](https://github.com/WebAssembly/spec/tree/main/proposals/multi-value/)

\[4\] ([1](#id4),[2](#id5),[3](#id6),[4](#id7))

[https://github.com/WebAssembly/spec/tree/main/proposals/reference-types/](https://github.com/WebAssembly/spec/tree/main/proposals/reference-types/)

\[[5](#id8)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/bulk-memory-operations/](https://github.com/WebAssembly/spec/tree/main/proposals/bulk-memory-operations/)

\[[6](#id9)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/simd/](https://github.com/WebAssembly/spec/tree/main/proposals/simd/)

#### Release 3.0[](#release-30)

##### Extended Constant Expressions[](#extended-constant-expressions①)

Allowed basic numeric computations in constant expressions. [\[7\]](#proposal-extconst)

*   Extended set of [constant instructions](#valid-const) with:
    
    *   inn.add
        
    *   inn.sub
        
    *   inn.mul
        
    *   [global.get](#syntax-instr-variable) for any previously declared immutable [global](#syntax-global)
        

Note

The [garbage collection](#extension-gc) extension added further constant instructions.

##### Tail Calls[](#tail-calls①)

Added instructions to perform tail calls. [\[8\]](#proposal-tailcall)

*   New [control instructions](#syntax-instr-control):
    
    *   [return\_call](#syntax-instr-control)
        
    *   [return\_call\_indirect](#syntax-instr-control)
        

##### Exception Handling[](#exception-handling③)

Added tag definitions, imports, and exports, and instructions to throw and catch exceptions. [\[9\]](#proposal-exn)

*   [Modules](#syntax-module) may
    
    *   [define](#syntax-tag) tags
        
    *   [import](#syntax-import) tags
        
    *   [export](#syntax-export) tags
        
*   New [heap types](#syntax-heaptype):
    
    *   [exn](#syntax-heaptype)
        
    *   [noexn](#syntax-heaptype)
        
*   New [reference type](#syntax-reftype) short-hands:
    
    *   [exnref](#syntax-reftype)
        
    *   [nullexnref](#syntax-reftype)
        
*   New [control instructions](#syntax-instr-control):
    
    *   [throw](#syntax-instr-control)
        
    *   [throw\_ref](#syntax-instr-control)
        
    *   [try\_table](#syntax-instr-control)
        
*   New [tag section](#binary-tagsec) in binary format.
    

##### Multiple Memories[](#multiple-memories①)

Added the ability to use multiple memories per module. [\[10\]](#proposal-multimem)

*   [Modules](#syntax-module) may
    
    *   [define](#syntax-mem) multiple memories
        
    *   [import](#syntax-import) multiple memories
        
    *   [export](#syntax-export) multiple memories
        
*   [Memory instructions](#syntax-instr-memory) take a [memory index](#syntax-memidx) immediate:
    
    *   [memory.size](#syntax-instr-memory)
        
    *   [memory.grow](#syntax-instr-memory)
        
    *   [memory.fill](#syntax-instr-memory)
        
    *   [memory.copy](#syntax-instr-memory)
        
    *   [memory.init](#syntax-instr-memory)
        
    *   t.load
        
    *   t.store
        
    *   t.loadN\_[sx](#syntax-sx)
        
    *   t.storeN
        
    *   v128.loadNxM\_[sx](#syntax-sx)
        
    *   v128.loadN\_zero
        
    *   v128.loadN\_splat
        
    *   v128.loadN\_lane
        
    *   v128.storeN\_lane
        
*   [Data segments](#syntax-elem) take a [memory index](#syntax-memidx)
    

##### 64-bit Address Space[](#64-bit-address-space)

Added the ability to declare an [i64](#syntax-numtype) [address type](#syntax-addrtype) for [tables](#syntax-tabletype) and [memories](#syntax-memtype). [\[11\]](#proposal-addr64)

*   [Address types](#syntax-addrtype) denote a subset of the integral [number types](#syntax-numtype)
    
*   [Table types](#syntax-tabletype) include an [address type](#syntax-addrtype)
    
*   [Memory types](#syntax-memtype) include an [address type](#syntax-addrtype)
    
*   Operand types of [table](#syntax-instr-table) and [memory](#syntax-instr-memory) instructions now depend on the subject’s declared address type:
    
    *   [table.get](#syntax-instr-table)
        
    *   [table.set](#syntax-instr-table)
        
    *   [table.size](#syntax-instr-table)
        
    *   [table.grow](#syntax-instr-table)
        
    *   [table.fill](#syntax-instr-table)
        
    *   [table.copy](#syntax-instr-table)
        
    *   [table.init](#syntax-instr-table)
        
    *   [memory.size](#syntax-instr-memory)
        
    *   [memory.grow](#syntax-instr-memory)
        
    *   [memory.fill](#syntax-instr-memory)
        
    *   [memory.copy](#syntax-instr-memory)
        
    *   [memory.init](#syntax-instr-memory)
        
    *   t.load
        
    *   t.store
        
    *   t.loadN\_[sx](#syntax-sx)
        
    *   t.storeN
        
    *   v128.loadNxM\_[sx](#syntax-sx)
        
    *   v128.loadN\_zero
        
    *   v128.loadN\_splat
        
    *   v128.loadN\_lane
        
    *   v128.storeN\_lane
        

##### Typeful References[](#typeful-references①)

Added more precise types for references. [\[12\]](#proposal-typedref)

*   New generalised form of [reference types](#syntax-reftype):
    
    *   ([ref](#syntax-reftype) [null](#syntax-reftype)? [heaptype](#syntax-heaptype))
        
*   New class of [heap types](#syntax-heaptype):
    
    *   [func](#syntax-func)
        
    *   [extern](#syntax-heaptype)
        
    *   [typeidx](#syntax-typeidx)
        
*   Basic [subtyping](#match) on [reference](#match-reftype) and [value](#match-valtype) types
    
*   New [reference instructions](#syntax-instr-ref):
    
    *   [ref.as\_non\_null](#syntax-instr-ref)
        
    *   [br\_on\_null](#syntax-instr-control)
        
    *   [br\_on\_non\_null](#syntax-instr-control)
        
*   New [control instruction](#syntax-instr-control):
    
    *   [call\_ref](#syntax-instr-control)
        
*   Refined typing of [reference instruction](#syntax-instr-ref):
    
    *   [ref.func](#syntax-instr-ref) with more precise result type
        
*   Refined typing of [local instructions](#valid-instr-variable) and [instruction sequences](#valid-instrs) to track the [initialization status](#syntax-init) of [locals](#syntax-local) with non-defaultable type
    
*   Refined decoding of [active](#syntax-elemmode) [element segments](#binary-elem) with implicit element type and plain function indices (opcode 0) to produce [non-null](#syntax-null) [reference type](#syntax-reftype)
    
*   Extended [table definitions](#syntax-table) with optional initializer expression
    

##### Garbage Collection[](#garbage-collection①)

Added managed reference types. [\[13\]](#proposal-gc)

*   New forms of [heap types](#syntax-heaptype):
    
    *   [any](#syntax-heaptype)
        
    *   [eq](#syntax-heaptype)
        
    *   [i31](#syntax-heaptype)
        
    *   [struct](#syntax-heaptype)
        
    *   [array](#syntax-heaptype)
        
    *   [none](#syntax-heaptype)
        
    *   [nofunc](#syntax-heaptype)
        
    *   [noextern](#syntax-heaptype)
        
*   New [reference type](#syntax-reftype) short-hands:
    
    *   [anyref](#syntax-reftype)
        
    *   [eqref](#syntax-reftype)
        
    *   [i31ref](#syntax-reftype)
        
    *   [structref](#syntax-reftype)
        
    *   [arrayref](#syntax-reftype)
        
    *   [nullref](#syntax-reftype)
        
    *   [nullfuncref](#syntax-reftype)
        
    *   [nullexternref](#syntax-reftype)
        
*   New forms of type definitions:
    
    *   [structure](#syntax-structtype)
        
    *   [array types](#syntax-arraytype)
        
    *   [sub types](#syntax-subtype)
        
    *   [recursive types](#syntax-rectype)
        
*   Enriched [subtyping](#match) based on explicitly declared [sub types](#syntax-subtype) and the new heap types
    
*   New generic [reference instructions](#syntax-instr-ref):
    
    *   [ref.eq](#syntax-instr-ref)
        
    *   [ref.test](#syntax-instr-ref)
        
    *   [ref.cast](#syntax-instr-ref)
        
    *   [br\_on\_cast](#syntax-instr-control)
        
    *   [br\_on\_cast\_fail](#syntax-instr-control)
        
*   New [reference instructions](#syntax-instr-ref) for [unboxed scalars](#syntax-i31):
    
    *   [ref.i31](#syntax-instr-i31)
        
    *   [i31.get](#syntax-instr-i31)\_[sx](#syntax-sx)
        
*   New [reference instructions](#syntax-instr-ref) for [structure types](#syntax-structtype):
    
    *   [struct.new](#syntax-instr-struct)
        
    *   [struct.new\_default](#syntax-instr-struct)
        
    *   [struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)?
        
    *   [struct.set](#syntax-instr-struct)
        
*   New [reference instructions](#syntax-instr-ref) for [array types](#syntax-structtype):
    
    *   [array.new](#syntax-instr-array)
        
    *   [array.new\_default](#syntax-instr-array)
        
    *   [array.new\_fixed](#syntax-instr-array)
        
    *   [array.new\_data](#syntax-instr-array)
        
    *   [array.new\_elem](#syntax-instr-array)
        
    *   [array.get](#syntax-instr-array)\_[sx](#syntax-sx)?
        
    *   [array.set](#syntax-instr-array)
        
    *   [array.len](#syntax-instr-array)
        
    *   [array.fill](#syntax-instr-array)
        
    *   [array.copy](#syntax-instr-array)
        
    *   [array.init\_data](#syntax-instr-array)
        
    *   [array.init\_elem](#syntax-instr-array)
        
*   New [reference instructions](#syntax-instr-ref) for converting [external types](#syntax-externtype):
    
    *   [any.convert\_extern](#syntax-instr-extern)
        
    *   [extern.convert\_any](#syntax-instr-extern)
        
*   Extended set of [constant instructions](#valid-const) with:
    
    *   [ref.i31](#syntax-instr-i31)
        
    *   [struct.new](#syntax-instr-struct)
        
    *   [struct.new\_default](#syntax-instr-struct)
        
    *   [array.new](#syntax-instr-array)
        
    *   [array.new\_default](#syntax-instr-array)
        
    *   [array.new\_fixed](#syntax-instr-array)
        
    *   [any.convert\_extern](#syntax-instr-extern)
        
    *   [extern.convert\_any](#syntax-instr-extern)
        

##### Relaxed Vector Instructions[](#relaxed-vector-instructions①)

Added new _relaxed_ vector instructions, whose behaviour is non-deterministic and implementation-dependent. [\[14\]](#proposal-relaxed)

*   New binary [vector instruction](#syntax-instr-vec-relaxed):
    
    *   fNxM.relaxed\_min
        
    *   fNxM.relaxed\_max
        
    *   i16x8.relaxed\_q15mulr\_s
        
    *   i16x8.relaxed\_dot\_i8x16\_i7x16\_s
        
*   New ternary [vector instruction](#syntax-instr-vec-relaxed):
    
    *   fNxM.relaxed\_madd
        
    *   fNxM.relaxed\_nmadd
        
    *   iNxM.relaxed\_laneselect
        
    *   i32x4.relaxed\_dot\_i8x16\_i7x16\_add\_s
        
*   New conversion [vector instructions](#syntax-instr-vec-relaxed):
    
    *   i32x4.relaxed\_trunc\_f32x4\_[sx](#syntax-sx)
        
    *   i32x4.relaxed\_trunc\_f64x2\_[sx](#syntax-sx)\_zero
        
*   New byte reordering [vector instruction](#syntax-instr-vec-relaxed):
    
    *   i8x16.relaxed\_swizzle
        

##### Profiles[](#profiles②)

Introduced the concept of [profile](#profiles) for specifying language subsets.

*   A new profile defining a [deterministic](#profile-deterministic) mode of execution.
    

##### Custom Annotations[](#custom-annotations③)

Added generic syntax for custom annotations in the text format, mirroring the role of custom sections in the binary format. [\[15\]](#proposal-annot)

*   [Annotations](#text-annot) of the form ‘(@id …)’ are allowed anywhere in the [text format](#text)
    
*   [Identifiers](#text-id) can be escaped as ‘@"…"’ with arbitrary [names](#text-name)
    
*   Defined [name annotations](#text-nameannot) ‘(@name "…")’ for:
    
    *   [module names](#text-modulenameannot)
        
    *   [type names](#text-typenameannot)
        
    *   [function names](#text-funcnameannot)
        
    *   [local names](#text-localnameannot)
        
    *   [field names](#text-fieldnameannot)
        
*   Defined [custom annotation](#text-customannot) ‘(@custom "…")’ to represent arbitrary [custom sections](#binary-customsec) in the text format
    

\[[7](#id10)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/extended-const/](https://github.com/WebAssembly/spec/tree/main/proposals/extended-const/)

\[[8](#id11)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/tail-call/](https://github.com/WebAssembly/spec/tree/main/proposals/tail-call/)

\[[9](#id12)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/exception-handling/](https://github.com/WebAssembly/spec/tree/main/proposals/exception-handling/)

\[[10](#id13)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/multi-memory/](https://github.com/WebAssembly/spec/tree/main/proposals/multi-memory/)

\[[11](#id14)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/memory64/](https://github.com/WebAssembly/spec/tree/main/proposals/memory64/)

\[[12](#id15)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/function-references/](https://github.com/WebAssembly/spec/tree/main/proposals/function-references/)

\[[13](#id16)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/gc/](https://github.com/WebAssembly/spec/tree/main/proposals/gc/)

\[[14](#id17)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/relaxed-simd/](https://github.com/WebAssembly/spec/tree/main/proposals/relaxed-simd/)

\[[15](#id18)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/annotations/](https://github.com/WebAssembly/spec/tree/main/proposals/annotations/)

### A.9 Index of Types[](#a9-index-of-types)

Category

Constructor

Binary Opcode

[Type index](#syntax-typeidx)

x

(positive number as [s32](#binary-int) or [u32](#binary-int))

[Number type](#syntax-numtype)

[i32](#syntax-numtype)

0x7F (-1 as [s7](#binary-int))

[Number type](#syntax-numtype)

[i64](#syntax-numtype)

0x7E (-2 as [s7](#binary-int))

[Number type](#syntax-numtype)

[f32](#syntax-numtype)

0x7D (-3 as [s7](#binary-int))

[Number type](#syntax-numtype)

[f64](#syntax-numtype)

0x7C (-4 as [s7](#binary-int))

[Vector type](#syntax-vectype)

[v128](#syntax-vectype)

0x7B (-5 as [s7](#binary-int))

(reserved)

0x7A .. 0x79

[Packed type](#syntax-packtype)

[i8](#syntax-storagetype)

0x78 (-8 as [s7](#binary-int))

[Packed type](#syntax-packtype)

[i16](#syntax-storagetype)

0x77 (-9 as [s7](#binary-int))

(reserved)

0x78 .. 0x75

[Heap type](#syntax-heaptype)

[noexn](#syntax-heaptype)

0x74 (-12 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[nofunc](#syntax-heaptype)

0x73 (-13 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[noextern](#syntax-heaptype)

0x72 (-14 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[none](#syntax-heaptype)

0x71 (-15 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[func](#syntax-func)

0x70 (-16 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[extern](#syntax-heaptype)

0x6F (-17 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[any](#syntax-heaptype)

0x6E (-18 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[eq](#syntax-heaptype)

0x6D (-19 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[i31](#syntax-heaptype)

0x6C (-20 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[struct](#syntax-heaptype)

0x6B (-21 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[array](#syntax-heaptype)

0x6A (-22 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[exn](#syntax-heaptype)

0x69 (-23 as [s7](#binary-int))

(reserved)

0x68 .. 0x65

[Reference type](#syntax-reftype)

[ref](#syntax-reftype)

0x64 (-28 as [s7](#binary-int))

[Reference type](#syntax-reftype)

[ref](#syntax-reftype) [null](#syntax-reftype)

0x63 (-29 as [s7](#binary-int))

(reserved)

0x62 .. 0x61

[Composite type](#syntax-comptype)

[func](#syntax-comptype) \[[valtype](#syntax-valtype)∗\][→](#syntax-comptype)\[[valtype](#syntax-valtype)∗\]

0x60 (-32 as [s7](#binary-int))

[Composite type](#syntax-comptype)

[struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗

0x5F (-33 as [s7](#binary-int))

[Composite type](#syntax-comptype)

[array](#syntax-comptype) [fieldtype](#syntax-fieldtype)

0x5E (-34 as [s7](#binary-int))

(reserved)

0x5D .. 0x51

[Sub type](#syntax-subtype)

[sub](#syntax-subtype) [typeidx](#syntax-typeidx)∗ [comptype](#syntax-comptype)

0x50 (-48 as [s7](#binary-int))

[Sub type](#syntax-subtype)

[sub](#syntax-subtype) [final](#syntax-subtype) [typeidx](#syntax-typeidx)∗ [comptype](#syntax-comptype)

0x4F (-49 as [s7](#binary-int))

[Recursive type](#syntax-rectype)

[rec](#syntax-rectype) [subtype](#syntax-subtype)∗

0x4E (-50 as [s7](#binary-int))

(reserved)

0x4D .. 0x41

[Result type](#syntax-resulttype)

\[ϵ\]

0x40 (-64 as [s7](#binary-int))

[Tag type](#syntax-tagtype)

[typeuse](#syntax-typeuse)

(none)

[Global type](#syntax-globaltype)

[mut](#syntax-mut) [valtype](#syntax-valtype)

(none)

[Memory type](#syntax-memtype)

[addrtype](#syntax-addrtype) [limits](#syntax-limits)

(none)

[Table type](#syntax-tabletype)

[addrtype](#syntax-addrtype) [limits](#syntax-limits) [reftype](#syntax-reftype)

(none)

### A.10 Index of Instructions[](#a10-index-of-instructions)

Instruction

Binary Opcode

Type

Validation

Execution

[unreachable](#syntax-instr-control)

0x00

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-unreachable)

[execution](#exec-unreachable)

[nop](#syntax-instr-control)

0x01

\[\][→](#syntax-instrtype)\[\]

[validation](#valid-nop)

[execution](#exec-nop)

[block](#syntax-instr-control) bt

0x02

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-block)

[execution](#exec-block)

[loop](#syntax-instr-control) bt

0x03

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-loop)

[execution](#exec-loop)

[if](#syntax-instr-control) bt

0x04

\[t1∗​ [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-if)

[execution](#exec-if)

[else](#syntax-instr-control)

0x05

(reserved)

0x06

(reserved)

0x07

[throw](#syntax-instr-control) x

0x08

\[t1∗​ tx∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-throw)

[execution](#exec-throw)

(reserved)

0x09

[throw\_ref](#syntax-instr-control)

0x0A

\[t1∗​ [exnref](#syntax-reftype)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-throw-ref)

[execution](#exec-throw-ref)

[end](#syntax-instr-control)

0x0B

[br](#syntax-instr-control) l

0x0C

\[t1∗​ t∗\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-br)

[execution](#exec-br)

[br\_if](#syntax-instr-control) l

0x0D

\[t∗ [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t∗\]

[validation](#valid-br-if)

[execution](#exec-br-if)

[br\_table](#syntax-instr-control) l∗ l

0x0E

\[t1∗​ t∗ [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-br-table)

[execution](#exec-br-table)

[return](#syntax-instr-control)

0x0F

\[t1∗​ t∗\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-return)

[execution](#exec-return)

[call](#syntax-instr-control) x

0x10

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-call)

[execution](#exec-call)

[call\_indirect](#syntax-instr-control) x y

0x11

\[t1∗​ [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-call-indirect)

[execution](#exec-call-indirect)

[return\_call](#syntax-instr-control) x

0x12

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-return-call)

[execution](#exec-return-call)

[return\_call\_indirect](#syntax-instr-control) x y

0x13

\[t1∗​ [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-return-call-indirect)

[execution](#exec-return-call-indirect)

[call\_ref](#syntax-instr-control) x

0x14

\[t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-call-ref)

[execution](#exec-call-ref)

[return\_call\_ref](#syntax-instr-control) x

0x15

\[t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-return-call-ref)

[execution](#exec-return-call-ref)

(reserved)

0x16

(reserved)

0x17

(reserved)

0x18

(reserved)

0x19

[drop](#syntax-instr-parametric)

0x1A

\[t\][→](#syntax-instrtype)\[\]

[validation](#valid-drop)

[execution](#exec-drop)

[select](#syntax-instr-parametric)

0x1B

\[t t [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t\]

[validation](#valid-select)

[execution](#exec-select)

[select](#syntax-instr-parametric) t

0x1C

\[t t [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t\]

[validation](#valid-select)

[execution](#exec-select)

(reserved)

0x1D

(reserved)

0x1E

[try\_table](#syntax-instr-control) bt

0x1F

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-try-table)

[execution](#exec-try-table)

[local.get](#syntax-instr-variable) x

0x20

\[\][→](#syntax-instrtype)\[t\]

[validation](#valid-local-get)

[execution](#exec-local-get)

[local.set](#syntax-instr-variable) x

0x21

\[t\][→](#syntax-instrtype)\[\]

[validation](#valid-local-set)

[execution](#exec-local-set)

[local.tee](#syntax-instr-variable) x

0x22

\[t\][→](#syntax-instrtype)\[t\]

[validation](#valid-local-tee)

[execution](#exec-local-tee)

[global.get](#syntax-instr-variable) x

0x23

\[\][→](#syntax-instrtype)\[t\]

[validation](#valid-global-get)

[execution](#exec-global-get)

[global.set](#syntax-instr-variable) x

0x24

\[t\][→](#syntax-instrtype)\[\]

[validation](#valid-global-set)

[execution](#exec-global-set)

[table.get](#syntax-instr-table) x

0x25

\[at\][→](#syntax-instrtype)\[t\]

[![W3C](https://www.w3.org/StyleSheets/TR/2021/logos/W3C)](https://www.w3.org/)

WebAssembly Core Specification
==============================

[Editor’s Draft](https://www.w3.org/standards/types/#ED), 21 January 2026

More details about this document

This version:

[https://webassembly.github.io/spec/core/bikeshed/](https://webassembly.github.io/spec/core/bikeshed/)

Latest published version:

[https://www.w3.org/TR/wasm-core-2/](https://www.w3.org/TR/wasm-core-2/)

Implementation Report:

[https://webassembly.org/features/](https://webassembly.org/features/)

Feedback:

[GitHub](https://github.com/WebAssembly/spec/issues)

Editor:

Andreas Rossberg

Issue Tracking:

[GitHub Issues](https://github.com/WebAssembly/spec/labels/wasm-core-2)

[Copyright](https://www.w3.org/policies/#copyright) © 2026 [World Wide Web Consortium](https://www.w3.org/). W3C® [liability](https://www.w3.org/policies/#Legal_Disclaimer), [trademark](https://www.w3.org/policies/#W3C_Trademarks) and [permissive document license](https://www.w3.org/copyright/software-license/ "W3C Software and Document License") rules apply.

* * *

Abstract
--------

This document describes release 3.0 of the core WebAssembly standard, a safe, portable, low-level code format designed for efficient execution and compact representation.

This is part of a collection of related documents: the [Core WebAssembly Specification](https://www.w3.org/TR/wasm-core/), the [WebAssembly JS Interface](https://www.w3.org/TR/wasm-js-api/), and the [WebAssembly Web API](https://www.w3.org/TR/wasm-web-api/).

Status of this document
-----------------------

_This section describes the status of this document at the time of its publication. A list of current W3C publications and the latest revision of this technical report can be found in the [W3C technical reports index.](https://www.w3.org/TR/)_

This is a public copy of the editors’ draft. It is provided for discussion only and may change at any moment. Its publication here does not imply endorsement of its contents by W3C. Don’t cite this document other than as work in progress.

[GitHub Issues](https://github.com/WebAssembly/spec/issues) are preferred for discussion of this specification. All issues and comments are [archived](https://github.com/WebAssembly/spec/issues?utf8=%E2%9C%93&q=is%3Aissue++).

This document was produced by the [WebAssembly Working Group](https://www.w3.org/groups/wg/wasm).

This document was produced by a group operating under the [W3C Patent Policy](https://www.w3.org/policies/patent-policy/). W3C maintains a [public list of any patent disclosures](https://www.w3.org/2004/01/pp-impl/101196/status) made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent that the individual believes contains [Essential Claim(s)](https://www.w3.org/policies/patent-policy/#def-essential) must disclose the information in accordance with [section 6 of the W3C Patent Policy](https://www.w3.org/policies/patent-policy/#sec-Disclosure).

This document is governed by the [18 August 2025 W3C Process Document](https://www.w3.org/policies/process/20250818/).

Table of Contents
-----------------

1.  [1 Introduction](#introduction①)
    1.  [1.1 Introduction](#introduction③)
        1.  [1.1.1 Design Goals](#design-goals①)
        2.  [1.1.2 Scope](#scope①)
        3.  [1.1.3 Security Considerations](#security-considerations①)
        4.  [1.1.4 Dependencies](#dependencies①)
    2.  [1.2 Overview](#overview①)
        1.  [1.2.1 Concepts](#concepts①)
        2.  [1.2.2 Semantic Phases](#semantic-phases①)
2.  [2 Structure](#structure①)
    1.  [2.1 Conventions](#conventions①)
        1.  [2.1.1 Grammar Notation](#grammar-notation①)
        2.  [2.1.2 Auxiliary Notation](#auxiliary-notation①)
        3.  [2.1.3 Lists](#lists①)
    2.  [2.2 Values](#values①)
        1.  [2.2.1 Bytes](#bytes①)
        2.  [2.2.2 Integers](#integers①)
        3.  [2.2.3 Floating-Point](#floating-point①)
        4.  [2.2.4 Vectors](#vectors①)
        5.  [2.2.5 Names](#names①)
    3.  [2.3 Types](#types①)
        1.  [2.3.1 Number Types](#number-types①)
        2.  [2.3.2 Vector Types](#vector-types①)
        3.  [2.3.3 Type Uses](#type-uses①)
        4.  [2.3.4 Heap Types](#heap-types①)
        5.  [2.3.5 Reference Types](#reference-types①)
        6.  [2.3.6 Value Types](#value-types①)
        7.  [2.3.7 Result Types](#result-types①)
        8.  [2.3.8 Block Types](#block-types①)
        9.  [2.3.9 Composite Types](#composite-types①)
        10.  [2.3.10 Recursive Types](#recursive-types①)
        11.  [2.3.11 Address Types](#address-types①)
        12.  [2.3.12 Limits](#limits①)
        13.  [2.3.13 Tag Types](#tag-types①)
        14.  [2.3.14 Global Types](#global-types①)
        15.  [2.3.15 Memory Types](#memory-types①)
        16.  [2.3.16 Table Types](#table-types①)
        17.  [2.3.17 Data Types](#data-types①)
        18.  [2.3.18 Element Types](#element-types①)
        19.  [2.3.19 External Types](#external-types①)
    4.  [2.4 Instructions](#instructions①)
        1.  [2.4.1 Parametric Instructions](#parametric-instructions①)
        2.  [2.4.2 Control Instructions](#control-instructions①)
        3.  [2.4.3 Variable Instructions](#variable-instructions①)
        4.  [2.4.4 Table Instructions](#table-instructions①)
        5.  [2.4.5 Memory Instructions](#memory-instructions①)
        6.  [2.4.6 Reference Instructions](#reference-instructions①)
        7.  [2.4.7 Aggregate Instructions](#aggregate-instructions①)
        8.  [2.4.8 Numeric Instructions](#numeric-instructions①)
        9.  [2.4.9 Vector Instructions](#vector-instructions①)
        10.  [2.4.10 Expressions](#expressions①)
    5.  [2.5 Modules](#modules①)
        1.  [2.5.1 Indices](#indices①)
        2.  [2.5.2 Types](#types③)
        3.  [2.5.3 Tags](#tags①)
        4.  [2.5.4 Globals](#globals①)
        5.  [2.5.5 Memories](#memories①)
        6.  [2.5.6 Tables](#tables①)
        7.  [2.5.7 Functions](#functions①)
        8.  [2.5.8 Data Segments](#data-segments①)
        9.  [2.5.9 Element Segments](#element-segments①)
        10.  [2.5.10 Start Function](#start-function①)
        11.  [2.5.11 Imports](#imports①)
        12.  [2.5.12 Exports](#exports①)
3.  [3 Validation](#validation②)
    1.  [3.1 Conventions](#conventions②⓪)
        1.  [3.1.1 Types](#types⑤)
        2.  [3.1.2 Defined Types](#defined-types①)
        3.  [3.1.3 Rolling and Unrolling](#rolling-and-unrolling①)
        4.  [3.1.4 Instruction Types](#instruction-types①)
        5.  [3.1.5 Local Types](#local-types①)
        6.  [3.1.6 Contexts](#contexts①)
        7.  [3.1.7 Prose Notation](#prose-notation①)
        8.  [3.1.8 Formal Notation](#formal-notation①)
    2.  [3.2 Types](#types⑦)
        1.  [3.2.1 Number Types](#number-types③)
        2.  [3.2.2 Vector Types](#vector-types③)
        3.  [3.2.3 Type Uses](#type-uses③)
        4.  [3.2.4 Heap Types](#heap-types③)
        5.  [3.2.5 Reference Types](#reference-types③)
        6.  [3.2.6 Value Types](#value-types③)
        7.  [3.2.7 Result Types](#result-types③)
        8.  [3.2.8 Block Types](#block-types③)
        9.  [3.2.9 Instruction Types](#instruction-types③)
        10.  [3.2.10 Composite Types](#composite-types③)
        11.  [3.2.11 Recursive Types](#recursive-types③)
        12.  [3.2.12 Limits](#limits③)
        13.  [3.2.13 Tag Types](#tag-types③)
        14.  [3.2.14 Global Types](#global-types③)
        15.  [3.2.15 Memory Types](#memory-types③)
        16.  [3.2.16 Table Types](#table-types③)
        17.  [3.2.17 External Types](#external-types③)
    3.  [3.3 Matching](#matching①)
        1.  [3.3.1 Number Types](#number-types⑤)
        2.  [3.3.2 Vector Types](#vector-types⑤)
        3.  [3.3.3 Heap Types](#heap-types⑤)
        4.  [3.3.4 Reference Types](#reference-types⑤)
        5.  [3.3.5 Value Types](#value-types⑤)
        6.  [3.3.6 Result Types](#result-types⑤)
        7.  [3.3.7 Instruction Types](#instruction-types⑤)
        8.  [3.3.8 Composite Types](#composite-types⑤)
        9.  [3.3.9 Field Types](#field-types①)
        10.  [3.3.10 Defined Types](#defined-types③)
        11.  [3.3.11 Limits](#limits⑤)
        12.  [3.3.12 Tag Types](#tag-types⑤)
        13.  [3.3.13 Global Types](#global-types⑤)
        14.  [3.3.14 Memory Types](#memory-types⑤)
        15.  [3.3.15 Table Types](#table-types⑤)
        16.  [3.3.16 External Types](#external-types⑤)
    4.  [3.4 Instructions](#instructions③)
        1.  [3.4.1 Parametric Instructions](#parametric-instructions③)
        2.  [3.4.2 Control Instructions](#control-instructions③)
        3.  [3.4.3 Variable Instructions](#variable-instructions③)
        4.  [3.4.4 Table Instructions](#table-instructions③)
        5.  [3.4.5 Memory Instructions](#memory-instructions③)
        6.  [3.4.6 Reference Instructions](#reference-instructions③)
        7.  [3.4.7 Aggregate Reference Instructions](#aggregate-reference-instructions①)
        8.  [3.4.8 Scalar Reference Instructions](#scalar-reference-instructions①)
        9.  [3.4.9 External Reference Instructions](#external-reference-instructions①)
        10.  [3.4.10 Numeric Instructions](#numeric-instructions③)
        11.  [3.4.11 Vector Instructions](#vector-instructions③)
        12.  [3.4.12 Instruction Sequences](#instruction-sequences①)
        13.  [3.4.13 Expressions](#expressions③)
    5.  [3.5 Modules](#modules③)
        1.  [3.5.1 Types](#types⑨)
        2.  [3.5.2 Tags](#tags③)
        3.  [3.5.3 Globals](#globals③)
        4.  [3.5.4 Memories](#memories③)
        5.  [3.5.5 Tables](#tables③)
        6.  [3.5.6 Functions](#functions③)
        7.  [3.5.7 Locals](#locals①)
        8.  [3.5.8 Data Segments](#data-segments③)
        9.  [3.5.9 Element Segments](#element-segments③)
        10.  [3.5.10 Start Function](#start-function③)
        11.  [3.5.11 Imports](#imports③)
        12.  [3.5.12 Exports](#exports③)
        13.  [3.5.13 Modules](#modules④)
4.  [4 Execution](#execution②)
    1.  [4.1 Conventions](#conventions②③)
        1.  [4.1.1 Prose Notation](#prose-notation③)
        2.  [4.1.2 Formal Notation](#formal-notation③)
    2.  [4.2 Runtime Structure](#runtime-structure①)
        1.  [4.2.1 Values](#values③)
        2.  [4.2.2 Results](#results①)
        3.  [4.2.3 Store](#store①)
        4.  [4.2.4 Addresses](#addresses①)
        5.  [4.2.5 External Addresses](#external-addresses①)
        6.  [4.2.6 Module Instances](#module-instances①)
        7.  [4.2.7 Function Instances](#function-instances①)
        8.  [4.2.8 Table Instances](#table-instances①)
        9.  [4.2.9 Memory Instances](#memory-instances①)
        10.  [4.2.10 Global Instances](#global-instances①)
        11.  [4.2.11 Tag Instances](#tag-instances①)
        12.  [4.2.12 Element Instances](#element-instances①)
        13.  [4.2.13 Data Instances](#data-instances①)
        14.  [4.2.14 Export Instances](#export-instances①)
        15.  [4.2.15 Aggregate Instances](#aggregate-instances①)
        16.  [4.2.16 Exception Instances](#exception-instances①)
        17.  [4.2.17 Stack](#stack①)
        18.  [4.2.18 Administrative Instructions](#administrative-instructions①)
        19.  [4.2.19 Configurations](#configurations①)
    3.  [4.3 Numerics](#numerics①)
        1.  [4.3.1 Representations](#representations①)
        2.  [4.3.2 Integer Operations](#integer-operations①)
        3.  [4.3.3 Floating-Point Operations](#floating-point-operations①)
        4.  [4.3.4 Conversions](#conversions①)
        5.  [4.3.5 Vector Operations](#vector-operations①)
        6.  [4.3.6 Relaxed Operations](#relaxed-operations①)
    4.  [4.4 Types](#types①①)
        1.  [4.4.1 Instantiation](#instantiation②)
    5.  [4.5 Values](#values⑥)
        1.  [4.5.1 Value Typing](#value-typing①)
        2.  [4.5.2 External Typing](#external-typing①)
    6.  [4.6 Instructions](#instructions⑤)
        1.  [4.6.1 Parametric Instructions](#parametric-instructions⑤)
        2.  [4.6.2 Control Instructions](#control-instructions⑤)
        3.  [4.6.3 Blocks](#blocks①)
        4.  [4.6.4 Exception Handling](#exception-handling①)
        5.  [4.6.5 Function Calls](#function-calls①)
        6.  [4.6.6 Variable Instructions](#variable-instructions⑤)
        7.  [4.6.7 Table Instructions](#table-instructions⑤)
        8.  [4.6.8 Memory Instructions](#memory-instructions⑤)
        9.  [4.6.9 Reference Instructions](#reference-instructions⑤)
        10.  [4.6.10 Numeric Instructions](#numeric-instructions⑤)
        11.  [4.6.11 Vector Instructions](#vector-instructions⑤)
        12.  [4.6.12 Expressions](#expressions⑤)
    7.  [4.7 Modules](#modules⑥)
        1.  [4.7.1 Allocation](#allocation①)
        2.  [4.7.2 Instantiation](#instantiation④)
        3.  [4.7.3 Invocation](#invocation②)
5.  [5 Binary Format](#binary-format①)
    1.  [5.1 Conventions](#conventions③①)
        1.  [5.1.1 Grammar](#grammar②)
        2.  [5.1.2 Auxiliary Notation](#auxiliary-notation③)
        3.  [5.1.3 Lists](#lists③)
    2.  [5.2 Values](#values⑧)
        1.  [5.2.1 Bytes](#bytes③)
        2.  [5.2.2 Integers](#integers⑤)
        3.  [5.2.3 Floating-Point](#floating-point⑤)
        4.  [5.2.4 Names](#names③)
    3.  [5.3 Types](#types①③)
        1.  [5.3.1 Number Types](#number-types⑦)
        2.  [5.3.2 Vector Types](#vector-types⑦)
        3.  [5.3.3 Heap Types](#heap-types⑦)
        4.  [5.3.4 Reference Types](#reference-types⑦)
        5.  [5.3.5 Value Types](#value-types⑦)
        6.  [5.3.6 Result Types](#result-types⑦)
        7.  [5.3.7 Composite Types](#composite-types⑦)
        8.  [5.3.8 Recursive Types](#recursive-types⑤)
        9.  [5.3.9 Limits](#limits⑦)
        10.  [5.3.10 Tag Types](#tag-types⑦)
        11.  [5.3.11 Global Types](#global-types⑦)
        12.  [5.3.12 Memory Types](#memory-types⑦)
        13.  [5.3.13 Table Types](#table-types⑦)
        14.  [5.3.14 External Types](#external-types⑦)
    4.  [5.4 Instructions](#instructions⑦)
        1.  [5.4.1 Parametric Instructions](#parametric-instructions⑦)
        2.  [5.4.2 Control Instructions](#control-instructions⑦)
        3.  [5.4.3 Variable Instructions](#variable-instructions⑦)
        4.  [5.4.4 Table Instructions](#table-instructions⑦)
        5.  [5.4.5 Memory Instructions](#memory-instructions⑦)
        6.  [5.4.6 Reference Instructions](#reference-instructions⑦)
        7.  [5.4.7 Aggregate Instructions](#aggregate-instructions③)
        8.  [5.4.8 Numeric Instructions](#numeric-instructions⑦)
        9.  [5.4.9 Vector Instructions](#vector-instructions⑦)
        10.  [5.4.10 Expressions](#expressions⑦)
    5.  [5.5 Modules](#modules⑨)
        1.  [5.5.1 Indices](#indices③)
        2.  [5.5.2 Sections](#sections①)
        3.  [5.5.3 Custom Section](#custom-section①)
        4.  [5.5.4 Type Section](#type-section①)
        5.  [5.5.5 Import Section](#import-section①)
        6.  [5.5.6 Function Section](#function-section①)
        7.  [5.5.7 Table Section](#table-section①)
        8.  [5.5.8 Memory Section](#memory-section①)
        9.  [5.5.9 Global Section](#global-section①)
        10.  [5.5.10 Export Section](#export-section①)
        11.  [5.5.11 Start Section](#start-section①)
        12.  [5.5.12 Element Section](#element-section①)
        13.  [5.5.13 Code Section](#code-section①)
        14.  [5.5.14 Data Section](#data-section①)
        15.  [5.5.15 Data Count Section](#data-count-section①)
        16.  [5.5.16 Tag Section](#tag-section①)
        17.  [5.5.17 Modules](#modules①⓪)
6.  [6 Text Format](#text-format①)
    1.  [6.1 Conventions](#conventions③③)
        1.  [6.1.1 Grammar](#grammar④)
        2.  [6.1.2 Abbreviations](#abbreviations①)
        3.  [6.1.3 Contexts](#contexts③)
        4.  [6.1.4 Lists](#lists⑤)
    2.  [6.2 Lexical Format](#lexical-format①)
        1.  [6.2.1 Characters](#characters①)
        2.  [6.2.2 Tokens](#tokens①)
        3.  [6.2.3 White Space](#white-space①)
        4.  [6.2.4 Comments](#comments①)
        5.  [6.2.5 Annotations](#annotations①)
    3.  [6.3 Values](#values①⓪)
        1.  [6.3.1 Integers](#integers⑦)
        2.  [6.3.2 Floating-Point](#floating-point⑦)
        3.  [6.3.3 Strings](#strings①)
        4.  [6.3.4 Names](#names⑤)
        5.  [6.3.5 Identifiers](#identifiers①)
    4.  [6.4 Types](#types①⑤)
        1.  [6.4.1 Number Types](#number-types⑨)
        2.  [6.4.2 Vector Types](#vector-types⑨)
        3.  [6.4.3 Heap Types](#heap-types⑨)
        4.  [6.4.4 Reference Types](#reference-types⑨)
        5.  [6.4.5 Value Types](#value-types⑨)
        6.  [6.4.6 Composite Types](#composite-types⑨)
        7.  [6.4.7 Recursive Types](#recursive-types⑦)
        8.  [6.4.8 Address Types](#address-types③)
        9.  [6.4.9 Limits](#limits⑨)
        10.  [6.4.10 Tag Types](#tag-types⑨)
        11.  [6.4.11 Global Types](#global-types⑨)
        12.  [6.4.12 Memory Types](#memory-types⑨)
        13.  [6.4.13 Table Types](#table-types⑨)
        14.  [6.4.14 External Types](#external-types⑨)
        15.  [6.4.15 Type Uses](#type-uses⑤)
    5.  [6.5 Instructions](#instructions⑨)
        1.  [6.5.1 Labels](#labels③)
        2.  [6.5.2 Parametric Instructions](#parametric-instructions⑨)
        3.  [6.5.3 Control Instructions](#control-instructions⑨)
        4.  [6.5.4 Variable Instructions](#variable-instructions⑨)
        5.  [6.5.5 Table Instructions](#table-instructions⑨)
        6.  [6.5.6 Memory Instructions](#memory-instructions⑨)
        7.  [6.5.7 Reference Instructions](#reference-instructions⑨)
        8.  [6.5.8 Aggregate Instructions](#aggregate-instructions⑤)
        9.  [6.5.9 Numeric Instructions](#numeric-instructions⑨)
        10.  [6.5.10 Vector Instructions](#vector-instructions⑨)
        11.  [6.5.11 Folded Instructions](#folded-instructions①)
        12.  [6.5.12 Expressions](#expressions⑨)
    6.  [6.6 Modules](#modules①②)
        1.  [6.6.1 Indices](#indices⑤)
        2.  [6.6.2 Types](#types①⑦)
        3.  [6.6.3 Tags](#tags⑨)
        4.  [6.6.4 Globals](#globals⑨)
        5.  [6.6.5 Memories](#memories⑨)
        6.  [6.6.6 Tables](#tables⑨)
        7.  [6.6.7 Functions](#functions⑨)
        8.  [6.6.8 Data Segments](#data-segments⑦)
        9.  [6.6.9 Element Segments](#element-segments⑦)
        10.  [6.6.10 Start Function](#start-function⑤)
        11.  [6.6.11 Imports](#imports⑤)
        12.  [6.6.12 Exports](#exports⑤)
        13.  [6.6.13 Modules](#modules①③)
7.  [A Appendix](#a-appendix)
    1.  [A.1 Embedding](#a1-embedding)
        1.  [Types](#types①⑨)
        2.  [Booleans](#booleans①)
        3.  [Exceptions and Errors](#exceptions-and-errors①)
        4.  [Pre- and Post-Conditions](#pre--and-post-conditions)
        5.  [Store](#store③)
        6.  [Modules](#modules①⑤)
        7.  [Module Instances](#module-instances③)
        8.  [Functions](#functions①①)
        9.  [Tables](#tables①①)
        10.  [Memories](#memories①①)
        11.  [Tags](#tags①①)
        12.  [Exceptions](#exceptions①)
        13.  [Globals](#globals①①)
        14.  [Values](#values①②)
        15.  [Matching](#matching③)
    2.  [A.2 Profiles](#a2-profiles)
        1.  [Conventions](#conventions③⑧)
        2.  [Defined Profiles](#defined-profiles①)
    3.  [A.3 Implementation Limitations](#a3-implementation-limitations)
        1.  [Syntactic Limits](#syntactic-limits①)
        2.  [Validation](#validation④)
        3.  [Execution](#execution④)
    4.  [Type Soundness](#type-soundness①)
        1.  [Contexts](#contexts⑤)
        2.  [Types](#types②①)
        3.  [Subtyping](#subtyping②)
        4.  [Results](#results③)
        5.  [Store Validity](#store-validity①)
        6.  [Configuration Validity](#configuration-validity①)
        7.  [Administrative Instructions](#administrative-instructions③)
        8.  [Store Extension](#store-extension①)
        9.  [Theorems](#theorems①)
    5.  [A.7 Type System Properties](#a7-type-system-properties)
        1.  [Principal Types](#principal-types①)
        2.  [Type Lattice](#type-lattice①)
        3.  [Compositionality](#compositionality①)
    6.  [A.4 Validation Algorithm](#a4-validation-algorithm)
        1.  [Data Structures](#data-structures①)
        2.  [Validation of Opcode Sequences](#validation-of-opcode-sequences①)
    7.  [Custom Sections and Annotations](#custom-sections-and-annotations①)
        1.  [Name Section](#name-section①)
        2.  [Name Annotations](#name-annotations①)
        3.  [Custom Annotations](#custom-annotations①)
    8.  [A.8 Change History](#a8-change-history)
        1.  [Release 2.0](#release-20)
        2.  [Release 3.0](#release-30)
    9.  [A.9 Index of Types](#a9-index-of-types)
    10.  [A.10 Index of Instructions](#a10-index-of-instructions)
    11.  [A.11 Index of Semantic Rules](#a11-index-of-semantic-rules)
        1.  [Well-formedness of Types](#well-formedness-of-types①)
        2.  [Typing of Static Constructs](#typing-of-static-constructs①)
        3.  [Typing of Runtime Constructs](#typing-of-runtime-constructs①)
        4.  [Constantness](#constantness①)
        5.  [Matching](#matching⑤)
        6.  [Store Extension](#store-extension③)
        7.  [Execution](#execution⑥)
8.  [Conformance](#w3c-conformance)
    1.  [Document conventions](#w3c-conventions)
    2.  [Conformant Algorithms](#w3c-conformant-algorithms)
9.  [References](#references)
    1.  [Normative References](#normative)

1\. Introduction[](#introduction①)
----------------------------------

### 1.1. Introduction[](#introduction③)

WebAssembly (abbreviated Wasm [\[1\]](#wasm)) is a _safe, portable, low-level code format_ designed for efficient execution and compact representation. Its main goal is to enable high performance applications on the Web, but it does not make any Web-specific assumptions or provide Web-specific features, so it can be employed in other environments as well.

WebAssembly is an open standard developed by a [W3C Community Group](https://www.w3.org/community/webassembly/).

This document describes version 3.0 (2026-01-21) of the [core](#scope) WebAssembly standard. It is intended that it will be superseded by new incremental releases with additional features in the future.

#### 1.1.1. Design Goals[](#design-goals①)

The design goals of WebAssembly are the following:

*   Fast, safe, and portable _semantics_:
    
    *   **Fast**: executes with near native code performance, taking advantage of capabilities common to all contemporary hardware.
        
    *   **Safe**: code is validated and executes in a memory-safe [\[2\]](#memorysafe), sandboxed environment preventing data corruption or security breaches.
        
    *   **Well-defined**: fully and precisely defines valid programs and their behavior in a way that is easy to reason about informally and formally.
        
    *   **Hardware-independent**: can be compiled on all modern architectures, desktop or mobile devices and embedded systems alike.
        
    *   **Language-independent**: does not privilege any particular language, programming model, or object model.
        
    *   **Platform-independent**: can be embedded in browsers, run as a stand-alone VM, or integrated in other environments.
        
    *   **Open**: programs can interoperate with their environment in a simple and universal manner.
        
*   Efficient and portable _representation_:
    
    *   **Compact**: has a binary format that is fast to transmit by being smaller than typical text or native code formats.
        
    *   **Modular**: programs can be split up in smaller parts that can be transmitted, cached, and consumed separately.
        
    *   **Efficient**: can be decoded, validated, and compiled in a fast single pass, equally with either just-in-time (JIT) or ahead-of-time (AOT) compilation.
        
    *   **Streamable**: allows decoding, validation, and compilation to begin as soon as possible, before all data has been seen.
        
    *   **Parallelizable**: allows decoding, validation, and compilation to be split into many independent parallel tasks.
        
    *   **Portable**: makes no architectural assumptions that are not broadly supported across modern hardware.
        

WebAssembly code is also intended to be easy to inspect and debug, especially in environments like web browsers, but such features are beyond the scope of this specification.

\[[1](#id1)\]

A contraction of “WebAssembly”, not an acronym, hence not using all-caps.

\[[2](#id2)\]

No program can break WebAssembly’s memory model. Of course, it cannot guarantee that an unsafe language compiling to WebAssembly does not corrupt its own memory layout, e.g. inside WebAssembly’s linear memory.

#### 1.1.2. Scope[](#scope①)

At its core, WebAssembly is a _virtual instruction set architecture (virtual ISA)_. As such, it has many use cases and can be embedded in many different environments. To encompass their variety and enable maximum reuse, the WebAssembly specification is split and layered into several documents.

This document is concerned with the core ISA layer of WebAssembly. It defines the instruction set, binary encoding, validation, and execution semantics, as well as a textual representation. It does not, however, define how WebAssembly programs can interact with a specific environment they execute in, nor how they are invoked from such an environment.

Instead, this specification is complemented by additional documents defining interfaces to specific embedding environments such as the Web. These will each define a WebAssembly _application programming interface (API)_ suitable for a given environment.

#### 1.1.3. Security Considerations[](#security-considerations①)

WebAssembly provides no ambient access to the computing environment in which code is executed. Any interaction with the environment, such as I/O, access to resources, or operating system calls, can only be performed by invoking [functions](#function) provided by the [embedder](#embedder) and imported into a WebAssembly [module](#module). An embedder can establish security policies suitable for a respective environment by controlling or limiting which functional capabilities it makes available for import. Such considerations are an embedder’s responsibility and the subject of [API definitions](#scope) for a specific environment.

Because WebAssembly is designed to be translated into machine code running directly on the host’s hardware, it is potentially vulnerable to side channel attacks on the hardware level. In environments where this is a concern, an embedder may have to put suitable mitigations into place to isolate WebAssembly computations.

#### 1.1.4. Dependencies[](#dependencies①)

WebAssembly depends on two existing standards:

*   [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic"), for the representation of [floating-point data](#syntax-float) and the semantics of respective [numeric operations](#float-ops).
    
*   [\[UNICODE\]](#biblio-unicode "The Unicode Standard"), for the representation of import/export [names](#syntax-name) and the [text format](#text).
    

However, to make this specification self-contained, relevant aspects of the aforementioned standards are defined and formalized as part of this specification, such as the [binary representation](#aux-fbits) and [rounding](#aux-ieee) of floating-point values, and the [value range](#syntax-char) and [UTF-8 encoding](#binary-utf8) of Unicode characters.

Note

The aforementioned standards are the authoritative source of all respective definitions. Formalizations given in this specification are intended to match these definitions. Any discrepancy in the syntax or semantics described is to be considered an error.

### 1.2. Overview[](#overview①)

#### 1.2.1. Concepts[](#concepts①)

WebAssembly encodes a low-level, assembly-like programming language. This language is structured around the following concepts.

**Values**

WebAssembly provides only four basic _number types_. These are integers and [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") numbers, each in 32 and 64 bit width. 32-bit integers also serve as Booleans and as memory addresses. The usual operations on these types are available, including the full matrix of conversions between them. There is no distinction between signed and unsigned integer types. Instead, integers are interpreted by respective operations as either unsigned or signed in two’s complement representation.

In addition to these basic number types, there is a single 128 bit wide vector type representing different types of packed data. The supported representations are four 32-bit, or two 64-bit [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") numbers, or different widths of packed integer values, specifically two 64-bit integers, four 32-bit integers, eight 16-bit integers, or sixteen 8-bit integers.

Finally, values can consist of opaque _references_ that represent pointers towards different sorts of entities. Unlike with other types, their size or representation is not observable.

**Instructions**

The computational model of WebAssembly is based on a _stack machine_. Code consists of sequences of _instructions_ that are executed in order. Instructions manipulate values on an implicit _operand stack_ [\[1\]](#stackmachine) and fall into two main categories. _Simple_ instructions perform basic operations on data. They pop arguments from the operand stack and push results back to it. _Control_ instructions alter control flow. Control flow is _structured_, meaning it is expressed with well-nested constructs such as blocks, loops, and conditionals. Branches can only target such constructs.

**Traps**

Under some conditions, certain instructions may produce a _trap_, which immediately aborts execution. Traps cannot be handled by WebAssembly code, but are reported to the outside environment, where they typically can be caught.

**Functions**

Code is organized into separate _functions_. Each function takes a sequence of values as parameters and returns a sequence of values as results. Functions can call each other, including recursively, resulting in an implicit call stack that cannot be accessed directly. Functions may also declare mutable _local variables_ that are usable as virtual registers.

**Tables**

A _table_ is an array of opaque values of a particular _reference type_. It allows programs to select such values indirectly through a dynamic index operand. Thereby, for example, a program can call functions indirectly through a dynamic index into a table. This allows emulating function pointers by way of table indices.

**Linear Memory**

A _linear memory_ is a contiguous, mutable array of raw bytes. Such a memory is created with an initial size but can be grown dynamically. A program can load and store values from/to a linear memory at any byte address (including unaligned). Integer loads and stores can specify a _storage size_ which is smaller than the size of the respective value type. A trap occurs if an access is not within the bounds of the current memory size.

**Modules**

A WebAssembly binary takes the form of a _module_ that contains definitions for functions, tables, and linear memories, as well as mutable or immutable _global variables_. Definitions can also be _imported_, specifying a module/name pair and a suitable type. Each definition can optionally be _exported_ under one or more names. In addition to definitions, modules can define initialization data for their memories or tables that takes the form of _segments_ copied to given offsets. They can also define a _start function_ that is automatically executed.

**Embedder**

A WebAssembly implementation will typically be _embedded_ into a _host_ environment. This environment defines how loading of modules is initiated, how imports are provided (including host-side definitions), and how exports can be accessed. However, the details of any particular embedding are beyond the scope of this specification, and will instead be provided by complementary, environment-specific API definitions.

\[[1](#id2)\]

In practice, implementations need not maintain an actual operand stack. Instead, the stack can be viewed as a set of anonymous registers that are implicitly referenced by instructions. The [type system](#validation) ensures that the stack height, and thus any referenced register, is always known statically.

#### 1.2.2. Semantic Phases[](#semantic-phases①)

Conceptually, the semantics of WebAssembly is divided into three phases. For each part of the language, the specification specifies each of them.

**Decoding**

WebAssembly modules are distributed in a _binary format_. _Decoding_ processes that format and converts it into an internal representation of a module. In this specification, this representation is modelled by _abstract syntax_, but a real implementation could compile directly to machine code instead.

**Validation**

A decoded module has to be _valid_. Validation checks a number of well-formedness conditions to guarantee that the module is meaningful and safe. In particular, it performs _type checking_ of functions and the instruction sequences in their bodies, ensuring for example that the operand stack is used consistently.

**Execution**

Finally, a valid module can be _executed_. Execution can be further divided into two phases:

**Instantiation**. A module _instance_ is the dynamic representation of a module, complete with its own state and execution stack. Instantiation executes the module body itself, given definitions for all its imports. It initializes globals, memories and tables and invokes the module’s start function if defined. It returns the instances of the module’s exports.

**Invocation**. Once instantiated, further WebAssembly computations can be initiated by _invoking_ an exported function on a module instance. Given the required arguments, that executes the respective function and returns its results.

Instantiation and invocation are operations within the embedding environment.

2\. Structure[](#structure①)
----------------------------

### 2.1. Conventions[](#conventions①)

WebAssembly is a programming language that has multiple concrete representations (its [binary format](#binary) and the [text format](#text)). Both map to a common structure. For conciseness, this structure is described in the form of an _abstract syntax_. All parts of this specification are defined in terms of this abstract syntax.

#### 2.1.1. Grammar Notation[](#grammar-notation①)

The following conventions are adopted in defining grammar rules for abstract syntax.

*   Terminal symbols (atoms) are written in sans-serif font or in symbolic form: i32, nop, →, \[,\].
    
*   Nonterminal symbols are written in italic font: [valtype](#syntax-valtype), [instr](#syntax-instr).
    
*   An is a sequence of n≥0 iterations of A.
    
*   A∗ is a possibly empty sequence of iterations of A. (This is a shorthand for An used where n is not relevant.)
    
*   A+ is a non-empty sequence of iterations of A. (This is a shorthand for An where n≥1.)
    
*   A? is an optional occurrence of A. (This is a shorthand for An where n≤1.)
    
*   Productions are written ​sym​::=​A1​ ∣ … ∣ An​​.
    
*   Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, ​sym​::=​A1​​, and starting continuations with ellipses, ​sym​::=​… ∣ A2​​.
    
*   Some productions are augmented with side conditions, “ifcondition”, that provide a shorthand for a combinatorial expansion of the production into many separate cases.
    
*   If the same meta variable or non-terminal symbol appears multiple times in a production, then all those occurrences must have the same instantiation. (This is a shorthand for a side condition requiring multiple different variables to be equal.)
    

#### 2.1.2. Auxiliary Notation[](#auxiliary-notation①)

When dealing with syntactic constructs the following notation is also used:

*   ϵ denotes the empty sequence.
    
*   ∣s∣ denotes the length of a sequence s.
    
*   s\[i\] denotes the i\-th element of a sequence s, starting from 0.
    
*   s\[i:n\] denotes the sub-sequence s\[i\]…s\[i+n−1\] of a sequence s.
    
*   s\[\[i\]\=A\] denotes the same sequence as s, except that the i\-th element is replaced with A.
    
*   s\[\[i:n\]\=An\] denotes the same sequence as s, except that the sub-sequence s\[i:n\] is replaced with An.
    
*   s1​⊕s2​ denotes the sequence s1​ concatenated with s2​; this is equivalent to s1​ s2​, but used for clarity.
    
*   ⨁s∗ denotes the flattened sequence, formed by concatenating all sequences si​ in s∗.
    
*   A∈s denotes that A is a member of the sequence s, that is, s is of the form s1​ A s2​ for some sequences s1​, s2​.
    

Moreover, the following conventions are employed:

*   The notation xn, where x is a non-terminal symbol, is treated as a meta variable ranging over respective sequences of x (similarly for x∗, x+, x?).
    
*   When given a sequence xn, then the occurrences of x in an iterated sequence (…x…)n are assumed to denote the individual elements of xn, respectively (similarly for x∗, x+, x?). This implicitly expresses a form of mapping syntactic constructions over a sequence.
    
*   ei<n denotes the same sequence as en, but implicitly also defines in to be the sequence of values 0 to (n−1).
    

Note

For example, if xn is the sequence a b c, then (f(x)+1)n denotes the sequence (f(a)+1) (f(b)+1) (f(c)+1).

The form ei<n additionally gives access to an index variable inside the iteration. For example, (f(x)+i)i<n denotes the sequence (f(a)+0) (f(b)+1) (f(c)+2).

Productions of the following form are interpreted as _records_ that map a fixed set of fields fieldi​ to “values” Ai​, respectively:

​r​::=​{field1​ A1​,field2​ A2​,… }​​​

The following notation is adopted for manipulating such records:

*   Where the type of a record is clear from context, empty fields with value ϵ are often omitted.
    
*   r.field denotes the contents of the field component of r.
    
*   r\[.field\=A\] denotes the same record as r, except that the value of the field component is replaced with A.
    
*   r\[.field\=⊕A∗\] denotes the same record as r, except that A∗ is appended to the sequence value of the field component, that is, it is short for r\[.field\=r.field⊕A∗\].
    
*   r1​⊕r2​ denotes the composition of two identically shaped records by concatenating each field of sequences point-wise:
    
    {field1​A1∗​,field2​A2∗​,…}⊕{field1​B1∗​,field2​B2∗​,…}\={field1​(A1∗​⊕B1∗​),field2​(A2∗​⊕B2∗​),…}
    
*   ⨁r∗ denotes the composition of a sequence of records, respectively; if the sequence is empty, then all fields of the resulting record are empty.
    

The update notation for sequences and records generalizes recursively to nested components accessed by “paths” ​pth​::=​(\[i\] ∣ .field)+​:

*   s\[\[i\]pth\=A\] is short for s\[\[i\]\=s\[i\]\[pth\=A\]\],
    
*   r\[.field pth\=A\] is short for r\[.field\=r.field\[pth\=A\]\].
    

#### 2.1.3. Lists[](#lists①)

_Lists_ are bounded sequences of the form An (or A∗), where the A can either be values or complex constructions. A list can have at most 232−1 elements.

​[list](#syntax-list)(X)​::=​X∗​if ∣X∗∣<232​​

### 2.2. Values[](#values①)

WebAssembly programs operate on primitive numeric _values_. Moreover, in the definition of programs, immutable sequences of values occur to represent more complex data, such as text strings or other vectors.

#### 2.2.1. Bytes[](#bytes①)

The simplest form of value are raw uninterpreted _bytes_. In the abstract syntax they are represented as hexadecimal literals.

​[byte](#syntax-byte)​::=​0x00 ∣ … ∣ 0xFF​​

##### 2.2.1.1. Conventions[](#conventions③)

*   The meta variable b ranges over bytes.
    
*   Bytes are sometimes interpreted as natural numbers n<256.
    

#### 2.2.2. Integers[](#integers①)

Different classes of _integers_ with different value ranges are distinguished by their _bit width_ N and by whether they are _unsigned_ or _signed_.

​[u](#syntax-int)N[s](#syntax-int)N[i](#syntax-int)N​::=::=::=​0 ∣ … ∣ 2N−1−2N−1 ∣ … ∣ −1 ∣ 0 ∣ +1 ∣ … ∣ +2N−1−1[u](#syntax-int)N​​

The class [i](#syntax-int) defines _uninterpreted_ integers, whose signedness interpretation can vary depending on context. In the abstract syntax, they are represented as unsigned values. However, some operations [convert](#aux-signed) them to signed based on a two’s complement interpretation.

Note

The main integer types occurring in this specification are [u8](#syntax-int), [u32](#syntax-int), [u64](#syntax-int), and u128. However, other sizes occur as auxiliary constructions, e.g., in the definition of [floating-point](#syntax-float) numbers.

##### 2.2.2.1. Conventions[](#conventions④)

*   The meta variables m, n, i, j range over integers.
    
*   Numbers may be denoted by simple arithmetics, as in the grammar above. In order to distinguish arithmetics like 2N from sequences like (1)N, the latter is distinguished with parentheses.
    

#### 2.2.3. Floating-Point[](#floating-point①)

_Floating-point_ data represents 32 or 64 bit values that correspond to the respective binary formats of the [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") standard (Section 3.3).

Every value has a _sign_ and a _magnitude_. Magnitudes can either be expressed as _normal_ numbers of the form m0​ . m1​ m2​ … mm​⋅2e, where e is the exponent and m is the _significand_ whose most significant bit m0​ is 1, or as a _subnormal_ number where the exponent is fixed to the smallest possible value and m0​ is 0; among the subnormals are positive and negative zero values. Since the significands are binary values, normals are represented in the form (1+m⋅2−M)⋅2e in the abstract syntax, where M is the bit width of m; similarly for subnormals.

Possible magnitudes also include the special values ∞ (infinity) and nan (_NaN_, not a number). NaN values have a _payload_ that describes the mantissa bits in the underlying [binary representation](#aux-fbits). No distinction is made between signalling and quiet NaNs.

​[f](#syntax-float)N[fmagN](#syntax-float)​::=::=∣∣∣​+[fmagN](#syntax-float) ∣ −[fmagN](#syntax-float)(1+m⋅2−M)⋅2e(0+m⋅2−M)⋅2e∞[nan](#syntax-float)(m)​if m<2M∧2−2E−1≤e≤2E−1−1if m<2M∧2−2E−1\=eif 1≤m<2M​​

where M​\=​[signif](#aux-signif)(N)​ and E​\=​[expon](#aux-expon)(N)​ with

[signif](#aux-signif)(32)[signif](#aux-signif)(64)[expon](#aux-expon)(64)​\=\=\=​23520.8ex\][expon](#aux-expon)(32)11​\=​8​​

A _canonical NaN_ is a floating-point value ±nan([canon](#aux-canon)N​) where [canon](#aux-canon)N​ is a payload whose most significant bit is 1 while all others are 0:

[canon](#aux-canon)N​​\=​2[signif](#aux-signif)(N)−1​​

An _arithmetic NaN_ is a floating-point value ±nan(m) with m≥[canon](#aux-canon)N​, such that the most significant bit is 1 while all others are arbitrary.

Note

In the abstract syntax, subnormals are distinguished by the leading 0 of the significand. The exponent of subnormals has the same value as the smallest possible exponent of a normal number. Only in the [binary representation](#binary-float) the exponent of a subnormal is encoded differently than the exponent of any normal number.

The notion of canonical NaN defined here is unrelated to the notion of canonical NaN that the [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") standard (Section 3.5.2) defines for decimal interchange formats.

##### 2.2.3.1. Conventions[](#conventions⑤)

*   The meta variable z ranges over floating-point values where clear from context.
    
*   Where clear from context, shorthands like +1 denote floating point values like +(1+0⋅2−M)⋅20.
    

#### 2.2.4. Vectors[](#vectors①)

_Numeric vectors_ are 128-bit values that are processed by vector instructions (also known as _SIMD_ instructions, single instruction multiple data). They are represented in the abstract syntax using u128. The interpretation of lane types ([integer](#syntax-int) or [floating-point](#syntax-float) numbers) and lane sizes are determined by the specific instruction operating on them.

#### 2.2.5. Names[](#names①)

_Names_ are sequences of _characters_, which are _scalar values_ as defined by [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 2.4).

​[name](#syntax-name)[char](#syntax-name)​::=::=​[char](#syntax-name)∗U+00 ∣ … ∣ U+D7FF ∣ U+E000 ∣ … ∣ U+10FFFF​if ∣[utf8](#binary-utf8)([char](#syntax-name)∗)∣<232​

Due to the limitations of the [binary format](#binary-name), the length of a name is bounded by the length of its [UTF-8](#binary-utf8) encoding.

##### 2.2.5.1. Convention[](#convention①)

*   Characters (Unicode scalar values) are sometimes used interchangeably with natural numbers n<1114112.
    

### 2.3. Types[](#types①)

Various entities in WebAssembly are classified by types. Types are checked during [validation](#valid), [instantiation](#exec-instantiation), and possibly [execution](#syntax-call-indirect).

#### 2.3.1. Number Types[](#number-types①)

_Number types_ classify numeric values.

​[numtype](#syntax-numtype)​::=​[i32](#syntax-numtype) ∣ [i64](#syntax-numtype) ∣ [f32](#syntax-numtype) ∣ [f64](#syntax-numtype)​​

The types i32 and i64 classify 32 and 64 bit integers, respectively. Integers are not inherently signed or unsigned, their interpretation is determined by individual operations.

The types f32 and f64 classify 32 and 64 bit floating-point data, respectively. They correspond to the respective binary floating-point representations, also known as _single_ and _double_ precision, as defined by the [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") standard (Section 3.3).

Number types are _transparent_, meaning that their bit patterns can be observed. Values of number type can be stored in [memories](#syntax-mem).

##### 2.3.1.1. Conventions[](#conventions⑦)

*   The notation ∣t∣ denotes the _bit width_ of a number type t. That is, ∣i32∣\=∣f32∣\=32 and ∣i64∣\=∣f64∣\=64.
    

#### 2.3.2. Vector Types[](#vector-types①)

_Vector types_ classify vectors of [numeric](#syntax-numtype) values processed by vector instructions (also known as _SIMD_ instructions, single instruction multiple data).

​[vectype](#syntax-vectype)​::=​[v128](#syntax-vectype)​​

The type v128 corresponds to a 128 bit vector of packed integer or floating-point data. The packed data can be interpreted as signed or unsigned integers, single or double precision floating-point values, or a single 128 bit type. The interpretation is determined by individual operations.

Vector types, like [number types](#syntax-numtype) are _transparent_, meaning that their bit patterns can be observed. Values of vector type can be stored in [memories](#syntax-mem).

##### 2.3.2.1. Conventions[](#conventions⑧)

*   The notation ∣t∣ for [bit width](#bitwidth-numtype) extends to vector types as well, that is, ∣v128∣\=128.
    

#### 2.3.3. Type Uses[](#type-uses①)

A _type use_ is the use site of a [type index](#syntax-typeidx) referencing a [composite type](#syntax-comptype) [defined](#syntax-type) in a [module](#syntax-module). It classifies objects of the respective type.

​[typeuse](#syntax-typeuse)​::=​[typeidx](#syntax-typeidx)​​

The syntax of type uses is [extended](#syntax-typeuse-ext) with additional forms for the purpose of specifying [validation](#valid) and [execution](#exec).

#### 2.3.4. Heap Types[](#heap-types①)

_Heap types_ classify objects in the runtime [store](#store). There are three disjoint hierarchies of heap types:

*   _function types_ classify [functions](#syntax-func),
    
*   _aggregate types_ classify dynamically allocated _managed_ data, such as _structures_, _arrays_, or _unboxed scalars_,
    
*   _external types_ classify _external_ references possibly owned by the [embedder](#embedder).
    

The values from the latter two hierarchies are interconvertible by ways of the [extern.convert\_any](#syntax-instr-extern) and [any.convert\_extern](#syntax-instr-extern) instructions. That is, both type hierarchies are inhabited by an isomorphic set of values, but may have different, incompatible representations in practice.

​[absheaptype](#syntax-absheaptype)[heaptype](#syntax-heaptype)​::=∣∣∣::=​[any](#syntax-heaptype) ∣ [eq](#syntax-heaptype) ∣ [i31](#syntax-heaptype) ∣ [struct](#syntax-heaptype) ∣ [array](#syntax-heaptype) ∣ [none](#syntax-heaptype)[func](#syntax-heaptype) ∣ [nofunc](#syntax-heaptype)[exn](#syntax-heaptype) ∣ [noexn](#syntax-heaptype)[extern](#syntax-heaptype) ∣ [noextern](#syntax-heaptype)[absheaptype](#syntax-absheaptype) ∣ [typeuse](#syntax-typeuse)​​

A heap type is either _abstract_ or _concrete_. A concrete heap type consists of a [type use](#syntax-typeuse) that classifies an object of the respective [type](#syntax-type) defined in a module. Abstract types are denoted by individual keywords.

The type func denotes the common supertype of all [function types](#syntax-functype), regardless of their concrete definition. Dually, the type nofunc denotes the common subtype of all [function types](#syntax-functype), regardless of their concrete definition. This type has no values.

The type exn denotes the common supertype of all [exception references](#syntax-ref-exn). This type has no concrete subtypes. Dually, the type noexn denotes the common subtype of all forms of exception references. This type has no values.

The type extern denotes the common supertype of all external references received through the [embedder](#embedder). This type has no concrete subtypes. Dually, the type noextern denotes the common subtype of all forms of external references. This type has no values.

The type any denotes the common supertype of all aggregate types, as well as possibly abstract values produced by _internalizing_ an external reference of type extern. Dually, the type none denotes the common subtype of all forms of aggregate types. This type has no values.

The type eq is a subtype of any that includes all types for which references can be compared, i.e., aggregate values and i31.

The types struct and array denote the common supertypes of all [structure](#syntax-structtype) and [array](#syntax-arraytype) aggregates, respectively.

The type i31 denotes _unboxed scalars_, that is, integers injected into references. Their observable value range is limited to 31 bits.

Note

Values of type i31 are not actually allocated in the store, but represented in a way that allows them to be mixed with actual references into the store without ambiguity. Engines need to perform some form of _pointer tagging_ to achieve this, which is why one bit is reserved. Since this type is to be reliably unboxed on all hardware platforms supported by WebAssembly, it cannot be wider than 32 bits minus the tag bit.

Although the types none, nofunc, noexn, and noextern are not inhabited by any values, they can be used to form the types of all null [references](#syntax-reftype) in their respective hierarchy. For example, (ref null nofunc) is the generic type of a null reference compatible with all function reference types.

The syntax of abstract heap types is [extended](#syntax-heaptype-ext) with additional forms for the purpose of specifying [validation](#valid) and [execution](#exec).

#### 2.3.5. Reference Types[](#reference-types①)

_Reference types_ classify [values](#syntax-value) that are first-class references to objects in the runtime [store](#store).

​[reftype](#syntax-reftype)​::=​[ref](#syntax-reftype) [null](#syntax-reftype)? [heaptype](#syntax-heaptype)​​

A reference type is characterised by the [heap type](#syntax-heaptype) it points to.

In addition, a reference type of the form ref null ht is _nullable_, meaning that it can either be a proper reference to ht or [null](#syntax-null). Other references are _non-null_.

Reference types are _opaque_, meaning that neither their size nor their bit pattern can be observed. Values of reference type can be stored in [tables](#syntax-table) but not in [memories](#syntax-mem).

##### 2.3.5.1. Conventions[](#conventions⑨)

*   The reference type [anyref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [any](#syntax-heaptype)).
    
*   The reference type [eqref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [eq](#syntax-heaptype)).
    
*   The reference type [i31ref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [i31](#syntax-heaptype)).
    
*   The reference type [structref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [struct](#syntax-heaptype)).
    
*   The reference type [arrayref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [array](#syntax-heaptype)).
    
*   The reference type [funcref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)).
    
*   The reference type [exnref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [exn](#syntax-heaptype)).
    
*   The reference type [externref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [extern](#syntax-heaptype)).
    
*   The reference type [nullref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [none](#syntax-heaptype)).
    
*   The reference type [nullfuncref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [nofunc](#syntax-heaptype)).
    
*   The reference type [nullexnref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [noexn](#syntax-heaptype)).
    
*   The reference type [nullexternref](#syntax-reftype) is an abbreviation for ([ref](#syntax-reftype) [null](#syntax-reftype) [noextern](#syntax-heaptype)).
    

#### 2.3.6. Value Types[](#value-types①)

_Value types_ classify the individual values that WebAssembly code can compute with and the values that a variable accepts. They are either [number types](#syntax-numtype), [vector types](#syntax-vectype), or [reference types](#syntax-reftype).

​[consttype](#syntax-consttype)[valtype](#syntax-valtype)​::=::=​[numtype](#syntax-numtype) ∣ [vectype](#syntax-vectype)[numtype](#syntax-numtype) ∣ [vectype](#syntax-vectype) ∣ [reftype](#syntax-reftype)​​

The syntax of value types is [extended](#syntax-valtype-ext) with additional forms for the purpose of specifying [validation](#valid).

##### 2.3.6.1. Conventions[](#conventions①⓪)

*   The meta variable t ranges over value types or subclasses thereof where clear from context.
    

#### 2.3.7. Result Types[](#result-types①)

_Result types_ classify the result of [executing](#exec-instr) [instructions](#syntax-instr) or [functions](#syntax-func), which is a sequence of values, written with brackets.

​[resulttype](#syntax-resulttype)​::=​[list](#syntax-list)([valtype](#syntax-valtype))​​

#### 2.3.8. Block Types[](#block-types①)

_Block types_ classify the _input_ and _output_ of structured [control instructions](#syntax-instr-control) delimiting [blocks](#syntax-block) of instructions.

​[blocktype](#syntax-blocktype)​::=∣​[valtype](#syntax-valtype)?[typeidx](#syntax-typeidx)​​

They are given either as a [type index](#syntax-funcidx) that refers to a suitable [function type](#syntax-functype) reinterpreted as an [instruction type](#syntax-instrtype), or as an optional [value type](#syntax-valtype) inline, which is a shorthand for the instruction type ϵ→[valtype](#syntax-valtype)?.

#### 2.3.9. Composite Types[](#composite-types①)

_Composite types_ are all types composed from simpler types, including _function types_, _structure types_ and _array types_.

​[comptype](#syntax-comptype)[storagetype](#syntax-storagetype)[packtype](#syntax-packtype)​::=∣∣::=::=​[struct](#syntax-comptype) [list](#syntax-list)([fieldtype](#syntax-fieldtype))[array](#syntax-comptype) [fieldtype](#syntax-fieldtype)[func](#syntax-comptype) [resulttype](#syntax-resulttype)[→](#syntax-comptype)[resulttype](#syntax-resulttype)0.8ex\][valtype](#syntax-valtype) ∣ [packtype](#syntax-packtype)[i8](#syntax-storagetype) ∣ [i16](#syntax-storagetype)​[fieldtype](#syntax-fieldtype)​::=​[mut](#syntax-mut)? [storagetype](#syntax-storagetype)​​

Function types classify the signature of [functions](#syntax-func), mapping a list of parameters to a list of results. They are also used to classify the inputs and outputs of [instructions](#syntax-instr).

_Aggregate types_ like structure or array types consist of a list of possibly mutable, possibly packed _field types_ describing their components. Structures are heterogeneous, but require static indexing, while arrays need to be homogeneous, but allow dynamic indexing.

##### 2.3.9.1. Conventions[](#conventions①①)

*   The notation ∣t∣ for the [bit width](#bitwidth-valtype) of a [value type](#syntax-valtype) t extends to packed types as well, that is, ∣i8∣\=8 and ∣i16∣\=16.
    
*   The auxiliary function [unpack](#aux-unpack) maps a storage type to the [value type](#syntax-valtype) obtained when accessing a field:
    

[unpack](#aux-unpack)([valtype](#syntax-valtype))[unpack](#aux-unpack)([packtype](#syntax-packtype))​\=\=​[valtype](#syntax-valtype)[i32](#syntax-numtype)​​

#### 2.3.10. Recursive Types[](#recursive-types①)

_Recursive types_ denote a group of mutually recursive [composite types](#syntax-comptype), each of which can optionally declare a list of [type uses](#syntax-typeuse) of supertypes that it [matches](#match-comptype). Each type can also be declared _final_, preventing further subtyping.

​[rectype](#syntax-rectype)[subtype](#syntax-subtype)​::=::=​[rec](#syntax-rectype) [list](#syntax-list)([subtype](#syntax-subtype))[sub](#syntax-subtype) [final](#syntax-subtype)? [typeuse](#syntax-typeuse)∗ [comptype](#syntax-comptype)​​

In a [module](#syntax-module), each member of a recursive type is assigned a separate [type index](#syntax-typeidx).

#### 2.3.11. Address Types[](#address-types①)

_Address types_ are a subset of [number types](#syntax-numtype) that classify the values that can be used as offsets into [memories](#syntax-mem) and [tables](#syntax-table).

​[addrtype](#syntax-addrtype)​::=​[i32](#syntax-numtype) ∣ [i64](#syntax-numtype)​​

##### 2.3.11.1. Conventions[](#conventions①②)

The _minimum_ of two address types is defined as the address type whose [bit width](#bitwidth-numtype) is the minimum of the two.

[min](#aux-addrtype-min)(at1​,at2​)[min](#aux-addrtype-min)(at1​,at2​)​\=\=​at1​at2​​if ∣at1​∣≤∣at2​∣otherwise​​

#### 2.3.12. Limits[](#limits①)

_Limits_ classify the size range of resizeable storage associated with [memory types](#syntax-memtype) and [table types](#syntax-tabletype).

​[limits](#syntax-limits)​::=​\[[u64](#syntax-int)[..](#syntax-limits)[u64](#syntax-int)?\]​​

If no maximum is present, then the respective storage can grow to any valid size.

#### 2.3.13. Tag Types[](#tag-types①)

_Tag types_ classify the signature [tags](#syntax-tag) with a [type use](#syntax-typeuse) referring to the definition of a [function type](#syntax-functype) that declares the types of parameter and result values associated with the tag. The result type is empty for exception tags.

​[tagtype](#syntax-tagtype)​::=​[typeuse](#syntax-typeuse)​​

#### 2.3.14. Global Types[](#global-types①)

_Global types_ classify [global](#syntax-global) variables, which hold a value and can either be mutable or immutable.

​[globaltype](#syntax-globaltype)​::=​[mut](#syntax-mut)? [valtype](#syntax-valtype)​​

#### 2.3.15. Memory Types[](#memory-types①)

_Memory types_ classify linear [memories](#syntax-mem) and their size range.

​[memtype](#syntax-memtype)​::=​[addrtype](#syntax-addrtype) [limits](#syntax-limits) [page](#syntax-memtype)​​

The limits constrain the minimum and optionally the maximum size of a memory. The limits are given in units of [page size](#page-size).

#### 2.3.16. Table Types[](#table-types①)

_Table types_ classify [tables](#syntax-table) over elements of [reference type](#syntax-reftype) within a size range.

​[tabletype](#syntax-tabletype)​::=​[addrtype](#syntax-addrtype) [limits](#syntax-limits) [reftype](#syntax-reftype)​​

Like memories, tables are constrained by limits for their minimum and optionally maximum size. The limits are given in numbers of entries.

#### 2.3.17. Data Types[](#data-types①)

_Data types_ classify [data segments](#syntax-elem). Since the contents of a data segment requires no further classification, they merely consist of a universal marker ok indicating well-formedness.

​[datatype](#syntax-datatype)​::=​[ok](#valid-data)​​

#### 2.3.18. Element Types[](#element-types①)

_Element types_ classify [element segments](#syntax-elem) by the [reference type](#syntax-reftype) of its elements.

​[elemtype](#syntax-elemtype)​::=​[reftype](#syntax-reftype)​​

#### 2.3.19. External Types[](#external-types①)

_External types_ classify [imports](#syntax-import) and [external addresses](#syntax-externaddr) with their respective types.

​[externtype](#syntax-externtype)​::=​[tag](#syntax-externtype) [tagtype](#syntax-tagtype) ∣ [global](#syntax-externtype) [globaltype](#syntax-globaltype) ∣ [mem](#syntax-externtype) [memtype](#syntax-memtype) ∣ [table](#syntax-externtype) [tabletype](#syntax-tabletype) ∣ [func](#syntax-externtype) [typeuse](#syntax-typeuse)​​

For functions, the [type use](#syntax-typeuse) has to refer to the definition of a [function type](#syntax-functype).

Note

Future versions of WebAssembly may have additional uses for tags, and may allow non-empty result types in the function types of tags.

##### 2.3.19.1. Conventions[](#conventions①③)

The following auxiliary notation is defined for sequences of external types. It filters out entries of a specific kind in an order-preserving fashion:

[funcs](#syntax-externtype)(ϵ)[funcs](#syntax-externtype)(([func](#syntax-externtype) dt) xt∗)[funcs](#syntax-externtype)([externtype](#syntax-externtype) xt∗)[tables](#syntax-externtype)(([table](#syntax-externtype) tt) xt∗)[tables](#syntax-externtype)([externtype](#syntax-externtype) xt∗)[mems](#syntax-externtype)(([mem](#syntax-externtype) mt) xt∗)[mems](#syntax-externtype)([externtype](#syntax-externtype) xt∗)[globals](#syntax-externtype)(([global](#syntax-externtype) gt) xt∗)[globals](#syntax-externtype)([externtype](#syntax-externtype) xt∗)[tags](#syntax-externtype)(([tag](#syntax-externtype) jt) xt∗)[tags](#syntax-externtype)([externtype](#syntax-externtype) xt∗)​\=\=\=\=\=\=\=\=\=\=\=​ϵdt [funcs](#syntax-externtype)(xt∗)[funcs](#syntax-externtype)(xt∗)tt [tables](#syntax-externtype)(xt∗)[tables](#syntax-externtype)(xt∗)mt [mems](#syntax-externtype)(xt∗)[mems](#syntax-externtype)(xt∗)gt [globals](#syntax-externtype)(xt∗)[globals](#syntax-externtype)(xt∗)jt [tags](#syntax-externtype)(xt∗)[tags](#syntax-externtype)(xt∗)​otherwise0.8ex\][tables](#syntax-externtype)(ϵ)otherwise0.8ex\][mems](#syntax-externtype)(ϵ)otherwise0.8ex\][globals](#syntax-externtype)(ϵ)otherwise0.8ex\][tags](#syntax-externtype)(ϵ)otherwise​\=\=\=\=​ϵϵϵϵ​​

### 2.4. Instructions[](#instructions①)

WebAssembly code consists of sequences of _instructions_. Its computational model is based on a _stack machine_ in that instructions manipulate values on an implicit _operand stack_, consuming (popping) argument values and producing or returning (pushing) result values.

In addition to dynamic operands from the stack, some instructions also have static _immediate_ arguments, typically [indices](#syntax-index) or type annotations, which are part of the instruction itself.

Some instructions are [structured](#syntax-instr-control) in that they contain nested sequences of instructions.

The following sections group instructions into a number of different categories.

The syntax of instruction is further [extended](#syntax-instr-admin) with additional forms for the purpose of specifying [execution](#exec).

#### 2.4.1. Parametric Instructions[](#parametric-instructions①)

Instructions in this group can operate on operands of any [value type](#syntax-valtype).

​[instr](#syntax-instr)​::=∣∣∣​[nop](#syntax-instr-control)[unreachable](#syntax-instr-control)[drop](#syntax-instr-parametric)[select](#syntax-instr-parametric) ([valtype](#syntax-valtype)∗)?​​

The nop instruction does nothing.

The unreachable instruction causes an unconditional [trap](#trap).

The drop instruction simply throws away a single operand.

The select instruction selects one of its first two operands based on whether its third operand is zero or not. It may include a [value type](#syntax-valtype) determining the type of these operands. If missing, the operands must be of [numeric](#syntax-numtype) or [vector](#syntax-vectype) type.

Note

In future versions of WebAssembly, the type annotation on select may allow for more than a single value being selected at the same time.

#### 2.4.2. Control Instructions[](#control-instructions①)

Instructions in this group affect the flow of control.

​[instr](#syntax-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…[block](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗[loop](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗[if](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗ [else](#syntax-instr-control) [instr](#syntax-instr)∗[br](#syntax-instr-control) [labelidx](#syntax-labelidx)[br\_if](#syntax-instr-control) [labelidx](#syntax-labelidx)[br\_table](#syntax-instr-control) [labelidx](#syntax-labelidx)∗ [labelidx](#syntax-labelidx)[br\_on\_null](#syntax-instr-control) [labelidx](#syntax-labelidx)[br\_on\_non\_null](#syntax-instr-control) [labelidx](#syntax-labelidx)[br\_on\_cast](#syntax-instr-control) [labelidx](#syntax-labelidx) [reftype](#syntax-reftype) [reftype](#syntax-reftype)[br\_on\_cast\_fail](#syntax-instr-control) [labelidx](#syntax-labelidx) [reftype](#syntax-reftype) [reftype](#syntax-reftype)[call](#syntax-instr-control) [funcidx](#syntax-funcidx)[call\_ref](#syntax-instr-control) [typeuse](#syntax-typeuse)[call\_indirect](#syntax-instr-control) [tableidx](#syntax-tableidx) [typeuse](#syntax-typeuse)[return](#syntax-instr-control)[return\_call](#syntax-instr-control) [funcidx](#syntax-funcidx)[return\_call\_ref](#syntax-instr-control) [typeuse](#syntax-typeuse)[return\_call\_indirect](#syntax-instr-control) [tableidx](#syntax-tableidx) [typeuse](#syntax-typeuse)[throw](#syntax-instr-control) [tagidx](#syntax-tagidx)[throw\_ref](#syntax-instr-control)[try\_table](#syntax-instr-control) [blocktype](#syntax-blocktype) [list](#syntax-list)([catch](#syntax-catch)) [instr](#syntax-instr)∗0.8ex\][catch\_ref](#syntax-instr-control) [tagidx](#syntax-tagidx) [labelidx](#syntax-labelidx)[catch\_all](#syntax-instr-control) [labelidx](#syntax-labelidx)[catch\_all\_ref](#syntax-instr-control) [labelidx](#syntax-labelidx)​[catch](#syntax-catch)​::=​[catch](#syntax-instr-control) [tagidx](#syntax-tagidx) [labelidx](#syntax-labelidx)​​

The block, loop, if and try\_table instructions are _structured_ instructions. They bracket nested sequences of instructions, called _blocks_. As the grammar prescribes, they must be well-nested.

A structured instruction can consume _input_ and produce _output_ on the operand stack according to its annotated [block type](#syntax-blocktype).

Each structured control instruction introduces an implicit _label_. Labels are targets for branch instructions that reference them with [label indices](#syntax-labelidx). Unlike with other [index spaces](#syntax-index), indexing of labels is relative by nesting depth, that is, label 0 refers to the innermost structured control instruction enclosing the referring branch instruction, while increasing indices refer to those farther out. Consequently, labels can only be referenced from _within_ the associated structured control instruction. This also implies that branches can only be directed outwards, “breaking” from the block of the control construct they target. The exact effect depends on that control construct. In case of block or if it is a _forward jump_, resuming execution after the end of the block. In case of loop it is a _backward jump_ to the beginning of the loop.

Note

This enforces _structured control flow_. Intuitively, a branch targeting a block or if behaves like a break statement in most C-like languages, while a branch targeting a loop behaves like a continue statement.

Branch instructions come in several flavors: br performs an unconditional branch, br\_if performs a conditional branch, and br\_table performs an indirect branch through an operand indexing into the label list that is an immediate to the instruction, or to a default target if the operand is out of bounds. The br\_on\_null and br\_on\_non\_null instructions check whether a reference operand is [null](#syntax-nullref) and branch if that is the case or not the case, respectively. Similarly, br\_on\_cast and br\_on\_cast\_fail attempt a downcast on a reference operand and branch if that succeeds, or fails, respectively.

The return instruction is a shortcut for an unconditional branch to the outermost block, which implicitly is the body of the current function. Taking a branch _unwinds_ the operand stack up to the height where the targeted structured control instruction was entered. However, branches may additionally consume operands themselves, which they push back on the operand stack after unwinding. Forward branches require operands according to the output of the targeted block’s type, i.e., represent the values produced by the terminated block. Backward branches require operands according to the input of the targeted block’s type, i.e., represent the values consumed by the restarted block.

The call instruction invokes another [function](#syntax-func), consuming the necessary arguments from the stack and returning the result values of the call. The call\_ref instruction invokes a function indirectly through a [function reference](#syntax-reftype) operand. The call\_indirect instruction calls a function indirectly through an operand indexing into a [table](#syntax-table) that is denoted by a [table index](#syntax-tableidx) and must contain [function references](#syntax-reftype). Since it may contain functions of heterogeneous type, the callee is dynamically checked against the [function type](#syntax-functype) indexed by the instruction’s second immediate, and the call is aborted with a [trap](#trap) if it does not match.

The return\_call, return\_call\_ref, and return\_call\_indirect instructions are _tail-call_ variants of the previous ones. That is, they first return from the current function before actually performing the respective call. It is guaranteed that no sequence of nested calls using only these instructions can cause resource exhaustion due to hitting an [implementation’s limit](#impl-exec) on the number of active calls.

The instructions throw, throw\_ref, and try\_table are concerned with _exceptions_. The throw and throw\_ref instructions raise and reraise an exception, respectively, and transfers control to the innermost enclosing exception handler that has a matching catch clause. The try\_table instruction installs an exception _handler_ that handles exceptions as specified by its catch clauses.

#### 2.4.3. Variable Instructions[](#variable-instructions①)

Variable instructions are concerned with access to [local](#syntax-local) or [global](#syntax-global) variables.

​[instr](#syntax-instr)​::=∣∣∣∣∣​…[local.get](#syntax-instr-variable) [localidx](#syntax-localidx)[local.set](#syntax-instr-variable) [localidx](#syntax-localidx)[local.tee](#syntax-instr-variable) [localidx](#syntax-localidx)[global.get](#syntax-instr-variable) [globalidx](#syntax-globalidx)[global.set](#syntax-instr-variable) [globalidx](#syntax-globalidx)​​

These instructions get or set the values of respective variables. The local.tee instruction is like local.set but also returns its argument.

#### 2.4.4. Table Instructions[](#table-instructions①)

Instructions in this group are concerned with tables [table](#syntax-table).

​[instr](#syntax-instr)​::=∣∣∣∣∣∣∣∣​…[table.get](#syntax-instr-table) [tableidx](#syntax-tableidx)[table.set](#syntax-instr-table) [tableidx](#syntax-tableidx)[table.size](#syntax-instr-table) [tableidx](#syntax-tableidx)[table.grow](#syntax-instr-table) [tableidx](#syntax-tableidx)[table.fill](#syntax-instr-table) [tableidx](#syntax-tableidx)[table.copy](#syntax-instr-table) [tableidx](#syntax-tableidx) [tableidx](#syntax-tableidx)[table.init](#syntax-instr-table) [tableidx](#syntax-tableidx) [elemidx](#syntax-elemidx)[elem.drop](#syntax-instr-table) [elemidx](#syntax-elemidx)​​

The table.get and table.set instructions load or store an element in a table, respectively.

The table.size instruction returns the current size of a table. The table.grow instruction grows table by a given delta and returns the previous size, or −1 if enough space cannot be allocated. It also takes an initialization value for the newly allocated entries.

The table.fill instruction sets all entries in a range to a given value. The table.copy instruction copies elements from a source table region to a possibly overlapping destination region; the first index denotes the destination. The table.init instruction copies elements from a [passive element segment](#syntax-elem) into a table.

The elem.drop instruction prevents further use of a passive element segment. This instruction is intended to be used as an optimization hint. After an element segment is dropped its elements can no longer be retrieved, so the memory used by this segment may be freed.

Note

An additional instruction that accesses a table is the [control instruction](#syntax-instr-control) call\_indirect.

#### 2.4.5. Memory Instructions[](#memory-instructions①)

Instructions in this group are concerned with linear [memory](#syntax-mem).

​[memarg](#syntax-memarg)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣​{[align](#syntax-instr-memory) [u32](#syntax-int),[offset](#syntax-instr-memory) [u64](#syntax-int)}​0.8ex\][sz](#syntax-sz)\_[splat](#syntax-instr-memory)[sz](#syntax-sz)\_[zero](#syntax-instr-memory)[numtype](#syntax-numtype).[load](#syntax-instr-memory)[loadop](#syntax-loadop)[numtype](#syntax-numtype)?​ [memidx](#syntax-memidx) [memarg](#syntax-memarg)[numtype](#syntax-numtype).[store](#syntax-instr-memory)[storeop](#syntax-storeop)[numtype](#syntax-numtype)?​ [memidx](#syntax-memidx) [memarg](#syntax-memarg)[vectype](#syntax-vectype).[load](#syntax-instr-memory)[vloadop](#syntax-vloadop)[vectype](#syntax-vectype)?​ [memidx](#syntax-memidx) [memarg](#syntax-memarg)[vectype](#syntax-vectype).[load](#syntax-instr-memory)[sz](#syntax-sz)\_[lane](#syntax-instr-memory) [memidx](#syntax-memidx) [memarg](#syntax-memarg) [laneidx](#syntax-laneidx)[vectype](#syntax-vectype).[store](#syntax-instr-memory) [memidx](#syntax-memidx) [memarg](#syntax-memarg)[vectype](#syntax-vectype).[store](#syntax-instr-memory)[sz](#syntax-sz)\_[lane](#syntax-instr-memory) [memidx](#syntax-memidx) [memarg](#syntax-memarg) [laneidx](#syntax-laneidx)[memory.size](#syntax-instr-memory) [memidx](#syntax-memidx)[memory.grow](#syntax-instr-memory) [memidx](#syntax-memidx)[memory.fill](#syntax-instr-memory) [memidx](#syntax-memidx)[memory.copy](#syntax-instr-memory) [memidx](#syntax-memidx) [memidx](#syntax-memidx)[memory.init](#syntax-instr-memory) [memidx](#syntax-memidx) [dataidx](#syntax-dataidx)[data.drop](#syntax-instr-memory) [dataidx](#syntax-dataidx)​[loadop](#syntax-loadop)[i](#syntax-numtype)[N](#syntax-numtype)​if [sz](#syntax-sz)≥320.8ex\]::=[instr](#syntax-instr)[sz](#syntax-sz)\_[sx](#syntax-sx)::=if [sz](#syntax-sz)<N0.8ex\]…[storeop](#syntax-storeop)[i](#syntax-numtype)[N](#syntax-numtype)​::=[sz](#syntax-sz)if [sz](#syntax-sz)<N0.8ex\][vloadop](#syntax-vloadop)[vectype](#syntax-vectype)​::=[sz](#syntax-sz)[x](#syntax-shape)M\_[sx](#syntax-sx)if [sz](#syntax-sz)⋅M\=∣[vectype](#syntax-vectype)∣/2​

Memory is accessed with load and store instructions for the different [number types](#syntax-numtype) and [vector types](#syntax-vectype). They all take a [memory index](#syntax-memidx) and a _memory argument_ [memarg](#syntax-memarg) that contains an address _offset_ and the expected _alignment_ (expressed as the exponent of a power of 2).

Integer loads and stores can optionally specify a _storage size_ [sz](#syntax-sz) that is smaller than the [bit width](#syntax-numtype) of the respective value type. In the case of loads, a sign extension mode [sx](#syntax-sx) is then required to select appropriate behavior.

Vector loads can specify a shape that is half the [bit width](#syntax-valtype) of v128. Each lane is half its usual size, and the sign extension mode [sx](#syntax-sx) then specifies how the smaller lane is extended to the larger lane. Alternatively, vector loads can perform a _splat_, such that only a single lane of the specified storage size is loaded, and the result is duplicated to all lanes.

The static address offset is added to the dynamic address operand, yielding a 33-bit or 65-bit _effective address_ that is the zero-based index at which the memory is accessed. All values are read and written in [little endian](https://en.wikipedia.org/wiki/Endianness#Little-endian) byte order. A [trap](#trap) results if any of the accessed memory bytes lies outside the address range implied by the memory’s current size.

The memory.size instruction returns the current size of a memory. The memory.grow instruction grows a memory by a given delta and returns the previous size, or −1 if enough memory cannot be allocated. Both instructions operate in units of [page size](#page-size).

The memory.fill instruction sets all values in a region of memory to a given byte. The memory.copy instruction copies data from a source memory region to a possibly overlapping destination region in another or the same memory; the first index denotes the destination. The memory.init instruction copies data from a [passive data segment](#syntax-data) into a memory.

The data.drop instruction prevents further use of a passive data segment. This instruction is intended to be used as an optimization hint. After a data segment is dropped its data can no longer be retrieved, so the memory used by this segment may be freed.

#### 2.4.6. Reference Instructions[](#reference-instructions①)

Instructions in this group are concerned with accessing [references](#syntax-reftype).

​[instr](#syntax-instr)​::=∣∣∣∣∣∣∣​…[ref.func](#syntax-instr-ref) [funcidx](#syntax-funcidx)[ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype)[ref.is\_null](#syntax-instr-ref)[ref.as\_non\_null](#syntax-instr-ref)[ref.eq](#syntax-instr-ref)[ref.test](#syntax-instr-ref) [reftype](#syntax-reftype)[ref.cast](#syntax-instr-ref) [reftype](#syntax-reftype)​​

The ref.null and ref.func instructions produce a [null](#syntax-nullref) reference or a reference to a given function, respectively.

The instruction ref.is\_null checks for null, while ref.as\_non\_null converts a [nullable](#syntax-reftype) to a non-null one, and [traps](#trap) if it encounters null.

The ref.eq compares two references.

The instructions ref.test and ref.cast test the [dynamic type](#type-inst) of a reference operand. The former merely returns the result of the test, while the latter performs a downcast and [traps](#trap) if the operand’s type does not match.

Note

The br\_on\_null and br\_on\_non\_null instructions provide versions of ref.as\_null that branch depending on the success of failure of a null test instead of trapping. Similarly, the br\_on\_cast and br\_on\_cast\_fail instructions provides versions of ref.cast that branch depending on the success of the downcast instead of trapping.

An additional instruction operating on function references is the [control instruction](#syntax-instr-control) call\_ref.

#### 2.4.7. Aggregate Instructions[](#aggregate-instructions①)

Instructions in this group are concerned with creating and accessing [references](#syntax-reftype) to [aggregate](#syntax-aggrtype) types.

​[instr](#syntax-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…[struct.new](#syntax-instr-struct) [typeidx](#syntax-typeidx)[struct.new\_default](#syntax-instr-struct) [typeidx](#syntax-typeidx)[struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? [typeidx](#syntax-typeidx) [u32](#syntax-int)[struct.set](#syntax-instr-struct) [typeidx](#syntax-typeidx) [u32](#syntax-int)[array.new](#syntax-instr-array) [typeidx](#syntax-typeidx)[array.new\_default](#syntax-instr-array) [typeidx](#syntax-typeidx)[array.new\_fixed](#syntax-instr-array) [typeidx](#syntax-typeidx) [u32](#syntax-int)[array.new\_data](#syntax-instr-array) [typeidx](#syntax-typeidx) [dataidx](#syntax-dataidx)[array.new\_elem](#syntax-instr-array) [typeidx](#syntax-typeidx) [elemidx](#syntax-elemidx)[array.get](#syntax-instr-array)\_[sx](#syntax-sx)? [typeidx](#syntax-typeidx)[array.set](#syntax-instr-array) [typeidx](#syntax-typeidx)[array.len](#syntax-instr-array)[array.fill](#syntax-instr-array) [typeidx](#syntax-typeidx)[array.copy](#syntax-instr-array) [typeidx](#syntax-typeidx) [typeidx](#syntax-typeidx)[array.init\_data](#syntax-instr-array) [typeidx](#syntax-typeidx) [dataidx](#syntax-dataidx)[array.init\_elem](#syntax-instr-array) [typeidx](#syntax-typeidx) [elemidx](#syntax-elemidx)[ref.i31](#syntax-instr-i31)[i31.get](#syntax-instr-i31)\_[sx](#syntax-sx)[extern.convert\_any](#syntax-instr-extern)[any.convert\_extern](#syntax-instr-extern)​​

The instructions struct.new and struct.new\_default allocate a new [structure](#syntax-structtype), initializing them either with operands or with default values. The remaining instructions on structs access individual fields, allowing for different sign extension modes in the case of [packed](#syntax-packtype) storage types.

Similarly, [arrays](#syntax-arraytype) can be allocated either with an explicit initialization operand or a default value. Furthermore, array.new\_fixed allocates an array with statically fixed size, and array.new\_data and array.new\_elem allocate an array and initialize it from a [data](#syntax-data) or [element](#syntax-elem) segment, respectively. The instructions array.get, array.get [sx](#syntax-sx), and array.set access individual slots, again allowing for different sign extension modes in the case of a [packed](#syntax-packtype) storage type; array.len produces the length of an array; array.fill fills a specified slice of an array with a given value and array.copy, array.init\_data, and array.init\_elem copy elements to a specified slice of an array from a given array, data segment, or element segment, respectively.

The instructions ref.i31 and i31.get [sx](#syntax-sx) convert between type i32 and an unboxed [scalar](#syntax-i31).

The instructions any.convert\_extern and extern.convert\_any allow lossless conversion between references represented as type ([ref](#syntax-reftype) [null](#syntax-reftype) [extern](#syntax-heaptype)) and as ([ref](#syntax-reftype) [null](#syntax-reftype) [any](#syntax-heaptype)).

#### 2.4.8. Numeric Instructions[](#numeric-instructions①)

Numeric instructions provide basic operations over numeric [values](#syntax-value) of specific [type](#syntax-numtype). These operations closely match respective operations available in hardware.

​[sz](#syntax-sz)[sx](#syntax-sx)[num](#syntax-num)[f](#syntax-numtype)[N](#syntax-numtype)​[unop](#syntax-unop)[f](#syntax-numtype)[N](#syntax-numtype)​[binop](#syntax-binop)[f](#syntax-numtype)[N](#syntax-numtype)​[relop](#syntax-relop)[f](#syntax-numtype)[N](#syntax-numtype)​[cvtop](#syntax-cvtop)[i](#syntax-numtype)[N](#syntax-numtype)1​,[f](#syntax-numtype)[N](#syntax-numtype)2​​[cvtop](#syntax-cvtop)[f](#syntax-numtype)[N](#syntax-numtype)1​,[i](#syntax-numtype)[N](#syntax-numtype)2​​[cvtop](#syntax-cvtop)[f](#syntax-numtype)[N](#syntax-numtype)1​,[f](#syntax-numtype)[N](#syntax-numtype)2​​​::=::=::=∣∣∣∣∣∣::=∣::=::=∣::=∣::=∣∣::=∣​8 ∣ 16 ∣ 32 ∣ 64[u](#syntax-sx) ∣ [s](#syntax-sx)0.8ex\][f](#syntax-float)N0.8ex\][numtype](#syntax-numtype).[const](#syntax-instr-numeric) [num](#syntax-num)[numtype](#syntax-numtype)​[numtype](#syntax-numtype).[unop](#syntax-unop)[numtype](#syntax-numtype)​[numtype](#syntax-numtype).[binop](#syntax-binop)[numtype](#syntax-numtype)​[numtype](#syntax-numtype).[testop](#syntax-testop)[numtype](#syntax-numtype)​[numtype](#syntax-numtype).[relop](#syntax-relop)[numtype](#syntax-numtype)​[numtype](#syntax-numtype)1​.[cvtop](#syntax-cvtop)[numtype](#syntax-numtype)2​,[numtype](#syntax-numtype)1​​\_[numtype](#syntax-numtype)2​0.8ex\][abs](#syntax-instr-numeric) ∣ [neg](#syntax-instr-numeric) ∣ [sqrt](#syntax-instr-numeric) ∣ [ceil](#syntax-instr-numeric) ∣ [floor](#syntax-instr-numeric) ∣ [trunc](#syntax-instr-numeric) ∣ [nearest](#syntax-instr-numeric)0.8ex\][and](#syntax-instr-numeric) ∣ [or](#syntax-instr-numeric) ∣ [xor](#syntax-instr-numeric) ∣ [shl](#syntax-instr-numeric) ∣ [shr](#syntax-instr-numeric)\_[sx](#syntax-sx) ∣ [rotl](#syntax-instr-numeric) ∣ [rotr](#syntax-instr-numeric)[add](#syntax-instr-numeric) ∣ [sub](#syntax-instr-numeric) ∣ [mul](#syntax-instr-numeric) ∣ [div](#syntax-instr-numeric) ∣ [min](#syntax-instr-numeric) ∣ [max](#syntax-instr-numeric) ∣ [copysign](#syntax-instr-numeric)0.8ex\][eq](#syntax-instr-numeric) ∣ [ne](#syntax-instr-numeric) ∣ [lt](#syntax-instr-numeric) ∣ [gt](#syntax-instr-numeric) ∣ [le](#syntax-instr-numeric) ∣ [ge](#syntax-instr-numeric)0.8ex\][wrap](#syntax-instr-numeric)[convert](#syntax-instr-numeric)\_[sx](#syntax-sx)[reinterpret](#syntax-instr-numeric)[trunc](#syntax-instr-numeric)\_[sx](#syntax-sx)[trunc\_sat](#syntax-instr-numeric)\_[sx](#syntax-sx)[reinterpret](#syntax-instr-numeric)[promote](#syntax-instr-numeric)[demote](#syntax-instr-numeric)​[num](#syntax-num)[i](#syntax-numtype)[N](#syntax-numtype)​[instr](#syntax-instr)[unop](#syntax-unop)[i](#syntax-numtype)[N](#syntax-numtype)​[binop](#syntax-binop)[i](#syntax-numtype)[N](#syntax-numtype)​[testop](#syntax-testop)[i](#syntax-numtype)[N](#syntax-numtype)​[cvtop](#syntax-cvtop)[i](#syntax-numtype)[N](#syntax-numtype)1​,[i](#syntax-numtype)[N](#syntax-numtype)2​​if N1​\>N2​if N1​\=N2​if N1​\=N2​if N1​<N2​if N1​\>N2​​::=::=::=::=::=::=​[i](#syntax-int)N…[clz](#syntax-instr-numeric) ∣ [ctz](#syntax-instr-numeric) ∣ [popcnt](#syntax-instr-numeric) ∣ [extend](#syntax-instr-numeric)[sz](#syntax-sz)\_[s](#syntax-sx)[add](#syntax-instr-numeric) ∣ [sub](#syntax-instr-numeric) ∣ [mul](#syntax-instr-numeric) ∣ [div](#syntax-instr-numeric)\_[sx](#syntax-sx) ∣ [rem](#syntax-instr-numeric)\_[sx](#syntax-sx)[eqz](#syntax-instr-numeric)0.8ex\][extend](#syntax-instr-numeric)\_[sx](#syntax-sx)​if [sz](#syntax-sz)<N[relop](#syntax-relop)[i](#syntax-numtype)[N](#syntax-numtype)​if N1​<N2​​::=​[eq](#syntax-instr-numeric) ∣ [ne](#syntax-instr-numeric) ∣ [lt](#syntax-instr-numeric)\_[sx](#syntax-sx) ∣ [gt](#syntax-instr-numeric)\_[sx](#syntax-sx) ∣ [le](#syntax-instr-numeric)\_[sx](#syntax-sx) ∣ [ge](#syntax-instr-numeric)\_[sx](#syntax-sx)​​

Numeric instructions are divided by [number type](#syntax-numtype). For each type, several subcategories can be distinguished:

*   _Constants_: return a static constant.
    
*   _Unary operations_: consume one operand and produce one result of the respective type.
    
*   _Binary operations_: consume two operands and produce one result of the respective type.
    
*   _Tests_: consume one operand of the respective type and produce a Boolean integer result.
    
*   _Comparisons_: consume two operands of the respective type and produce a Boolean integer result.
    
*   _Conversions_: consume a value of one type and produce a result of another (the source type of the conversion is the one after the “\_”).
    

Some integer instructions come in two flavors, where a signedness annotation [sx](#syntax-sx) distinguishes whether the operands are to be [interpreted](#aux-signed) as [unsigned](#syntax-uint) or [signed](#syntax-sint) integers. For the other integer instructions, the use of two’s complement for the signed interpretation means that they behave the same regardless of signedness.

#### 2.4.9. Vector Instructions[](#vector-instructions①)

Vector instructions (also known as _SIMD_ instructions, _single instruction multiple data_) provide basic operations over [values](#syntax-value) of [vector type](#syntax-vectype).

​[lanetype](#syntax-lanetype)[dim](#syntax-dim)[shape](#syntax-shape)[ishape](#syntax-shape)[bshape](#syntax-shape)​::=::=::=::=::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​[numtype](#syntax-numtype) ∣ [packtype](#syntax-packtype)1 ∣ 2 ∣ 4 ∣ 8 ∣ 16[lanetype](#syntax-lanetype)[x](#syntax-shape)[dim](#syntax-dim)[shape](#syntax-shape)[shape](#syntax-shape)[vectype](#syntax-vectype).[const](#syntax-instr-numeric) [vec](#syntax-vec)[vectype](#syntax-vectype)​[vectype](#syntax-vectype).[vvunop](#syntax-vvunop)[vectype](#syntax-vectype).[vvbinop](#syntax-vvbinop)[vectype](#syntax-vectype).[vvternop](#syntax-vvternop)[vectype](#syntax-vectype).[vvtestop](#syntax-vvtestop)[shape](#syntax-shape).[vunop](#syntax-vunop)[shape](#syntax-shape)​[shape](#syntax-shape).[vbinop](#syntax-vbinop)[shape](#syntax-shape)​[shape](#syntax-shape).[vternop](#syntax-vternop)[shape](#syntax-shape)​[shape](#syntax-shape).[vtestop](#syntax-vrelop)[shape](#syntax-shape)​[shape](#syntax-shape).[vrelop](#syntax-vrelop)[shape](#syntax-shape)​[ishape](#syntax-shape).[vshiftop](#syntax-vshiftop)[ishape](#syntax-shape)​[ishape](#syntax-shape).[bitmask](#syntax-instr-vec)[bshape](#syntax-shape).[vswizzlop](#syntax-vswizzlop)[bshape](#syntax-shape)​[bshape](#syntax-shape).[shuffle](#syntax-instr-vec) [laneidx](#syntax-laneidx)∗[ishape](#syntax-shape)1​.[vextunop](#syntax-vextunop)[ishape](#syntax-shape)2​,[ishape](#syntax-shape)1​​\_[ishape](#syntax-shape)2​[ishape](#syntax-shape)1​.[vextbinop](#syntax-vextbinop)[ishape](#syntax-shape)2​,[ishape](#syntax-shape)1​​\_[ishape](#syntax-shape)2​[ishape](#syntax-shape)1​.[vextternop](#syntax-vextternop)[ishape](#syntax-shape)2​,[ishape](#syntax-shape)1​​\_[ishape](#syntax-shape)2​[ishape](#syntax-shape)1​.[narrow](#syntax-instr-vec)\_[ishape](#syntax-shape)2​\_[sx](#syntax-sx)[shape](#syntax-shape)1​.[vcvtop](#syntax-vcvtop)[shape](#syntax-shape)2​,[shape](#syntax-shape)1​​\_[shape](#syntax-shape)2​[shape](#syntax-shape).[splat](#syntax-instr-vec)[shape](#syntax-shape).[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx)? [laneidx](#syntax-laneidx)[shape](#syntax-shape).[replace\_lane](#syntax-instr-vec) [laneidx](#syntax-laneidx)​if ∣[lanetype](#syntax-lanetype)∣⋅[dim](#syntax-dim)\=128if [lanetype](#aux-lanetype)([shape](#syntax-shape))\=[i](#syntax-numtype)[N](#syntax-numtype)if [lanetype](#aux-lanetype)([shape](#syntax-shape))\=[i8](#syntax-storagetype)0.8ex\]if ∣[laneidx](#syntax-laneidx)∗∣\=[dim](#aux-dim)([bshape](#syntax-shape))if ∣[lanetype](#aux-lanetype)([ishape](#syntax-shape)2​)∣\=2⋅∣[lanetype](#aux-lanetype)([ishape](#syntax-shape)1​)∣≤32if [sx](#syntax-sx)?\=ϵ⇔[lanetype](#aux-lanetype)([shape](#syntax-shape))∈[i32](#syntax-numtype) [i64](#syntax-numtype) [f32](#syntax-numtype) [f64](#syntax-numtype)​[half](#syntax-half)::=[low](#syntax-instr-vec) ∣ [high](#syntax-instr-vec)0.8ex\][zero](#syntax-zero)::=[zero](#syntax-instr-vec)0.8ex\][laneidx](#syntax-laneidx)::=[u8](#syntax-int)0.8ex\][instr](#syntax-instr)::=…​

Vector instructions have a naming convention involving a _shape_ prefix that determines how their operands will be interpreted, written txN, and consisting of a _lane type_ t, a possibly _packed_ [numeric type](#syntax-numtype), and its _dimension_ N, which denotes the number of lanes of that type. Operations are performed point-wise on the values of each lane.

Instructions prefixed with v128 do not involve a specific interpretation, and treat the v128 as either an [i128](#syntax-int) value or a vector of 128 individual bits.

Note

For example, the shape [i32](#syntax-numtype)[x](#syntax-shape)4 interprets the operand as four [i32](#syntax-int) values, packed into an [i128](#syntax-int). The bit width of the lane type t times N always is 128.

​[vvunop](#syntax-vvunop)[vunop](#syntax-vunop)[f](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vbinop](#syntax-vbinop)[f](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vternop](#syntax-vternop)[f](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vrelop](#syntax-vrelop)[f](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vcvtop](#syntax-vcvtop)[i](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[f](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​[vcvtop](#syntax-vcvtop)[f](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[i](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​[vcvtop](#syntax-vcvtop)[f](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[f](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​​::=∣::=∣∣∣∣∣∣∣∣∣::=∣::=∣∣∣∣::=∣∣::=::=∣::=∣​[not](#syntax-instr-vec)0.8ex\][popcnt](#syntax-instr-vec)[abs](#syntax-instr-vec) ∣ [neg](#syntax-instr-vec) ∣ [sqrt](#syntax-instr-vec) ∣ [ceil](#syntax-instr-vec) ∣ [floor](#syntax-instr-vec) ∣ [trunc](#syntax-instr-vec) ∣ [nearest](#syntax-instr-vec)0.8ex\][sub](#syntax-instr-vec)[add\_sat](#syntax-instr-vec)\_[sx](#syntax-sx)[sub\_sat](#syntax-instr-vec)\_[sx](#syntax-sx)[mul](#syntax-instr-vec)[avgr](#syntax-instr-vec)\_[u](#syntax-sx)[q15mulr\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[relaxed\_q15mulr](#syntax-instr-vec)\_[s](#syntax-sx)[min](#syntax-instr-vec)\_[sx](#syntax-sx)[max](#syntax-instr-vec)\_[sx](#syntax-sx)[add](#syntax-instr-vec) ∣ [sub](#syntax-instr-vec) ∣ [mul](#syntax-instr-vec) ∣ [div](#syntax-instr-vec) ∣ [min](#syntax-instr-vec) ∣ [max](#syntax-instr-vec) ∣ [pmin](#syntax-instr-vec) ∣ [pmax](#syntax-instr-vec)[relaxed\_min](#syntax-instr-vec) ∣ [relaxed\_max](#syntax-instr-vec)0.8ex\][relaxed\_madd](#syntax-instr-vec) ∣ [relaxed\_nmadd](#syntax-instr-vec)0.8ex\][lt](#syntax-instr-vec)\_[sx](#syntax-sx)[gt](#syntax-instr-vec)\_[sx](#syntax-sx)[le](#syntax-instr-vec)\_[sx](#syntax-sx)[ge](#syntax-instr-vec)\_[sx](#syntax-sx)[eq](#syntax-instr-vec) ∣ [ne](#syntax-instr-vec) ∣ [lt](#syntax-instr-vec) ∣ [gt](#syntax-instr-vec) ∣ [le](#syntax-instr-vec) ∣ [ge](#syntax-instr-vec)0.8ex\][dot](#syntax-instr-vec)\_[s](#syntax-sx)[relaxed\_dot](#syntax-instr-vec)\_[s](#syntax-sx)[convert](#syntax-instr-vec)\_[half](#syntax-half)?\_[sx](#syntax-sx)[trunc\_sat](#syntax-instr-vec)\_[sx](#syntax-sx)\_[zero](#syntax-zero)?[relaxed\_trunc](#syntax-instr-vec)\_[sx](#syntax-sx)\_[zero](#syntax-zero)?[demote](#syntax-instr-vec)\_[zero](#syntax-instr-vec)[promote](#syntax-instr-vec)\_[low](#syntax-instr-vec)​[vvbinop](#syntax-vvbinop)if N\=8[vbinop](#syntax-vbinop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​if N≤16if N≤16if N≥16if N≤16if N\=16if N\=16if N≤32if N≤32[vternop](#syntax-vternop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vtestop](#syntax-vrelop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​if N\=64∨[sx](#syntax-sx)\=[s](#syntax-sx)if N\=64∨[sx](#syntax-sx)\=[s](#syntax-sx)if N\=64∨[sx](#syntax-sx)\=[s](#syntax-sx)if N\=64∨[sx](#syntax-sx)\=[s](#syntax-sx)[vswizzlop](#syntax-vswizzlop)[i8](#syntax-storagetype)[x](#syntax-shape)M​if 2⋅N1​\=N2​\=32if 2⋅N1​\=N2​\=160.8ex\]if N2​\=N1​\=32∧[half](#syntax-half)?\=ϵ∨N2​\=2⋅N1​∧[half](#syntax-half)?\=[low](#syntax-instr-vec)if N1​\=N2​\=32∧[zero](#syntax-zero)?\=ϵ∨N1​\=2⋅N2​∧[zero](#syntax-zero)?\=[zero](#syntax-instr-vec)if N1​\=N2​\=32∧[zero](#syntax-zero)?\=ϵ∨N1​\=2⋅N2​∧[zero](#syntax-zero)?\=[zero](#syntax-instr-vec)if N1​\=2⋅N2​if 2⋅N1​\=N2​​::=::=::=::=::=[vextternop](#syntax-vextternop)[i](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[i](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​​[and](#syntax-instr-vec) ∣ [andnot](#syntax-instr-vec) ∣ [or](#syntax-instr-vec) ∣ [xor](#syntax-instr-vec)0.8ex\][add](#syntax-instr-vec)[relaxed\_laneselect](#syntax-instr-vec)[all\_true](#syntax-instr-vec)0.8ex\][swizzle](#syntax-instr-vec) ∣ [relaxed\_swizzle](#syntax-instr-vec)0.8ex\]::=​[vvternop](#syntax-vvternop)[vrelop](#syntax-vrelop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[vshiftop](#syntax-vshiftop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​[relaxed\_dot\_add](#syntax-instr-vec)\_[s](#syntax-sx)​::=::=::=if 4⋅N1​\=N2​\=320.8ex\]​[bitselect](#syntax-instr-vec)0.8ex\][eq](#syntax-instr-vec) ∣ [ne](#syntax-instr-vec)[shl](#syntax-instr-vec) ∣ [shr](#syntax-instr-vec)\_[sx](#syntax-sx)0.8ex\][vcvtop](#syntax-vcvtop)[i](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[i](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​​[vvtestop](#syntax-vvtestop)[vextunop](#syntax-vextunop)[i](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[i](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​::=​::=::=[extend](#syntax-instr-vec)\_[half](#syntax-half)\_[sx](#syntax-sx)​[any\_true](#syntax-instr-vec)0.8ex\][extadd\_pairwise](#syntax-instr-vec)\_[sx](#syntax-sx)if N2​\=2⋅N1​​[vunop](#syntax-vunop)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​if 16≤2⋅N1​\=N2​≤320.8ex\]​::=[vextbinop](#syntax-vextbinop)[i](#syntax-numtype)[N](#syntax-numtype)1​[x](#syntax-shape)M1​,[i](#syntax-numtype)[N](#syntax-numtype)2​[x](#syntax-shape)M2​​​[abs](#syntax-instr-vec) ∣ [neg](#syntax-instr-vec)::=​[extmul](#syntax-instr-vec)\_[half](#syntax-half)\_[sx](#syntax-sx)​if 2⋅N1​\=N2​≥16​​

Vector instructions can be grouped into several subcategories:

*   _Constants_: return a static constant.
    
*   _Unary Operations_: consume one v128 operand and produce one v128 result.
    
*   _Binary Operations_: consume two v128 operands and produce one v128 result.
    
*   _Ternary Operations_: consume three v128 operands and produce one v128 result.
    
*   _Tests_: consume one v128 operand and produce a Boolean integer result.
    
*   _Shifts_: consume a v128 operand and an i32 operand, producing one v128 result.
    
*   _Splats_: consume a value of numeric type and produce a v128 result of a specified shape.
    
*   _Extract lanes_: consume a v128 operand and return the numeric value in a given lane.
    
*   _Replace lanes_: consume a v128 operand and a numeric value for a given lane, and produce a v128 result.
    

Some vector instructions have a signedness annotation [sx](#syntax-sx) which distinguishes whether the elements in the operands are to be [interpreted](#aux-signed) as [unsigned](#syntax-uint) or [signed](#syntax-sint) integers. For the other vector instructions, the use of two’s complement for the signed interpretation means that they behave the same regardless of signedness.

##### 2.4.9.1. Conventions[](#conventions①⑤)

*   The function [lanetype](#aux-lanetype)([shape](#syntax-shape)) extracts the lane type of a shape.
    
*   The function [dim](#aux-dim)([shape](#syntax-shape)) extracts the dimension of a shape.
    
*   The function [zeroop](#aux-zeroop)([vcvtop](#syntax-vcvtop)) extracts the zero flag from a vector conversion operator, or returns ϵ if it does not contain any.
    
*   The function [halfop](#aux-halfop)([vcvtop](#syntax-vcvtop)) extracts the [half](#syntax-half) flag from a vector conversion operator, or returns ϵ if it does not contain any.
    

#### 2.4.10. Expressions[](#expressions①)

[Function](#syntax-func) bodies, initialization values for [globals](#syntax-global), elements and offsets of [element](#syntax-elem) segments, and offsets of [data](#syntax-data) segments are given as expressions, which are sequences of [instructions](#syntax-instr).

​[expr](#syntax-expr)​::=​[instr](#syntax-instr)∗​​

In some places, validation [restricts](#valid-constant) expressions to be _constant_, which limits the set of allowable instructions.

### 2.5. Modules[](#modules①)

WebAssembly programs are organized into _modules_, which are the unit of deployment, loading, and compilation. A module collects definitions for [types](#syntax-type), [tags](#syntax-tag), and [globals](#syntax-global), [memories](#syntax-mem), [tables](#syntax-table), [functions](#syntax-func). In addition, it can declare [imports](#syntax-import) and [exports](#syntax-export) and provide initialization in the form of [data](#syntax-data) and [element](#syntax-elem) segments, or a [start function](#syntax-start).

​[module](#syntax-module)​::=​[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗​​

Each of the lists — and thus the entire module — may be empty.

#### 2.5.1. Indices[](#indices①)

Definitions are referenced with zero-based _indices_. Each class of definition has its own _index space_, as distinguished by the following classes.

​[idx](#syntax-idx)[typeidx](#syntax-typeidx)[funcidx](#syntax-funcidx)[globalidx](#syntax-globalidx)[tableidx](#syntax-tableidx)[memidx](#syntax-memidx)[tagidx](#syntax-tagidx)[elemidx](#syntax-elemidx)[dataidx](#syntax-dataidx)[labelidx](#syntax-labelidx)[localidx](#syntax-localidx)[fieldidx](#syntax-fieldidx)​::=::=::=::=::=::=::=::=::=::=::=::=​[u32](#syntax-int)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)[idx](#syntax-idx)​​

The index space for [tags](#syntax-tag), [globals](#syntax-global), [memories](#syntax-mem), [tables](#syntax-table), and [functions](#syntax-func) includes respective [imports](#syntax-import) declared in the same module. The indices of these imports precede the indices of other definitions in the same index space.

Data indices reference [data segments](#syntax-data) and element indices reference [element segments](#syntax-elem).

The index space for [locals](#syntax-local) is only accessible inside a [function](#syntax-func) and includes the parameters of that function, which precede the local variables.

Label indices reference [structured control instructions](#syntax-instr-control) inside an instruction sequence.

Each [aggregate type](#syntax-aggrtype) provides an index space for its [fields](#syntax-fieldtype).

##### 2.5.1.1. Conventions[](#conventions①⑦)

*   The meta variable l ranges over label indices.
    
*   The meta variables x, y range over indices in any of the other index spaces.
    

*   For every index space abcidx, the notation abcidx(A) denotes the set of indices from that index space occurring free in A. Sometimes this set is reinterpreted as the [list](#syntax-list) of its elements.
    

Note

For example, if [instr](#syntax-instr)∗ is ([data.drop](#syntax-instr-memory) 1) ([memory.init](#syntax-instr-memory) 2 3), then dataidxinstrs​([instr](#syntax-instr)∗)\=1 3, or equivalently, the set {1,3}.

#### 2.5.2. Types[](#types③)

The [type](#syntax-rectype) section of a module defines a list of [recursive types](#syntax-rectype), each consisting of a list of [sub types](#syntax-subtype) referenced by individual [type indices](#syntax-typeidx). All [function](#syntax-functype), [structure](#syntax-structtype), or [array](#syntax-arraytype) types used in a module must be defined in this section.

​[type](#syntax-rectype)​::=​[type](#syntax-type) [rectype](#syntax-rectype)​​

#### 2.5.3. Tags[](#tags①)

The [tag](#syntax-tag) section of a module defines a list of _tags_:

​[tag](#syntax-tag)​::=​[tag](#syntax-tag) [tagtype](#syntax-tagtype)​​

The [type index](#syntax-typeidx) of a tag must refer to a [function type](#syntax-functype) that declares its [tag type](#syntax-tagtype).

Tags are referenced through [tag indices](#syntax-tagidx), starting with the smallest index not referencing a tag [import](#syntax-import).

#### 2.5.4. Globals[](#globals①)

The [global](#syntax-global) section of a module defines a list of _global variables_ (or _globals_ for short):

​[global](#syntax-global)​::=​[global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)​​

Each global stores a single value of the type specified in the [global type](#syntax-globaltype). It also specifies whether a global is immutable or mutable. Moreover, each global is initialized with a value given by a [constant](#valid-constant) initializer [expression](#syntax-expr).

Globals are referenced through [global indices](#syntax-globalidx), starting with the smallest index not referencing a global [import](#syntax-import).

#### 2.5.5. Memories[](#memories①)

The [mem](#syntax-mem) section of a module defines a list of _linear memories_ (or _memories_ for short) as described by their [memory type](#syntax-memtype):

​[mem](#syntax-mem)​::=​[memory](#syntax-mem) [memtype](#syntax-memtype)​​

A memory is a list of raw uninterpreted bytes. The minimum size in the [limits](#syntax-limits) of its [memory type](#syntax-memtype) specifies the initial size of that memory, while its maximum, if present, restricts the size to which it can grow later. Both are in units of [page size](#page-size).

Memories can be initialized through [data segments](#syntax-data).

Memories are referenced through [memory indices](#syntax-memidx), starting with the smallest index not referencing a memory [import](#syntax-import). Most constructs implicitly reference memory index 0.

#### 2.5.6. Tables[](#tables①)

The [table](#syntax-table) section of a module defines a list of _tables_ described by their [table type](#syntax-tabletype):

​[table](#syntax-table)​::=​[table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)​​

A table is an array of opaque values of a particular [reference type](#syntax-reftype) that is specified by the [table type](#syntax-tabletype). Each table slot is initialized with a value given by a [constant](#valid-constant) initializer [expression](#syntax-expr). Tables can further be initialized through [element segments](#syntax-elem).

The minimum size in the [limits](#syntax-limits) of the table type specifies the initial size of that table, while its maximum restricts the size to which it can grow later.

Tables are referenced through [table indices](#syntax-tableidx), starting with the smallest index not referencing a table [import](#syntax-import). Most constructs implicitly reference table index 0.

#### 2.5.7. Functions[](#functions①)

The [func](#syntax-func) section of a module defines a list of _functions_ with the following structure:

​[func](#syntax-func)[local](#syntax-local)​::=::=​[func](#syntax-func) [typeidx](#syntax-typeidx) [local](#syntax-local)∗ [expr](#syntax-expr)[local](#syntax-local) [valtype](#syntax-valtype)​​

The [type index](#syntax-typeidx) of a function declares its signature by reference to a [function type](#syntax-functype) defined in the module. The parameters of the function are referenced through 0-based [local indices](#syntax-localidx) in the function’s body; they are mutable.

The locals declare a list of mutable local variables and their types. These variables are referenced through [local indices](#syntax-localidx) in the function’s body. The index of the first local is the smallest index not referencing a parameter.

A function’s [expression](#syntax-expr) is an [instruction](#syntax-instr) sequence that represents the body of the function. Upon termination it must produce a stack matching the function type’s [result type](#syntax-resulttype).

Functions are referenced through [function indices](#syntax-funcidx), starting with the smallest index not referencing a function [import](#syntax-import).

#### 2.5.8. Data Segments[](#data-segments①)

The [data](#syntax-data) section of a module defines a list of _data segments_, which can be used to initialize a range of memory from a static [list](#syntax-list) of [bytes](#syntax-byte).

​[data](#syntax-data)[datamode](#syntax-datamode)​::=::=​[data](#syntax-data) [byte](#syntax-byte)∗ [datamode](#syntax-datamode)[active](#syntax-datamode) [memidx](#syntax-memidx) [expr](#syntax-expr) ∣ [passive](#syntax-datamode)​​

Similar to element segments, data segments have a mode that identifies them as either _active_ or _passive_. A passive data segment’s contents can be copied into a memory using the memory.init instruction. An active data segment copies its contents into a memory during [instantiation](#exec-instantiation), as specified by a [memory index](#syntax-memidx) and a [constant](#valid-constant) [expression](#syntax-expr) defining an offset into that memory.

Data segments are referenced through [data indices](#syntax-dataidx).

#### 2.5.9. Element Segments[](#element-segments①)

The [elem](#syntax-elem) section of a module defines a list of _element segments_, which can be used to initialize a subrange of a table from a static [list](#syntax-list) of elements.

​[elem](#syntax-elem)[elemmode](#syntax-elemmode)​::=::=​[elem](#syntax-elem) [reftype](#syntax-reftype) [expr](#syntax-expr)∗ [elemmode](#syntax-elemmode)[active](#syntax-elemmode) [tableidx](#syntax-tableidx) [expr](#syntax-expr) ∣ [passive](#syntax-elemmode) ∣ [declare](#syntax-elemmode)​​

Each element segment defines a [reference type](#syntax-reftype) and a corresponding list of [constant](#valid-constant) element [expressions](#syntax-expr).

Element segments have a mode that identifies them as either _active_, _passive_, or _declarative_. A passive element segment’s elements can be copied to a table using the table.init instruction. An active element segment copies its elements into a table during [instantiation](#exec-instantiation), as specified by a [table index](#syntax-tableidx) and a [constant](#valid-constant) [expression](#syntax-expr) defining an offset into that table. A declarative element segment is not available at runtime but merely serves to forward-declare references that are formed in code with instructions like ref.func. The offset is given by another [constant](#valid-constant) [expression](#syntax-expr).

Element segments are referenced through [element indices](#syntax-elemidx).

#### 2.5.10. Start Function[](#start-function①)

The [start](#syntax-start) section of a module declares the [function index](#syntax-funcidx) of a _start function_ that is automatically invoked when the module is [instantiated](#exec-instantiation), after [tables](#syntax-table) and [memories](#syntax-mem) have been initialized.

​[start](#syntax-start)​::=​[start](#syntax-start) [funcidx](#syntax-funcidx)​​

Note

The start function is intended for initializing the state of a module. The module and its exports are not accessible externally before this initialization has completed.

#### 2.5.11. Imports[](#imports①)

The [import](#syntax-import) section of a module defines a set of _imports_ that are required for [instantiation](#exec-instantiation).

​[import](#syntax-import)​::=​[import](#syntax-import) [name](#syntax-name) [name](#syntax-name) [externtype](#syntax-externtype)​​

Each import is labeled by a two-level [name](#syntax-name) space, consisting of a _module name_ and an _item name_ for an entity within that module. Importable definitions are [tags](#syntax-tag), [globals](#syntax-global), [memories](#syntax-mem), [tables](#syntax-table), and [functions](#syntax-func). Each import is specified by a respective [external type](#syntax-externtype) that a definition provided during instantiation is required to match.

Every import defines an index in the respective [index space](#syntax-index). In each index space, the indices of imports go before the first index of any definition contained in the module itself.

Note

Unlike export names, import names are not necessarily unique. It is possible to import the same module/item name pair multiple times; such imports may even have different type descriptions, including different kinds of entities. A module with such imports can still be instantiated depending on the specifics of how an [embedder](#embedder) allows resolving and supplying imports. However, embedders are not required to support such overloading, and a WebAssembly module itself cannot implement an overloaded name.

#### 2.5.12. Exports[](#exports①)

The [export](#syntax-export) section of a module defines a set of _exports_ that become accessible to the host environment once the module has been [instantiated](#exec-instantiation).

​[export](#syntax-export)​::=​[export](#syntax-export) [name](#syntax-name) [externidx](#syntax-externidx)0.8ex\]​[externidx](#syntax-externidx)​::=​[func](#syntax-externidx) [funcidx](#syntax-funcidx) ∣ [global](#syntax-externidx) [globalidx](#syntax-globalidx) ∣ [table](#syntax-externidx) [tableidx](#syntax-tableidx) ∣ [memory](#syntax-externidx) [memidx](#syntax-memidx) ∣ [tag](#syntax-externidx) [tagidx](#syntax-tagidx)​​

Each export is labeled by a unique [name](#syntax-name). Exportable definitions are [tags](#syntax-tag), [globals](#syntax-global), [memories](#syntax-mem), [tables](#syntax-table), and [functions](#syntax-func), which are referenced through a respective index.

##### 2.5.12.1. Conventions[](#conventions①⑧)

The following auxiliary notation is defined for sequences of exports, filtering out indices of a specific kind in an order-preserving fashion:

[funcs](#syntax-externidx)(ϵ)[funcs](#syntax-externidx)(([func](#syntax-externidx) x) xx∗)[funcs](#syntax-externidx)([externidx](#syntax-externidx) xx∗)[tables](#syntax-externidx)(([table](#syntax-externidx) x) xx∗)[tables](#syntax-externidx)([externidx](#syntax-externidx) xx∗)[mems](#syntax-externidx)(([memory](#syntax-externidx) x) xx∗)[mems](#syntax-externidx)([externidx](#syntax-externidx) xx∗)[globals](#syntax-externidx)(([global](#syntax-externidx) x) xx∗)[globals](#syntax-externidx)([externidx](#syntax-externidx) xx∗)[tags](#syntax-externidx)(([tag](#syntax-externidx) x) xx∗)[tags](#syntax-externidx)([externidx](#syntax-externidx) xx∗)​\=\=\=\=\=\=\=\=\=\=\=​ϵx [funcs](#syntax-externidx)(xx∗)[funcs](#syntax-externidx)(xx∗)x [tables](#syntax-externidx)(xx∗)[tables](#syntax-externidx)(xx∗)x [mems](#syntax-externidx)(xx∗)[mems](#syntax-externidx)(xx∗)x [globals](#syntax-externidx)(xx∗)[globals](#syntax-externidx)(xx∗)x [tags](#syntax-externidx)(xx∗)[tags](#syntax-externidx)(xx∗)​otherwise0.8ex\][tables](#syntax-externidx)(ϵ)otherwise0.8ex\][mems](#syntax-externidx)(ϵ)otherwise0.8ex\][globals](#syntax-externidx)(ϵ)otherwise0.8ex\][tags](#syntax-externidx)(ϵ)otherwise​\=\=\=\=​ϵϵϵϵ​​

3\. Validation[](#validation②)
------------------------------

### 3.1. Conventions[](#conventions②⓪)

Validation checks that a WebAssembly module is well-formed. Only valid modules can be [instantiated](#exec-instantiation).

Validity is defined by a _type system_ over the [abstract syntax](#syntax) of a [module](#syntax-module) and its contents. For each piece of abstract syntax, there is a typing rule that specifies the constraints that apply to it. All rules are given in two _equivalent_ forms:

1.  In _prose_, describing the meaning in intuitive form.
    
2.  In _formal notation_, describing the rule in mathematical form. [\[1\]](#cite-pldi2017)
    

Note

The prose and formal rules are equivalent, so that understanding of the formal notation is _not_ required to read this specification. The formalism offers a more concise description in notation that is used widely in programming languages semantics and is readily amenable to mathematical proof.

In both cases, the rules are formulated in a _declarative_ manner. That is, they only formulate the constraints, they do not define an algorithm. The skeleton of a sound and complete algorithm for type-checking instruction sequences according to this specification is provided in the [appendix](#algo-valid).

#### 3.1.1. Types[](#types⑤)

To define the semantics, the definition of some sorts of types is extended to include additional forms. By virtue of not being representable in either the [binary format](#binary-valtype) or the [text format](#text-valtype), these forms cannot be used in a program; they only occur during [validation](#valid) or [execution](#exec).

​[valtype](#syntax-valtype)[absheaptype](#syntax-absheaptype)[typeuse](#syntax-typeuse)​::=::=::=​… ∣ [bot](#syntax-valtype-ext)… ∣ [bot](#syntax-valtype-ext)… ∣ [deftype](#syntax-deftype) ∣ [rec](#syntax-heaptype).n​​

The unique [value type](#syntax-valtype) [bot](#syntax-valtype-ext) is a _bottom type_ that [matches](#match-valtype) all value types. Similarly, [bot](#syntax-valtype-ext) is also used as a bottom type of all [heap types](#syntax-heaptype).

Note

No validation rule uses bottom types explicitly, but various rules can pick any value or heap type, including bottom. This ensures the existence of [principal types](#principality), and thus a [validation algorithm](#algo-valid) without back tracking.

A [type use](#syntax-typeuse) can consist directly of a [defined type](#syntax-deftype). This occurs as the result of [substituting](#notation-subst) a [type index](#syntax-typeidx) with its definition.

A type use may also be a _recursive type index_. Such an index refers to the i\-th component of a surrounding [recursive type](#syntax-rectype). It occurs as the result of [rolling up](#aux-roll-rectype) the definition of a [recursive type](#syntax-rectype).

Both extensions affect occurrences of type uses in concrete [heap types](#syntax-heaptype), in [sub types](#syntax-subtype) and in [instructions](#syntax-instr).

A type of any form is _closed_ when it does not contain a heap type that is a [type index](#syntax-typeidx) or a recursive type index without a surrounding [recursive type](#syntax-reftype), i.e., all [type indices](#syntax-typeidx) have been [substituted](#notation-subst) with their [defined type](#syntax-deftype) and all free recursive type indices have been [unrolled](#aux-unroll-rectype).

Note

It is an invariant of the semantics that sub types occur only in one of two forms: either as “syntactic” types as in a source module, where all supertypes are type indices, or as “semantic” types, where all supertypes are resolved to either defined types or recursive type indices.

Recursive type indices are local to a recursive type. They are distinguished from regular type indices and represented such that two closed types are syntactically equal if and only if they have the same recursive structure.

##### 3.1.1.1. Convention[](#convention③)

*   The _difference_ rt1​[∖](#aux-reftypediff)rt2​ between two [reference types](#syntax-reftype) is defined as follows:
    
    ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​)[∖](#aux-reftypediff)([ref](#syntax-reftype) [null](#syntax-reftype) ht2​)([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​)[∖](#aux-reftypediff)([ref](#syntax-reftype) ht2​)​\=\=​([ref](#syntax-reftype) ht1​)([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​)​​
    

Note

This definition computes an approximation of the reference type that is inhabited by all values from rt1​ except those from rt2​. Since the type system does not have general union types, the definition only affects the presence of null and cannot express the absence of other values.

#### 3.1.2. Defined Types[](#defined-types①)

_Defined types_ denote the individual types defined in a [module](#syntax-module). Each such type is represented as a projection from the [recursive type](#syntax-rectype) group it originates from, indexed by its position in that group.

​[deftype](#syntax-deftype)​::=​[rectype](#syntax-rectype).n​​

Defined types do not occur in the [binary](#binary) or [text](#text) format, but are formed by [rolling up](#aux-roll-deftype) the [recursive types](#syntax-reftype) defined in a module.

Note

It is an invariant of the semantics that all [recursive types](#syntax-rectype) occurring in defined types are [rolled up](#aux-roll-rectype).

##### 3.1.2.1. Conventions[](#conventions②①)

*   t\[x∗[:=](#notation-subst)dt∗\] denotes the parallel _substitution_ of [type indices](#syntax-typeidx) x∗ with corresponding [defined types](#syntax-deftype) dt∗ in type t, provided ∣x∗∣\=∣dt∗∣.
    
*   t\[(rec i)∗[:=](#notation-subst)dt∗\] denotes the parallel substitution of [recursive type indices](#syntax-rectypeidx) (rec i)∗ with [defined types](#syntax-deftype) dt∗ in type t, provided ∣(rec i)∗∣\=∣dt∗∣. This substitution does not proceed under [recursive types](#syntax-rectype), since they are considered local _binders_ for all recursive type indices.
    
*   t\[[:=](#notation-subst)dt∗\] is shorthand for the substitution t\[x∗[:=](#notation-subst)dt∗\], where x∗\=0 … (∣dt∗∣−1).
    

Note

All recursive types formed by the semantics are closed with respect to recursive type indices that occur inside them. Hence, substitution of recursive type indices never needs to modify the bodies of recursive types. In addition, all types used for substitution are closed with respect to recursive type indices, such that name capture of recursive type indices cannot occur.

#### 3.1.3. Rolling and Unrolling[](#rolling-and-unrolling①)

In order to allow comparing [recursive types](#syntax-rectype) for [equivalence](#match-deftype), their representation is changed such that all [type indices](#syntax-typeidx) internal to the same recursive type are replaced by [recursive type indices](#syntax-rectypeidx).

Note

This representation is independent of the type index space, so that it is meaningful across module boundaries. Moreover, this representation ensures that types with equivalent recursive structure are also syntactically equal, hence allowing a simple equality check on (closed) types. It gives rise to an _iso-recursive_ interpretation of types.

The representation change is performed by two auxiliary operations on the syntax of [recursive types](#syntax-rectype):

*   _Rolling up_ a recursive type [substitutes](#notation-subst) its internal [type indices](#syntax-typeidx) with corresponding [recursive type indices](#syntax-rectypeidx).
    
*   _Unrolling_ a recursive type [substitutes](#notation-subst) its [recursive type indices](#syntax-rectypeidx) with the corresponding [defined types](#syntax-deftype).
    

These operations are extended to [defined types](#syntax-deftype) and defined as follows:

[roll](#aux-roll-rectype)x​([rectype](#syntax-rectype))​\=​[rec](#syntax-rectype) ([subtype](#syntax-subtype)\[(x+i)i<n[:=](#notation-subst)([rec](#syntax-heaptype).i)i<n\])n​if [rectype](#syntax-rectype)\=[rec](#syntax-rectype) [subtype](#syntax-subtype)n0.8ex\][unroll](#aux-unroll-rectype)([rectype](#syntax-rectype))​\=​[rec](#syntax-rectype) ([subtype](#syntax-subtype)\[([rec](#syntax-heaptype).i)i<n[:=](#notation-subst)([rectype](#syntax-rectype).i)i<n\])n​if [rectype](#syntax-rectype)\=[rec](#syntax-rectype) [subtype](#syntax-subtype)n0.8ex\][roll](#aux-roll-deftype)x∗​([rectype](#syntax-rectype))​\=​(([rec](#syntax-rectype) [subtype](#syntax-subtype)n).i)i<n​if [roll](#aux-roll-rectype)x​([rectype](#syntax-rectype))\=[rec](#syntax-rectype) [subtype](#syntax-subtype)n0.8ex\][unroll](#aux-unroll-deftype)([rectype](#syntax-rectype).i)​\=​[subtype](#syntax-subtype)∗\[i\]​if [unroll](#aux-unroll-rectype)([rectype](#syntax-rectype))\=[rec](#syntax-rectype) [subtype](#syntax-subtype)∗​​

In addition, the following auxiliary relation denotes the _expansion_ of a [defined type](#syntax-deftype) or [type use](#syntax-typeuse):

​[deftype](#syntax-deftype)[typeidx](#syntax-typeidx)​[≈](#aux-expand-deftype)[≈](#aux-expand-typeuse)C​​[comptype](#syntax-comptype)[comptype](#syntax-comptype)​if [expand](#aux-expand-deftype)([deftype](#syntax-deftype))\=[comptype](#syntax-comptype)0.8ex\]if C.[types](#context)\[[typeidx](#syntax-typeidx)\][≈](#aux-expand-deftype)[comptype](#syntax-comptype)​[deftype](#syntax-deftype)[≈](#aux-expand-typeuse)C​[comptype](#syntax-comptype)if [deftype](#syntax-deftype)[≈](#aux-expand-deftype)[comptype](#syntax-comptype)​

#### 3.1.4. Instruction Types[](#instruction-types①)

_Instruction types_ classify the behaviour of [instructions](#syntax-instr) or instruction sequences, by describing how they manipulate the [operand stack](#stack) and the initialization status of [locals](#syntax-local):

​[instrtype](#syntax-instrtype)​::=​[resulttype](#syntax-resulttype)[→](#syntax-instrtype)[localidx](#syntax-localidx)∗​[resulttype](#syntax-resulttype)​​

An instruction type t1∗​[→](#syntax-instrtype)x∗​t2∗​ describes the required input stack with argument values of types t1∗​ that an instruction pops off and the provided output stack with result values of types t2∗​ that it pushes back. Moreover, it enumerates the [indices](#syntax-localidx) x∗ of locals that have been set by the instruction or sequence.

Note

Instruction types are only used for [validation](#valid), they do not occur in programs.

#### 3.1.5. Local Types[](#local-types①)

_Local types_ classify [locals](#syntax-local), by describing their [value type](#syntax-valtype) as well as their _initialization status_:

​[localtype](#syntax-localtype)[init](#syntax-init)​::=::=​[init](#syntax-init) [valtype](#syntax-valtype)[set](#syntax-init) ∣ [unset](#syntax-init)​​

Note

Local types are only used for [validation](#valid), they do not occur in programs.

#### 3.1.6. Contexts[](#contexts①)

Validity of an individual definition is specified relative to a _context_, which collects relevant information about the surrounding [module](#syntax-module) and the definitions in scope:

*   _Types_: the list of [types](#syntax-type) defined in the current module.
    
*   _Recursive Types_: the list of [sub types](#syntax-subtype) in the current group of recursive types.
    
*   _Functions_: the list of [functions](#syntax-func) declared in the current module, represented by a [defined type](#syntax-deftype) that [expands](#aux-expand-deftype) to their [function type](#syntax-functype).
    
*   _Tables_: the list of [tables](#syntax-table) declared in the current module, represented by their [table type](#syntax-tabletype).
    
*   _Memories_: the list of [memories](#syntax-mem) declared in the current module, represented by their [memory type](#syntax-memtype).
    
*   _Globals_: the list of [globals](#syntax-global) declared in the current module, represented by their [global type](#syntax-globaltype).
    
*   _Tags_: the list of tags declared in the current module, represented by their [tag type](#syntax-tagtype).
    
*   _Element Segments_: the list of [element segments](#syntax-elem) declared in the current module, represented by the elements’ [reference type](#syntax-reftype).
    
*   _Data Segments_: the list of [data segments](#syntax-data) declared in the current module, each represented by an [ok](#valid-data) entry.
    
*   _Locals_: the list of [locals](#syntax-local) declared in the current [function](#syntax-func) (including parameters), represented by their [local type](#syntax-localtype).
    
*   _Labels_: the stack of [labels](#syntax-label) accessible from the current position, represented by their [result type](#syntax-resulttype).
    
*   _Return_: the return type of the current [function](#syntax-func), represented as an optional [result type](#syntax-resulttype) that is absent when no return is allowed, as in free-standing expressions.
    
*   _References_: the list of [function indices](#syntax-funcidx) that occur in the module outside functions and can hence be used to form references inside them.
    

In other words, a context contains a sequence of suitable [types](#syntax-type) for each [index space](#syntax-index), describing each defined entry in that space. Locals, labels and return type are only used for validating [instructions](#syntax-instr) in [function bodies](#syntax-func), and are left empty elsewhere. The label stack is the only part of the context that changes as validation of an instruction sequence proceeds.

More concretely, contexts are defined as [records](#notation-record) C with abstract syntax:

​[context](#context)​::=​{[types](#context) [deftype](#syntax-deftype)∗[recs](#context-ext) [subtype](#syntax-subtype)∗[tags](#context) [tagtype](#syntax-tagtype)∗[globals](#context) [globaltype](#syntax-globaltype)∗[mems](#context) [memtype](#syntax-memtype)∗[tables](#context) [tabletype](#syntax-tabletype)∗[funcs](#context) [deftype](#syntax-deftype)∗[datas](#context) [datatype](#syntax-datatype)∗[elems](#context) [elemtype](#syntax-elemtype)∗[locals](#context) [localtype](#syntax-localtype)∗[labels](#context) [resulttype](#syntax-resulttype)∗[return](#context) [resulttype](#syntax-resulttype)?[refs](#context) [funcidx](#syntax-funcidx)∗}​​​

##### 3.1.6.1. Convention[](#convention④)

A type of any shape can be _closed_ to bring it into [closed](#type-closed) form relative to a [context](#context) it is [valid](#valid-type) in, by [substituting](#notation-subst) each [type index](#syntax-typeidx) x occurring in it with its own corresponding [defined type](#syntax-deftype) C.[types](#context)\[x\], after first closing the types in C.[types](#context) themselves.

[clos](#aux-clostype)C​(t)[clos](#aux-clostype)∗(dt∗ dtn​)​\=\=​t\[[:=](#notation-subst)dt∗\]dt′∗ dtn​\[[:=](#notation-subst)dt′∗\]​if dt∗\=[clos](#aux-clostype)∗(C.[types](#context))0.8ex\][clos](#aux-clostype)∗(ϵ)if dt′∗\=[clos](#aux-clostype)∗(dt∗)​\=ϵ​

Note

Free type indices referring to types within the same [recursive type](#syntax-rectype) are handled separately by [rolling up](#aux-roll-rectype) recursive types before closing them.

#### 3.1.7. Prose Notation[](#prose-notation①)

Validation is specified by stylised rules for each relevant part of the [abstract syntax](#syntax). The rules not only state constraints defining when a phrase is valid, they also classify it with a type. The following conventions are adopted in stating these rules.

*   A phrase A is said to be “valid with type T” if and only if all constraints expressed by the respective rules are met. The form of T depends on the syntactic class of A.
    
    Note
    
    For example, if A is a [function](#syntax-func), then T is a [defined function type](#syntax-deftype); for an A that is a [global](#syntax-global), T is a [global type](#syntax-globaltype); and so on.
    
*   The rules implicitly assume a given [context](#context) C.
    
*   In some places, this context is locally extended to a context C′ with additional entries. The formulation “Under context C′, … _statement_ …” is adopted to express that the following statement must apply under the assumptions embodied in the extended context.
    

#### 3.1.8. Formal Notation[](#formal-notation①)

Note

This section gives a brief explanation of the notation for specifying typing rules formally. For the interested reader, a more thorough introduction can be found in respective text books. [\[2\]](#cite-tapl)

The proposition that a phrase A has a respective type T is written A : T. In general, however, typing is dependent on a context C. To express this explicitly, the complete form is a _judgement_ C ⊢ A : T, which says that A : T holds under the assumptions encoded in C.

The formal typing rules use a standard approach for specifying type systems, rendering them into _deduction rules_. Every rule has the following general form:

conclusionpremise1​premise2​…premisen​​​

Such a rule is read as a big implication: if all premises hold, then the conclusion holds. Some rules have no premises; they are _axioms_ whose conclusion holds unconditionally. The conclusion always is a judgment C ⊢ A : T, and there usually is one respective rule for each relevant construct A of the abstract syntax.

Note

For example, the typing rule for the [i32](#syntax-numtype).[add](#syntax-instr-numeric) instruction can be given as an axiom:

C⊢[i32](#syntax-numtype).[add](#syntax-instr-numeric):[i32](#syntax-numtype) [i32](#syntax-numtype)→[i32](#syntax-numtype)​​

The instruction is always valid with type [i32](#syntax-numtype) [i32](#syntax-numtype)→[i32](#syntax-numtype) (saying that it consumes two [i32](#syntax-numtype) values and produces one), independent of any side conditions.

An instruction like global.get can be typed as follows:

C⊢[global.get](#syntax-instr-variable) x:ϵ→tC.[globals](#context)\[x\]\=[mut](#syntax-mut) t​​

Here, the premise enforces that the immediate [global index](#syntax-globalidx) x exists in the context. The instruction produces a value of its respective type t (and does not consume any values). If C.[globals](#context)\[x\] does not exist then the premise does not hold, and the instruction is ill-typed.

Finally, a [structured](#syntax-instr-control) instruction requires a recursive rule, where the premise is itself a typing judgement:

C⊢[block](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗:t1∗​→t2∗​C[⊢](#valid-blocktype)[blocktype](#syntax-blocktype):t1∗​→t2∗​{[labels](#context) (t2∗​)}⊕C⊢[instr](#syntax-instr)∗:t1∗​→t2∗​​​

A block instruction is only valid when the instruction sequence in its body is. Moreover, the result type must match the block’s annotation [blocktype](#syntax-blocktype). If so, then the block instruction has the same type as the body. Inside the body an additional label of the corresponding result type is available, which is expressed by extending the context C with the additional label information for the premise.

\[[1](#id1)\]

The semantics is derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. [Bringing the Web up to Speed with WebAssembly](https://dl.acm.org/citation.cfm?doid=3062341.3062363). Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.

\[[2](#id4)\]

For example: Benjamin Pierce. [Types and Programming Languages](https://www.cis.upenn.edu/~bcpierce/tapl/). The MIT Press 2002

### 3.2. Types[](#types⑦)

Simple [types](#syntax-type), such as [number types](#syntax-numtype) are universally valid. However, restrictions apply to most other types, such as [reference types](#syntax-reftype), [function types](#syntax-functype), as well as the [limits](#syntax-limits) of [table types](#syntax-tabletype) and [memory types](#syntax-memtype), which must be checked during validation.

Moreover, [block types](#syntax-blocktype) are converted to [instruction types](#syntax-instrtype) for ease of processing.

#### 3.2.1. Number Types[](#number-types③)

The [number type](#syntax-numtype) [numtype](#syntax-numtype) is always [valid](#valid-numtype).

C[⊢](#valid-numtype)[numtype](#syntax-numtype):[ok](#valid-numtype)​​

#### 3.2.2. Vector Types[](#vector-types③)

The [vector type](#syntax-vectype) [vectype](#syntax-vectype) is always [valid](#valid-vectype).

C[⊢](#valid-vectype)[vectype](#syntax-vectype):[ok](#valid-vectype)​​

#### 3.2.3. Type Uses[](#type-uses③)

The [type use](#syntax-typeuse) [typeidx](#syntax-typeidx) is [valid](#valid-typeuse) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\] exists.
>     

C[⊢](#valid-typeuse)[typeidx](#syntax-typeidx):[ok](#valid-typeuse)C.[types](#context)\[[typeidx](#syntax-typeidx)\]\=dt​​

#### 3.2.4. Heap Types[](#heap-types③)

The [heap type](#syntax-heaptype) [absheaptype](#syntax-absheaptype) is always [valid](#valid-heaptype).

C[⊢](#valid-heaptype)[absheaptype](#syntax-absheaptype):[ok](#valid-heaptype)​​

#### 3.2.5. Reference Types[](#reference-types③)

The [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype)? [heaptype](#syntax-heaptype)) is [valid](#valid-reftype) if:

> *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype) is [valid](#valid-heaptype).
>     

C[⊢](#valid-reftype)[ref](#syntax-reftype) [null](#syntax-reftype)? [heaptype](#syntax-heaptype):[ok](#valid-reftype)C[⊢](#valid-heaptype)[heaptype](#syntax-heaptype):[ok](#valid-heaptype)​​

#### 3.2.6. Value Types[](#value-types③)

The [value type](#syntax-valtype) [valtype](#syntax-valtype) is [valid](#valid-valtype) if:

> *   Either:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype) is of the form [numtype](#syntax-numtype).
>     >     
>     > *   The [number type](#syntax-numtype) [numtype](#syntax-numtype) is [valid](#valid-numtype).
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype) is of the form [vectype](#syntax-vectype).
>     >     
>     > *   The [vector type](#syntax-vectype) [vectype](#syntax-vectype) is [valid](#valid-vectype).
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype) is of the form [reftype](#syntax-reftype).
>     >     
>     > *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype) is [valid](#valid-reftype).
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype) is of the form [bot](#syntax-valtype-ext).
>     >     
>     

C[⊢](#valid-valtype)[bot](#syntax-valtype-ext):[ok](#valid-valtype)​​

#### 3.2.7. Result Types[](#result-types③)

The [result type](#syntax-resulttype) t∗ is [valid](#valid-resulttype) if:

> *   For all t in t∗:
>     
>     > *   The [value type](#syntax-valtype) t is [valid](#valid-valtype).
>     >     
>     

C[⊢](#valid-resulttype)t∗:[ok](#valid-resulttype)(C[⊢](#valid-valtype)t:[ok](#valid-valtype))∗​​

#### 3.2.8. Block Types[](#block-types③)

[Block types](#syntax-blocktype) may be expressed in one of two forms, both of which are converted to [instruction types](#syntax-instrtype) by the following rules.

The [block type](#syntax-blocktype) [typeidx](#syntax-typeidx) is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[[typeidx](#syntax-typeidx)\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-blocktype)[typeidx](#syntax-typeidx):t1∗​→t2∗​C.[types](#context)\[[typeidx](#syntax-typeidx)\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

The [block type](#syntax-blocktype) [valtype](#syntax-valtype)? is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) ϵ → [valtype](#syntax-valtype)? if:

> *   If [valtype](#syntax-valtype) is defined, then:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype) is [valid](#valid-valtype).
>     >     
>     

C[⊢](#valid-blocktype)[valtype](#syntax-valtype)?:ϵ→[valtype](#syntax-valtype)?(C[⊢](#valid-valtype)[valtype](#syntax-valtype):[ok](#valid-valtype))?​​

#### 3.2.9. Instruction Types[](#instruction-types③)

The [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x∗​t2∗​ is [valid](#valid-instrtype) if:

> *   The [result type](#syntax-resulttype) t1∗​ is [valid](#valid-resulttype).
>     
> *   The [result type](#syntax-resulttype) t2∗​ is [valid](#valid-resulttype).
>     
> *   For all x in x∗:
>     
>     > *   The [local](#syntax-localtype) C.[locals](#context)\[x\] exists.
>     >     
>     

C[⊢](#valid-instrtype)t1∗​[→](#syntax-instrtype)x∗​t2∗​:[ok](#valid-instrtype)C[⊢](#valid-resulttype)t1∗​:[ok](#valid-resulttype)C[⊢](#valid-resulttype)t2∗​:[ok](#valid-resulttype)(C.[locals](#context)\[x\]\=lt)∗​​

#### 3.2.10. Composite Types[](#composite-types③)

The [composite type](#syntax-comptype) ([struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗) is [valid](#valid-comptype) if:

> *   For all [fieldtype](#syntax-fieldtype) in [fieldtype](#syntax-fieldtype)∗:
>     
>     > *   The [field type](#syntax-fieldtype) [fieldtype](#syntax-fieldtype) is [valid](#valid-fieldtype).
>     >     
>     

C[⊢](#valid-comptype)[struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗:[ok](#valid-comptype)(C[⊢](#valid-fieldtype)[fieldtype](#syntax-fieldtype):[ok](#valid-fieldtype))∗​​

The [composite type](#syntax-comptype) ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)) is [valid](#valid-comptype) if:

> *   The [field type](#syntax-fieldtype) [fieldtype](#syntax-fieldtype) is [valid](#valid-fieldtype).
>     

C[⊢](#valid-comptype)[array](#syntax-comptype) [fieldtype](#syntax-fieldtype):[ok](#valid-comptype)C[⊢](#valid-fieldtype)[fieldtype](#syntax-fieldtype):[ok](#valid-fieldtype)​​

The [composite type](#syntax-comptype) ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​) is [valid](#valid-comptype) if:

> *   The [result type](#syntax-resulttype) t1∗​ is [valid](#valid-resulttype).
>     
> *   The [result type](#syntax-resulttype) t2∗​ is [valid](#valid-resulttype).
>     

C[⊢](#valid-comptype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​:[ok](#valid-comptype)C[⊢](#valid-resulttype)t1∗​:[ok](#valid-resulttype)C[⊢](#valid-resulttype)t2∗​:[ok](#valid-resulttype)​​

The [field type](#syntax-fieldtype) ([mut](#syntax-mut)? [storagetype](#syntax-storagetype)) is [valid](#valid-fieldtype) if:

> *   The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype) is [valid](#valid-storagetype).
>     

C[⊢](#valid-fieldtype)[mut](#syntax-mut)? [storagetype](#syntax-storagetype):[ok](#valid-fieldtype)C[⊢](#valid-storagetype)[storagetype](#syntax-storagetype):[ok](#valid-storagetype)​​

The [packed type](#syntax-packtype) [packtype](#syntax-packtype) is always [valid](#valid-packtype).

C[⊢](#valid-packtype)[packtype](#syntax-packtype):[ok](#valid-packtype)​​

#### 3.2.11. Recursive Types[](#recursive-types③)

[Recursive types](#syntax-rectype) are validated with respect to the first [type index](#syntax-typeidx) defined by the recursive group.

##### 3.2.11.1. [rec](#syntax-rectype) [subtype](#syntax-subtype)∗[](#-hrefsyntax-rectypemathsfrechrefsyntax-subtypemathitsubtypeast)

The [recursive type](#syntax-rectype) ([rec](#syntax-rectype) [subtype](#syntax-subtype)∗) is [valid](#valid-rectype) for the type index x if:

> *   Either:
>     
>     > *   The sub type sequence [subtype](#syntax-subtype)∗ is empty.
>     >     
>     
> *   Or:
>     
>     > *   The sub type sequence [subtype](#syntax-subtype)∗ is of the form [subtype](#syntax-subtype)1​ [subtype](#syntax-subtype)′∗.
>     >     
>     > *   The [sub type](#syntax-subtype) [subtype](#syntax-subtype)1​ is [valid](#valid-subtype) for the type index x.
>     >     
>     > *   The [recursive type](#syntax-rectype) ([rec](#syntax-rectype) [subtype](#syntax-subtype)′∗) is [valid](#valid-rectype) for the type index x+1.
>     >     
>     

C[⊢](#valid-rectype)[rec](#syntax-rectype) ϵ:[ok](#valid-subtype)(x)​C[⊢](#valid-rectype)[rec](#syntax-rectype) ([subtype](#syntax-subtype)1​ [subtype](#syntax-subtype)∗):[ok](#valid-subtype)(x)C[⊢](#valid-subtype)[subtype](#syntax-subtype)1​:[ok](#valid-subtype)(x)C[⊢](#valid-rectype)[rec](#syntax-rectype) [subtype](#syntax-subtype)∗:[ok](#valid-subtype)(x+1)​​

##### 3.2.11.2. [sub](#syntax-subtype) [final](#syntax-subtype)? y∗ [comptype](#syntax-comptype)[](#-hrefsyntax-subtypemathsfsubhrefsyntax-subtypemathsffinalyasthrefsyntax-comptypemathitcomptype)

The [sub type](#syntax-subtype) ([sub](#syntax-subtype) [final](#syntax-subtype)? x∗ [comptype](#syntax-comptype)) is [valid](#valid-subtype) for the type index x0​ if:

> *   The length of x∗ is less than or equal to 1.
>     
> *   For all x in x∗:
>     
>     > *   The [index](#syntax-idx) x is less than x0​.
>     >     
>     > *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     >     
>     > *   The [sub type](#syntax-subtype) [unroll](#aux-unroll-deftype)(C.[types](#context)\[x\]) is of the form ([sub](#syntax-subtype) x′∗ [comptype](#syntax-comptype)′).
>     >     
>     
> *   [comptype](#syntax-comptype)′∗ is the concatenation of all such [comptype](#syntax-comptype)′.
>     
> *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype) is [valid](#valid-comptype).
>     
> *   For all [comptype](#syntax-comptype)′ in [comptype](#syntax-comptype)′∗:
>     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype) [matches](#match-comptype) the [composite type](#syntax-comptype) [comptype](#syntax-comptype)′.
>     >     
>     

C[⊢](#valid-subtype)[sub](#syntax-subtype) [final](#syntax-subtype)? x∗ [comptype](#syntax-comptype):[ok](#valid-subtype)(x0​)∣x∗∣≤1(x<x0​)∗([unroll](#aux-unroll-deftype)(C.[types](#context)\[x\])\=[sub](#syntax-subtype) x′∗ [comptype](#syntax-comptype)′)∗C[⊢](#valid-comptype)[comptype](#syntax-comptype):[ok](#valid-comptype)(C[⊢](#match-comptype)[comptype](#syntax-comptype)[≤](#match-comptype)[comptype](#syntax-comptype)′)∗​​​​

Note

The side condition on the index ensures that a declared supertype is a previously defined types, preventing cyclic subtype hierarchies.

Future versions of WebAssembly may allow more than one supertype.

#### 3.2.12. Limits[](#limits③)

[Limits](#syntax-limits) must have meaningful bounds that are within a given range.

The [limits range](#syntax-limits) \[n[..](#syntax-limits)m?\] is [valid](#valid-limits) within k if:

> *   n is less than or equal to k.
>     
> *   If m is defined, then:
>     
>     > *   n is less than or equal to m.
>     >     
>     > *   m is less than or equal to k.
>     >     
>     

C[⊢](#valid-limits)\[n[..](#syntax-limits)m?\]:kn≤k(n≤m≤k)?​​

#### 3.2.13. Tag Types[](#tag-types③)

The [tag type](#syntax-tagtype) [typeuse](#syntax-typeuse) is [valid](#valid-tagtype) if:

> *   The [type use](#syntax-typeuse) [typeuse](#syntax-typeuse) is [valid](#valid-typeuse).
>     
> *   The [expansion](#aux-expand-typeuse) of C is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-tagtype)[typeuse](#syntax-typeuse):[ok](#valid-tagtype)C[⊢](#valid-typeuse)[typeuse](#syntax-typeuse):[ok](#valid-typeuse)[typeuse](#syntax-typeuse)[≈](#aux-expand-typeuse)C​[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

#### 3.2.14. Global Types[](#global-types③)

The [global type](#syntax-globaltype) ([mut](#syntax-mut)? t) is [valid](#valid-globaltype) if:

> *   The [value type](#syntax-valtype) t is [valid](#valid-valtype).
>     

C[⊢](#valid-globaltype)[mut](#syntax-mut)? t:[ok](#valid-globaltype)C[⊢](#valid-valtype)t:[ok](#valid-valtype)​​

#### 3.2.15. Memory Types[](#memory-types③)

The [memory type](#syntax-memtype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits) [page](#syntax-memtype)) is [valid](#valid-memtype) if:

> *   The [limits range](#syntax-limits) [limits](#syntax-limits) is [valid](#valid-limits) within 216.
>     

C[⊢](#valid-memtype)[addrtype](#syntax-addrtype) [limits](#syntax-limits) [page](#syntax-memtype):[ok](#valid-memtype)C[⊢](#valid-limits)[limits](#syntax-limits):216​​

#### 3.2.16. Table Types[](#table-types③)

The [table type](#syntax-tabletype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits) [reftype](#syntax-reftype)) is [valid](#valid-tabletype) if:

> *   The [limits range](#syntax-limits) [limits](#syntax-limits) is [valid](#valid-limits) within 232−1.
>     
> *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype) is [valid](#valid-reftype).
>     

C[⊢](#valid-tabletype)[addrtype](#syntax-addrtype) [limits](#syntax-limits) [reftype](#syntax-reftype):[ok](#valid-tabletype)C[⊢](#valid-limits)[limits](#syntax-limits):232−1C[⊢](#valid-reftype)[reftype](#syntax-reftype):[ok](#valid-reftype)​​

#### 3.2.17. External Types[](#external-types③)

The [external type](#syntax-externtype) ([tag](#syntax-externtype) [tagtype](#syntax-tagtype)) is [valid](#valid-externtype) if:

> *   The [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype) is [valid](#valid-tagtype).
>     

C[⊢](#valid-externtype)[tag](#syntax-externtype) [tagtype](#syntax-tagtype):[ok](#valid-externtype)C[⊢](#valid-tagtype)[tagtype](#syntax-tagtype):[ok](#valid-tagtype)​​

The [external type](#syntax-externtype) ([global](#syntax-externtype) [globaltype](#syntax-globaltype)) is [valid](#valid-externtype) if:

> *   The [global type](#syntax-globaltype) [globaltype](#syntax-globaltype) is [valid](#valid-globaltype).
>     

C[⊢](#valid-externtype)[global](#syntax-externtype) [globaltype](#syntax-globaltype):[ok](#valid-externtype)C[⊢](#valid-globaltype)[globaltype](#syntax-globaltype):[ok](#valid-globaltype)​​

The [external type](#syntax-externtype) ([mem](#syntax-externtype) [memtype](#syntax-memtype)) is [valid](#valid-externtype) if:

> *   The [memory type](#syntax-memtype) [memtype](#syntax-memtype) is [valid](#valid-memtype).
>     

C[⊢](#valid-externtype)[mem](#syntax-externtype) [memtype](#syntax-memtype):[ok](#valid-externtype)C[⊢](#valid-memtype)[memtype](#syntax-memtype):[ok](#valid-memtype)​​

The [external type](#syntax-externtype) ([table](#syntax-externtype) [tabletype](#syntax-tabletype)) is [valid](#valid-externtype) if:

> *   The [table type](#syntax-tabletype) [tabletype](#syntax-tabletype) is [valid](#valid-tabletype).
>     

C[⊢](#valid-externtype)[table](#syntax-externtype) [tabletype](#syntax-tabletype):[ok](#valid-externtype)C[⊢](#valid-tabletype)[tabletype](#syntax-tabletype):[ok](#valid-tabletype)​​

The [external type](#syntax-externtype) ([func](#syntax-externtype) [typeuse](#syntax-typeuse)) is [valid](#valid-externtype) if:

> *   The [type use](#syntax-typeuse) [typeuse](#syntax-typeuse) is [valid](#valid-typeuse).
>     
> *   The [expansion](#aux-expand-typeuse) of C is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-externtype)[func](#syntax-externtype) [typeuse](#syntax-typeuse):[ok](#valid-externtype)C[⊢](#valid-typeuse)[typeuse](#syntax-typeuse):[ok](#valid-typeuse)[typeuse](#syntax-typeuse)[≈](#aux-expand-typeuse)C​[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

### 3.3. Matching[](#matching①)

On most types, a notion of _subtyping_ is defined that is applicable in [validation](#valid) rules, during [module instantiation](#exec-instantiation) when checking the types of imports, or during [execution](#exec), when performing casts.

#### 3.3.1. Number Types[](#number-types⑤)

The [number type](#syntax-numtype) [numtype](#syntax-numtype) [matches](#match-numtype) only itself.

C[⊢](#match-numtype)[numtype](#syntax-numtype)[≤](#match-numtype)[numtype](#syntax-numtype)​​

#### 3.3.2. Vector Types[](#vector-types⑤)

The [vector type](#syntax-vectype) [vectype](#syntax-vectype) [matches](#match-vectype) only itself.

C[⊢](#match-vectype)[vectype](#syntax-vectype)[≤](#match-vectype)[vectype](#syntax-vectype)​​

#### 3.3.3. Heap Types[](#heap-types⑤)

The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ if:

> *   Either:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [heaptype](#syntax-heaptype)1​.
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)′ is [valid](#valid-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)′.
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)′ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [eq](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [any](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [i31](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [eq](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [struct](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [eq](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [array](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [eq](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [deftype](#syntax-deftype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [struct](#syntax-heaptype).
>     >     
>     > *   The [expansion](#aux-expand-deftype) of [deftype](#syntax-deftype) is ([struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [deftype](#syntax-deftype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [array](#syntax-heaptype).
>     >     
>     > *   The [expansion](#aux-expand-deftype) of [deftype](#syntax-deftype) is ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [deftype](#syntax-deftype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [func](#syntax-heaptype).
>     >     
>     > *   The [expansion](#aux-expand-deftype) of [deftype](#syntax-deftype) is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [deftype](#syntax-deftype)1​.
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [deftype](#syntax-deftype)2​.
>     >     
>     > *   The [defined type](#syntax-deftype) [deftype](#syntax-deftype)1​ [matches](#match-deftype) the [defined type](#syntax-deftype) [deftype](#syntax-deftype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [typeidx](#syntax-typeidx).
>     >     
>     > *   The [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\] exists.
>     >     
>     > *   The [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\] [matches](#match-deftype) the [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [typeidx](#syntax-typeidx).
>     >     
>     > *   The [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\] exists.
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ [matches](#match-heaptype) the [type](#syntax-deftype) C.[types](#context)\[[typeidx](#syntax-typeidx)\].
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form ([rec](#syntax-heaptype).i).
>     >     
>     > *   The length of [typeuse](#syntax-typeuse)∗ is greater than j.
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ is of the form [typeuse](#syntax-typeuse)∗\[j\].
>     >     
>     > *   The [recursive type](#syntax-subtype) C.[recs](#context-ext)\[i\] exists.
>     >     
>     > *   The [recursive type](#syntax-subtype) C.[recs](#context-ext)\[i\] is of the form ([sub](#syntax-subtype) [final](#syntax-subtype)? [typeuse](#syntax-typeuse)∗ ct).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [none](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [any](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [nofunc](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [func](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [noexn](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [exn](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [noextern](#syntax-heaptype).
>     >     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)2​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) [extern](#syntax-heaptype).
>     >     
>     
> *   Or:
>     
>     > *   The [heap type](#syntax-heaptype) [heaptype](#syntax-heaptype)1​ is of the form [bot](#syntax-valtype-ext).
>     >     
>     

C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[heaptype](#syntax-heaptype)​C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)1​[≤](#match-heaptype)[heaptype](#syntax-heaptype)2​C[⊢](#valid-heaptype)[heaptype](#syntax-heaptype)′:[ok](#valid-heaptype)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)1​[≤](#match-heaptype)[heaptype](#syntax-heaptype)′C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)′[≤](#match-heaptype)[heaptype](#syntax-heaptype)2​​3ex\]C[⊢](#match-heaptype)[eq](#syntax-heaptype)[≤](#match-heaptype)[any](#syntax-heaptype)​C[⊢](#match-heaptype)[i31](#syntax-heaptype)[≤](#match-heaptype)[eq](#syntax-heaptype)​C[⊢](#match-heaptype)[struct](#syntax-heaptype)[≤](#match-heaptype)[eq](#syntax-heaptype)​C[⊢](#match-heaptype)[array](#syntax-heaptype)[≤](#match-heaptype)[eq](#syntax-heaptype)​3ex\]C[⊢](#match-heaptype)[deftype](#syntax-deftype)[≤](#match-heaptype)[struct](#syntax-heaptype)[deftype](#syntax-deftype)[≈](#aux-expand-deftype)[struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗​C[⊢](#match-heaptype)[deftype](#syntax-deftype)[≤](#match-heaptype)[array](#syntax-heaptype)[deftype](#syntax-deftype)[≈](#aux-expand-deftype)[array](#syntax-comptype) [fieldtype](#syntax-fieldtype)​C[⊢](#match-heaptype)[deftype](#syntax-deftype)[≤](#match-heaptype)[func](#syntax-heaptype)[deftype](#syntax-deftype)[≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​3ex\]C[⊢](#match-heaptype)[typeidx](#syntax-typeidx)[≤](#match-heaptype)[heaptype](#syntax-heaptype)C[⊢](#match-heaptype)C.[types](#context)\[[typeidx](#syntax-typeidx)\][≤](#match-heaptype)[heaptype](#syntax-heaptype)​C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[typeidx](#syntax-typeidx)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)C.[types](#context)\[[typeidx](#syntax-typeidx)\]​3ex\]C[⊢](#match-heaptype)[rec](#syntax-heaptype).i[≤](#match-heaptype)[typeuse](#syntax-typeuse)∗\[j\]C.[recs](#context-ext)\[i\]\=[sub](#syntax-subtype) [final](#syntax-subtype)? [typeuse](#syntax-typeuse)∗ ct​3ex\]C[⊢](#match-heaptype)[none](#syntax-heaptype)[≤](#match-heaptype)[heaptype](#syntax-heaptype)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[any](#syntax-heaptype)​C[⊢](#match-heaptype)[nofunc](#syntax-heaptype)[≤](#match-heaptype)[heaptype](#syntax-heaptype)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[func](#syntax-heaptype)​C[⊢](#match-heaptype)[noexn](#syntax-heaptype)[≤](#match-heaptype)[heaptype](#syntax-heaptype)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[exn](#syntax-heaptype)​C[⊢](#match-heaptype)[noextern](#syntax-heaptype)[≤](#match-heaptype)[heaptype](#syntax-heaptype)C[⊢](#match-heaptype)[heaptype](#syntax-heaptype)[≤](#match-heaptype)[extern](#syntax-heaptype)​3ex\]C[⊢](#match-heaptype)[bot](#syntax-valtype-ext)[≤](#match-heaptype)[heaptype](#syntax-heaptype)​​​

#### 3.3.4. Reference Types[](#reference-types⑤)

The [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​) [matches](#match-reftype) the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype)2?​ ht2​) if:

> *   The [heap type](#syntax-heaptype) ht1​ [matches](#match-heaptype) the [heap type](#syntax-heaptype) ht2​.
>     
> *   Either:
>     
>     > *   [null](#syntax-reftype)1?​ is absent.
>     >     
>     > *   [null](#syntax-reftype)2?​ is absent.
>     >     
>     
> *   Or:
>     
>     > *   [null](#syntax-reftype)1?​ is of the form [null](#syntax-reftype)?.
>     >     
>     > *   [null](#syntax-reftype)2?​ is of the form [null](#syntax-reftype).
>     >     
>     

C[⊢](#match-reftype)[ref](#syntax-reftype) ht1​[≤](#match-reftype)[ref](#syntax-reftype) ht2​C[⊢](#match-heaptype)ht1​[≤](#match-heaptype)ht2​​C[⊢](#match-reftype)[ref](#syntax-reftype) [null](#syntax-reftype)? ht1​[≤](#match-reftype)[ref](#syntax-reftype) [null](#syntax-reftype) ht2​C[⊢](#match-heaptype)ht1​[≤](#match-heaptype)ht2​​​

#### 3.3.5. Value Types[](#value-types⑤)

The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ [matches](#match-valtype) the [value type](#syntax-valtype) [valtype](#syntax-valtype)2​ if:

> *   Either:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ is of the form [numtype](#syntax-numtype)1​.
>     >     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)2​ is of the form [numtype](#syntax-numtype)2​.
>     >     
>     > *   The [number type](#syntax-numtype) [numtype](#syntax-numtype)1​ [matches](#match-numtype) the [number type](#syntax-numtype) [numtype](#syntax-numtype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ is of the form [vectype](#syntax-vectype)1​.
>     >     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)2​ is of the form [vectype](#syntax-vectype)2​.
>     >     
>     > *   The [vector type](#syntax-vectype) [vectype](#syntax-vectype)1​ [matches](#match-vectype) the [vector type](#syntax-vectype) [vectype](#syntax-vectype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ is of the form [reftype](#syntax-reftype)1​.
>     >     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)2​ is of the form [reftype](#syntax-reftype)2​.
>     >     
>     > *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype)1​ [matches](#match-reftype) the [reference type](#syntax-reftype) [reftype](#syntax-reftype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ is of the form [bot](#syntax-valtype-ext).
>     >     
>     

C[⊢](#match-valtype)[bot](#syntax-valtype-ext)[≤](#match-valtype)[valtype](#syntax-valtype)​​

#### 3.3.6. Result Types[](#result-types⑤)

Subtyping is lifted to [result types](#syntax-resulttype) in a pointwise manner.

The [result type](#syntax-resulttype) t1∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t2∗​ if:

> *   For all t1​ in t1∗​, and corresponding t2​ in t2∗​:
>     
>     > *   The [value type](#syntax-valtype) t1​ [matches](#match-valtype) the [value type](#syntax-valtype) t2​.
>     >     
>     

C[⊢](#match-resulttype)t1∗​[≤](#match-resulttype)t2∗​(C[⊢](#match-valtype)t1​[≤](#match-valtype)t2​)∗​​

#### 3.3.7. Instruction Types[](#instruction-types⑤)

Subtyping is further lifted to [instruction types](#syntax-instrtype).

The [instruction type](#syntax-instrtype) t11∗​ [→](#syntax-instrtype)x1∗​​t12∗​ [matches](#match-instrtype) the [instruction type](#syntax-instrtype) t21∗​ [→](#syntax-instrtype)x2∗​​t22∗​ if:

> *   The [result type](#syntax-resulttype) t21∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t11∗​.
>     
> *   The [result type](#syntax-resulttype) t12∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t22∗​.
>     
> *   The local index sequence x∗ is of the form x2∗​∖x1∗​.
>     
> *   For all x in x∗:
>     
>     > *   The [local](#syntax-localtype) C.[locals](#context)\[x\] exists.
>     >     
>     > *   The [local](#syntax-localtype) C.[locals](#context)\[x\] is of the form ([set](#syntax-init) t).
>     >     
>     

C[⊢](#match-instrtype)t11∗​[→](#syntax-instrtype)x1∗​​t12∗​[≤](#match-instrtype)t21∗​[→](#syntax-instrtype)x2∗​​t22∗​C[⊢](#match-resulttype)t21∗​[≤](#match-resulttype)t11∗​C[⊢](#match-resulttype)t12∗​[≤](#match-resulttype)t22∗​x∗\=x2∗​∖x1∗​(C.[locals](#context)\[x\]\=[set](#syntax-init) t)∗​​

Note

Instruction types are contravariant in their input and covariant in their output. Moreover, the supertype may ignore variables from the init set x1∗​. It may also _add_ variables to the init set, provided these are already set in the context, i.e., are vacuously initialized.

#### 3.3.8. Composite Types[](#composite-types⑤)

The [composite type](#syntax-comptype) [comptype](#syntax-comptype)1​ [matches](#match-comptype) the [composite type](#syntax-comptype) [comptype](#syntax-comptype)2​ if:

> *   Either:
>     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)1​ is of the form ([struct](#syntax-comptype) ft1∗​ ft′1∗​).
>     >     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)2​ is of the form ([struct](#syntax-comptype) ft2∗​).
>     >     
>     > *   For all ft1​ in ft1∗​, and corresponding ft2​ in ft2∗​:
>     >     
>     >     > *   The [field type](#syntax-fieldtype) ft1​ [matches](#match-fieldtype) the [field type](#syntax-fieldtype) ft2​.
>     >     >     
>     >     
>     
> *   Or:
>     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)1​ is of the form ([array](#syntax-comptype) ft1​).
>     >     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)2​ is of the form ([array](#syntax-comptype) ft2​).
>     >     
>     > *   The [field type](#syntax-fieldtype) ft1​ [matches](#match-fieldtype) the [field type](#syntax-fieldtype) ft2​.
>     >     
>     
> *   Or:
>     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)1​ is of the form ([func](#syntax-comptype) t11∗​ [→](#syntax-comptype) t12∗​).
>     >     
>     > *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype)2​ is of the form ([func](#syntax-comptype) t21∗​ [→](#syntax-comptype) t22∗​).
>     >     
>     > *   The [result type](#syntax-resulttype) t21∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t11∗​.
>     >     
>     > *   The [result type](#syntax-resulttype) t12∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t22∗​.
>     >     
>     

C[⊢](#match-comptype)[struct](#syntax-comptype) (ft1∗​ ft′1∗​)[≤](#match-comptype)[struct](#syntax-comptype) ft2∗​(C[⊢](#match-fieldtype)ft1​[≤](#match-fieldtype)ft2​)∗​C[⊢](#match-comptype)[array](#syntax-comptype) ft1​[≤](#match-comptype)[array](#syntax-comptype) ft2​C[⊢](#match-fieldtype)ft1​[≤](#match-fieldtype)ft2​​C[⊢](#match-comptype)[func](#syntax-comptype) t11∗​[→](#syntax-comptype)t12∗​[≤](#match-comptype)[func](#syntax-comptype) t21∗​[→](#syntax-comptype)t22∗​C[⊢](#match-resulttype)t21∗​[≤](#match-resulttype)t11∗​C[⊢](#match-resulttype)t12∗​[≤](#match-resulttype)t22∗​​​

#### 3.3.9. Field Types[](#field-types①)

The [field type](#syntax-fieldtype) ([mut](#syntax-mut)1?​ zt1​) [matches](#match-fieldtype) the [field type](#syntax-fieldtype) ([mut](#syntax-mut)2?​ zt2​) if:

> *   The [storage type](#syntax-storagetype) zt1​ [matches](#match-storagetype) the [storage type](#syntax-storagetype) zt2​.
>     
> *   Either:
>     
>     > *   [mut](#syntax-mut)1?​ is absent.
>     >     
>     > *   [mut](#syntax-mut)2?​ is absent.
>     >     
>     
> *   Or:
>     
>     > *   [mut](#syntax-mut)1?​ is of the form [mut](#syntax-mut).
>     >     
>     > *   [mut](#syntax-mut)2?​ is of the form [mut](#syntax-mut).
>     >     
>     > *   The [storage type](#syntax-storagetype) zt2​ [matches](#match-storagetype) the [storage type](#syntax-storagetype) zt1​.
>     >     
>     

C[⊢](#match-fieldtype)zt1​[≤](#match-fieldtype)zt2​C[⊢](#match-storagetype)zt1​[≤](#match-storagetype)zt2​​C[⊢](#match-fieldtype)[mut](#syntax-mut) zt1​[≤](#match-fieldtype)[mut](#syntax-mut) zt2​C[⊢](#match-storagetype)zt1​[≤](#match-storagetype)zt2​C[⊢](#match-storagetype)zt2​[≤](#match-storagetype)zt1​​​

The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)1​ [matches](#match-storagetype) the [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)2​ if:

> *   Either:
>     
>     > *   The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)1​ is of the form [valtype](#syntax-valtype)1​.
>     >     
>     > *   The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)2​ is of the form [valtype](#syntax-valtype)2​.
>     >     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ [matches](#match-valtype) the [value type](#syntax-valtype) [valtype](#syntax-valtype)2​.
>     >     
>     
> *   Or:
>     
>     > *   The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)1​ is of the form [packtype](#syntax-packtype)1​.
>     >     
>     > *   The [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)2​ is of the form [packtype](#syntax-packtype)2​.
>     >     
>     > *   The [packed type](#syntax-packtype) [packtype](#syntax-packtype)1​ [matches](#match-packtype) the [packed type](#syntax-packtype) [packtype](#syntax-packtype)2​.
>     >     
>     

The [packed type](#syntax-packtype) [packtype](#syntax-packtype) [matches](#match-packtype) only itself.

C[⊢](#match-packtype)[packtype](#syntax-packtype)[≤](#match-packtype)[packtype](#syntax-packtype)​​

#### 3.3.10. Defined Types[](#defined-types③)

The [defined type](#syntax-deftype) [deftype](#syntax-deftype)1​ [matches](#match-deftype) the [defined type](#syntax-deftype) [deftype](#syntax-deftype)2​ if:

> *   Either:
>     
>     > *   The [defined type](#syntax-deftype) [clos](#aux-clostype)C​([deftype](#syntax-deftype)1​) is of the form [clos](#aux-clostype)C​([deftype](#syntax-deftype)2​).
>     >     
>     
> *   Or:
>     
>     > *   The [sub type](#syntax-subtype) [unroll](#aux-unroll-deftype)([deftype](#syntax-deftype)1​) is of the form ([sub](#syntax-subtype) [final](#syntax-subtype)? [typeuse](#syntax-typeuse)∗ ct).
>     >     
>     > *   The length of [typeuse](#syntax-typeuse)∗ is greater than i.
>     >     
>     > *   The [type use](#syntax-typeuse) [typeuse](#syntax-typeuse)∗\[i\] [matches](#match) the [heap type](#syntax-heaptype) [deftype](#syntax-deftype)2​.
>     >     
>     

C[⊢](#match-deftype)[deftype](#syntax-deftype)1​[≤](#match-deftype)[deftype](#syntax-deftype)2​[clos](#aux-clostype)C​([deftype](#syntax-deftype)1​)\=[clos](#aux-clostype)C​([deftype](#syntax-deftype)2​)​3ex\]C[⊢](#match-deftype)[deftype](#syntax-deftype)1​[≤](#match-deftype)[deftype](#syntax-deftype)2​[unroll](#aux-unroll-deftype)([deftype](#syntax-deftype)1​)\=[sub](#syntax-subtype) [final](#syntax-subtype)? [typeuse](#syntax-typeuse)∗ ctC[⊢](#match-heaptype)[typeuse](#syntax-typeuse)∗\[i\][≤](#match-heaptype)[deftype](#syntax-deftype)2​​​​

Note

Note that there is no explicit definition of type _equivalence_, since it coincides with syntactic equality, as used in the premise of the former rule above.

#### 3.3.11. Limits[](#limits⑤)

The [limits range](#syntax-limits) \[n1​[..](#syntax-limits)[u64](#syntax-int)1?​\] [matches](#match-limits) the [limits range](#syntax-limits) \[n2​[..](#syntax-limits)[u64](#syntax-int)2?​\] if:

> *   n1​ is greater than or equal to n2​.
>     
> *   Either:
>     
>     > *   [u64](#syntax-int)1?​ is of the form m1​.
>     >     
>     > *   If [u64](#syntax-int)2​ is defined, then:
>     >     
>     >     > *   m1​ is less than or equal to [u64](#syntax-int)2​.
>     >     >     
>     >     
>     
> *   Or:
>     
>     > *   [u64](#syntax-int)1?​ is absent.
>     >     
>     > *   [u64](#syntax-int)2?​ is absent.
>     >     
>     

C[⊢](#match-limits)\[n1​[..](#syntax-limits)m1​\][≤](#match-limits)\[n2​[..](#syntax-limits)m2?​\]n1​≥n2​(m1​≤m2​)?​C[⊢](#match-limits)\[n1​[..](#syntax-limits)ϵ\][≤](#match-limits)\[n2​[..](#syntax-limits)ϵ\]n1​≥n2​​​

#### 3.3.12. Tag Types[](#tag-types⑤)

The [tag type](#syntax-tagtype) [deftype](#syntax-deftype)1​ [matches](#match-tagtype) the [tag type](#syntax-tagtype) [deftype](#syntax-deftype)2​ if:

> *   The [defined type](#syntax-deftype) [deftype](#syntax-deftype)1​ [matches](#match-deftype) the [defined type](#syntax-deftype) [deftype](#syntax-deftype)2​.
>     
> *   The [defined type](#syntax-deftype) [deftype](#syntax-deftype)2​ [matches](#match-deftype) the [defined type](#syntax-deftype) [deftype](#syntax-deftype)1​.
>     

C[⊢](#match-tagtype)[deftype](#syntax-deftype)1​[≤](#match-tagtype)[deftype](#syntax-deftype)2​C[⊢](#match-deftype)[deftype](#syntax-deftype)1​[≤](#match-deftype)[deftype](#syntax-deftype)2​C[⊢](#match-deftype)[deftype](#syntax-deftype)2​[≤](#match-deftype)[deftype](#syntax-deftype)1​​​

Note

Although the conclusion of this rule looks identical to its premise, they in fact describe different relations: the premise invokes subtyping on defined types, while the conclusion defines it on tag types that happen to be expressed as defined types.

#### 3.3.13. Global Types[](#global-types⑤)

The [global type](#syntax-globaltype) ([mut](#syntax-mut)1?​ [valtype](#syntax-valtype)1​) [matches](#match-globaltype) the [global type](#syntax-globaltype) ([mut](#syntax-mut)2?​ [valtype](#syntax-valtype)2​) if:

> *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)1​ [matches](#match-valtype) the [value type](#syntax-valtype) [valtype](#syntax-valtype)2​.
>     
> *   Either:
>     
>     > *   [mut](#syntax-mut)1?​ is absent.
>     >     
>     > *   [mut](#syntax-mut)2?​ is absent.
>     >     
>     
> *   Or:
>     
>     > *   [mut](#syntax-mut)1?​ is of the form [mut](#syntax-mut).
>     >     
>     > *   [mut](#syntax-mut)2?​ is of the form [mut](#syntax-mut).
>     >     
>     > *   The [value type](#syntax-valtype) [valtype](#syntax-valtype)2​ [matches](#match-valtype) the [value type](#syntax-valtype) [valtype](#syntax-valtype)1​.
>     >     
>     

C[⊢](#match-globaltype)[valtype](#syntax-valtype)1​[≤](#match-globaltype)[valtype](#syntax-valtype)2​C[⊢](#match-valtype)[valtype](#syntax-valtype)1​[≤](#match-valtype)[valtype](#syntax-valtype)2​​C[⊢](#match-globaltype)[mut](#syntax-mut) [valtype](#syntax-valtype)1​[≤](#match-globaltype)[mut](#syntax-mut) [valtype](#syntax-valtype)2​C[⊢](#match-valtype)[valtype](#syntax-valtype)1​[≤](#match-valtype)[valtype](#syntax-valtype)2​C[⊢](#match-valtype)[valtype](#syntax-valtype)2​[≤](#match-valtype)[valtype](#syntax-valtype)1​​​

#### 3.3.14. Memory Types[](#memory-types⑤)

The [memory type](#syntax-memtype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits)1​ [page](#syntax-memtype)) [matches](#match-memtype) the [memory type](#syntax-memtype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits)2​ [page](#syntax-memtype)) if:

> *   The [limits range](#syntax-limits) [limits](#syntax-limits)1​ [matches](#match-limits) the [limits range](#syntax-limits) [limits](#syntax-limits)2​.
>     

C[⊢](#match-memtype)[addrtype](#syntax-addrtype) [limits](#syntax-limits)1​ [page](#syntax-memtype)[≤](#match-memtype)[addrtype](#syntax-addrtype) [limits](#syntax-limits)2​ [page](#syntax-memtype)C[⊢](#match-limits)[limits](#syntax-limits)1​[≤](#match-limits)[limits](#syntax-limits)2​​​

#### 3.3.15. Table Types[](#table-types⑤)

The [table type](#syntax-tabletype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits)1​ [reftype](#syntax-reftype)1​) [matches](#match-tabletype) the [table type](#syntax-tabletype) ([addrtype](#syntax-addrtype) [limits](#syntax-limits)2​ [reftype](#syntax-reftype)2​) if:

> *   The [limits range](#syntax-limits) [limits](#syntax-limits)1​ [matches](#match-limits) the [limits range](#syntax-limits) [limits](#syntax-limits)2​.
>     
> *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype)1​ [matches](#match-reftype) the [reference type](#syntax-reftype) [reftype](#syntax-reftype)2​.
>     
> *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype)2​ [matches](#match-reftype) the [reference type](#syntax-reftype) [reftype](#syntax-reftype)1​.
>     

C[⊢](#match-tabletype)[addrtype](#syntax-addrtype) [limits](#syntax-limits)1​ [reftype](#syntax-reftype)1​[≤](#match-tabletype)[addrtype](#syntax-addrtype) [limits](#syntax-limits)2​ [reftype](#syntax-reftype)2​C[⊢](#match-limits)[limits](#syntax-limits)1​[≤](#match-limits)[limits](#syntax-limits)2​C[⊢](#match-reftype)[reftype](#syntax-reftype)1​[≤](#match-reftype)[reftype](#syntax-reftype)2​C[⊢](#match-reftype)[reftype](#syntax-reftype)2​[≤](#match-reftype)[reftype](#syntax-reftype)1​​​

#### 3.3.16. External Types[](#external-types⑤)

The [external type](#syntax-externtype) ([tag](#syntax-externtype) [tagtype](#syntax-tagtype)1​) [matches](#match-externtype) the [external type](#syntax-externtype) ([tag](#syntax-externtype) [tagtype](#syntax-tagtype)2​) if:

> *   The [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype)1​ [matches](#match-tagtype) the [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype)2​.
>     

C[⊢](#match-externtype)[tag](#syntax-externtype) [tagtype](#syntax-tagtype)1​[≤](#match-externtype)[tag](#syntax-externtype) [tagtype](#syntax-tagtype)2​C[⊢](#match-tagtype)[tagtype](#syntax-tagtype)1​[≤](#match-tagtype)[tagtype](#syntax-tagtype)2​​​

The [external type](#syntax-externtype) ([global](#syntax-externtype) [globaltype](#syntax-globaltype)1​) [matches](#match-externtype) the [external type](#syntax-externtype) ([global](#syntax-externtype) [globaltype](#syntax-globaltype)2​) if:

> *   The [global type](#syntax-globaltype) [globaltype](#syntax-globaltype)1​ [matches](#match-globaltype) the [global type](#syntax-globaltype) [globaltype](#syntax-globaltype)2​.
>     

C[⊢](#match-externtype)[global](#syntax-externtype) [globaltype](#syntax-globaltype)1​[≤](#match-externtype)[global](#syntax-externtype) [globaltype](#syntax-globaltype)2​C[⊢](#match-globaltype)[globaltype](#syntax-globaltype)1​[≤](#match-globaltype)[globaltype](#syntax-globaltype)2​​​

The [external type](#syntax-externtype) ([mem](#syntax-externtype) [memtype](#syntax-memtype)1​) [matches](#match-externtype) the [external type](#syntax-externtype) ([mem](#syntax-externtype) [memtype](#syntax-memtype)2​) if:

> *   The [memory type](#syntax-memtype) [memtype](#syntax-memtype)1​ [matches](#match-memtype) the [memory type](#syntax-memtype) [memtype](#syntax-memtype)2​.
>     

C[⊢](#match-externtype)[mem](#syntax-externtype) [memtype](#syntax-memtype)1​[≤](#match-externtype)[mem](#syntax-externtype) [memtype](#syntax-memtype)2​C[⊢](#match-memtype)[memtype](#syntax-memtype)1​[≤](#match-memtype)[memtype](#syntax-memtype)2​​​

The [external type](#syntax-externtype) ([table](#syntax-externtype) [tabletype](#syntax-tabletype)1​) [matches](#match-externtype) the [external type](#syntax-externtype) ([table](#syntax-externtype) [tabletype](#syntax-tabletype)2​) if:

> *   The [table type](#syntax-tabletype) [tabletype](#syntax-tabletype)1​ [matches](#match-tabletype) the [table type](#syntax-tabletype) [tabletype](#syntax-tabletype)2​.
>     

C[⊢](#match-externtype)[table](#syntax-externtype) [tabletype](#syntax-tabletype)1​[≤](#match-externtype)[table](#syntax-externtype) [tabletype](#syntax-tabletype)2​C[⊢](#match-tabletype)[tabletype](#syntax-tabletype)1​[≤](#match-tabletype)[tabletype](#syntax-tabletype)2​​​

The [external type](#syntax-externtype) ([func](#syntax-externtype) [deftype](#syntax-deftype)1​) [matches](#match-externtype) the [external type](#syntax-externtype) ([func](#syntax-externtype) [deftype](#syntax-deftype)2​) if:

> *   The [defined type](#syntax-deftype) [deftype](#syntax-deftype)1​ [matches](#match-deftype) the [defined type](#syntax-deftype) [deftype](#syntax-deftype)2​.
>     

C[⊢](#match-externtype)[func](#syntax-externtype) [deftype](#syntax-deftype)1​[≤](#match-externtype)[func](#syntax-externtype) [deftype](#syntax-deftype)2​C[⊢](#match-deftype)[deftype](#syntax-deftype)1​[≤](#match-deftype)[deftype](#syntax-deftype)2​​​

### 3.4. Instructions[](#instructions③)

[Instructions](#syntax-instr) are classified by [instruction types](#syntax-instrtype) that describe how they manipulate the [operand stack](#stack) and initialize [locals](#syntax-local): A type t1∗​[→](#syntax-instrtype)x∗​t2∗​ describes the required input stack with argument values of types t1∗​ that an instruction pops off and the provided output stack with result values of types t2∗​ that it pushes back. Moreover, it enumerates the [indices](#syntax-localidx) x∗ of locals that have been set by the instruction. In most cases, this is empty.

Note

For example, the instruction [i32](#syntax-numtype).[add](#syntax-instr-numeric) has type [i32](#syntax-numtype) [i32](#syntax-numtype)→[i32](#syntax-numtype), consuming two [i32](#syntax-numtype) values and producing one. The instruction ([local.set](#syntax-instr-variable) x) has type t[→](#syntax-instrtype)x​ϵ, provided t is the type declared for the local x.

Typing extends to [instruction sequences](#valid-instrs) [instr](#syntax-instr)∗. Such a sequence has an instruction type t1∗​[→](#syntax-instrtype)x∗​t2∗​ if the accumulative effect of executing the instructions is consuming values of types t1∗​ off the operand stack, pushing new values of types t2∗​, and setting all locals x∗.

For some instructions, the typing rules do not fully constrain the type, and therefore allow for multiple types. Such instructions are called _polymorphic_. Two degrees of polymorphism can be distinguished:

*   _value-polymorphic_: the [value type](#syntax-valtype) t of one or several individual operands is unconstrained. That is the case for all [parametric instructions](#valid-instr-parametric) like drop and select.
    
*   _stack-polymorphic_: the entire (or most of the) [instruction type](#syntax-instrtype) t1∗​→t2∗​ of the instruction is unconstrained. That is the case for all [control instructions](#valid-instr-control) that perform an _unconditional control transfer_, such as unreachable, br, or return.
    

In both cases, the unconstrained types or type sequences can be chosen arbitrarily, as long as they meet the constraints imposed for the surrounding parts of the program.

Note

For example, the select instruction is valid with type t t [i32](#syntax-numtype)→t, for any possible [number type](#syntax-numtype) t. Consequently, both instruction sequences

([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 2) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 3) ([select](#syntax-instr-parametric))

and

([f64](#syntax-numtype).[const](#syntax-instr-numeric) +64) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) +64) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) +64) ([select](#syntax-instr-parametric))

are valid, with t in the typing of select being instantiated to i32 or f64, respectively.

The unreachable instruction is stack-polymorphic, and hence valid with type t1∗​→t2∗​ for any possible sequences of value types t1∗​ and t2∗​. Consequently,

([unreachable](#syntax-instr-control)) ([i32](#syntax-numtype).[add](#syntax-instr-numeric))

is valid by assuming type ϵ→[i32](#syntax-numtype) for the unreachable instruction. In contrast,

([unreachable](#syntax-instr-control)) ([i64](#syntax-numtype).[const](#syntax-instr-numeric) 0) ([i32](#syntax-numtype).[add](#syntax-instr-numeric))

is invalid, because there is no possible type to pick for the unreachable instruction that would make the sequence well-typed.

The [Appendix](#algo-valid) describes a type checking [algorithm](#algo-valid) that efficiently implements validation of instruction sequences as prescribed by the rules given here.

#### 3.4.1. Parametric Instructions[](#parametric-instructions③)

##### 3.4.1.1. [nop](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfnop)

The [instruction](#syntax-instr) [nop](#syntax-instr-control) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ϵ.

C[⊢](#valid-instr)[nop](#syntax-instr-control):ϵ→ϵ​​

##### 3.4.1.2. [unreachable](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfunreachable)

The [instruction](#syntax-instr) [unreachable](#syntax-instr-control) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [instruction type](#syntax-instrtype) t1∗​ → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[unreachable](#syntax-instr-control):t1∗​→t2∗​C[⊢](#valid-instrtype)t1∗​→t2∗​:[ok](#valid-instrtype)​​

Note

The unreachable instruction is [stack-polymorphic](#polymorphism).

##### 3.4.1.3. [drop](#syntax-instr-parametric)[](#-hrefsyntax-instr-parametricmathsfdrop)

The [instruction](#syntax-instr) [drop](#syntax-instr-parametric) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t → ϵ if:

> *   The [value type](#syntax-valtype) t is [valid](#valid-valtype).
>     

C[⊢](#valid-instr)[drop](#syntax-instr-parametric):t→ϵC[⊢](#valid-valtype)t:[ok](#valid-valtype)​​

Note

Both drop and select without annotation are [value-polymorphic](#polymorphism) instructions.

##### 3.4.1.4. [select](#syntax-instr-parametric) (t∗)?[](#-hrefsyntax-instr-parametricmathsfselect-tast)

The [instruction](#syntax-instr) ([select](#syntax-instr-parametric) [valtype](#syntax-valtype)?) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t t [i32](#syntax-numtype) → t if:

> *   The [value type](#syntax-valtype) t is [valid](#valid-valtype).
>     
> *   Either:
>     
>     > *   The value type sequence [valtype](#syntax-valtype)? is of the form t.
>     >     
>     
> *   Or:
>     
>     > *   The value type sequence [valtype](#syntax-valtype)? is absent.
>     >     
>     > *   The [value type](#syntax-valtype) t [matches](#match-valtype) the [value type](#syntax-valtype) t′.
>     >     
>     > *   The [value type](#syntax-valtype) t′ is of the form [numtype](#syntax-numtype) or t′ is of the form [vectype](#syntax-vectype).
>     >     
>     

C[⊢](#valid-instr)[select](#syntax-instr-parametric) t:t t [i32](#syntax-numtype)→tC[⊢](#valid-valtype)t:[ok](#valid-valtype)​C[⊢](#valid-instr)[select](#syntax-instr-parametric):t t [i32](#syntax-numtype)→tC[⊢](#valid-valtype)t:[ok](#valid-valtype)C[⊢](#match-valtype)t[≤](#match-valtype)t′t′\=[numtype](#syntax-numtype)∨t′\=[vectype](#syntax-vectype)​​

Note

In future versions of WebAssembly, select may allow more than one value per choice.

#### 3.4.2. Control Instructions[](#control-instructions③)

##### 3.4.2.1. [block](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsfblockhrefsyntax-blocktypemathitblocktypehrefsyntax-instrmathitinstrast)

The [instruction](#syntax-instr) ([block](#syntax-instr-control) bt [instr](#syntax-instr)∗) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [block type](#syntax-blocktype) bt is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) t1∗​ → t2∗​.
>     
> *   Let C′ be the same context as C, but with the result type sequence t2∗​ prepended to the field [labels](#context).
>     
> *   Under the context C′, the instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x∗​t2∗​.
>     

C[⊢](#valid-instr)[block](#syntax-instr-control) bt [instr](#syntax-instr)∗:t1∗​→t2∗​C[⊢](#valid-blocktype)bt:t1∗​→t2∗​{[labels](#context) (t2∗​)}⊕C[⊢](#valid-instrs)[instr](#syntax-instr)∗:t1∗​[→](#syntax-instrtype)x∗​t2∗​​​

Note

The [notation](#notation-concat) {[labels](#context) (t∗)}⊕C inserts the new label type at index 0, shifting all others. The same applies to all other block instructions.

##### 3.4.2.2. [loop](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsfloophrefsyntax-blocktypemathitblocktypehrefsyntax-instrmathitinstrast)

The [instruction](#syntax-instr) ([loop](#syntax-instr-control) bt [instr](#syntax-instr)∗) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [block type](#syntax-blocktype) bt is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) t1∗​ → t2∗​.
>     
> *   Let C′ be the same context as C, but with the result type sequence t1∗​ prepended to the field [labels](#context).
>     
> *   Under the context C′, the instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x∗​t2∗​.
>     

C[⊢](#valid-instr)[loop](#syntax-instr-control) bt [instr](#syntax-instr)∗:t1∗​→t2∗​C[⊢](#valid-blocktype)bt:t1∗​→t2∗​{[labels](#context) (t1∗​)}⊕C[⊢](#valid-instrs)[instr](#syntax-instr)∗:t1∗​[→](#syntax-instrtype)x∗​t2∗​​​

##### 3.4.2.3. [if](#syntax-instr-control) [blocktype](#syntax-blocktype) [instr](#syntax-instr)1∗​ [else](#syntax-instr-control) [instr](#syntax-instr)2∗​[](#-hrefsyntax-instr-controlmathsfifhrefsyntax-blocktypemathitblocktypehrefsyntax-instrmathitinstr_1asthrefsyntax-instr-controlmathsfelsehrefsyntax-instrmathitinstr_2ast)

The [instruction](#syntax-instr) ([if](#syntax-instr-control) bt [instr](#syntax-instr)1∗​ [else](#syntax-instr-control) [instr](#syntax-instr)2∗​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [i32](#syntax-numtype) → t2∗​ if:

> *   The [block type](#syntax-blocktype) bt is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) t1∗​ → t2∗​.
>     
> *   Let C′ be the same context as C, but with the result type sequence t2∗​ prepended to the field [labels](#context).
>     
> *   Under the context C′, the instruction sequence [instr](#syntax-instr)1∗​ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x1∗​​t2∗​.
>     
> *   Under the context C′, the instruction sequence [instr](#syntax-instr)2∗​ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x2∗​​t2∗​.
>     

C[⊢](#valid-instr)[if](#syntax-instr-control) bt [instr](#syntax-instr)1∗​ [else](#syntax-instr-control) [instr](#syntax-instr)2∗​:t1∗​ [i32](#syntax-numtype)→t2∗​C[⊢](#valid-blocktype)bt:t1∗​→t2∗​{[labels](#context) (t2∗​)}⊕C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​:t1∗​[→](#syntax-instrtype)x1∗​​t2∗​{[labels](#context) (t2∗​)}⊕C[⊢](#valid-instrs)[instr](#syntax-instr)2∗​:t1∗​[→](#syntax-instrtype)x2∗​​t2∗​​​

##### 3.4.2.4. [br](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbrl)

The [instruction](#syntax-instr) ([br](#syntax-instr-control) l) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ t∗ → t2∗​ if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗.
>     
> *   The [instruction type](#syntax-instrtype) t1∗​ → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[br](#syntax-instr-control) l:t1∗​ t∗→t2∗​C.[labels](#context)\[l\]\=t∗C[⊢](#valid-instrtype)t1∗​→t2∗​:[ok](#valid-instrtype)​​

Note

The [label index](#syntax-labelidx) space in the [context](#context) C contains the most recent label first, so that C.labels\[l\] performs a relative lookup as expected. This applies to other branch instructions as well.

The br instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.5. [br\_if](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_ifl)

The [instruction](#syntax-instr) ([br\_if](#syntax-instr-control) l) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ [i32](#syntax-numtype) → t∗ if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗.
>     

C[⊢](#valid-instr)[br\_if](#syntax-instr-control) l:t∗ [i32](#syntax-numtype)→t∗C.[labels](#context)\[l\]\=t∗​​

##### 3.4.2.6. [br\_table](#syntax-instr-control) l∗ lN​[](#-hrefsyntax-instr-controlmathsfbr_tablelastl_n)

The [instruction](#syntax-instr) ([br\_table](#syntax-instr-control) l∗ l′) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ t∗ [i32](#syntax-numtype) → t2∗​ if:

> *   For all l in l∗:
>     
>     > *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     >     
>     > *   The [result type](#syntax-resulttype) t∗ [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l\].
>     >     
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l′\] exists.
>     
> *   The [result type](#syntax-resulttype) t∗ [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l′\].
>     
> *   The [instruction type](#syntax-instrtype) t1∗​ t∗ [i32](#syntax-numtype) → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[br\_table](#syntax-instr-control) l∗ l′:t1∗​ t∗ [i32](#syntax-numtype)→t2∗​(C[⊢](#match-resulttype)t∗[≤](#match-resulttype)C.[labels](#context)\[l\])∗C[⊢](#match-resulttype)t∗[≤](#match-resulttype)C.[labels](#context)\[l′\]C[⊢](#valid-instrtype)t1∗​ t∗ [i32](#syntax-numtype)→t2∗​:[ok](#valid-instrtype)​​

Note

The br\_table instruction is [stack-polymorphic](#polymorphism).

Furthermore, the [result type](#syntax-resulttype) t∗ is also chosen non-deterministically in this rule. Although it may seem necessary to compute t∗ as the greatest lower bound of all label types in practice, a simple [sequential algorithm](#algo-valid) does not require this.

##### 3.4.2.7. [br\_on\_null](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_on_nulll)

The [instruction](#syntax-instr) ([br\_on\_null](#syntax-instr-control) l) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ ([ref](#syntax-reftype) [null](#syntax-reftype) ht) → t∗ ([ref](#syntax-reftype) ht) if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗.
>     
> *   The [heap type](#syntax-heaptype) ht is [valid](#valid-heaptype).
>     

C[⊢](#valid-instr)[br\_on\_null](#syntax-instr-control) l:t∗ ([ref](#syntax-reftype) [null](#syntax-reftype) ht)→t∗ ([ref](#syntax-reftype) ht)C.[labels](#context)\[l\]\=t∗C[⊢](#valid-heaptype)ht:[ok](#valid-heaptype)​​

##### 3.4.2.8. [br\_on\_non\_null](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_on_non_nulll)

The [instruction](#syntax-instr) ([br\_on\_non\_null](#syntax-instr-control) l) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ ([ref](#syntax-reftype) [null](#syntax-reftype) ht) → t∗ if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗ ([ref](#syntax-reftype) [null](#syntax-reftype)? ht).
>     

C[⊢](#valid-instr)[br\_on\_non\_null](#syntax-instr-control) l:t∗ ([ref](#syntax-reftype) [null](#syntax-reftype) ht)→t∗C.[labels](#context)\[l\]\=t∗ ([ref](#syntax-reftype) [null](#syntax-reftype)? ht)​​

##### 3.4.2.9. [br\_on\_cast](#syntax-instr-control) l rt1​ rt2​[](#-hrefsyntax-instr-controlmathsfbr_on_castlmathitrt_1mathitrt_2)

The [instruction](#syntax-instr) ([br\_on\_cast](#syntax-instr-control) l rt1​ rt2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ rt1​ → t∗ [reftype](#syntax-reftype) if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗ rt.
>     
> *   The [reference type](#syntax-reftype) rt1​ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt2​ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt1​.
>     
> *   The [reference type](#syntax-reftype) rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt.
>     
> *   The [reference type](#syntax-reftype) [reftype](#syntax-reftype) is rt1​[∖](#aux-reftypediff)rt2​.
>     

C[⊢](#valid-instr)[br\_on\_cast](#syntax-instr-control) l rt1​ rt2​:t∗ rt1​→t∗ (rt1​[∖](#aux-reftypediff)rt2​)C.[labels](#context)\[l\]\=t∗ rtC[⊢](#valid-reftype)rt1​:[ok](#valid-reftype)C[⊢](#valid-reftype)rt2​:[ok](#valid-reftype)C[⊢](#match-reftype)rt2​[≤](#match-reftype)rt1​C[⊢](#match-reftype)rt2​[≤](#match-reftype)rt​​

##### 3.4.2.10. [br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​[](#-hrefsyntax-instr-controlmathsfbr_on_cast_faillmathitrt_1mathitrt_2)

The [instruction](#syntax-instr) ([br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ rt1​ → t∗ rt2​ if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] is of the form t∗ rt.
>     
> *   The [reference type](#syntax-reftype) rt1​ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt2​ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt1​.
>     
> *   The [reference type](#syntax-reftype) rt1​[∖](#aux-reftypediff)rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt.
>     

C[⊢](#valid-instr)[br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​:t∗ rt1​→t∗ rt2​C.[labels](#context)\[l\]\=t∗ rtC[⊢](#valid-reftype)rt1​:[ok](#valid-reftype)C[⊢](#valid-reftype)rt2​:[ok](#valid-reftype)C[⊢](#match-reftype)rt2​[≤](#match-reftype)rt1​C[⊢](#match-reftype)rt1​[∖](#aux-reftypediff)rt2​[≤](#match-reftype)rt​​

##### 3.4.2.11. [call](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfcallx)

The [instruction](#syntax-instr) ([call](#syntax-instr-control) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[funcs](#context)\[x\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-instr)[call](#syntax-instr-control) x:t1∗​→t2∗​C.[funcs](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

##### 3.4.2.12. [call\_ref](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfcall_refx)

The [instruction](#syntax-instr) ([call\_ref](#syntax-instr-control) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x) → t2∗​ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-instr)[call\_ref](#syntax-instr-control) x:t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x)→t2∗​C.[types](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

##### 3.4.2.13. [call\_indirect](#syntax-instr-control) x y[](#-hrefsyntax-instr-controlmathsfcall_indirectxy)

The [instruction](#syntax-instr) ([call\_indirect](#syntax-instr-control) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ at → t2∗​ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     
> *   The [reference type](#syntax-reftype) rt [matches](#match-reftype) the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)).
>     
> *   The [type](#syntax-deftype) C.[types](#context)\[y\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[y\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     

C[⊢](#valid-instr)[call\_indirect](#syntax-instr-control) x y:t1∗​ at→t2∗​C.[tables](#context)\[x\]\=at lim rtC[⊢](#match-reftype)rt[≤](#match-reftype)([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype))C.[types](#context)\[y\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​​

##### 3.4.2.14. [return](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfreturn)

The [instruction](#syntax-instr) [return](#syntax-instr-control) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ t∗ → t2∗​ if:

> *   The result type C.[return](#context) is of the form t∗.
>     
> *   The [instruction type](#syntax-instrtype) t1∗​ → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[return](#syntax-instr-control):t1∗​ t∗→t2∗​C.[return](#context)\=(t∗)C[⊢](#valid-instrtype)t1∗​→t2∗​:[ok](#valid-instrtype)​​

Note

The return instruction is [stack-polymorphic](#polymorphism).

C.[return](#context) is absent (set to ϵ) when validating an [expression](#valid-expr) that is not a function body. This differs from it being set to the empty result type \[ϵ\], which is the case for functions not returning anything.

##### 3.4.2.15. [return\_call](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfreturn_callx)

The [instruction](#syntax-instr) ([return\_call](#syntax-instr-control) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t3∗​ t1∗​ → t4∗​ if:

> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[funcs](#context)\[x\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     
> *   The result type C.[return](#context) is of the form t′2∗​.
>     
> *   The [result type](#syntax-resulttype) t2∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t′2∗​.
>     
> *   The [instruction type](#syntax-instrtype) t3∗​ → t4∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[return\_call](#syntax-instr-control) x:t3∗​ t1∗​→t4∗​C.[funcs](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​C.[return](#context)\=(t′2∗​)C[⊢](#match-resulttype)t2∗​[≤](#match-resulttype)t′2∗​C[⊢](#valid-instrtype)t3∗​→t4∗​:[ok](#valid-instrtype)​​

Note

The return\_call instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.16. [return\_call\_ref](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfreturn_call_refx)

The [instruction](#syntax-instr) ([return\_call\_ref](#syntax-instr-control) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t3∗​ t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x) → t4∗​ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     
> *   The result type C.[return](#context) is of the form t′2∗​.
>     
> *   The [result type](#syntax-resulttype) t2∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t′2∗​.
>     
> *   The [instruction type](#syntax-instrtype) t3∗​ → t4∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[return\_call\_ref](#syntax-instr-control) x:t3∗​ t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x)→t4∗​C.[types](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​C.[return](#context)\=(t′2∗​)C[⊢](#match-resulttype)t2∗​[≤](#match-resulttype)t′2∗​C[⊢](#valid-instrtype)t3∗​→t4∗​:[ok](#valid-instrtype)​​

Note

The return\_call\_ref instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.17. [return\_call\_indirect](#syntax-instr-control) x y[](#-hrefsyntax-instr-controlmathsfreturn_call_indirectxy)

The [instruction](#syntax-instr) ([return\_call\_indirect](#syntax-instr-control) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t3∗​ t1∗​ at → t4∗​ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     
> *   The [reference type](#syntax-reftype) rt [matches](#match-reftype) the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)).
>     
> *   The [type](#syntax-deftype) C.[types](#context)\[y\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[y\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     
> *   The result type C.[return](#context) is of the form t′2∗​.
>     
> *   The [result type](#syntax-resulttype) t2∗​ [matches](#match-resulttype) the [result type](#syntax-resulttype) t′2∗​.
>     
> *   The [instruction type](#syntax-instrtype) t3∗​ → t4∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[return\_call\_indirect](#syntax-instr-control) x y:t3∗​ t1∗​ at→t4∗​C.[tables](#context)\[x\]\=at lim rtC[⊢](#match-reftype)rt[≤](#match-reftype)([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype))C.[types](#context)\[y\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​C.[return](#context)\=(t′2∗​)C[⊢](#match-resulttype)t2∗​[≤](#match-resulttype)t′2∗​C[⊢](#valid-instrtype)t3∗​→t4∗​:[ok](#valid-instrtype)​​​​

Note

The return\_call\_indirect instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.18. [throw](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfthrowx)

The [instruction](#syntax-instr) ([throw](#syntax-instr-control) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ t∗ → t2∗​ if:

> *   The [tag](#syntax-tagtype) C.[tags](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[tags](#context)\[x\] is ([func](#syntax-comptype) t∗ [→](#syntax-comptype)).
>     
> *   The [instruction type](#syntax-instrtype) t1∗​ → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[throw](#syntax-instr-control) x:t1∗​ t∗→t2∗​C.[tags](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t∗[→](#syntax-comptype)ϵC[⊢](#valid-instrtype)t1∗​→t2∗​:[ok](#valid-instrtype)​​

Note

The throw instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.19. [throw\_ref](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfthrow_ref)

The [instruction](#syntax-instr) [throw\_ref](#syntax-instr-control) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) [exn](#syntax-heaptype)) → t2∗​ if:

> *   The [instruction type](#syntax-instrtype) t1∗​ → t2∗​ is [valid](#valid-instrtype).
>     

C[⊢](#valid-instr)[throw\_ref](#syntax-instr-control):t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) [exn](#syntax-heaptype))→t2∗​C[⊢](#valid-instrtype)t1∗​→t2∗​:[ok](#valid-instrtype)​​

Note

The throw\_ref instruction is [stack-polymorphic](#polymorphism).

##### 3.4.2.20. [try\_table](#syntax-instr-control) [blocktype](#syntax-blocktype) [catch](#syntax-catch)∗ [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsftry_tablehrefsyntax-blocktypemathitblocktypehrefsyntax-catchmathitcatchasthrefsyntax-instrmathitinstrast)

The [instruction](#syntax-instr) ([try\_table](#syntax-instr-control) bt [catch](#syntax-catch)∗ [instr](#syntax-instr)∗) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ → t2∗​ if:

> *   The [block type](#syntax-blocktype) bt is [valid](#valid-blocktype) as the [instruction type](#syntax-instrtype) t1∗​ → t2∗​.
>     
> *   Let C′ be the same context as C, but with the result type sequence t2∗​ prepended to the field [labels](#context).
>     
> *   Under the context C′, the instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x∗​t2∗​.
>     
> *   For all [catch](#syntax-catch) in [catch](#syntax-catch)∗:
>     
>     > *   The [catch clause](#syntax-catch) [catch](#syntax-catch) is [valid](#valid-catch).
>     >     
>     

C[⊢](#valid-instr)[try\_table](#syntax-instr-control) bt [catch](#syntax-catch)∗ [instr](#syntax-instr)∗:t1∗​→t2∗​C[⊢](#valid-blocktype)bt:t1∗​→t2∗​{[labels](#context) (t2∗​)}⊕C[⊢](#valid-instrs)[instr](#syntax-instr)∗:t1∗​[→](#syntax-instrtype)x∗​t2∗​(C[⊢](#valid-catch)[catch](#syntax-catch):[ok](#valid-catch))∗​​

##### 3.4.2.21. [catch](#syntax-instr-control) x l[](#-hrefsyntax-instr-controlmathsfcatchxl)

The [catch clause](#syntax-catch) ([catch](#syntax-instr-control) x l) is [valid](#valid-catch) if:

> *   The [tag](#syntax-tagtype) C.[tags](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[tags](#context)\[x\] is ([func](#syntax-comptype) t∗ [→](#syntax-comptype)).
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [result type](#syntax-resulttype) t∗ [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l\].
>     

C[⊢](#valid-catch)[catch](#syntax-instr-control) x l:[ok](#valid-catch)C.[tags](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t∗[→](#syntax-comptype)ϵC[⊢](#match-resulttype)t∗[≤](#match-resulttype)C.[labels](#context)\[l\]​​

##### 3.4.2.22. [catch\_ref](#syntax-instr-control) x l[](#-hrefsyntax-instr-controlmathsfcatch_refxl)

The [catch clause](#syntax-catch) ([catch\_ref](#syntax-instr-control) x l) is [valid](#valid-catch) if:

> *   The [tag](#syntax-tagtype) C.[tags](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[tags](#context)\[x\] is ([func](#syntax-comptype) t∗ [→](#syntax-comptype)).
>     
> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [result type](#syntax-resulttype) t∗ ([ref](#syntax-reftype) [exn](#syntax-heaptype)) [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l\].
>     

C[⊢](#valid-catch)[catch\_ref](#syntax-instr-control) x l:[ok](#valid-catch)C.[tags](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t∗[→](#syntax-comptype)ϵC[⊢](#match-resulttype)t∗ ([ref](#syntax-reftype) [exn](#syntax-heaptype))[≤](#match-resulttype)C.[labels](#context)\[l\]​​

##### 3.4.2.23. [catch\_all](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfcatch_alll)

The [catch clause](#syntax-catch) ([catch\_all](#syntax-instr-control) l) is [valid](#valid-catch) if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [result type](#syntax-resulttype) ϵ [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l\].
>     

C[⊢](#valid-catch)[catch\_all](#syntax-instr-control) l:[ok](#valid-catch)C[⊢](#match-resulttype)ϵ[≤](#match-resulttype)C.[labels](#context)\[l\]​​

##### 3.4.2.24. [catch\_all\_ref](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfcatch_all_refl)

The [catch clause](#syntax-catch) ([catch\_all\_ref](#syntax-instr-control) l) is [valid](#valid-catch) if:

> *   The [label](#syntax-resulttype) C.[labels](#context)\[l\] exists.
>     
> *   The [result type](#syntax-resulttype) ([ref](#syntax-reftype) [exn](#syntax-heaptype)) [matches](#match-resulttype) the [label](#syntax-resulttype) C.[labels](#context)\[l\].
>     

C[⊢](#valid-catch)[catch\_all\_ref](#syntax-instr-control) l:[ok](#valid-catch)C[⊢](#match-resulttype)([ref](#syntax-reftype) [exn](#syntax-heaptype))[≤](#match-resulttype)C.[labels](#context)\[l\]​​

#### 3.4.3. Variable Instructions[](#variable-instructions③)

##### 3.4.3.1. [local.get](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalgetx)

The [instruction](#syntax-instr) ([local.get](#syntax-instr-variable) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → t if:

> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] exists.
>     
> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] is of the form ([set](#syntax-init) t).
>     

C[⊢](#valid-instr)[local.get](#syntax-instr-variable) x:ϵ→tC.[locals](#context)\[x\]\=[set](#syntax-init) t​​

##### 3.4.3.2. [local.set](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalsetx)

The [instruction](#syntax-instr) ([local.set](#syntax-instr-variable) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t [→](#syntax-instrtype)x​ϵ if:

> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] exists.
>     
> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] is of the form ([init](#syntax-init) t).
>     

C[⊢](#valid-instr)[local.set](#syntax-instr-variable) x:t[→](#syntax-instrtype)x​ϵC.[locals](#context)\[x\]\=[init](#syntax-init) t​​

##### 3.4.3.3. [local.tee](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalteex)

The [instruction](#syntax-instr) ([local.tee](#syntax-instr-variable) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t [→](#syntax-instrtype)x​t if:

> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] exists.
>     
> *   The [local](#syntax-localtype) C.[locals](#context)\[x\] is of the form ([init](#syntax-init) t).
>     

C[⊢](#valid-instr)[local.tee](#syntax-instr-variable) x:t[→](#syntax-instrtype)x​tC.[locals](#context)\[x\]\=[init](#syntax-init) t​​

##### 3.4.3.4. [global.get](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsfglobalgetx)

The [instruction](#syntax-instr) ([global.get](#syntax-instr-variable) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → t if:

> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] exists.
>     
> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] is of the form ([mut](#syntax-mut)? t).
>     

C[⊢](#valid-instr)[global.get](#syntax-instr-variable) x:ϵ→tC.[globals](#context)\[x\]\=[mut](#syntax-mut)? t​​

##### 3.4.3.5. [global.set](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsfglobalsetx)

The [instruction](#syntax-instr) ([global.set](#syntax-instr-variable) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t → ϵ if:

> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] exists.
>     
> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] is of the form ([mut](#syntax-mut) t).
>     

C[⊢](#valid-instr)[global.set](#syntax-instr-variable) x:t→ϵC.[globals](#context)\[x\]\=[mut](#syntax-mut) t​​

#### 3.4.4. Table Instructions[](#table-instructions③)

##### 3.4.4.1. [table.get](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablegetx)

The [instruction](#syntax-instr) ([table.get](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → rt if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     

C[⊢](#valid-instr)[table.get](#syntax-instr-table) x:at→rtC.[tables](#context)\[x\]\=at lim rt​​

##### 3.4.4.2. [table.set](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablesetx)

The [instruction](#syntax-instr) ([table.set](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at rt → ϵ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     

C[⊢](#valid-instr)[table.set](#syntax-instr-table) x:at rt→ϵC.[tables](#context)\[x\]\=at lim rt​​

##### 3.4.4.3. [table.size](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablesizex)

The [instruction](#syntax-instr) ([table.size](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → at if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     

C[⊢](#valid-instr)[table.size](#syntax-instr-table) x:ϵ→atC.[tables](#context)\[x\]\=at lim rt​​

##### 3.4.4.4. [table.grow](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablegrowx)

The [instruction](#syntax-instr) ([table.grow](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) rt at → [i32](#syntax-numtype) if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     

C[⊢](#valid-instr)[table.grow](#syntax-instr-table) x:rt at→[i32](#syntax-numtype)C.[tables](#context)\[x\]\=at lim rt​​

##### 3.4.4.5. [table.fill](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablefillx)

The [instruction](#syntax-instr) ([table.fill](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at rt at → ϵ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt).
>     

C[⊢](#valid-instr)[table.fill](#syntax-instr-table) x:at rt at→ϵC.[tables](#context)\[x\]\=at lim rt​​

##### 3.4.4.6. [table.copy](#syntax-instr-table) x y[](#-hrefsyntax-instr-tablemathsftablecopyxy)

The [instruction](#syntax-instr) ([table.copy](#syntax-instr-table) x1​ x2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at1​ at2​ [addrtype](#syntax-addrtype) → ϵ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x1​\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x1​\] is of the form (at1​ lim1​ rt1​).
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x2​\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x2​\] is of the form (at2​ lim2​ rt2​).
>     
> *   The [reference type](#syntax-reftype) rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt1​.
>     
> *   The [address type](#syntax-addrtype) [addrtype](#syntax-addrtype) is [min](#aux-addrtype-min)(at1​,at2​).
>     

C[⊢](#valid-instr)[table.copy](#syntax-instr-table) x1​ x2​:at1​ at2​ [min](#aux-addrtype-min)(at1​,at2​)→ϵC.[tables](#context)\[x1​\]\=at1​ lim1​ rt1​C.[tables](#context)\[x2​\]\=at2​ lim2​ rt2​C[⊢](#match-reftype)rt2​[≤](#match-reftype)rt1​​​

##### 3.4.4.7. [table.init](#syntax-instr-table) x y[](#-hrefsyntax-instr-tablemathsftableinitxy)

The [instruction](#syntax-instr) ([table.init](#syntax-instr-table) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [i32](#syntax-numtype) [i32](#syntax-numtype) → ϵ if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt1​).
>     
> *   The [element segment](#syntax-elemtype) C.[elems](#context)\[y\] exists.
>     
> *   The [element segment](#syntax-reftype) C.[elems](#context)\[y\] is of the form rt2​.
>     
> *   The [reference type](#syntax-reftype) rt2​ [matches](#match-reftype) the [reference type](#syntax-reftype) rt1​.
>     

C[⊢](#valid-instr)[table.init](#syntax-instr-table) x y:at [i32](#syntax-numtype) [i32](#syntax-numtype)→ϵC.[tables](#context)\[x\]\=at lim rt1​C.[elems](#context)\[y\]\=rt2​C[⊢](#match-reftype)rt2​[≤](#match-reftype)rt1​​​

##### 3.4.4.8. [elem.drop](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsfelemdropx)

The [instruction](#syntax-instr) ([elem.drop](#syntax-instr-table) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ϵ if:

> *   The [element segment](#syntax-elemtype) C.[elems](#context)\[x\] exists.
>     

C[⊢](#valid-instr)[elem.drop](#syntax-instr-table) x:ϵ→ϵC.[elems](#context)\[x\]\=rt​​

#### 3.4.5. Memory Instructions[](#memory-instructions③)

Memory instructions use [memory arguments](#syntax-memarg), which are classified by the [address type](#syntax-addrtype) and the and [bit width](#bitwidth-valtype) of the access they are suitable for.

##### 3.4.5.1. [memarg](#syntax-memarg)[](#-hrefsyntax-memargmathitmemarg)

{[align](#syntax-instr-memory) n,[offset](#syntax-instr-memory) m} is valid for at and N if:

> *   2n is less than or equal to N/8.
>     
> *   m is less than 2∣at∣.
>     

[⊢](#valid-memarg){[align](#syntax-instr-memory) n,[offset](#syntax-instr-memory) m}:at[→](#valid-memarg)N2n≤N/8m<2∣at∣​​

##### 3.4.5.2. t.[load](#syntax-instr-memory) x [memarg](#syntax-memarg)[](#-tmathsfhrefsyntax-instr-memorymathsfloadxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) (nt.[load](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → nt if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and ∣nt∣.
>     

C[⊢](#valid-instr)nt.[load](#syntax-instr-memory) x [memarg](#syntax-memarg):at→ntC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)∣nt∣​​

##### 3.4.5.3. t.[load](#syntax-instr-memory)N\_[sx](#syntax-sx) x [memarg](#syntax-memarg)[](#-tmathsfhrefsyntax-instr-memorymathsfloadnmathsf_hrefsyntax-sxmathitsxxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([i](#syntax-numtype)[N](#syntax-numtype).[load](#syntax-instr-memory)M\_[sx](#syntax-sx) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → [i](#syntax-numtype)[N](#syntax-numtype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and M.
>     

C[⊢](#valid-instr)[i](#syntax-numtype)[N](#syntax-numtype).[load](#syntax-instr-memory)M\_[sx](#syntax-sx) x [memarg](#syntax-memarg):at→[i](#syntax-numtype)[N](#syntax-numtype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)M​​

##### 3.4.5.4. t.[store](#syntax-instr-memory) x [memarg](#syntax-memarg)[](#-tmathsfhrefsyntax-instr-memorymathsfstorexhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) (nt.[store](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at nt → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and ∣nt∣.
>     

C[⊢](#valid-instr)nt.[store](#syntax-instr-memory) x [memarg](#syntax-memarg):at nt→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)∣nt∣​​

##### 3.4.5.5. t.[store](#syntax-instr-memory)N x [memarg](#syntax-memarg)[](#-tmathsfhrefsyntax-instr-memorymathsfstorenxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([i](#syntax-numtype)[N](#syntax-numtype).[store](#syntax-instr-memory)M x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [i](#syntax-numtype)[N](#syntax-numtype) → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and M.
>     

C[⊢](#valid-instr)[i](#syntax-numtype)[N](#syntax-numtype).[store](#syntax-instr-memory)M x [memarg](#syntax-memarg):at [i](#syntax-numtype)[N](#syntax-numtype)→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)M​​

##### 3.4.5.6. v128.[load](#syntax-instr-memory) x [memarg](#syntax-memarg)[](#-mathsfv128hrefsyntax-instr-memorymathsfloadxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[load](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → [v128](#syntax-vectype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and ∣[v128](#syntax-vectype)∣.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[load](#syntax-instr-memory) x [memarg](#syntax-memarg):at→[v128](#syntax-vectype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)∣[v128](#syntax-vectype)∣​​

##### 3.4.5.7. v128.[load](#syntax-instr-memory)NxM\_[sx](#syntax-sx) x [memarg](#syntax-memarg)[](#-mathsfv128hrefsyntax-instr-memorymathsfloadnmathsfxm_hrefsyntax-sxmathitsxxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[load](#syntax-instr-memory)M[x](#syntax-shape)N\_[sx](#syntax-sx) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → [v128](#syntax-vectype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and M⋅N.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[load](#syntax-instr-memory)M[x](#syntax-shape)N\_[sx](#syntax-sx) x [memarg](#syntax-memarg):at→[v128](#syntax-vectype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)M⋅N​​

##### 3.4.5.8. v128.[load](#syntax-instr-memory)N\_splat x [memarg](#syntax-memarg)[](#-mathsfv128hrefsyntax-instr-memorymathsfloadnmathsf_splatxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[splat](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → [v128](#syntax-vectype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and N.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[splat](#syntax-instr-memory) x [memarg](#syntax-memarg):at→[v128](#syntax-vectype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)N​​

##### 3.4.5.9. v128.[load](#syntax-instr-memory)N\_zero x [memarg](#syntax-memarg)[](#-mathsfv128hrefsyntax-instr-memorymathsfloadnmathsf_zeroxhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[zero](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → [v128](#syntax-vectype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and N.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[zero](#syntax-instr-memory) x [memarg](#syntax-memarg):at→[v128](#syntax-vectype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)N​​

##### 3.4.5.10. v128.[load](#syntax-instr-memory)N\_lane x [memarg](#syntax-memarg) [laneidx](#syntax-laneidx)[](#-mathsfv128hrefsyntax-instr-memorymathsfloadnmathsf_lanexhrefsyntax-memargmathitmemarghrefsyntax-laneidxmathitlaneidx)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x [memarg](#syntax-memarg) i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [v128](#syntax-vectype) → [v128](#syntax-vectype) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and N.
>     
> *   i is less than 128/N.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x [memarg](#syntax-memarg) i:at [v128](#syntax-vectype)→[v128](#syntax-vectype)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)Ni<128/N​​

##### 3.4.5.11. v128.[store](#syntax-instr-memory) x [memarg](#syntax-memarg)[](#-mathsfv128hrefsyntax-instr-memorymathsfstorexhrefsyntax-memargmathitmemarg)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[store](#syntax-instr-memory) x [memarg](#syntax-memarg)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [v128](#syntax-vectype) → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and ∣[v128](#syntax-vectype)∣.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[store](#syntax-instr-memory) x [memarg](#syntax-memarg):at [v128](#syntax-vectype)→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)∣[v128](#syntax-vectype)∣​​

##### 3.4.5.12. v128.[store](#syntax-instr-memory)N\_lane x [memarg](#syntax-memarg) [laneidx](#syntax-laneidx)[](#-mathsfv128hrefsyntax-instr-memorymathsfstorenmathsf_lanexhrefsyntax-memargmathitmemarghrefsyntax-laneidxmathitlaneidx)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[store](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x [memarg](#syntax-memarg) i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [v128](#syntax-vectype) → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   [memarg](#syntax-memarg) is valid for at and N.
>     
> *   i is less than 128/N.
>     

C[⊢](#valid-instr)[v128](#syntax-vectype).[store](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x [memarg](#syntax-memarg) i:at [v128](#syntax-vectype)→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)[⊢](#valid-memarg)[memarg](#syntax-memarg):at[→](#valid-memarg)Ni<128/N​​

##### 3.4.5.13. [memory.size](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemorysizex)

The [instruction](#syntax-instr) ([memory.size](#syntax-instr-memory) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → at if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     

C[⊢](#valid-instr)[memory.size](#syntax-instr-memory) x:ϵ→atC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)​​

##### 3.4.5.14. [memory.grow](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemorygrowx)

The [instruction](#syntax-instr) ([memory.grow](#syntax-instr-memory) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at → at if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     

C[⊢](#valid-instr)[memory.grow](#syntax-instr-memory) x:at→atC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)​​

##### 3.4.5.15. [memory.fill](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemoryfillx)

The [instruction](#syntax-instr) ([memory.fill](#syntax-instr-memory) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [i32](#syntax-numtype) at → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     

C[⊢](#valid-instr)[memory.fill](#syntax-instr-memory) x:at [i32](#syntax-numtype) at→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)​​

##### 3.4.5.16. [memory.copy](#syntax-instr-memory) x y[](#-hrefsyntax-instr-memorymathsfmemorycopyxy)

The [instruction](#syntax-instr) ([memory.copy](#syntax-instr-memory) x1​ x2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at1​ at2​ [addrtype](#syntax-addrtype) → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x1​\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x1​\] is of the form (at1​ lim1​ [page](#syntax-memtype)).
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x2​\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x2​\] is of the form (at2​ lim2​ [page](#syntax-memtype)).
>     
> *   The [address type](#syntax-addrtype) [addrtype](#syntax-addrtype) is [min](#aux-addrtype-min)(at1​,at2​).
>     

C[⊢](#valid-instr)[memory.copy](#syntax-instr-memory) x1​ x2​:at1​ at2​ [min](#aux-addrtype-min)(at1​,at2​)→ϵC.[mems](#context)\[x1​\]\=at1​ lim1​ [page](#syntax-memtype)C.[mems](#context)\[x2​\]\=at2​ lim2​ [page](#syntax-memtype)​​

##### 3.4.5.17. [memory.init](#syntax-instr-memory) x y[](#-hrefsyntax-instr-memorymathsfmemoryinitxy)

The [instruction](#syntax-instr) ([memory.init](#syntax-instr-memory) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) at [i32](#syntax-numtype) [i32](#syntax-numtype) → ϵ if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] exists.
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] is of the form [ok](#valid-data).
>     

C[⊢](#valid-instr)[memory.init](#syntax-instr-memory) x y:at [i32](#syntax-numtype) [i32](#syntax-numtype)→ϵC.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)C.[datas](#context)\[y\]\=[ok](#valid-data)​​

##### 3.4.5.18. [data.drop](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfdatadropx)

The [instruction](#syntax-instr) ([data.drop](#syntax-instr-memory) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ϵ if:

> *   The [data segment](#syntax-datatype) C.[datas](#context)\[x\] exists.
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[x\] is of the form [ok](#valid-data).
>     

C[⊢](#valid-instr)[data.drop](#syntax-instr-memory) x:ϵ→ϵC.[datas](#context)\[x\]\=[ok](#valid-data)​​

#### 3.4.6. Reference Instructions[](#reference-instructions③)

##### 3.4.6.1. [ref.null](#syntax-instr-ref) ht[](#-hrefsyntax-instr-refmathsfrefnullmathitht)

The [instruction](#syntax-instr) ([ref.null](#syntax-instr-ref) ht) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ([ref](#syntax-reftype) [null](#syntax-reftype) ht) if:

> *   The [heap type](#syntax-heaptype) ht is [valid](#valid-heaptype).
>     

C[⊢](#valid-instr)[ref.null](#syntax-instr-ref) ht:ϵ→([ref](#syntax-reftype) [null](#syntax-reftype) ht)C[⊢](#valid-heaptype)ht:[ok](#valid-heaptype)​​

##### 3.4.6.2. [ref.func](#syntax-instr-ref) x[](#-hrefsyntax-instr-refmathsfreffuncx)

The [instruction](#syntax-instr) ([ref.func](#syntax-instr-ref) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ([ref](#syntax-reftype) dt) if:

> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] exists.
>     
> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] is of the form dt.
>     
> *   x is contained in C.[refs](#context).
>     

C[⊢](#valid-instr)[ref.func](#syntax-instr-ref) x:ϵ→([ref](#syntax-reftype) dt)C.[funcs](#context)\[x\]\=dtx∈C.[refs](#context)​​

##### 3.4.6.3. [ref.is\_null](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefis_null)

The [instruction](#syntax-instr) [ref.is\_null](#syntax-instr-ref) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) ht) → [i32](#syntax-numtype) if:

> *   The [heap type](#syntax-heaptype) ht is [valid](#valid-heaptype).
>     

C[⊢](#valid-instr)[ref.is\_null](#syntax-instr-ref):([ref](#syntax-reftype) [null](#syntax-reftype) ht)→[i32](#syntax-numtype)C[⊢](#valid-heaptype)ht:[ok](#valid-heaptype)​​

##### 3.4.6.4. [ref.as\_non\_null](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefas_non_null)

The [instruction](#syntax-instr) [ref.as\_non\_null](#syntax-instr-ref) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) ht) → ([ref](#syntax-reftype) ht) if:

> *   The [heap type](#syntax-heaptype) ht is [valid](#valid-heaptype).
>     

C[⊢](#valid-instr)[ref.as\_non\_null](#syntax-instr-ref):([ref](#syntax-reftype) [null](#syntax-reftype) ht)→([ref](#syntax-reftype) ht)C[⊢](#valid-heaptype)ht:[ok](#valid-heaptype)​​

##### 3.4.6.5. [ref.eq](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefeq)

The [instruction](#syntax-instr) [ref.eq](#syntax-instr-ref) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) [eq](#syntax-heaptype)) ([ref](#syntax-reftype) [null](#syntax-reftype) [eq](#syntax-heaptype)) → [i32](#syntax-numtype).

C[⊢](#valid-instr)[ref.eq](#syntax-instr-ref):([ref](#syntax-reftype) [null](#syntax-reftype) [eq](#syntax-heaptype)) ([ref](#syntax-reftype) [null](#syntax-reftype) [eq](#syntax-heaptype))→[i32](#syntax-numtype)​​

##### 3.4.6.6. [ref.test](#syntax-instr-ref) rt[](#-hrefsyntax-instr-refmathsfreftestmathitrt)

The [instruction](#syntax-instr) ([ref.test](#syntax-instr-ref) rt) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) rt′ → [i32](#syntax-numtype) if:

> *   The [reference type](#syntax-reftype) rt is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt′ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt [matches](#match-reftype) the [reference type](#syntax-reftype) rt′.
>     

C[⊢](#valid-instr)[ref.test](#syntax-instr-ref) rt:rt′→[i32](#syntax-numtype)C[⊢](#valid-reftype)rt:[ok](#valid-reftype)C[⊢](#valid-reftype)rt′:[ok](#valid-reftype)C[⊢](#match-reftype)rt[≤](#match-reftype)rt′​​

Note

The liberty to pick a supertype rt′ allows typing the instruction with the least precise super type of rt as input, that is, the top type in the corresponding heap subtyping hierarchy.

##### 3.4.6.7. [ref.cast](#syntax-instr-ref) rt[](#-hrefsyntax-instr-refmathsfrefcastmathitrt)

The [instruction](#syntax-instr) ([ref.cast](#syntax-instr-ref) rt) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) rt′ → rt if:

> *   The [reference type](#syntax-reftype) rt is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt′ is [valid](#valid-reftype).
>     
> *   The [reference type](#syntax-reftype) rt [matches](#match-reftype) the [reference type](#syntax-reftype) rt′.
>     

C[⊢](#valid-instr)[ref.cast](#syntax-instr-ref) rt:rt′→rtC[⊢](#valid-reftype)rt:[ok](#valid-reftype)C[⊢](#valid-reftype)rt′:[ok](#valid-reftype)C[⊢](#match-reftype)rt[≤](#match-reftype)rt′​​

Note

The liberty to pick a supertype rt′ allows typing the instruction with the least precise super type of rt as input, that is, the top type in the corresponding heap subtyping hierarchy.

#### 3.4.7. Aggregate Reference Instructions[](#aggregate-reference-instructions①)

##### 3.4.7.1. [struct.new](#syntax-instr-struct) x[](#-hrefsyntax-instr-structmathsfstructnewx)

The [instruction](#syntax-instr) ([struct.new](#syntax-instr-struct) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t∗ → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗).
>     
> *   The value type sequence t∗ is [unpack](#aux-unpack)(zt)∗.
>     

C[⊢](#valid-instr)[struct.new](#syntax-instr-struct) x:[unpack](#aux-unpack)(zt)∗→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗​​

##### 3.4.7.2. [struct.new\_default](#syntax-instr-struct) x[](#-hrefsyntax-instr-structmathsfstructnew_defaultx)

The [instruction](#syntax-instr) ([struct.new\_default](#syntax-instr-struct) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗).
>     
> *   For all zt in zt∗:
>     
>     > *   A [default value](#aux-default) for [unpack](#aux-unpack)(zt) is defined.
>     >     
>     

C[⊢](#valid-instr)[struct.new\_default](#syntax-instr-struct) x:ϵ→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗([default](#aux-default)[unpack](#aux-unpack)(zt)​\=ϵ)∗​​

##### 3.4.7.3. [struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x y[](#-hrefsyntax-instr-structmathsfstructgetmathsf_hrefsyntax-sxmathitsxxy)

The [instruction](#syntax-instr) ([struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) → t if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([struct](#syntax-comptype) ft∗).
>     
> *   The length of ft∗ is greater than i.
>     
> *   The [field type](#syntax-fieldtype) ft∗\[i\] is of the form ([mut](#syntax-mut)? zt).
>     
> *   The signedness [sx](#syntax-sx)? is absent if and only if zt is a packed type.
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x i:([ref](#syntax-reftype) [null](#syntax-reftype) x)→[unpack](#aux-unpack)(zt)C.[types](#context)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ft∗ft∗\[i\]\=[mut](#syntax-mut)? zt[sx](#syntax-sx)?\=ϵ⇔zt\=[unpack](#aux-unpack)(zt)​​

##### 3.4.7.4. [struct.set](#syntax-instr-struct) x y[](#-hrefsyntax-instr-structmathsfstructsetxy)

The [instruction](#syntax-instr) ([struct.set](#syntax-instr-struct) x i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) t → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([struct](#syntax-comptype) ft∗).
>     
> *   The length of ft∗ is greater than i.
>     
> *   The [field type](#syntax-fieldtype) ft∗\[i\] is of the form ([mut](#syntax-mut) zt).
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[struct.set](#syntax-instr-struct) x i:([ref](#syntax-reftype) [null](#syntax-reftype) x) [unpack](#aux-unpack)(zt)→ϵC.[types](#context)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ft∗ft∗\[i\]\=[mut](#syntax-mut) zt​​

##### 3.4.7.5. [array.new](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraynewx)

The [instruction](#syntax-instr) ([array.new](#syntax-instr-array) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t [i32](#syntax-numtype) → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt)).
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[array.new](#syntax-instr-array) x:[unpack](#aux-unpack)(zt) [i32](#syntax-numtype)→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)​​

##### 3.4.7.6. [array.new\_default](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraynew_defaultx)

The [instruction](#syntax-instr) ([array.new\_default](#syntax-instr-array) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [i32](#syntax-numtype) → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt)).
>     
> *   A [default value](#aux-default) for [unpack](#aux-unpack)(zt) is defined.
>     

C[⊢](#valid-instr)[array.new\_default](#syntax-instr-array) x:[i32](#syntax-numtype)→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)[default](#aux-default)[unpack](#aux-unpack)(zt)​\=ϵ​​

##### 3.4.7.7. [array.new\_fixed](#syntax-instr-array) x n[](#-hrefsyntax-instr-arraymathsfarraynew_fixedxn)

The [instruction](#syntax-instr) ([array.new\_fixed](#syntax-instr-array) x n) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) tn → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt)).
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[array.new\_fixed](#syntax-instr-array) x n:[unpack](#aux-unpack)(zt)n→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)​​

##### 3.4.7.8. [array.new\_elem](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarraynew_elemxy)

The [instruction](#syntax-instr) ([array.new\_elem](#syntax-instr-array) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [i32](#syntax-numtype) [i32](#syntax-numtype) → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? rt)).
>     
> *   The [element segment](#syntax-elemtype) C.[elems](#context)\[y\] exists.
>     
> *   The [element segment](#syntax-reftype) C.[elems](#context)\[y\] [matches](#match-reftype) the [reference type](#syntax-reftype) rt.
>     

C[⊢](#valid-instr)[array.new\_elem](#syntax-instr-array) x y:[i32](#syntax-numtype) [i32](#syntax-numtype)→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? rt)C[⊢](#match-reftype)C.[elems](#context)\[y\][≤](#match-reftype)rt​​

##### 3.4.7.9. [array.new\_data](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarraynew_dataxy)

The [instruction](#syntax-instr) ([array.new\_data](#syntax-instr-array) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [i32](#syntax-numtype) [i32](#syntax-numtype) → ([ref](#syntax-reftype) x) if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt)).
>     
> *   The [value type](#syntax-valtype) [unpack](#aux-unpack)(zt) is of the form [numtype](#syntax-numtype) or [unpack](#aux-unpack)(zt) is of the form [vectype](#syntax-vectype).
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] exists.
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] is of the form [ok](#valid-data).
>     

C[⊢](#valid-instr)[array.new\_data](#syntax-instr-array) x y:[i32](#syntax-numtype) [i32](#syntax-numtype)→([ref](#syntax-reftype) x)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)[unpack](#aux-unpack)(zt)\=[numtype](#syntax-numtype)∨[unpack](#aux-unpack)(zt)\=[vectype](#syntax-vectype)C.[datas](#context)\[y\]\=[ok](#valid-data)​​

##### 3.4.7.10. [array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x[](#-hrefsyntax-instr-arraymathsfarraygetmathsf_hrefsyntax-sxmathitsxx)

The [instruction](#syntax-instr) ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) → t if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt)).
>     
> *   The signedness [sx](#syntax-sx)? is absent if and only if zt is a packed type.
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x:([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype)→[unpack](#aux-unpack)(zt)C.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)[sx](#syntax-sx)?\=ϵ⇔zt\=[unpack](#aux-unpack)(zt)​​

##### 3.4.7.11. [array.set](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraysetx)

The [instruction](#syntax-instr) ([array.set](#syntax-instr-array) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) t → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut) zt)).
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[array.set](#syntax-instr-array) x:([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [unpack](#aux-unpack)(zt)→ϵC.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut) zt)​​

##### 3.4.7.12. [array.len](#syntax-instr-array)[](#-hrefsyntax-instr-arraymathsfarraylen)

The [instruction](#syntax-instr) [array.len](#syntax-instr-array) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) [array](#syntax-heaptype)) → [i32](#syntax-numtype).

C[⊢](#valid-instr)[array.len](#syntax-instr-array):([ref](#syntax-reftype) [null](#syntax-reftype) [array](#syntax-heaptype))→[i32](#syntax-numtype)​​

##### 3.4.7.13. [array.fill](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarrayfillx)

The [instruction](#syntax-instr) ([array.fill](#syntax-instr-array) x) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) t [i32](#syntax-numtype) → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut) zt)).
>     
> *   The [value type](#syntax-valtype) t is [unpack](#aux-unpack)(zt).
>     

C[⊢](#valid-instr)[array.fill](#syntax-instr-array) x:([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [unpack](#aux-unpack)(zt) [i32](#syntax-numtype)→ϵC.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut) zt)​​

##### 3.4.7.14. [array.copy](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarraycopyxy)

The [instruction](#syntax-instr) ([array.copy](#syntax-instr-array) x1​ x2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x1​) [i32](#syntax-numtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x2​) [i32](#syntax-numtype) [i32](#syntax-numtype) → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x1​\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x1​\] is ([array](#syntax-comptype) ([mut](#syntax-mut) zt1​)).
>     
> *   The [type](#syntax-deftype) C.[types](#context)\[x2​\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x2​\] is ([array](#syntax-comptype) ([mut](#syntax-mut)? zt2​)).
>     
> *   The [storage type](#syntax-storagetype) zt2​ [matches](#match-storagetype) the [storage type](#syntax-storagetype) zt1​.
>     

C[⊢](#valid-instr)[array.copy](#syntax-instr-array) x1​ x2​:([ref](#syntax-reftype) [null](#syntax-reftype) x1​) [i32](#syntax-numtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x2​) [i32](#syntax-numtype) [i32](#syntax-numtype)→ϵC.[types](#context)\[x1​\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut) zt1​)C.[types](#context)\[x2​\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt2​)C[⊢](#match-storagetype)zt2​[≤](#match-storagetype)zt1​​​

##### 3.4.7.15. [array.init\_elem](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarrayinit_elemxy)

The [instruction](#syntax-instr) ([array.init\_elem](#syntax-instr-array) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [i32](#syntax-numtype) [i32](#syntax-numtype) → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut) zt)).
>     
> *   The [element segment](#syntax-elemtype) C.[elems](#context)\[y\] exists.
>     
> *   The [element segment](#syntax-elemtype) C.[elems](#context)\[y\] [matches](#match) the [storage type](#syntax-storagetype) zt.
>     

C[⊢](#valid-instr)[array.init\_elem](#syntax-instr-array) x y:([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [i32](#syntax-numtype) [i32](#syntax-numtype)→ϵC.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut) zt)C[⊢](#match-storagetype)C.[elems](#context)\[y\][≤](#match-storagetype)zt​​

##### 3.4.7.16. [array.init\_data](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarrayinit_dataxy)

The [instruction](#syntax-instr) ([array.init\_data](#syntax-instr-array) x y) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [i32](#syntax-numtype) [i32](#syntax-numtype) → ϵ if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([array](#syntax-comptype) ([mut](#syntax-mut) zt)).
>     
> *   The [value type](#syntax-valtype) [unpack](#aux-unpack)(zt) is of the form [numtype](#syntax-numtype) or [unpack](#aux-unpack)(zt) is of the form [vectype](#syntax-vectype).
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] exists.
>     
> *   The [data segment](#syntax-datatype) C.[datas](#context)\[y\] is of the form [ok](#valid-data).
>     

C[⊢](#valid-instr)[array.init\_data](#syntax-instr-array) x y:([ref](#syntax-reftype) [null](#syntax-reftype) x) [i32](#syntax-numtype) [i32](#syntax-numtype) [i32](#syntax-numtype)→ϵC.[types](#context)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut) zt)[unpack](#aux-unpack)(zt)\=[numtype](#syntax-numtype)∨[unpack](#aux-unpack)(zt)\=[vectype](#syntax-vectype)C.[datas](#context)\[y\]\=[ok](#valid-data)​​

#### 3.4.8. Scalar Reference Instructions[](#scalar-reference-instructions①)

##### 3.4.8.1. [ref.i31](#syntax-instr-i31)[](#-hrefsyntax-instr-i31mathsfrefiscriptstyle31)

The [instruction](#syntax-instr) [ref.i31](#syntax-instr-i31) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [i32](#syntax-numtype) → ([ref](#syntax-reftype) [i31](#syntax-heaptype)).

C[⊢](#valid-instr)[ref.i31](#syntax-instr-i31):[i32](#syntax-numtype)→([ref](#syntax-reftype) [i31](#syntax-heaptype))​​

##### 3.4.8.2. [i31.get](#syntax-instr-i31)\_[sx](#syntax-sx)[](#-hrefsyntax-instr-i31mathsfiscriptstyle31getmathsf_hrefsyntax-sxmathitsx)

The [instruction](#syntax-instr) ([i31.get](#syntax-instr-i31)\_[sx](#syntax-sx)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype) [i31](#syntax-heaptype)) → [i32](#syntax-numtype).

C[⊢](#valid-instr)[i31.get](#syntax-instr-i31)\_[sx](#syntax-sx):([ref](#syntax-reftype) [null](#syntax-reftype) [i31](#syntax-heaptype))→[i32](#syntax-numtype)​​

#### 3.4.9. External Reference Instructions[](#external-reference-instructions①)

##### 3.4.9.1. [any.convert\_extern](#syntax-instr-extern)[](#-hrefsyntax-instr-externmathsfanyconvert_extern)

The [instruction](#syntax-instr) [any.convert\_extern](#syntax-instr-extern) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ [extern](#syntax-heaptype)) → ([ref](#syntax-reftype) [null](#syntax-reftype)2?​ [any](#syntax-heaptype)) if:

> *   [null](#syntax-reftype)1?​ is of the form [null](#syntax-reftype)2?​.
>     

C[⊢](#valid-instr)[any.convert\_extern](#syntax-instr-extern):([ref](#syntax-reftype) [null](#syntax-reftype)1?​ [extern](#syntax-heaptype))→([ref](#syntax-reftype) [null](#syntax-reftype)2?​ [any](#syntax-heaptype))[null](#syntax-reftype)1?​\=[null](#syntax-reftype)2?​​​

##### 3.4.9.2. [extern.convert\_any](#syntax-instr-extern)[](#-hrefsyntax-instr-externmathsfexternconvert_any)

The [instruction](#syntax-instr) [extern.convert\_any](#syntax-instr-extern) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ [any](#syntax-heaptype)) → ([ref](#syntax-reftype) [null](#syntax-reftype)2?​ [extern](#syntax-heaptype)) if:

> *   [null](#syntax-reftype)1?​ is of the form [null](#syntax-reftype)2?​.
>     

C[⊢](#valid-instr)[extern.convert\_any](#syntax-instr-extern):([ref](#syntax-reftype) [null](#syntax-reftype)1?​ [any](#syntax-heaptype))→([ref](#syntax-reftype) [null](#syntax-reftype)2?​ [extern](#syntax-heaptype))[null](#syntax-reftype)1?​\=[null](#syntax-reftype)2?​​​

#### 3.4.10. Numeric Instructions[](#numeric-instructions③)

##### 3.4.10.1. t.[const](#syntax-instr-numeric) c[](#-tmathsfhrefsyntax-instr-numericmathsfconstc)

The [instruction](#syntax-instr) (nt.[const](#syntax-instr-numeric) cnt​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → nt.

C[⊢](#valid-instr)nt.[const](#syntax-instr-numeric) cnt​:ϵ→nt​​

##### 3.4.10.2. t.[unop](#syntax-unop)[](#-tmathsfhrefsyntax-unopmathitunop)

The [instruction](#syntax-instr) (nt.[unop](#syntax-unop)nt​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) nt → nt.

C[⊢](#valid-instr)nt.[unop](#syntax-unop)nt​:nt→nt​​

##### 3.4.10.3. t.[binop](#syntax-binop)[](#-tmathsfhrefsyntax-binopmathitbinop)

The [instruction](#syntax-instr) (nt.[binop](#syntax-binop)nt​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) nt nt → nt.

C[⊢](#valid-instr)nt.[binop](#syntax-binop)nt​:nt nt→nt​​

##### 3.4.10.4. t.[testop](#syntax-testop)[](#-tmathsfhrefsyntax-testopmathittestop)

The [instruction](#syntax-instr) (nt.[testop](#syntax-testop)nt​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) nt → [i32](#syntax-numtype).

C[⊢](#valid-instr)nt.[testop](#syntax-testop)nt​:nt→[i32](#syntax-numtype)​​

##### 3.4.10.5. t.[relop](#syntax-relop)[](#-tmathsfhrefsyntax-relopmathitrelop)

The [instruction](#syntax-instr) (nt.[relop](#syntax-relop)nt​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) nt nt → [i32](#syntax-numtype).

C[⊢](#valid-instr)nt.[relop](#syntax-relop)nt​:nt nt→[i32](#syntax-numtype)​​

##### 3.4.10.6. t1​.[cvtop](#syntax-cvtop)\_t2​\_[sx](#syntax-sx)?[](#-t_1mathsfhrefsyntax-cvtopmathitcvtopmathsf_t_2mathsf_hrefsyntax-sxmathitsx)

The [instruction](#syntax-instr) (nt1​.[cvtop](#syntax-cvtop)\_nt2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) nt2​ → nt1​.

C[⊢](#valid-instr)nt1​.[cvtop](#syntax-cvtop)\_nt2​:nt2​→nt1​​​

#### 3.4.11. Vector Instructions[](#vector-instructions③)

Vector instructions can have a prefix to describe the [shape](#syntax-shape) of the operand. Packed numeric types, [i8](#syntax-storagetype) and [i16](#syntax-storagetype), are not [value types](#syntax-valtype). An auxiliary function maps such packed type shapes to value types:

[unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)N)​\=​[unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype))​​

##### 3.4.11.1. [v128](#syntax-vectype).[const](#syntax-instr-vec) c[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-instr-vecmathsfconstc)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → [v128](#syntax-vectype).

C[⊢](#valid-instr)[v128](#syntax-vectype).[const](#syntax-instr-numeric) c:ϵ→[v128](#syntax-vectype)​​

##### 3.4.11.2. [v128](#syntax-vectype).[vvunop](#syntax-vvunop)[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-vvunopmathitvvunop)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[vvunop](#syntax-vvunop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)[v128](#syntax-vectype).[vvunop](#syntax-vvunop):[v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.3. [v128](#syntax-vectype).[vvbinop](#syntax-vvbinop)[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-vvbinopmathitvvbinop)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[vvbinop](#syntax-vvbinop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)[v128](#syntax-vectype).[vvbinop](#syntax-vvbinop):[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.4. [v128](#syntax-vectype).[vvternop](#syntax-vvternop)[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-vvternopmathitvvternop)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[vvternop](#syntax-vvternop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)[v128](#syntax-vectype).[vvternop](#syntax-vvternop):[v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.5. [v128](#syntax-vectype).[vvtestop](#syntax-vvtestop)[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-vvtestopmathitvvtestop)

The [instruction](#syntax-instr) ([v128](#syntax-vectype).[vvtestop](#syntax-vvtestop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [i32](#syntax-numtype).

C[⊢](#valid-instr)[v128](#syntax-vectype).[vvtestop](#syntax-vvtestop):[v128](#syntax-vectype)→[i32](#syntax-numtype)​​

##### 3.4.11.6. [shape](#syntax-shape).[vunop](#syntax-vunop)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vunopmathitvunop)

The [instruction](#syntax-instr) (sh.[vunop](#syntax-vunop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vunop](#syntax-vunop):[v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.7. [shape](#syntax-shape).[vbinop](#syntax-vbinop)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vbinopmathitvbinop)

The [instruction](#syntax-instr) (sh.[vbinop](#syntax-vbinop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vbinop](#syntax-vbinop):[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.8. [shape](#syntax-shape).[vternop](#syntax-vternop)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vternopmathitvternop)

The [instruction](#syntax-instr) (sh.[vternop](#syntax-vternop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vternop](#syntax-vternop):[v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.9. [shape](#syntax-shape).[vtestop](#syntax-vrelop)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vrelopmathitvtestop)

The [instruction](#syntax-instr) (sh.[vtestop](#syntax-vrelop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [i32](#syntax-numtype).

C[⊢](#valid-instr)sh.[vtestop](#syntax-vrelop):[v128](#syntax-vectype)→[i32](#syntax-numtype)​​

##### 3.4.11.10. [shape](#syntax-shape).[vrelop](#syntax-vrelop)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vrelopmathitvrelop)

The [instruction](#syntax-instr) (sh.[vrelop](#syntax-vrelop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vrelop](#syntax-vrelop):[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.11. [ishape](#syntax-shape).[vishiftop](#syntax-vshiftop)[](#-hrefsyntax-shapemathitishapemathsfhrefsyntax-vshiftopmathitvishiftop)

The [instruction](#syntax-instr) (sh.[vshiftop](#syntax-vshiftop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [i32](#syntax-numtype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vshiftop](#syntax-vshiftop):[v128](#syntax-vectype) [i32](#syntax-numtype)→[v128](#syntax-vectype)​​

##### 3.4.11.12. [ishape](#syntax-shape).[bitmask](#syntax-instr-vec)[](#-hrefsyntax-shapemathitishapemathsfhrefsyntax-instr-vecmathsfbitmask)

The [instruction](#syntax-instr) (sh.[bitmask](#syntax-instr-vec)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [i32](#syntax-numtype).

C[⊢](#valid-instr)sh.[bitmask](#syntax-instr-vec):[v128](#syntax-vectype)→[i32](#syntax-numtype)​​

##### 3.4.11.13. i8x16.[vswizzlop](#syntax-vswizzlop)[](#-mathsfi8x16hrefsyntax-vswizzlopmathitvswizzlop)

The [instruction](#syntax-instr) (sh.[vswizzlop](#syntax-vswizzlop)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh.[vswizzlop](#syntax-vswizzlop):[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.14. i8x16.[shuffle](#syntax-instr-vec) [laneidx](#syntax-laneidx)16[](#-mathsfi8x16hrefsyntax-instr-vecmathsfshufflehrefsyntax-laneidxmathitlaneidx16)

The [instruction](#syntax-instr) (sh.[shuffle](#syntax-instr-vec) i∗) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype) if:

> *   For all i in i∗:
>     
>     > *   The [lane index](#syntax-laneidx) i is less than 2⋅[dim](#aux-dim)(sh).
>     >     
>     

C[⊢](#valid-instr)sh.[shuffle](#syntax-instr-vec) i∗:[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)(i<2⋅[dim](#aux-dim)(sh))∗​​

##### 3.4.11.15. [shape](#syntax-shape).[splat](#syntax-instr-vec)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-instr-vecmathsfsplat)

The [instruction](#syntax-instr) (sh.[splat](#syntax-instr-vec)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [numtype](#syntax-numtype) → [v128](#syntax-vectype) if:

> *   The [number type](#syntax-numtype) [numtype](#syntax-numtype) is [unpack](#aux-unpack)(sh).
>     

C[⊢](#valid-instr)sh.[splat](#syntax-instr-vec):[unpack](#aux-unpack)(sh)→[v128](#syntax-vectype)​​

##### 3.4.11.16. [shape](#syntax-shape).[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx)? [laneidx](#syntax-laneidx)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-instr-vecmathsfextract_lanemathsf_hrefsyntax-sxmathitsxhrefsyntax-laneidxmathitlaneidx)

The [instruction](#syntax-instr) (sh.[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx)? i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [numtype](#syntax-numtype) if:

> *   The [lane index](#syntax-laneidx) i is less than [dim](#aux-dim)(sh).
>     
> *   The [number type](#syntax-numtype) [numtype](#syntax-numtype) is [unpack](#aux-unpack)(sh).
>     

C[⊢](#valid-instr)sh.[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx)? i:[v128](#syntax-vectype)→[unpack](#aux-unpack)(sh)i<[dim](#aux-dim)(sh)​​

##### 3.4.11.17. [shape](#syntax-shape).[replace\_lane](#syntax-instr-vec) [laneidx](#syntax-laneidx)[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-instr-vecmathsfreplace_lanehrefsyntax-laneidxmathitlaneidx)

The [instruction](#syntax-instr) (sh.[replace\_lane](#syntax-instr-vec) i) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [numtype](#syntax-numtype) → [v128](#syntax-vectype) if:

> *   The [lane index](#syntax-laneidx) i is less than [dim](#aux-dim)(sh).
>     
> *   The [number type](#syntax-numtype) [numtype](#syntax-numtype) is [unpack](#aux-unpack)(sh).
>     

C[⊢](#valid-instr)sh.[replace\_lane](#syntax-instr-vec) i:[v128](#syntax-vectype) [unpack](#aux-unpack)(sh)→[v128](#syntax-vectype)i<[dim](#aux-dim)(sh)​​

##### 3.4.11.18. [ishape](#syntax-shape)1​.[vextunop](#syntax-vextunop)\_[ishape](#syntax-shape)2​[](#-hrefsyntax-shapemathitishape_1mathsfhrefsyntax-vextunopmathitvextunopmathsf_hrefsyntax-shapemathitishape_2)

The [instruction](#syntax-instr) (sh1​.[vextunop](#syntax-vextunop)\_sh2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh1​.[vextunop](#syntax-vextunop)\_sh2​:[v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.19. [ishape](#syntax-shape)1​.[vextbinop](#syntax-vextbinop)\_[ishape](#syntax-shape)2​[](#-hrefsyntax-shapemathitishape_1mathsfhrefsyntax-vextbinopmathitvextbinopmathsf_hrefsyntax-shapemathitishape_2)

The [instruction](#syntax-instr) (sh1​.[vextbinop](#syntax-vextbinop)\_sh2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh1​.[vextbinop](#syntax-vextbinop)\_sh2​:[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.20. [ishape](#syntax-shape)1​.[vextternop](#syntax-vextternop)\_[ishape](#syntax-shape)2​[](#-hrefsyntax-shapemathitishape_1mathsfhrefsyntax-vextternopmathitvextternopmathsf_hrefsyntax-shapemathitishape_2)

The [instruction](#syntax-instr) (sh1​.[vextternop](#syntax-vextternop)\_sh2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh1​.[vextternop](#syntax-vextternop)\_sh2​:[v128](#syntax-vectype) [v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.21. [ishape](#syntax-shape)1​.[narrow](#syntax-instr-vec)\_[ishape](#syntax-shape)2​\_[sx](#syntax-sx)[](#-hrefsyntax-shapemathitishape_1mathsfhrefsyntax-instr-vecmathsfnarrowmathsf_hrefsyntax-shapemathitishape_2mathsf_hrefsyntax-sxmathitsx)

The [instruction](#syntax-instr) (sh1​.[narrow](#syntax-instr-vec)\_sh2​\_[sx](#syntax-sx)) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh1​.[narrow](#syntax-instr-vec)\_sh2​\_[sx](#syntax-sx):[v128](#syntax-vectype) [v128](#syntax-vectype)→[v128](#syntax-vectype)​​

##### 3.4.11.22. [shape](#syntax-shape).[vcvtop](#syntax-vcvtop)\_[half](#syntax-half)?\_[shape](#syntax-shape)\_[sx](#syntax-sx)?\_zero?[](#-hrefsyntax-shapemathitshapemathsfhrefsyntax-vcvtopmathitvcvtopmathsf_hrefsyntax-halfmathithalfmathsf_hrefsyntax-shapemathitshapemathsf_hrefsyntax-sxmathitsxmathsf_zero)

The [instruction](#syntax-instr) (sh1​.[vcvtop](#syntax-vcvtop)\_sh2​) is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) [v128](#syntax-vectype) → [v128](#syntax-vectype).

C[⊢](#valid-instr)sh1​.[vcvtop](#syntax-vcvtop)\_sh2​:[v128](#syntax-vectype)→[v128](#syntax-vectype)​​

#### 3.4.12. Instruction Sequences[](#instruction-sequences①)

Typing of instruction sequences is defined recursively.

##### 3.4.12.1. Empty Instruction Sequence: ϵ[](#empty-instruction-sequence--epsilon)

The instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) it if:

> *   Either:
>     
>     > *   The instruction sequence [instr](#syntax-instr)∗ is empty.
>     >     
>     > *   The [instruction type](#syntax-instrtype) it is of the form ϵ → ϵ.
>     >     
>     
> *   Or:
>     
>     > *   The instruction sequence [instr](#syntax-instr)∗ is of the form [instr](#syntax-instr)1​ [instr](#syntax-instr)2∗​.
>     >     
>     > *   The [instruction type](#syntax-instrtype) it is of the form t1∗​ [→](#syntax-instrtype)x1∗​ x2∗​​t3∗​.
>     >     
>     > *   The [instruction](#syntax-instr) [instr](#syntax-instr)1​ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x1∗​​t2∗​.
>     >     
>     > *   For all x1​ in x1∗​:
>     >     
>     >     > *   The [local](#syntax-localtype) C.[locals](#context)\[x1​\] exists.
>     >     >     
>     >     > *   The [local](#syntax-localtype) C.[locals](#context)\[x1​\] is of the form ([init](#syntax-init) t).
>     >     >     
>     >     
>     > *   Under the context C with the local types of x1∗​ updated to ([set](#syntax-init) t)∗, the instruction sequence [instr](#syntax-instr)2∗​ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t2∗​ [→](#syntax-instrtype)x2∗​​t3∗​.
>     >     
>     
> *   Or:
>     
>     > *   The instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) it′′.
>     >     
>     > *   The [instruction type](#syntax-instrtype) it′′ [matches](#match-instrtype) the [instruction type](#syntax-instrtype) it.
>     >     
>     > *   The [instruction type](#syntax-instrtype) it is [valid](#valid-instrtype).
>     >     
>     
> *   Or:
>     
>     > *   The [instruction type](#syntax-instrtype) it is of the form t∗ t1∗​ [→](#syntax-instrtype)x∗​t∗ t2∗​.
>     >     
>     > *   The instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) t1∗​ [→](#syntax-instrtype)x∗​t2∗​.
>     >     
>     > *   The [result type](#syntax-resulttype) t∗ is [valid](#valid-resulttype).
>     >     
>     

C[⊢](#valid-instrs)ϵ:ϵ→ϵ​​

C[⊢](#valid-instrs)[instr](#syntax-instr)1​ [instr](#syntax-instr)2∗​:t1∗​[→](#syntax-instrtype)x1∗​ x2∗​​t3∗​C[⊢](#valid-instr)[instr](#syntax-instr)1​:t1∗​[→](#syntax-instrtype)x1∗​​t2∗​(C.[locals](#context)\[x1​\]\=[init](#syntax-init) t)∗C\[.[local](#syntax-local)\[x1∗​\]\=([set](#syntax-init) t)∗\][⊢](#valid-instrs)[instr](#syntax-instr)2∗​:t2∗​[→](#syntax-instrtype)x2∗​​t3∗​​​

C[⊢](#valid-instrs)[instr](#syntax-instr)∗:it′C[⊢](#valid-instrs)[instr](#syntax-instr)∗:itC[⊢](#match-instrtype)it[≤](#match-instrtype)it′C[⊢](#valid-instrtype)it′:[ok](#valid-instrtype)​C[⊢](#valid-instrs)[instr](#syntax-instr)∗:(t∗ t1∗​)[→](#syntax-instrtype)x∗​(t∗ t2∗​)C[⊢](#valid-instrs)[instr](#syntax-instr)∗:t1∗​[→](#syntax-instrtype)x∗​t2∗​C[⊢](#valid-resulttype)t∗:[ok](#valid-resulttype)​​

Note

In combination with the previous rule, subsumption allows to compose instructions whose types would not directly fit otherwise. For example, consider the instruction sequence

([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 2) ([i32](#syntax-numtype).[add](#syntax-instr-numeric))

To type this sequence, its subsequence ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 2) ([i32](#syntax-numtype).[add](#syntax-instr-numeric)) needs to be valid with an intermediate type. But the direct type of ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 2) is ϵ→[i32](#syntax-numtype), not matching the two inputs expected by [i32](#syntax-numtype).[add](#syntax-instr-numeric). The subsumption rule allows to weaken the type of (const i32 2) to the supertype [i32](#syntax-numtype)→[i32](#syntax-numtype) [i32](#syntax-numtype), such that it can be composed with [i32](#syntax-numtype).[add](#syntax-instr-numeric) and yields the intermediate type [i32](#syntax-numtype)→[i32](#syntax-numtype) [i32](#syntax-numtype) for the subsequence. That can in turn be composed with the first constant.

Furthermore, subsumption allows to drop init variables x∗ from the instruction type in a context where they are not needed, for example, at the end of the body of a [block](#valid-block).

#### 3.4.13. Expressions[](#expressions③)

Expressions [expr](#syntax-expr) are classified by [result types](#syntax-resulttype) t∗.

The [expression](#syntax-expr) [instr](#syntax-instr)∗ is [valid](#valid-expr) with the [result type](#syntax-resulttype) t∗ if:

> *   The instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-instr) with the [instruction type](#syntax-instrtype) ϵ → t∗.
>     

C[⊢](#valid-expr)[instr](#syntax-instr)∗:t∗C[⊢](#valid-instrs)[instr](#syntax-instr)∗:ϵ[→](#syntax-instrtype)ϵ​t∗​​

##### 3.4.13.1. Constant Expressions[](#constant-expressions①)

In a _constant_ expression, all instructions must be constant.

[instr](#syntax-instr)∗ is constant if:

> *   For all [instr](#syntax-instr) in [instr](#syntax-instr)∗:
>     
>     > *   [instr](#syntax-instr) is constant.
>     >     
>     

[val](#syntax-val) is constant if:

> *   Either:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form (nt.[const](#syntax-instr-numeric) cnt​).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form (vt.[const](#syntax-instr-numeric) cvt​).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([ref.null](#syntax-instr-ref) ht).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form [ref.i31](#syntax-instr-i31).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([ref.func](#syntax-instr-ref) x).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([struct.new](#syntax-instr-struct) x).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([struct.new\_default](#syntax-instr-struct) x).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([array.new](#syntax-instr-array) x).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([array.new\_default](#syntax-instr-array) x).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([array.new\_fixed](#syntax-instr-array) x n).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form [any.convert\_extern](#syntax-instr-extern).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form [extern.convert\_any](#syntax-instr-extern).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([global.get](#syntax-instr-variable) x).
>     >     
>     > *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] exists.
>     >     
>     > *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] is of the form (ϵ t).
>     >     
>     
> *   Or:
>     
>     > *   The [value](#syntax-val) [val](#syntax-val) is of the form ([i](#syntax-numtype)[N](#syntax-numtype).[binop](#syntax-binop)).
>     >     
>     > *   [i](#syntax-numtype)[N](#syntax-numtype) is contained in \[[i32](#syntax-numtype); [i64](#syntax-numtype)\].
>     >     
>     > *   [binop](#syntax-binop) is contained in \[[add](#syntax-instr-numeric); [sub](#syntax-instr-numeric); [mul](#syntax-instr-numeric)\].
>     >     
>     

C[⊢](#valid-const)[instr](#syntax-instr)∗ [const](#valid-const)(C[⊢](#valid-const)[instr](#syntax-instr) [const](#valid-const))∗​​

C[⊢](#valid-const)(nt.[const](#syntax-instr-numeric) cnt​) [const](#valid-const)​C[⊢](#valid-const)(vt.[const](#syntax-instr-numeric) cvt​) [const](#valid-const)​C[⊢](#valid-const)([i](#syntax-numtype)[N](#syntax-numtype).[binop](#syntax-binop)) [const](#valid-const)[i](#syntax-numtype)[N](#syntax-numtype)∈[i32](#syntax-numtype) [i64](#syntax-numtype)[binop](#syntax-binop)∈[add](#syntax-instr-numeric) [sub](#syntax-instr-numeric) [mul](#syntax-instr-numeric)​3ex\]C[⊢](#valid-const)([ref.null](#syntax-instr-ref) ht) [const](#valid-const)​C[⊢](#valid-const)([ref.i31](#syntax-instr-i31)) [const](#valid-const)​C[⊢](#valid-const)([ref.func](#syntax-instr-ref) x) [const](#valid-const)​3ex\]C[⊢](#valid-const)([struct.new](#syntax-instr-struct) x) [const](#valid-const)​C[⊢](#valid-const)([struct.new\_default](#syntax-instr-struct) x) [const](#valid-const)​3ex\]C[⊢](#valid-const)([array.new](#syntax-instr-array) x) [const](#valid-const)​C[⊢](#valid-const)([array.new\_default](#syntax-instr-array) x) [const](#valid-const)​C[⊢](#valid-const)([array.new\_fixed](#syntax-instr-array) x n) [const](#valid-const)​3ex\]C[⊢](#valid-const)([any.convert\_extern](#syntax-instr-extern)) [const](#valid-const)​C[⊢](#valid-const)([extern.convert\_any](#syntax-instr-extern)) [const](#valid-const)​3ex\]C[⊢](#valid-const)([global.get](#syntax-instr-variable) x) [const](#valid-const)C.[globals](#context)\[x\]\=t​​​

Note

Currently, constant expressions occurring in [globals](#syntax-global) are further constrained in that contained global.get instructions are only allowed to refer to _imported_ or _previously defined_ globals. Constant expressions occurring in [tables](#syntax-table) may only have global.get instructions that refer to _imported_ globals. This is enforced in the [validation rule for modules](#valid-module) by constraining the context C accordingly.

The definition of constant expression may be extended in future versions of WebAssembly.

### 3.5. Modules[](#modules③)

[Modules](#syntax-module) are valid when all the components they contain are valid. To verify this, most definitions are themselves classified with a suitable type.

#### 3.5.1. Types[](#types⑨)

The sequence of [types](#syntax-type) defined in a module is validated incrementally, yielding a sequence of [defined types](#syntax-deftype) representing them individually.

The [type definition](#syntax-type) ([type](#syntax-type) [rectype](#syntax-rectype)) is [valid](#valid-type) with the defined type sequence dt∗ if:

> *   The length of C.[types](#context) is equal to x.
>     
> *   The defined type sequence dt∗ is of the form [roll](#aux-roll-deftype)x∗​([rectype](#syntax-rectype)).
>     
> *   Let C′ be the same context as C, but with the defined type sequence dt∗ appended to the field [types](#context).
>     
> *   Under the context C′, the [recursive type](#syntax-rectype) [rectype](#syntax-rectype) is [valid](#valid-rectype) for the type index x.
>     

C[⊢](#valid-type)[type](#syntax-type) [rectype](#syntax-rectype):dt∗x\=∣C.[types](#context)∣dt∗\=[roll](#aux-roll-deftype)x∗​([rectype](#syntax-rectype))C⊕{[types](#context) dt∗}[⊢](#valid-rectype)[rectype](#syntax-rectype):[ok](#valid-subtype)(x)​​

The type definition sequence [type](#syntax-rectype)∗ is [valid](#valid-type) with the defined type sequence [deftype](#syntax-deftype)∗ if:

> *   Either:
>     
>     > *   The type definition sequence [type](#syntax-rectype)∗ is empty.
>     >     
>     > *   The defined type sequence [deftype](#syntax-deftype)∗ is empty.
>     >     
>     
> *   Or:
>     
>     > *   The type definition sequence [type](#syntax-rectype)∗ is of the form [type](#syntax-rectype)1​ [type](#syntax-rectype)′∗.
>     >     
>     > *   The defined type sequence [deftype](#syntax-deftype)∗ is of the form dt1∗​ dt∗.
>     >     
>     > *   The [type definition](#syntax-type) [type](#syntax-rectype)1​ is [valid](#valid-type) with the defined type sequence dt1∗​.
>     >     
>     > *   Let C′ be the same context as C, but with the defined type sequence dt1∗​ appended to the field [types](#context).
>     >     
>     > *   Under the context C′, the type definition sequence [type](#syntax-rectype)′∗ is [valid](#valid-type) with the defined type sequence dt∗.
>     >     
>     

C[⊢](#valid-types)ϵ:ϵ​C[⊢](#valid-types)[type](#syntax-rectype)1​ [type](#syntax-rectype)∗:dt1∗​ dt∗C[⊢](#valid-type)[type](#syntax-rectype)1​:dt1∗​C⊕{[types](#context) dt1∗​}[⊢](#valid-types)[type](#syntax-rectype)∗:dt∗​​

#### 3.5.2. Tags[](#tags③)

Tags [tag](#syntax-tag) are classified by their [tag types](#syntax-tagtype), which are [defined types](#syntax-deftype) expanding to [function types](#syntax-functype).

The [tag](#syntax-tag) ([tag](#syntax-tag) [tagtype](#syntax-tagtype)) is [valid](#valid-tag) with the [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype)′ if:

> *   The [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype) is [valid](#valid-tagtype).
>     
> *   The [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype)′ is [clos](#aux-clostype)C​([tagtype](#syntax-tagtype)).
>     

C[⊢](#valid-tag)[tag](#syntax-tag) [tagtype](#syntax-tagtype):[clos](#aux-clostype)C​([tagtype](#syntax-tagtype))C[⊢](#valid-tagtype)[tagtype](#syntax-tagtype):[ok](#valid-tagtype)​​

#### 3.5.3. Globals[](#globals③)

Globals [global](#syntax-global) are classified by [global types](#syntax-globaltype).

The [global](#syntax-global) ([global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)) is [valid](#valid-global) with the [global type](#syntax-globaltype) [globaltype](#syntax-globaltype) if:

> *   The [global type](#syntax-globaltype) [globaltype](#syntax-globaltype) is [valid](#valid-globaltype).
>     
> *   The [global type](#syntax-globaltype) [globaltype](#syntax-globaltype) is of the form ([mut](#syntax-mut)? t).
>     
> *   The [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [value type](#syntax-valtype) t.
>     
> *   [expr](#syntax-expr) is constant.
>     

C[⊢](#valid-global)[global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr):[globaltype](#syntax-globaltype)C[⊢](#valid-globaltype)[globaltype](#syntax-globaltype):[ok](#valid-globaltype)[globaltype](#syntax-globaltype)\=[mut](#syntax-mut)? tC[⊢](#valid-const)[expr](#syntax-expr):t [const](#valid-const)​​

Sequences of globals are handled incrementally, such that each definition has access to previous definitions.

The global sequence [global](#syntax-global)∗ is [valid](#valid-global) with the global type sequence [globaltype](#syntax-globaltype)∗ if:

> *   Either:
>     
>     > *   The global sequence [global](#syntax-global)∗ is empty.
>     >     
>     > *   The global type sequence [globaltype](#syntax-globaltype)∗ is empty.
>     >     
>     
> *   Or:
>     
>     > *   The global sequence [global](#syntax-global)∗ is of the form [global](#syntax-global)1​ [global](#syntax-global)′∗.
>     >     
>     > *   The global type sequence [globaltype](#syntax-globaltype)∗ is of the form gt1​ gt∗.
>     >     
>     > *   The [global](#syntax-global) [global](#syntax-global)1​ is [valid](#valid-global) with the [global type](#syntax-globaltype) gt1​.
>     >     
>     > *   Let C′ be the same context as C, but with the global type sequence gt1​ appended to the field [globals](#context).
>     >     
>     > *   Under the context C′, the global sequence [global](#syntax-global)′∗ is [valid](#valid-global) with the global type sequence gt∗.
>     >     
>     

C[⊢](#valid-globalseq)ϵ:ϵ​C[⊢](#valid-globalseq)[global](#syntax-global)1​ [global](#syntax-global)∗:gt1​ gt∗C[⊢](#valid-global)[global](#syntax-global)1​:gt1​C⊕{[globals](#context) gt1​}[⊢](#valid-globalseq)[global](#syntax-global)∗:gt∗​​

#### 3.5.4. Memories[](#memories③)

Memories [mem](#syntax-mem) are classified by [memory types](#syntax-memtype).

The [memory](#syntax-mem) ([memory](#syntax-mem) [memtype](#syntax-memtype)) is [valid](#valid-mem) with the [memory type](#syntax-memtype) [memtype](#syntax-memtype) if:

> *   The [memory type](#syntax-memtype) [memtype](#syntax-memtype) is [valid](#valid-memtype).
>     

C[⊢](#valid-mem)[memory](#syntax-mem) [memtype](#syntax-memtype):[memtype](#syntax-memtype)C[⊢](#valid-memtype)[memtype](#syntax-memtype):[ok](#valid-memtype)​​

#### 3.5.5. Tables[](#tables③)

Tables [table](#syntax-table) are classified by [table types](#syntax-tabletype).

The [table](#syntax-table) ([table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)) is [valid](#valid-table) with the [table type](#syntax-tabletype) [tabletype](#syntax-tabletype) if:

> *   The [table type](#syntax-tabletype) [tabletype](#syntax-tabletype) is [valid](#valid-tabletype).
>     
> *   The [table type](#syntax-tabletype) [tabletype](#syntax-tabletype) is of the form (at lim rt).
>     
> *   The [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [value type](#syntax-valtype) rt.
>     
> *   [expr](#syntax-expr) is constant.
>     

C[⊢](#valid-table)[table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr):[tabletype](#syntax-tabletype)C[⊢](#valid-tabletype)[tabletype](#syntax-tabletype):[ok](#valid-tabletype)[tabletype](#syntax-tabletype)\=at lim rtC[⊢](#valid-const)[expr](#syntax-expr):rt [const](#valid-const)​​

#### 3.5.6. Functions[](#functions③)

Functions [func](#syntax-func) are classified by [defined types](#syntax-deftype) that [expand](#aux-expand-deftype) to [function types](#syntax-functype) of the form [func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​.

The [function](#syntax-func) ([func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr)) is [valid](#valid-func) with the [type](#syntax-deftype) C.[types](#context)\[x\] if:

> *   The [type](#syntax-deftype) C.[types](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[types](#context)\[x\] is ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​).
>     
> *   For all [local](#syntax-local) in [local](#syntax-local)∗:
>     
>     > *   The [local](#syntax-local) [local](#syntax-local) is [valid](#valid-local) with the [local type](#syntax-localtype) lt.
>     >     
>     
> *   lt∗ is the concatenation of all such lt.
>     
> *   Under the context C with the field [locals](#context) appended by ([set](#syntax-init) t1​)∗ lt∗ and the field [labels](#context) appended by t2∗​ and the field [return](#context) appended by t2∗​, the [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [result type](#syntax-resulttype) t2∗​.
>     

C[⊢](#valid-func)[func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr):C.[types](#context)\[x\]C.[types](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​(C[⊢](#valid-local)[local](#syntax-local):lt)∗C⊕{[locals](#context) ([set](#syntax-init) t1​)∗ lt∗,[labels](#context) (t2∗​),[return](#context) (t2∗​)}[⊢](#valid-expr)[expr](#syntax-expr):t2∗​​​​​

#### 3.5.7. Locals[](#locals①)

Locals [local](#syntax-local) are classified with [local types](#syntax-localtype).

The [local](#syntax-local) ([local](#syntax-local) t) is [valid](#valid-local) with the [local type](#syntax-localtype) ([init](#syntax-init) t) if:

> *   Either:
>     
>     > *   The [initialization status](#syntax-init) [init](#syntax-init) is of the form [set](#syntax-init).
>     >     
>     > *   A [default value](#aux-default) for t is defined.
>     >     
>     
> *   Or:
>     
>     > *   The [initialization status](#syntax-init) [init](#syntax-init) is of the form [unset](#syntax-init).
>     >     
>     > *   A [default value](#aux-default) for t is not defined.
>     >     
>     

C[⊢](#valid-local)[local](#syntax-local) t:[set](#syntax-init) t[default](#aux-default)t​\=ϵ​C[⊢](#valid-local)[local](#syntax-local) t:[unset](#syntax-init) t[default](#aux-default)t​\=ϵ​​

Note

For cases where both rules are applicable, the former yields the more permissable type.

#### 3.5.8. Data Segments[](#data-segments③)

Data segments [data](#syntax-data) are classified by the singleton [data type](#syntax-datatype), which merely expresses well-formedness.

The [memory segment](#syntax-data) ([data](#syntax-data) b∗ [datamode](#syntax-datamode)) is [valid](#valid-data) if:

> *   The [data mode](#syntax-datamode) [datamode](#syntax-datamode) is [valid](#valid-datamode).
>     

C[⊢](#valid-data)[data](#syntax-data) b∗ [datamode](#syntax-datamode):[ok](#valid-data)C[⊢](#valid-datamode)[datamode](#syntax-datamode):[ok](#valid-data)​​

The [data mode](#syntax-datamode) [datamode](#syntax-datamode) is [valid](#valid-datamode) if:

> *   Either:
>     
>     > *   The [data mode](#syntax-datamode) [datamode](#syntax-datamode) is of the form [passive](#syntax-datamode).
>     >     
>     
> *   Or:
>     
>     > *   The [data mode](#syntax-datamode) [datamode](#syntax-datamode) is of the form ([active](#syntax-datamode) x [expr](#syntax-expr)).
>     >     
>     > *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     >     
>     > *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form (at lim [page](#syntax-memtype)).
>     >     
>     > *   The [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [value type](#syntax-valtype) at.
>     >     
>     > *   [expr](#syntax-expr) is constant.
>     >     
>     

C[⊢](#valid-datamode)[passive](#syntax-datamode):[ok](#valid-data)​C[⊢](#valid-datamode)[active](#syntax-datamode) x [expr](#syntax-expr):[ok](#valid-data)C.[mems](#context)\[x\]\=at lim [page](#syntax-memtype)C[⊢](#valid-const)[expr](#syntax-expr):at [const](#valid-const)​​

#### 3.5.9. Element Segments[](#element-segments③)

Element segments [elem](#syntax-elem) are classified by their [element type](#syntax-elemtype).

The [table segment](#syntax-elem) ([elem](#syntax-elem) [elemtype](#syntax-elemtype) [expr](#syntax-expr)∗ [elemmode](#syntax-elemmode)) is [valid](#valid-elem) with the [element type](#syntax-elemtype) [elemtype](#syntax-elemtype) if:

> *   The [reference type](#syntax-reftype) [elemtype](#syntax-elemtype) is [valid](#valid-reftype).
>     
> *   For all [expr](#syntax-expr) in [expr](#syntax-expr)∗:
>     
>     > *   The [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [value type](#syntax-valtype) [elemtype](#syntax-elemtype).
>     >     
>     > *   [expr](#syntax-expr) is constant.
>     >     
>     
> *   The [element mode](#syntax-elemmode) [elemmode](#syntax-elemmode) is [valid](#valid-elemmode) with the [element type](#syntax-elemtype) [elemtype](#syntax-elemtype).
>     

C[⊢](#valid-elem)[elem](#syntax-elem) [elemtype](#syntax-elemtype) [expr](#syntax-expr)∗ [elemmode](#syntax-elemmode):[elemtype](#syntax-elemtype)C[⊢](#valid-reftype)[elemtype](#syntax-elemtype):[ok](#valid-reftype)(C[⊢](#valid-const)[expr](#syntax-expr):[elemtype](#syntax-elemtype) [const](#valid-const))∗C[⊢](#valid-elemmode)[elemmode](#syntax-elemmode):[elemtype](#syntax-elemtype)​​

The [element mode](#syntax-elemmode) [elemmode](#syntax-elemmode) is [valid](#valid-elemmode) with the [element type](#syntax-elemtype) rt if:

> *   Either:
>     
>     > *   The [element mode](#syntax-elemmode) [elemmode](#syntax-elemmode) is of the form [passive](#syntax-elemmode).
>     >     
>     
> *   Or:
>     
>     > *   The [element mode](#syntax-elemmode) [elemmode](#syntax-elemmode) is of the form [declare](#syntax-elemmode).
>     >     
>     
> *   Or:
>     
>     > *   The [element mode](#syntax-elemmode) [elemmode](#syntax-elemmode) is of the form ([active](#syntax-elemmode) x [expr](#syntax-expr)).
>     >     
>     > *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     >     
>     > *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form (at lim rt′).
>     >     
>     > *   The [reference type](#syntax-reftype) rt [matches](#match-reftype) the [reference type](#syntax-reftype) rt′.
>     >     
>     > *   The [expression](#syntax-expr) [expr](#syntax-expr) is [valid](#valid-expr) with the [value type](#syntax-valtype) at.
>     >     
>     > *   [expr](#syntax-expr) is constant.
>     >     
>     

C[⊢](#valid-elemmode)[passive](#syntax-elemmode):rt​C[⊢](#valid-elemmode)[declare](#syntax-elemmode):rt​3ex\]C[⊢](#valid-elemmode)[active](#syntax-elemmode) x [expr](#syntax-expr):rtC.[tables](#context)\[x\]\=at lim rt′C[⊢](#match-reftype)rt[≤](#match-reftype)rt′C[⊢](#valid-const)[expr](#syntax-expr):at [const](#valid-const)​​​

#### 3.5.10. Start Function[](#start-function③)

The [start function](#syntax-start) ([start](#syntax-start) x) is [valid](#valid-start) if:

> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] exists.
>     
> *   The [expansion](#aux-expand-deftype) of C.[funcs](#context)\[x\] is ([func](#syntax-comptype) [→](#syntax-comptype)).
>     

C[⊢](#valid-start)[start](#syntax-start) x:[ok](#valid-start)C.[funcs](#context)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) ϵ[→](#syntax-comptype)ϵ​​

#### 3.5.11. Imports[](#imports③)

Imports [import](#syntax-import) are classified by [external types](#syntax-externtype).

The [import](#syntax-import) ([import](#syntax-import) [name](#syntax-name)1​ [name](#syntax-name)2​ xt) is [valid](#valid-import) with the [external type](#syntax-externtype) [externtype](#syntax-externtype) if:

> *   The [external type](#syntax-externtype) xt is [valid](#valid-externtype).
>     
> *   The [external type](#syntax-externtype) [externtype](#syntax-externtype) is [clos](#aux-clostype)C​(xt).
>     

C[⊢](#valid-import)[import](#syntax-import) [name](#syntax-name)1​ [name](#syntax-name)2​ xt:[clos](#aux-clostype)C​(xt)C[⊢](#valid-externtype)xt:[ok](#valid-externtype)​​

#### 3.5.12. Exports[](#exports③)

Exports [export](#syntax-export) are classified by their [external type](#syntax-externtype).

The [export](#syntax-export) ([export](#syntax-export) [name](#syntax-name) [externidx](#syntax-externidx)) is [valid](#valid-export) with the [name](#syntax-name) [name](#syntax-name) and the [external type](#syntax-externtype) xt if:

> *   The [external index](#syntax-externidx) [externidx](#syntax-externidx) is [valid](#valid-externidx) with the [external type](#syntax-externtype) xt.
>     

C[⊢](#valid-export)[export](#syntax-export) [name](#syntax-name) [externidx](#syntax-externidx):[name](#syntax-name) xtC[⊢](#valid-externidx)[externidx](#syntax-externidx):xt​​

##### 3.5.12.1. [tag](#syntax-externidx) x[](#-hrefsyntax-externidxmathsftagx)

The [external index](#syntax-externidx) ([tag](#syntax-externidx) x) is [valid](#valid-externidx) with the [external type](#syntax-externtype) ([tag](#syntax-externtype) jt) if:

> *   The [tag](#syntax-tagtype) C.[tags](#context)\[x\] exists.
>     
> *   The [tag](#syntax-tagtype) C.[tags](#context)\[x\] is of the form jt.
>     

C[⊢](#valid-externidx)[tag](#syntax-externidx) x:[tag](#syntax-externtype) jtC.[tags](#context)\[x\]\=jt​​

##### 3.5.12.2. [global](#syntax-externidx) x[](#-hrefsyntax-externidxmathsfglobalx)

The [external index](#syntax-externidx) ([global](#syntax-externidx) x) is [valid](#valid-externidx) with the [external type](#syntax-externtype) ([global](#syntax-externtype) gt) if:

> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] exists.
>     
> *   The [global](#syntax-globaltype) C.[globals](#context)\[x\] is of the form gt.
>     

C[⊢](#valid-externidx)[global](#syntax-externidx) x:[global](#syntax-externtype) gtC.[globals](#context)\[x\]\=gt​​

##### 3.5.12.3. [memory](#syntax-externidx) x[](#-hrefsyntax-externidxmathsfmemoryx)

The [external index](#syntax-externidx) ([memory](#syntax-externidx) x) is [valid](#valid-externidx) with the [external type](#syntax-externtype) ([mem](#syntax-externtype) mt) if:

> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] exists.
>     
> *   The [memory](#syntax-memtype) C.[mems](#context)\[x\] is of the form mt.
>     

C[⊢](#valid-externidx)[memory](#syntax-externidx) x:[mem](#syntax-externtype) mtC.[mems](#context)\[x\]\=mt​​

##### 3.5.12.4. [table](#syntax-externidx) x[](#-hrefsyntax-externidxmathsftablex)

The [external index](#syntax-externidx) ([table](#syntax-externidx) x) is [valid](#valid-externidx) with the [external type](#syntax-externtype) ([table](#syntax-externtype) tt) if:

> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] exists.
>     
> *   The [table](#syntax-tabletype) C.[tables](#context)\[x\] is of the form tt.
>     

C[⊢](#valid-externidx)[table](#syntax-externidx) x:[table](#syntax-externtype) ttC.[tables](#context)\[x\]\=tt​​

##### 3.5.12.5. [func](#syntax-externidx) x[](#-hrefsyntax-externidxmathsffuncx)

The [external index](#syntax-externidx) ([func](#syntax-externidx) x) is [valid](#valid-externidx) with the [external type](#syntax-externtype) ([func](#syntax-externtype) dt) if:

> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] exists.
>     
> *   The [function](#syntax-deftype) C.[funcs](#context)\[x\] is of the form dt.
>     

C[⊢](#valid-externidx)[func](#syntax-externidx) x:[func](#syntax-externtype) dtC.[funcs](#context)\[x\]\=dt​​

#### 3.5.13. Modules[](#modules④)

Modules are classified by their mapping from the [external types](#syntax-externtype) of their [imports](#syntax-import) to those of their [exports](#syntax-export).

A module is entirely _closed_, that is, its components can only refer to definitions that appear in the module itself. Consequently, no initial [context](#context) is required. Instead, the [context](#context) C for validation of the module’s content is constructed from the definitions in the module.

The [module](#syntax-module) ([module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗) is [valid](#valid-module) with the [module type](#syntax-moduletype) [moduletype](#syntax-moduletype) if:

> *   Under the context {[return](#context) ϵ}, the type definition sequence [type](#syntax-rectype)∗ is [valid](#valid-type) with the defined type sequence dt′∗.
>     
> *   For all [import](#syntax-import) in [import](#syntax-import)∗:
>     
>     > *   Under the context {[types](#context) dt′∗,[return](#context) ϵ}, the [import](#syntax-import) [import](#syntax-import) is [valid](#valid-import) with the [external type](#syntax-externtype) xti​.
>     >     
>     
> *   xti∗​ is the concatenation of all such xti​.
>     
> *   For all [tag](#syntax-tag) in [tag](#syntax-tag)∗:
>     
>     > *   Under the context C′, the [tag](#syntax-tag) [tag](#syntax-tag) is [valid](#valid-tag) with the [tag type](#syntax-tagtype) jt.
>     >     
>     
> *   jt∗ is the concatenation of all such jt.
>     
> *   Under the context C′, the global sequence [global](#syntax-global)∗ is [valid](#valid-global) with the global type sequence gt∗.
>     
> *   For all [mem](#syntax-mem) in [mem](#syntax-mem)∗:
>     
>     > *   Under the context C′, the [memory](#syntax-mem) [mem](#syntax-mem) is [valid](#valid-mem) with the [memory type](#syntax-memtype) mt.
>     >     
>     
> *   mt∗ is the concatenation of all such mt.
>     
> *   For all [table](#syntax-table) in [table](#syntax-table)∗:
>     
>     > *   Under the context C′, the [table](#syntax-table) [table](#syntax-table) is [valid](#valid-table) with the [table type](#syntax-tabletype) tt.
>     >     
>     
> *   tt∗ is the concatenation of all such tt.
>     
> *   For all [func](#syntax-func) in [func](#syntax-func)∗:
>     
>     > *   The [function](#syntax-func) [func](#syntax-func) is [valid](#valid-func) with the [defined type](#syntax-deftype) dt.
>     >     
>     
> *   dt∗ is the concatenation of all such dt.
>     
> *   For all [data](#syntax-data) in [data](#syntax-data)∗:
>     
>     > *   The [memory segment](#syntax-data) [data](#syntax-data) is [valid](#valid-data).
>     >     
>     
> *   ok∗ is the concatenation of all such ok.
>     
> *   For all [elem](#syntax-elem) in [elem](#syntax-elem)∗:
>     
>     > *   The [table segment](#syntax-elem) [elem](#syntax-elem) is [valid](#valid-elem) with the [element type](#syntax-elemtype) rt.
>     >     
>     
> *   rt∗ is the concatenation of all such rt.
>     
> *   If [start](#syntax-start) is defined, then:
>     
>     > *   The [start function](#syntax-start) [start](#syntax-start) is [valid](#valid-start).
>     >     
>     
> *   For all [export](#syntax-export) in [export](#syntax-export)∗:
>     
>     > *   The [export](#syntax-export) [export](#syntax-export) is [valid](#valid-export) with the [name](#syntax-name) nm and the [external type](#syntax-externtype) xte​.
>     >     
>     
> *   nm∗ is the concatenation of all such nm.
>     
> *   xte∗​ is the concatenation of all such xte​.
>     
> *   nm∗ disjoint is true.
>     
> *   The [context](#context) C is of the form C′ with the field [tags](#context) appended by jti∗​ jt∗ and the field [globals](#context) appended by gt∗ and the field [mems](#context) appended by mti∗​ mt∗ and the field [tables](#context) appended by tti∗​ tt∗ and the field [datas](#context) appended by ok∗ and the field [elems](#context) appended by rt∗.
>     
> *   The [context](#context) C′ is of the form {[types](#context) dt′∗,[globals](#context) gti∗​,[funcs](#context) dti∗​ dt∗,[return](#context) ϵ,[refs](#context) x∗}.
>     
> *   The function index sequence x∗ is of the form [funcidx](#syntax-funcidx)([global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [elem](#syntax-elem)∗).
>     
> *   The tag type sequence jti∗​ is of the form [tags](#syntax-externtype)(xti∗​).
>     
> *   The global type sequence gti∗​ is of the form [globals](#syntax-externtype)(xti∗​).
>     
> *   The memory type sequence mti∗​ is of the form [mems](#syntax-externtype)(xti∗​).
>     
> *   The table type sequence tti∗​ is of the form [tables](#syntax-externtype)(xti∗​).
>     
> *   The defined type sequence dti∗​ is of the form [funcs](#syntax-externtype)(xti∗​).
>     
> *   The [module type](#syntax-moduletype) [moduletype](#syntax-moduletype) is [clos](#aux-clostype)C​(xti∗​ [→](#syntax-moduletype) xte∗​).
>     

[⊢](#valid-module)[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗:[clos](#aux-clostype)C​(xti∗​[→](#syntax-moduletype)xte∗​){}[⊢](#valid-types)[type](#syntax-rectype)∗:dt′∗({[types](#context) dt′∗}[⊢](#valid-import)[import](#syntax-import):xti​)∗(C′[⊢](#valid-tag)[tag](#syntax-tag):jt)∗C′[⊢](#valid-globalseq)[global](#syntax-global)∗:gt∗(C′[⊢](#valid-mem)[mem](#syntax-mem):mt)∗(C′[⊢](#valid-table)[table](#syntax-table):tt)∗(C[⊢](#valid-func)[func](#syntax-func):dt)∗(C[⊢](#valid-data)[data](#syntax-data):ok)∗(C[⊢](#valid-elem)[elem](#syntax-elem):rt)∗(C[⊢](#valid-start)[start](#syntax-start):[ok](#valid-start))?(C[⊢](#valid-export)[export](#syntax-export):nm xte​)∗nm∗ disjointC\=C′⊕{[tags](#context) jti∗​ jt∗,[globals](#context) gt∗,[mems](#context) mti∗​ mt∗,[tables](#context) tti∗​ tt∗,[datas](#context) ok∗,[elems](#context) rt∗}C′\={[types](#context) dt′∗,[globals](#context) gti∗​,[funcs](#context) dti∗​ dt∗,[refs](#context) x∗}x∗\=[funcidx](#syntax-funcidx)([global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [elem](#syntax-elem)∗)jti∗​\=[tags](#syntax-externtype)(xti∗​)gti∗​\=[globals](#syntax-externtype)(xti∗​)mti∗​\=[mems](#syntax-externtype)(xti∗​)tti∗​\=[tables](#syntax-externtype)(xti∗​)dti∗​\=[funcs](#syntax-externtype)(xti∗​)​​​​

Note

All functions in a module are mutually recursive. Consequently, the definition of the [context](#context) C in this rule is recursive: it depends on the outcome of validation of the function, table, memory, and global definitions contained in the module, which itself depends on C. However, this recursion is just a specification device. All types needed to construct C can easily be determined from a simple pre-pass over the module that does not perform any actual validation.

Globals, however, are not recursive but evaluated sequentially, such that each [constant expressions](#valid-const) only has access to imported or previously defined globals.

4\. Execution[](#execution②)
----------------------------

### 4.1. Conventions[](#conventions②③)

WebAssembly code is _executed_ when [instantiating](#exec-instantiation) a module or [invoking](#exec-invocation) an [exported](#syntax-export) function on the resulting module [instance](#syntax-moduleinst).

Execution behavior is defined in terms of an _abstract machine_ that models the _program state_. It includes a _stack_, which records operand values and control constructs, and an abstract _store_ containing global state.

For each instruction, there is a rule that specifies the effect of its execution on the program state. Furthermore, there are rules describing the instantiation of a module. As with [validation](#validation), all rules are given in two _equivalent_ forms:

1.  In _prose_, describing the execution in intuitive form.
    
2.  In _formal notation_, describing the rule in mathematical form. [\[1\]](#cite-pldi2017)
    

Note

As with validation, the prose and formal rules are equivalent, so that understanding of the formal notation is _not_ required to read this specification. The formalism offers a more concise description in notation that is used widely in programming languages semantics and is readily amenable to mathematical proof.

#### 4.1.1. Prose Notation[](#prose-notation③)

Execution is specified by stylised, step-wise rules for each [instruction](#syntax-instr) of the [abstract syntax](#syntax). The following conventions are adopted in stating these rules.

*   The execution rules implicitly assume a given [store](#store) s.
    
*   The execution rules also assume the presence of an implicit [stack](#stack) that is modified by _pushing_ or _popping_ [values](#syntax-value), [labels](#syntax-label), and [frames](#syntax-frame).
    
*   Certain rules require the stack to contain at least one frame. The most recent frame is referred to as the _current_ frame.
    
*   Both the store and the current frame are mutated by _replacing_ some of their components. Such replacement is assumed to apply globally.
    
*   The execution of an instruction may _trap_, in which case the entire computation is aborted and no further modifications to the store are performed by it. (Other computations can still be initiated afterwards.)
    
*   The execution of an instruction may also end in a _jump_ to a designated target, which defines the next instruction to execute.
    
*   Execution can _enter_ and _exit_ [instruction sequences](#syntax-instrs) that form [blocks](#syntax-instr-control).
    
*   [Instruction sequences](#syntax-instrs) are implicitly executed in order, unless a trap, jump, or exception occurs.
    
*   In various places the rules contain _assertions_ expressing crucial invariants about the program state.
    

#### 4.1.2. Formal Notation[](#formal-notation③)

Note

This section gives a brief explanation of the notation for specifying execution formally. For the interested reader, a more thorough introduction can be found in respective text books. [\[2\]](#cite-tapl)

The formal execution rules use a standard approach for specifying operational semantics, rendering them into _reduction rules_. Every rule has the following general form:

configuration↪configuration

A _configuration_ is a syntactic description of a program state. Each rule specifies one _step_ of execution. As long as there is at most one reduction rule applicable to a given configuration, reduction – and thereby execution – is _deterministic_. WebAssembly has only very few exceptions to this, which are noted explicitly in this specification.

For WebAssembly, a configuration typically is a tuple (s;f;[instr](#syntax-instr)∗) consisting of the current [store](#store) s, the [call frame](#frame) f of the current function, and the sequence of [instructions](#syntax-instr) that is to be executed. (A more precise definition is given [later](#syntax-config).)

To avoid unnecessary clutter, the store s and the frame f are often combined into a _state_ z, which is a pair (s;f). Moreover, z is omitted from reduction rules that do not touch them.

There is no separate representation of the [stack](#stack). Instead, it is conveniently represented as part of the configuration’s instruction sequence. In particular, [values](#syntax-val) are defined to coincide with const and ref instructions, and a sequence of such instructions can be interpreted as an operand “stack” that grows to the right.

Note

For example, the [reduction rule](#exec-binop) for the [i32](#syntax-numtype).[add](#syntax-instr-numeric) instruction can be given as follows:

([i32](#syntax-numtype).[const](#syntax-instr-numeric) n1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n2​) ([i32](#syntax-numtype).[add](#syntax-instr-numeric))[↪](#exec-notation)([i32](#syntax-numtype).[const](#syntax-instr-numeric) (n1​+n2​)mod232)

Per this rule, two const instructions and the add instruction itself are removed from the instruction stream and replaced with one new const instruction. This can be interpreted as popping two values off the stack and pushing the result.

When no result is produced, an instruction reduces to the empty sequence:

[nop](#syntax-instr-control)[↪](#exec-notation)ϵ

[Labels](#label) and [frames](#frame) are similarly [defined](#syntax-instr-admin) to be part of an instruction sequence.

The order of reduction is determined by the details of the reduction rules. Usually, the left-most instruction that is not a constant will be the subject of the next reduction _step_.

Reduction _terminates_ when no more reduction rules are applicable. [Soundness](#soundness) of the WebAssembly [type system](#type-system) guarantees that this is only the case when the original instruction sequence has either been reduced to a sequence of [value](#syntax-val) instructions, which can be interpreted as the [values](#syntax-val) of the resulting operand stack, or if an [exception](#exception) or [trap](#trap) occurred.

Note

For example, the following instruction sequence,

([f64](#syntax-numtype).[const](#syntax-instr-numeric) q1​) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) q2​) ([f64](#syntax-numtype).[neg](#syntax-instr-numeric)) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) q3​) ([f64](#syntax-numtype).[add](#syntax-instr-numeric)) ([f64](#syntax-numtype).[mul](#syntax-instr-numeric))

terminates after three steps:

​​↪↪↪​([f64](#syntax-numtype).[const](#syntax-instr-numeric) q1​) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) q4​) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) q3​) ([f64](#syntax-numtype).[add](#syntax-instr-numeric)) ([f64](#syntax-numtype).[mul](#syntax-instr-numeric))([f64](#syntax-numtype).[const](#syntax-instr-numeric) q1​) ([f64](#syntax-numtype).[const](#syntax-instr-numeric) q5​) ([f64](#syntax-numtype).[mul](#syntax-instr-numeric))([f64](#syntax-numtype).[const](#syntax-instr-numeric) q6​)​​

where q4​\=−q2​ and q5​\=−q2​+q3​ and q6​\=q1​⋅(−q2​+q3​).

\[[1](#id1)\]

The semantics is derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. [Bringing the Web up to Speed with WebAssembly](https://dl.acm.org/citation.cfm?doid=3062341.3062363). Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.

\[[2](#id2)\]

For example: Benjamin Pierce. [Types and Programming Languages](https://www.cis.upenn.edu/~bcpierce/tapl/). The MIT Press 2002

### 4.2. Runtime Structure[](#runtime-structure①)

[Store](#store), [stack](#stack), and other _runtime structure_ forming the WebAssembly abstract machine, such as [values](#syntax-val) or [module instances](#syntax-moduleinst), are made precise in terms of additional auxiliary syntax.

#### 4.2.1. Values[](#values③)

WebAssembly computations manipulate _values_ of either the four basic [number types](#syntax-numtype), i.e., [integers](#syntax-int) and [floating-point data](#syntax-float) of 32 or 64 bit width each, or [vectors](#syntax-vecnum) of 128 bit width, or of [reference type](#syntax-reftype).

In most places of the semantics, values of different types can occur. In order to avoid ambiguities, values are therefore represented with an abstract syntax that makes their type explicit. It is convenient to reuse the same notation as for the const [instructions](#syntax-const) and ref.null producing them.

References other than null are represented with additional [administrative instructions](#syntax-instr-admin). They either are _scalar references_, containing a 31-bit [integer](#syntax-int), _structure references_, pointing to a specific [structure address](#syntax-structaddr), _array references_, pointing to a specific [array address](#syntax-arrayaddr), _function references_, pointing to a specific [function address](#syntax-funcaddr), _exception references_, pointing to a specific [exception address](#syntax-exnaddr), or _host references_ pointing to an uninterpreted form of [host address](#syntax-hostaddr) defined by the [embedder](#embedder). Any of the aformentioned references can furthermore be wrapped up as an _external reference_.

​[val](#syntax-val)​::=∣∣∣∣∣∣∣​[num](#syntax-num) ∣ [vec](#syntax-vec) ∣ [ref](#syntax-ref)0.8ex\][ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype)0.8ex\][ref.struct](#syntax-ref) [structaddr](#syntax-structaddr)[ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr)[ref.func](#syntax-ref) [funcaddr](#syntax-funcaddr)[ref.exn](#syntax-ref) [exnaddr](#syntax-exnaddr)[ref.host](#syntax-ref) [hostaddr](#syntax-hostaddr)[ref.extern](#syntax-ref) [addrref](#syntax-addrref)​[num](#syntax-num)[addrref](#syntax-addrref)::=::=[numtype](#syntax-numtype).[const](#syntax-instr-numeric) [num](#syntax-num)[numtype](#syntax-numtype)​0.8ex\][ref.i31](#syntax-ref) [u31](#syntax-int)[vec](#syntax-vec)::=[vectype](#syntax-vectype).[const](#syntax-instr-vec) [vec](#syntax-vec)[vectype](#syntax-vectype)​0.8ex\][ref](#syntax-ref)::=[addrref](#syntax-addrref)​

Note

Future versions of WebAssembly may add additional forms of values.

[Value types](#syntax-valtype) can have an associated _default value_; it is the respective value 0 for [number types](#syntax-numtype), 0 for [vector types](#syntax-vectype), and null for nullable [reference types](#syntax-reftype). For other references, no default value is defined, [default](#aux-default)t​ hence is an optional value [val](#syntax-val)?.

[default](#aux-default)[i](#syntax-numtype)[N](#syntax-numtype)​[default](#aux-default)[f](#syntax-numtype)[N](#syntax-numtype)​[default](#aux-default)[v](#syntax-numtype)[N](#syntax-numtype)​[default](#aux-default)[ref](#syntax-reftype) [null](#syntax-reftype) ht​[default](#aux-default)[ref](#syntax-reftype) ht​​\=\=\=\=\=​([i](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-numeric) 0)([f](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-numeric) +0)([v](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-vec) 0)([ref.null](#syntax-instr-ref) ht)ϵ​​

##### 4.2.1.1. Convention[](#convention⑥)

*   The meta variable r ranges over reference values where clear from context.
    

#### 4.2.2. Results[](#results①)

A _result_ is the outcome of a computation. It is either a sequence of [values](#syntax-val), a thrown [exception](#exec-throw-ref), or a [trap](#syntax-trap).

​[result](#syntax-result)​::=​[val](#syntax-val)∗ ∣ ([ref.exn](#syntax-ref) [exnaddr](#syntax-exnaddr)) [throw\_ref](#syntax-instr-control) ∣ [trap](#syntax-trap)​​

#### 4.2.3. Store[](#store①)

The _store_ represents all global state that can be manipulated by WebAssembly programs. It consists of the runtime representation of all _instances_ of [functions](#syntax-funcinst), [tables](#syntax-tableinst), [memories](#syntax-meminst), [globals](#syntax-globalinst), [tags](#syntax-taginst), [element segments](#syntax-eleminst), [data segments](#syntax-datainst), and [structures](#syntax-structinst), [arrays](#syntax-arrayinst) or [exceptions](#syntax-exninst) that have been [allocated](#alloc) during the life time of the abstract machine.

It is an invariant of the semantics that no element or data instance is [addressed](#syntax-addr) from anywhere else but the owning module instances.

Syntactically, the store is defined as a [record](#notation-record) listing the existing instances of each category:

​[store](#syntax-store)​::=​{[tags](#syntax-store) [taginst](#syntax-taginst)∗[globals](#syntax-store) [globalinst](#syntax-globalinst)∗[mems](#syntax-store) [meminst](#syntax-meminst)∗[tables](#syntax-store) [tableinst](#syntax-tableinst)∗[funcs](#syntax-store) [funcinst](#syntax-funcinst)∗[datas](#syntax-store) [datainst](#syntax-datainst)∗[elems](#syntax-store) [eleminst](#syntax-eleminst)∗[structs](#syntax-store) [structinst](#syntax-structinst)∗[arrays](#syntax-store) [arrayinst](#syntax-arrayinst)∗[exns](#syntax-store) [exninst](#syntax-exninst)∗}​​​

Note

In practice, implementations may apply techniques like garbage collection or reference counting to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.

##### 4.2.3.1. Convention[](#convention⑦)

*   The meta variable s ranges over stores where clear from context.
    

#### 4.2.4. Addresses[](#addresses①)

[Function instances](#syntax-funcinst), [table instances](#syntax-tableinst), [memory instances](#syntax-meminst), [global instances](#syntax-globalinst), [tag instances](#syntax-taginst), [element instances](#syntax-eleminst), [data instances](#syntax-datainst) and [structure](#syntax-structinst), [array](#syntax-arrayinst) or [exception instances](#syntax-exninst) in the [store](#syntax-store) are referenced with abstract _addresses_. These are simply indices into the respective store component. In addition, an [embedder](#embedder) may supply an uninterpreted set of _host addresses_.

​[addr](#syntax-addr)[funcaddr](#syntax-funcaddr)[tableaddr](#syntax-tableaddr)[memaddr](#syntax-memaddr)[globaladdr](#syntax-globaladdr)[tagaddr](#syntax-tagaddr)[elemaddr](#syntax-elemaddr)[dataaddr](#syntax-dataaddr)[structaddr](#syntax-structaddr)[arrayaddr](#syntax-arrayaddr)[hostaddr](#syntax-hostaddr)​::=::=::=::=::=::=::=::=::=::=::=​0 ∣ 1 ∣ 2 ∣ …[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)[addr](#syntax-addr)​​

An [embedder](#embedder) may assign identity to [exported](#syntax-export) store objects corresponding to their addresses, even where this identity is not observable from within WebAssembly code itself (such as for [function instances](#syntax-funcinst) or immutable [globals](#syntax-globalinst)).

Note

Addresses are _dynamic_, globally unique references to runtime objects, in contrast to [indices](#syntax-index), which are _static_, module-local references to their original definitions. A _memory address_ [memaddr](#syntax-memaddr) denotes the abstract address _of_ a memory _instance_ in the store, not an offset _inside_ a memory instance.

There is no specific limit on the number of allocations of store objects, hence logical addresses can be arbitrarily large natural numbers.

##### 4.2.4.1. Conventions[](#conventions②⑤)

*   The notation addr(A) denotes the set of addresses from address space [addr](#syntax-addr) occurring free in A. We sometimes reinterpret this set as the [list](#syntax-list) of its elements, without assuming any particular order.
    

#### 4.2.5. External Addresses[](#external-addresses①)

An _external address_ is the runtime [address](#syntax-addr) of an entity that can be imported or exported. It is an [address](#syntax-addr) denoting either a [function instance](#syntax-funcinst), [global instance](#syntax-globalinst), [table instance](#syntax-tableinst), [memory instance](#syntax-meminst), or [tag instance](#syntax-taginst) in the shared [store](#syntax-store).

​[externaddr](#syntax-externaddr)​::=​[tag](#syntax-externaddr) [tagaddr](#syntax-tagaddr) ∣ [global](#syntax-externaddr) [globaladdr](#syntax-globaladdr) ∣ [mem](#syntax-externaddr) [memaddr](#syntax-memaddr) ∣ [table](#syntax-externaddr) [tableaddr](#syntax-tableaddr) ∣ [func](#syntax-externaddr) [funcaddr](#syntax-funcaddr)​​

#### 4.2.6. Module Instances[](#module-instances①)

A _module instance_ is the runtime representation of a [module](#syntax-module). It is created by [instantiating](#exec-instantiation) a module, and collects runtime representations of all entities that are imported, defined, or exported by the module.

​[moduleinst](#syntax-moduleinst)​::=​{[types](#syntax-moduleinst) [deftype](#syntax-deftype)∗[tags](#syntax-moduleinst) [tagaddr](#syntax-tagaddr)∗[globals](#syntax-moduleinst) [globaladdr](#syntax-globaladdr)∗[mems](#syntax-moduleinst) [memaddr](#syntax-memaddr)∗[tables](#syntax-moduleinst) [tableaddr](#syntax-tableaddr)∗[funcs](#syntax-moduleinst) [funcaddr](#syntax-funcaddr)∗[datas](#syntax-moduleinst) [dataaddr](#syntax-dataaddr)∗[elems](#syntax-moduleinst) [elemaddr](#syntax-elemaddr)∗[exports](#syntax-moduleinst) [exportinst](#syntax-exportinst)∗}​​​

Each component references runtime instances corresponding to respective declarations from the original module – whether imported or defined – in the order of their static [indices](#syntax-index). [Function instances](#syntax-funcinst), [table instances](#syntax-tableinst), [memory instances](#syntax-meminst), [global instances](#syntax-globalinst), and [tag instances](#syntax-taginst) are denoted by their respective [addresses](#syntax-addr) in the [store](#syntax-store).

It is an invariant of the semantics that all [export instances](#syntax-exportinst) in a given module instance have different [names](#syntax-name).

Note

All record fields except exports are to be considered _private_ components of a module instance. They are not accessible to other modules, only to function instances originating from the same module.

#### 4.2.7. Function Instances[](#function-instances①)

A _function instance_ is the runtime representation of a [function](#syntax-func). It effectively is a _closure_ of the original function over the runtime [module instance](#syntax-moduleinst) of its originating [module](#syntax-module). The module instance is used to resolve references to other definitions during execution of the function.

​[funcinst](#syntax-funcinst)[code](#syntax-funcinst)​::=::=​{[type](#syntax-funcinst) [deftype](#syntax-deftype),[module](#syntax-funcinst) [moduleinst](#syntax-moduleinst),[code](#syntax-funcinst) [code](#syntax-funcinst)}​[func](#syntax-func) ∣ [hostfunc](#syntax-hostfunc)​​

A _host function_ is a function expressed outside WebAssembly but passed to a [module](#syntax-module) as an [import](#syntax-import). The definition and behavior of host functions are outside the scope of this specification. For the purpose of this specification, it is assumed that when [invoked](#exec-invoke-host), a host function behaves non-deterministically, but within certain [constraints](#exec-invoke-host) that ensure the integrity of the runtime.

Note

Function instances are immutable, and their identity is not observable by WebAssembly code. However, an [embedder](#embedder) might provide implicit or explicit means for distinguishing their [addresses](#syntax-funcaddr).

#### 4.2.8. Table Instances[](#table-instances①)

A _table instance_ is the runtime representation of a [table](#syntax-table). It records its [type](#syntax-tabletype) and holds a sequence of [reference values](#syntax-ref).

​[tableinst](#syntax-tableinst)​::=​{[type](#syntax-tableinst) [tabletype](#syntax-tabletype),[refs](#syntax-tableinst) [ref](#syntax-ref)∗}​​​

Table elements can be mutated through [table instructions](#syntax-instr-table), the execution of an active [element segment](#syntax-elem), or by external means provided by the [embedder](#embedder).

It is an invariant of the semantics that all table elements have a type [matching](#match-reftype) the element type of [tabletype](#syntax-tabletype). It also is an invariant that the length of the element sequence never exceeds the maximum size of [tabletype](#syntax-tabletype).

#### 4.2.9. Memory Instances[](#memory-instances①)

A _memory instance_ is the runtime representation of a linear [memory](#syntax-mem). It records its [type](#syntax-memtype) and holds a sequence of [bytes](#syntax-byte).

​[meminst](#syntax-meminst)​::=​{[type](#syntax-meminst) [memtype](#syntax-memtype),[bytes](#syntax-meminst) [byte](#syntax-byte)∗}​​​

The length of the sequence always is a multiple of the WebAssembly _page size_, which is defined to be the constant 65536 – abbreviated 64 Ki.

A memory’s bytes can be mutated through [memory instructions](#syntax-instr-memory), the execution of an active [data segment](#syntax-data), or by external means provided by the [embedder](#embedder).

It is an invariant of the semantics that the length of the byte sequence, divided by page size, never exceeds the maximum size of [memtype](#syntax-memtype).

#### 4.2.10. Global Instances[](#global-instances①)

A _global instance_ is the runtime representation of a [global](#syntax-global) variable. It records its [type](#syntax-globaltype) and holds an individual [value](#syntax-val).

​[globalinst](#syntax-globalinst)​::=​{[type](#syntax-globalinst) [globaltype](#syntax-globaltype),[value](#syntax-globalinst) [val](#syntax-val)}​​​

The value of mutable globals can be mutated through [variable instructions](#syntax-instr-variable) or by external means provided by the [embedder](#embedder).

It is an invariant of the semantics that the value has a type [matching](#match-valtype) the [value type](#syntax-valtype) of [globaltype](#syntax-globaltype).

#### 4.2.11. Tag Instances[](#tag-instances①)

A _tag instance_ is the runtime representation of a [tag](#syntax-tag) definition. It records the [defined type](#syntax-deftype) of the tag.

​[taginst](#syntax-taginst)​::=​{[type](#syntax-taginst) [tagtype](#syntax-tagtype)}​​​

#### 4.2.12. Element Instances[](#element-instances①)

An _element instance_ is the runtime representation of an [element segment](#syntax-elem). It holds a list of references and its [type](#syntax-reftype).

​[eleminst](#syntax-eleminst)​::=​{[type](#syntax-eleminst) [elemtype](#syntax-elemtype),[refs](#syntax-eleminst) [ref](#syntax-ref)∗}​​​

It is an invariant of the semantics that all elements of a segment have a type [matching](#match-reftype) [elemtype](#syntax-elemtype).

#### 4.2.13. Data Instances[](#data-instances①)

A _data instance_ is the runtime representation of a [data segment](#syntax-data). It holds a list of [bytes](#syntax-byte).

​[datainst](#syntax-datainst)​::=​{[bytes](#syntax-datainst) [byte](#syntax-byte)∗}​​​

#### 4.2.14. Export Instances[](#export-instances①)

An _export instance_ is the runtime representation of an [export](#syntax-export). It defines the export’s [name](#syntax-name) and the associated [external address](#syntax-externaddr).

​[exportinst](#syntax-exportinst)​::=​{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) [externaddr](#syntax-externaddr)}​​​

##### 4.2.14.1. Conventions[](#conventions②⑥)

The following auxiliary functions are assumed on sequences of external addresses. They extract addresses of a specific kind in an order-preserving fashion:

*   [funcs](#syntax-externaddr)(xa∗) extracts all [function addresses](#syntax-funcaddr) from xa∗,
    
*   [tables](#syntax-externaddr)(xa∗) extracts all [table addresses](#syntax-funcaddr) from xa∗,
    
*   [mems](#syntax-externaddr)(xa∗) extracts all [memory addresses](#syntax-funcaddr) from xa∗,
    
*   [globals](#syntax-externaddr)(xa∗) extracts all [global addresses](#syntax-funcaddr) from xa∗,
    
*   [tags](#syntax-externaddr)(xa∗) extracts all [tag addresses](#syntax-funcaddr) from xa∗.
    

#### 4.2.15. Aggregate Instances[](#aggregate-instances①)

A _structure instance_ is the runtime representation of a heap object allocated from a [structure type](#syntax-structtype). Likewise, an _array instance_ is the runtime representation of a heap object allocated from an [array type](#syntax-arraytype). Both record their respective [defined type](#syntax-deftype) and hold a list of the values of their _fields_.

​[structinst](#syntax-structinst)[arrayinst](#syntax-arrayinst)[fieldval](#syntax-fieldval)[packval](#syntax-packval)​::=::=::=::=​{[type](#syntax-structinst) [deftype](#syntax-deftype),[fields](#syntax-structinst) [fieldval](#syntax-fieldval)∗}​{[type](#syntax-arrayinst) [deftype](#syntax-deftype),[fields](#syntax-arrayinst) [fieldval](#syntax-fieldval)∗}​[val](#syntax-val) ∣ [packval](#syntax-packval)[packtype](#syntax-packtype).[pack](#syntax-packval) [i](#syntax-int)N​​

##### 4.2.15.1. Conventions[](#conventions②⑦)

*   Conversion of a regular [value](#syntax-val) to a [field value](#syntax-fieldval) is defined as follows:
    
    [pack](#aux-packfield)[valtype](#syntax-valtype)​([val](#syntax-val))[pack](#aux-packfield)[packtype](#syntax-packtype)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) i)​\=\=​[val](#syntax-val)[packtype](#syntax-packtype).[pack](#syntax-packval) [wrap](#op-wrap)32,∣[packtype](#syntax-packtype)∣​(i)​​
    
*   The inverse conversion of a [field value](#syntax-fieldval) to a regular [value](#syntax-val) is defined as follows:
    
    [unpack](#aux-unpackfield)[valtype](#syntax-valtype)ϵ​([val](#syntax-val))[unpack](#aux-unpackfield)[packtype](#syntax-packtype)[sx](#syntax-sx)​([packtype](#syntax-packtype).[pack](#syntax-packval) i)​\=\=​[val](#syntax-val)[i32](#syntax-numtype).[const](#syntax-instr-numeric) [extend](#op-extend)∣[packtype](#syntax-packtype)∣,32[sx](#syntax-sx)​(i)​​
    

#### 4.2.16. Exception Instances[](#exception-instances①)

An _exception instance_ is the runtime representation of an [exception](#exception) produced by a throw instruction. It holds the [address](#syntax-tagaddr) of the respective [tag](#syntax-tag) and the argument [values](#syntax-val).

​[exninst](#syntax-exninst)​::=​{[tag](#syntax-exninst) [tagaddr](#syntax-tagaddr),[fields](#syntax-exninst) [val](#syntax-val)∗}​​​

#### 4.2.17. Stack[](#stack①)

Besides the [store](#store), most [instructions](#syntax-instr) interact with an implicit _stack_. The stack contains the two kinds of entries:

*   _Values_: the _operands_ of instructions.
    
*   _Control Frames_: currently active control flow structures.
    

The latter can in turn be one of the following:

*   _Labels_: active [structured control instructions](#syntax-instr-control) that can be targeted by branches.
    
*   _(Call) Frames_: the _activation records_ of active [function](#syntax-func) calls.
    
*   _Handlers_: active exception handlers.
    

Note

Where clear from context, _call frame_ is abbreviated to just _frame_.

All these entries can occur on the stack in any order during the execution of a program. Stack entries are described by abstract syntax as follows.

Note

It is possible to model the WebAssembly semantics using separate stacks for operands, control constructs, and calls. However, because the stacks are interdependent, additional book keeping about associated stack heights would be required. For the purpose of this specification, an interleaved representation is simpler.

##### 4.2.17.1. Values[](#values④)

Values are represented by [themselves](#syntax-val).

##### 4.2.17.2. Labels[](#labels①)

Labels carry an argument arity n and their associated branch _target_, which is expressed syntactically as an [instruction](#syntax-instr) sequence:

​[label](#syntax-label)​::=​[label](#syntax-label)n​{[instr](#syntax-instr)∗}​​

Intuitively, [instr](#syntax-instr)∗ is the _continuation_ to execute when the branch is taken, in place of the original control construct.

Note

For example, a loop label has the form

[label](#syntax-label)n​{([loop](#syntax-instr-control) bt …)}

When performing a branch to this label, this executes the loop, effectively restarting it from the beginning. Conversely, a simple block label has the form

[label](#syntax-label)n​{ϵ}

When branching, the empty continuation ends the targeted block, such that execution can proceed with consecutive instructions.

##### 4.2.17.3. Call Frames[](#call-frames①)

Call frames carry the return arity n of the respective function, hold the values of its [locals](#syntax-local) (including arguments) in the order corresponding to their static [local indices](#syntax-localidx), and a reference to the function’s own [module instance](#syntax-moduleinst):

​[callframe](#syntax-callframe)[frame](#syntax-frame)​::=::=​[frame](#syntax-frame)n​{[frame](#syntax-frame)}{[locals](#syntax-frame) ([val](#syntax-val)?)∗,[module](#syntax-frame) [moduleinst](#syntax-moduleinst)}​​​

Locals may be uninitialized, in which case they are empty. Locals are mutated by respective [variable instructions](#syntax-instr-variable).

##### 4.2.17.4. Exception Handlers[](#exception-handlers①)

Exception handlers are installed by [try\_table](#syntax-instr-control) instructions and record the corresponding list of [catch clauses](#syntax-catch):

​[handler](#syntax-handler)​::=​[handler](#syntax-handler)n​{[catch](#syntax-catch)∗}​

The handlers on the stack are searched when an exception is [thrown](#syntax-throw).

##### 4.2.17.5. Conventions[](#conventions②⑧)

*   The meta variable L ranges over labels where clear from context.
    
*   The meta variable f ranges over frame states where clear from context.
    
*   The meta variable H ranges over exception handlers where clear from context.
    
*   The following auxiliary definition takes a [block type](#syntax-blocktype) and looks up the [instruction type](#syntax-instrtype) that it denotes in the current frame:
    
    [instrtype](#aux-blocktype)z​(x)[instrtype](#aux-blocktype)z​(t?)​\=\=​t1∗​→t2∗​ϵ→t?​if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​​
    

#### 4.2.18. Administrative Instructions[](#administrative-instructions①)

Note

This section is only relevant for the [formal notation](#exec-notation).

In order to express the reduction of [traps](#trap), [calls](#syntax-call), [exception handling](#syntax-handler), and [control instructions](#syntax-instr-control), the syntax of instructions is extended to include the following _administrative instructions_:

​[instr](#syntax-instr)​::=∣∣∣∣∣​…[addrref](#syntax-addrref)[label](#syntax-label)n​{[instr](#syntax-instr)∗} [instr](#syntax-instr)∗[frame](#syntax-frame)n​{[frame](#syntax-frame)} [instr](#syntax-instr)∗[handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [instr](#syntax-instr)∗[trap](#syntax-trap)​​

An [address reference](#syntax-addrref) represents an allocated [reference](#syntax-ref) value of respective form [“on the stack”](#exec-notation).

The label, frame, and handler instructions model [labels](#syntax-label), [frames](#syntax-frame), and active [exception handlers](#syntax-handler), respectively, [“on the stack”](#exec-notation). Moreover, the administrative syntax maintains the nesting structure of the original [structured control instruction](#syntax-instr-control) or [function body](#syntax-func) and their [instruction sequences](#syntax-instrs).

The trap instruction represents the occurrence of a trap. Traps are bubbled up through nested instruction sequences, ultimately reducing the entire program to a single trap instruction, signalling abrupt termination.

Note

For example, the [reduction rule](#exec-block) for block is:

([block](#syntax-instr-control) bt [instr](#syntax-instr)∗)[↪](#exec-notation)([label](#syntax-label)n​{ϵ} [instr](#syntax-instr)∗)

if the [block type](#syntax-blocktype) bt denotes a [function type](#syntax-functype) [func](#syntax-comptype) t1m​[→](#syntax-comptype)t2n​, such that n is the block’s result arity. This rule replaces the block with a label instruction, which can be interpreted as “pushing” the label on the stack. When its end is reached, i.e., the inner instruction sequence has been reduced to the empty sequence – or rather, a sequence of n [values](#syntax-val) representing the results – then the label instruction is eliminated courtesy of its own [reduction rule](#exec-label):

([label](#syntax-label)n​{[instr](#syntax-instr)∗} [val](#syntax-val)∗)[↪](#exec-notation)[val](#syntax-val)∗

This can be interpreted as removing the label from the stack and only leaving the locally accumulated operand values. Validation guarantees that n matches the number ∣[val](#syntax-val)∗∣ of resulting values at this point.

#### 4.2.19. Configurations[](#configurations①)

A _configuration_ describes the current computation. It consists of the computations’s _state_ and the sequence of [instructions](#syntax-instr) left to execute. The state in turn consists of a global [store](#syntax-store) and a current [frame](#syntax-frame) referring to the [module instance](#syntax-moduleinst) in which the computation runs, i.e., where the current function originates from.

​[config](#syntax-config)​::=​[state](#syntax-state);[instr](#syntax-instr)∗0.8ex\]​[state](#syntax-state)​::=​[store](#syntax-store);[frame](#syntax-frame)​​

Note

The current version of WebAssembly is single-threaded, but configurations with multiple threads may be supported in the future.

##### 4.2.19.1. Conventions[](#conventions②⑨)

*   The meta variable z ranges over frame states where clear from context.
    
*   The following shorthands are defined for accessing a state z\=(s;f):
    
    *   (s;f).[types](#syntax-state)\[x\]​\=​f.[module](#syntax-frame).[types](#syntax-moduleinst)\[x\]​
        
    *   (s;f).[tags](#syntax-state)\[x\]​\=​s.[tags](#syntax-store)\[f.[module](#syntax-frame).[tags](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[globals](#syntax-state)\[x\]​\=​s.[globals](#syntax-store)\[f.[module](#syntax-frame).[globals](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[mems](#syntax-state)\[x\]​\=​s.[mems](#syntax-store)\[f.[module](#syntax-frame).[mems](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[tables](#syntax-state)\[x\]​\=​s.[tables](#syntax-store)\[f.[module](#syntax-frame).[tables](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[funcs](#syntax-state)\[x\]​\=​s.[funcs](#syntax-store)\[f.[module](#syntax-frame).[funcs](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[datas](#syntax-state)\[x\]​\=​s.[datas](#syntax-store)\[f.[module](#syntax-frame).[datas](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[elems](#syntax-state)\[x\]​\=​s.[elems](#syntax-store)\[f.[module](#syntax-frame).[elems](#syntax-moduleinst)\[x\]\]​
        
    *   (s;f).[locals](#syntax-state)\[x\]​\=​f.[locals](#syntax-frame)\[x\]​
        
*   These shorthands also extend to [notation](#notation-replace) for updating state:
    
    *   (s;f)\[.[globals](#syntax-state)\[x\].[value](#syntax-globalinst)\=v\]​\=​s\[.[globals](#syntax-store)\[f.[module](#syntax-frame).[globals](#syntax-moduleinst)\[x\]\].[value](#syntax-globalinst)\=v\];f​
        
    *   (s;f)\[.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i:j\]\=b∗\]​\=​s\[.[mems](#syntax-store)\[f.[module](#syntax-frame).[mems](#syntax-moduleinst)\[x\]\].[bytes](#syntax-meminst)\[i:j\]\=b∗\];f​
        
    *   (s;f)\[.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)\[i\]\=r\]​\=​s\[.[tables](#syntax-store)\[f.[module](#syntax-frame).[tables](#syntax-moduleinst)\[x\]\].[refs](#syntax-tableinst)\[i\]\=r\];f​
        
    *   (s;f)\[.[locals](#syntax-state)\[x\]\=v\]​\=​s;f\[.[locals](#syntax-frame)\[x\]\=v\]​
        

### 4.3. Numerics[](#numerics①)

Numeric primitives are defined in a generic manner, by operators indexed over a bit width N.

Some operators are _non-deterministic_, because they can return one of several possible results (such as different [NaN](#syntax-nan) values). Technically, each operator thus returns a _set_ of allowed values. For convenience, deterministic results are expressed as plain values, which are assumed to be identified with a respective singleton set.

Some operators are _partial_, because they are not defined on certain inputs. Technically, an empty set of results is returned for these inputs.

In formal notation, each operator is defined by equational clauses that apply in decreasing order of precedence. That is, the first clause that is applicable to the given arguments defines the result. In some cases, similar clauses are combined into one by using the notation ± or ∓. When several of these placeholders occur in a single clause, then they must be resolved consistently: either the upper sign is chosen for all of them or the lower sign.

Note

For example, the [fcopysign](#op-fcopysign) operator is defined as follows:

[fcopysign](#op-fcopysign)N​(±p1​,±p2​)[fcopysign](#op-fcopysign)N​(±p1​,∓p2​)​\=\=​±p1​∓p1​​​

This definition is to be read as a shorthand for the following expansion of each clause into two separate ones:

[fcopysign](#op-fcopysign)N​(+p1​,+p2​)[fcopysign](#op-fcopysign)N​(−p1​,−p2​)[fcopysign](#op-fcopysign)N​(+p1​,−p2​)[fcopysign](#op-fcopysign)N​(−p1​,+p2​)​\=\=\=\=​+p1​−p1​−p1​+p1​​​

Numeric operators are lifted to input sequences by applying the operator element-wise, returning a sequence of results. When there are multiple inputs, they must be of equal length.

op(c1n​,…,ckn​)​\=​op(c1n​\[0\],…,ckn​\[0\]) … op(c1n​\[n−1\],…,ckn​\[n−1\])​

Note

For example, the unary operator [fabs](#op-fabs), when given a sequence of floating-point values, return a sequence of floating-point results:

[fabs](#op-fabs)N​(zn)​\=​[fabs](#op-fabs)N​(z\[0\]) … [fabs](#op-fabs)N​(z\[n\])​

The binary operator [iadd](#op-iadd), when given two sequences of integers of the same length, n, return a sequence of integer results:

[iadd](#op-iadd)N​(i1n​,i2n​)​\=​[iadd](#op-iadd)N​(i1​\[0\],i2​\[0\]) … [iadd](#op-iadd)N​(i1​\[n\],i2​\[n\])​

Conventions:

*   The meta variable d is used to range over single bits.
    
*   The meta variable p is used to range over (signless) [magnitudes](#syntax-float) of floating-point values, including [nan](#syntax-float) and ∞.
    
*   The meta variable q is used to range over (signless) _rational_ [magnitudes](#syntax-float), excluding [nan](#syntax-float) or ∞.
    
*   The notation f−1 denotes the inverse of a bijective function f.
    
*   Truncation of rational values is written [trunc](#aux-trunc)(±q), with the usual mathematical definition:
    
    [trunc](#aux-trunc)(±q)​\=​±i​(ifi∈N∧+q−1<i≤+q)​​
    

*   Saturation of integers is written [sat\_u](#aux-sat)N​(i) and [sat\_s](#aux-sat)N​(i). The arguments to these two functions range over arbitrary signed integers.
    
    *   Unsigned saturation, [sat\_u](#aux-sat)N​(i) clamps i to between 0 and 2N−1:
        
        [sat\_u](#aux-sat)N​(i)[sat\_u](#aux-sat)N​(i)[sat\_u](#aux-sat)N​(i)​\=\=\=​02N−1i​(ifi<0)(ifi\>2N−1)(otherwise)​​
        
    *   Signed saturation, [sat\_s](#aux-sat)N​(i) clamps i to between −2N−1 and 2N−1−1:
        
    
    [sat\_s](#aux-sat)N​(i)[sat\_s](#aux-sat)N​(i)[sat\_s](#aux-sat)N​(i)​\=\=\=​−2N−12N−1−1i​(ifi<−2N−1)(ifi\>2N−1−1)(otherwise)​​
    

#### 4.3.1. Representations[](#representations①)

Numbers and numeric vectors have an underlying binary representation as a sequence of bits:

[bits](#aux-bits)[iN](#syntax-numtype)​(i)[bits](#aux-bits)[fN](#syntax-numtype)​(z)[bits](#aux-bits)[vN](#syntax-vectype)​(i)​\=\=\=​[ibits](#aux-ibits)N​(i)[fbits](#aux-fbits)N​(z)[ibits](#aux-ibits)N​(i)​​

The first case of these applies to representations of both integer [value types](#syntax-valtype) and [packed types](#syntax-packtype).

Each of these functions is a bijection, hence they are invertible.

##### 4.3.1.1. Integers[](#integers③)

[Integers](#syntax-int) are represented as base two unsigned numbers:

[ibits](#aux-ibits)N​(i)​\=​dN−1​ … d0​​(i\=2N−1⋅dN−1​+⋯+20⋅d0​)​​

Boolean operators like ∧, ∨, or ⊻ are lifted to bit sequences of equal length by applying them pointwise.

##### 4.3.1.2. Floating-Point[](#floating-point③)

[Floating-point values](#syntax-float) are represented in the respective binary format defined by [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") (Section 3.4):

[fbits](#aux-fbits)N​(±(1+m⋅2−M)⋅2e)[fbits](#aux-fbits)N​(±(0+m⋅2−M)⋅2e)[fbits](#aux-fbits)N​(±∞)[fbits](#aux-fbits)N​(±[nan](#syntax-float)(n))[fbias](#aux-fbias)N​[fsign](#aux-fsign)(+)[fsign](#aux-fsign)(−)​\=\=\=\=\=\=\=​[fsign](#aux-fsign)(±) [ibits](#aux-ibits)E​(e+[fbias](#aux-fbias)N​) [ibits](#aux-ibits)M​(m)[fsign](#aux-fsign)(±) (0)E [ibits](#aux-ibits)M​(m)[fsign](#aux-fsign)(±) (1)E (0)M[fsign](#aux-fsign)(±) (1)E [ibits](#aux-ibits)M​(n)2E−1−101​​

where M\=[signif](#aux-signif)(N) and E\=[expon](#aux-expon)(N).

##### 4.3.1.3. Vectors[](#vectors③)

Numeric vectors of type [vN](#syntax-vectype) have the same underlying representation as an [iN](#syntax-numtype). They can also be interpreted as a sequence of numeric values packed into a [vN](#syntax-vectype) with a particular [shape](#syntax-shape) txM, provided that N\=∣t∣⋅M.

[lanes](#aux-lanes)txM​(c)​\=​c0​ … cM−1​​(where∧∧​wb∗ci​​\=\=\=​∣t∣/8[bytes](#aux-bytes)[iN](#syntax-numtype)​(c)[bytes](#aux-bytes)t−1​(b∗\[i⋅w[:](#notation-slice)w\]))​​​

This function is a bijection on [iN](#syntax-numtype), hence it is invertible.

Numeric values can be _packed_ into lanes of a specific [lane type](#syntax-lanetype) and vice versa:

[pack](#aux-packnum)[numtype](#syntax-numtype)​(c)[pack](#aux-packnum)[packtype](#syntax-packtype)​(c)[unpack](#aux-unpacknum)[packtype](#syntax-packtype)​(c)​\=\=\=​c[wrap](#op-wrap)∣[unpack](#aux-unpack)([packtype](#syntax-packtype))∣,∣[packtype](#syntax-packtype)∣​(c)0.8ex\][unpack](#aux-unpacknum)[numtype](#syntax-numtype)​(c)[extend](#op-extend)∣[packtype](#syntax-packtype)∣,∣[unpack](#aux-unpack)([packtype](#syntax-packtype))∣[u](#syntax-sx)​(c)​\=​c​​

##### 4.3.1.4. Storage[](#storage①)

When a number is stored into [memory](#syntax-mem), it is converted into a sequence of [bytes](#syntax-byte) in [little endian](https://en.wikipedia.org/wiki/Endianness#Little-endian) byte order:

[bytes](#aux-bytes)t​(i)[littleendian](#aux-littleendian)(ϵ)[littleendian](#aux-littleendian)(d8 d′∗ )​\=\=\=​[littleendian](#aux-littleendian)([bits](#aux-bits)t​(i))ϵ[littleendian](#aux-littleendian)(d′∗) [ibits](#aux-ibits)8−1​(d8)​​

Again these functions are invertible bijections.

#### 4.3.2. Integer Operations[](#integer-operations①)

##### 4.3.2.1. Sign Interpretation[](#sign-interpretation①)

Integer operators are defined on [iN](#syntax-int) values. Operators that use a signed interpretation convert the value using the following definition, which takes the two’s complement when the value lies in the upper half of the value range (i.e., its most significant bit is 1):

[signed](#aux-signed)N​(i)[signed](#aux-signed)N​(i)​\=\=​ii−2N​(0≤i<2N−1)(2N−1≤i<2N)​​

This function is bijective, and hence invertible.

##### 4.3.2.2. Boolean Interpretation[](#boolean-interpretation①)

The integer result of predicates – i.e., [tests](#syntax-testop) and [relational](#syntax-relop) operators – is defined with the help of the following auxiliary function producing the value 1 or 0 depending on a condition.

[bool](#aux-tobool)(C)[bool](#aux-tobool)(C)​\=\=​10​(ifC)(otherwise)​​

##### 4.3.2.3. [iadd](#op-iadd)N​(i1​,i2​)[](#-hrefop-iaddmathrmiadd_n-i_1-i_2)

*   Return the result of adding i1​ and i2​ modulo 2N.
    

[iadd](#op-iadd)N​(i1​,i2​)​\=​(i1​+i2​)mod2N​

##### 4.3.2.4. [isub](#op-isub)N​(i1​,i2​)[](#-hrefop-isubmathrmisub_n-i_1-i_2)

*   Return the result of subtracting i2​ from i1​ modulo 2N.
    

[isub](#op-isub)N​(i1​,i2​)​\=​(i1​−i2​+2N)mod2N​

##### 4.3.2.5. [imul](#op-imul)N​(i1​,i2​)[](#-hrefop-imulmathrmimul_n-i_1-i_2)

*   Return the result of multiplying i1​ and i2​ modulo 2N.
    

[imul](#op-imul)N​(i1​,i2​)​\=​(i1​⋅i2​)mod2N​

##### 4.3.2.6. [idiv\_u](#op-idiv)N​(i1​,i2​)[](#-hrefop-idivmathrmidiv_u_n-i_1-i_2)

*   If i2​ is 0, then the result is undefined.
    
*   Else, return the result of dividing i1​ by i2​, truncated toward zero.
    

[idiv\_u](#op-idiv)N​(i1​,0)[idiv\_u](#op-idiv)N​(i1​,i2​)​\=\=​{}[trunc](#aux-trunc)(i1​/i2​)​​

Note

This operator is [partial](#exec-op-partial).

##### 4.3.2.7. [idiv\_s](#op-idiv)N​(i1​,i2​)[](#-hrefop-idivmathrmidiv_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   If j2​ is 0, then the result is undefined.
    
*   Else if j1​ divided by j2​ is 2N−1, then the result is undefined.
    
*   Else, return the result of dividing j1​ by j2​, truncated toward zero.
    

[idiv\_s](#op-idiv)N​(i1​,0)[idiv\_s](#op-idiv)N​(i1​,i2​)[idiv\_s](#op-idiv)N​(i1​,i2​)​\=\=\=​{}{}(if[signed](#aux-signed)N​(i1​)/[signed](#aux-signed)N​(i2​)\=2N−1)[signed](#aux-signed)N−1​([trunc](#aux-trunc)([signed](#aux-signed)N​(i1​)/[signed](#aux-signed)N​(i2​)))​​

Note

This operator is [partial](#exec-op-partial). Besides division by 0, the result of (−2N−1)/(−1)\=+2N−1 is not representable as an N\-bit signed integer.

##### 4.3.2.8. [irem\_u](#op-irem)N​(i1​,i2​)[](#-hrefop-iremmathrmirem_u_n-i_1-i_2)

*   If i2​ is 0, then the result is undefined.
    
*   Else, return the remainder of dividing i1​ by i2​.
    

[irem\_u](#op-irem)N​(i1​,0)[irem\_u](#op-irem)N​(i1​,i2​)​\=\=​{}i1​−i2​⋅[trunc](#aux-trunc)(i1​/i2​)​​

Note

This operator is [partial](#exec-op-partial).

As long as both operators are defined, it holds that i1​\=i2​⋅[idiv\_u](#op-idiv)(i1​,i2​)+[irem\_u](#op-irem)(i1​,i2​).

##### 4.3.2.9. [irem\_s](#op-irem)N​(i1​,i2​)[](#-hrefop-iremmathrmirem_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   If i2​ is 0, then the result is undefined.
    
*   Else, return the remainder of dividing j1​ by j2​, with the sign of the dividend j1​.
    

[irem\_s](#op-irem)N​(i1​,0)[irem\_s](#op-irem)N​(i1​,i2​)​\=\=​{}[signed](#aux-signed)N−1​(j1​−j2​⋅[trunc](#aux-trunc)(j1​/j2​))(wherej1​\=[signed](#aux-signed)N​(i1​)∧j2​\=[signed](#aux-signed)N​(i2​))​​

Note

This operator is [partial](#exec-op-partial).

As long as both operators are defined, it holds that i1​\=i2​⋅[idiv\_s](#op-idiv)(i1​,i2​)+[irem\_s](#op-irem)(i1​,i2​).

##### 4.3.2.10. [inot](#op-inot)N​(i)[](#-hrefop-inotmathrminot_n-i)

*   Return the bitwise negation of i.
    

[inot](#op-inot)N​(i)​\=​[ibits](#aux-ibits)N−1​([ibits](#aux-ibits)N​(i)⊻[ibits](#aux-ibits)N​(2N−1))​

##### 4.3.2.11. [irev](#op-irev)N​(i)[](#-hrefop-irevmathrmirev_n-i)

*   Return the bitwise reversal of i.
    

[irev](#op-irev)N​(i)​\=​[ibits](#aux-ibits)N−1​((dN\[N−i\])i≤N)​(ifdN\=[ibits](#aux-ibits)N​(i))​

##### 4.3.2.12. [iand](#op-iand)N​(i1​,i2​)[](#-hrefop-iandmathrmiand_n-i_1-i_2)

*   Return the bitwise conjunction of i1​ and i2​.
    

[iand](#op-iand)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​([ibits](#aux-ibits)N​(i1​)∧[ibits](#aux-ibits)N​(i2​))​

##### 4.3.2.13. [iandnot](#op-iandnot)N​(i1​,i2​)[](#-hrefop-iandnotmathrmiandnot_n-i_1-i_2)

*   Return the bitwise conjunction of i1​ and the bitwise negation of i2​.
    

[iandnot](#op-iandnot)N​(i1​,i2​)​\=​[iand](#op-iand)N​(i1​,[inot](#op-inot)N​(i2​))​

##### 4.3.2.14. [ior](#op-ior)N​(i1​,i2​)[](#-hrefop-iormathrmior_n-i_1-i_2)

*   Return the bitwise disjunction of i1​ and i2​.
    

[ior](#op-ior)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​([ibits](#aux-ibits)N​(i1​)∨[ibits](#aux-ibits)N​(i2​))​

##### 4.3.2.15. [ixor](#op-ixor)N​(i1​,i2​)[](#-hrefop-ixormathrmixor_n-i_1-i_2)

*   Return the bitwise exclusive disjunction of i1​ and i2​.
    

[ixor](#op-ixor)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​([ibits](#aux-ibits)N​(i1​)⊻[ibits](#aux-ibits)N​(i2​))​

##### 4.3.2.16. [ishl](#op-ishl)N​(i1​,i2​)[](#-hrefop-ishlmathrmishl_n-i_1-i_2)

*   Let k be i2​ modulo N.
    
*   Return the result of shifting i1​ left by k bits, modulo 2N.
    

[ishl](#op-ishl)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​(d2N−k​ 0k)​(if[ibits](#aux-ibits)N​(i1​)\=d1k​ d2N−k​∧k\=i2​modN)​

##### 4.3.2.17. [ishr\_u](#op-ishr)N​(i1​,i2​)[](#-hrefop-ishrmathrmishr_u_n-i_1-i_2)

*   Let k be i2​ modulo N.
    
*   Return the result of shifting i1​ right by k bits, extended with 0 bits.
    

[ishr\_u](#op-ishr)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​(0k d1N−k​)​(if[ibits](#aux-ibits)N​(i1​)\=d1N−k​ d2k​∧k\=i2​modN)​

##### 4.3.2.18. [ishr\_s](#op-ishr)N​(i1​,i2​)[](#-hrefop-ishrmathrmishr_s_n-i_1-i_2)

*   Let k be i2​ modulo N.
    
*   Return the result of shifting i1​ right by k bits, extended with the most significant bit of the original value.
    

[ishr\_s](#op-ishr)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​(d0k+1​ d1N−k−1​)​(if[ibits](#aux-ibits)N​(i1​)\=d0​ d1N−k−1​ d2k​∧k\=i2​modN)​

##### 4.3.2.19. [irotl](#op-irotl)N​(i1​,i2​)[](#-hrefop-irotlmathrmirotl_n-i_1-i_2)

*   Let k be i2​ modulo N.
    
*   Return the result of rotating i1​ left by k bits.
    

[irotl](#op-irotl)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​(d2N−k​ d1k​)​(if[ibits](#aux-ibits)N​(i1​)\=d1k​ d2N−k​∧k\=i2​modN)​

##### 4.3.2.20. [irotr](#op-irotr)N​(i1​,i2​)[](#-hrefop-irotrmathrmirotr_n-i_1-i_2)

*   Let k be i2​ modulo N.
    
*   Return the result of rotating i1​ right by k bits.
    

[irotr](#op-irotr)N​(i1​,i2​)​\=​[ibits](#aux-ibits)N−1​(d2k​ d1N−k​)​(if[ibits](#aux-ibits)N​(i1​)\=d1N−k​ d2k​∧k\=i2​modN)​

##### 4.3.2.21. [iclz](#op-iclz)N​(i)[](#-hrefop-iclzmathrmiclz_n-i)

*   Return the count of leading zero bits in i; all bits are considered leading zeros if i is 0.
    

[iclz](#op-iclz)N​(i)​\=​k​(if[ibits](#aux-ibits)N​(i)\=0k (1 d∗)?)​

##### 4.3.2.22. [ictz](#op-ictz)N​(i)[](#-hrefop-ictzmathrmictz_n-i)

*   Return the count of trailing zero bits in i; all bits are considered trailing zeros if i is 0.
    

[ictz](#op-ictz)N​(i)​\=​k​(if[ibits](#aux-ibits)N​(i)\=(d∗ 1)? 0k)​

##### 4.3.2.23. [ipopcnt](#op-ipopcnt)N​(i)[](#-hrefop-ipopcntmathrmipopcnt_n-i)

*   Return the count of non-zero bits in i.
    

[ipopcnt](#op-ipopcnt)N​(i)​\=​k​(if[ibits](#aux-ibits)N​(i)\=(0∗ 1)k 0∗)​

##### 4.3.2.24. [ieqz](#op-ieqz)N​(i)[](#-hrefop-ieqzmathrmieqz_n-i)

*   Return 1 if i is zero, 0 otherwise.
    

[ieqz](#op-ieqz)N​(i)​\=​[bool](#aux-tobool)(i\=0)​

##### 4.3.2.25. [inez](#op-inez)N​(i)[](#-hrefop-inezmathrminez_n-i)

*   Return 0 if i is zero, 1 otherwise.
    

[inez](#op-inez)N​(i)​\=​[bool](#aux-tobool)(i\=0)​

##### 4.3.2.26. [ieq](#op-ieq)N​(i1​,i2​)[](#-hrefop-ieqmathrmieq_n-i_1-i_2)

*   Return 1 if i1​ equals i2​, 0 otherwise.
    

[ieq](#op-ieq)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​\=i2​)​

##### 4.3.2.27. [ine](#op-ine)N​(i1​,i2​)[](#-hrefop-inemathrmine_n-i_1-i_2)

*   Return 1 if i1​ does not equal i2​, 0 otherwise.
    

[ine](#op-ine)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​\=i2​)​

##### 4.3.2.28. [ilt\_u](#op-ilt)N​(i1​,i2​)[](#-hrefop-iltmathrmilt_u_n-i_1-i_2)

*   Return 1 if i1​ is less than i2​, 0 otherwise.
    

[ilt\_u](#op-ilt)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​<i2​)​

##### 4.3.2.29. [ilt\_s](#op-ilt)N​(i1​,i2​)[](#-hrefop-iltmathrmilt_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   Return 1 if j1​ is less than j2​, 0 otherwise.
    

[ilt\_s](#op-ilt)N​(i1​,i2​)​\=​[bool](#aux-tobool)([signed](#aux-signed)N​(i1​)<[signed](#aux-signed)N​(i2​))​

##### 4.3.2.30. [igt\_u](#op-igt)N​(i1​,i2​)[](#-hrefop-igtmathrmigt_u_n-i_1-i_2)

*   Return 1 if i1​ is greater than i2​, 0 otherwise.
    

[igt\_u](#op-igt)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​\>i2​)​

##### 4.3.2.31. [igt\_s](#op-igt)N​(i1​,i2​)[](#-hrefop-igtmathrmigt_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   Return 1 if j1​ is greater than j2​, 0 otherwise.
    

[igt\_s](#op-igt)N​(i1​,i2​)​\=​[bool](#aux-tobool)([signed](#aux-signed)N​(i1​)\>[signed](#aux-signed)N​(i2​))​

##### 4.3.2.32. [ile\_u](#op-ile)N​(i1​,i2​)[](#-hrefop-ilemathrmile_u_n-i_1-i_2)

*   Return 1 if i1​ is less than or equal to i2​, 0 otherwise.
    

[ile\_u](#op-ile)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​≤i2​)​

##### 4.3.2.33. [ile\_s](#op-ile)N​(i1​,i2​)[](#-hrefop-ilemathrmile_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   Return 1 if j1​ is less than or equal to j2​, 0 otherwise.
    

[ile\_s](#op-ile)N​(i1​,i2​)​\=​[bool](#aux-tobool)([signed](#aux-signed)N​(i1​)≤[signed](#aux-signed)N​(i2​))​

##### 4.3.2.34. [ige\_u](#op-ige)N​(i1​,i2​)[](#-hrefop-igemathrmige_u_n-i_1-i_2)

*   Return 1 if i1​ is greater than or equal to i2​, 0 otherwise.
    

[ige\_u](#op-ige)N​(i1​,i2​)​\=​[bool](#aux-tobool)(i1​≥i2​)​

##### 4.3.2.35. [ige\_s](#op-ige)N​(i1​,i2​)[](#-hrefop-igemathrmige_s_n-i_1-i_2)

*   Let j1​ be the [signed interpretation](#aux-signed) of i1​.
    
*   Let j2​ be the [signed interpretation](#aux-signed) of i2​.
    
*   Return 1 if j1​ is greater than or equal to j2​, 0 otherwise.
    

[ige\_s](#op-ige)N​(i1​,i2​)​\=​[bool](#aux-tobool)([signed](#aux-signed)N​(i1​)≥[signed](#aux-signed)N​(i2​))​

##### 4.3.2.36. [iextendM\_s](#op-iextendn)N​(i)[](#-hrefop-iextendnmathrmiextendmmathrm_s_n-i)

*   Let j be the result of computing [wrap](#op-wrap)N,M​(i).
    
*   Return [extends](#op-extend)M,N​(j).
    

[iextendM\_s](#op-iextendn)N​(i)​\=​[extends](#op-extend)M,N​([wrap](#op-wrap)N,M​(i))​​

##### 4.3.2.37. [ibitselect](#op-ibitselect)N​(i1​,i2​,i3​)[](#-hrefop-ibitselectmathrmibitselect_n-i_1-i_2-i_3)

*   Let j1​ be the bitwise conjunction of i1​ and i3​.
    
*   Let j3′​ be the bitwise negation of i3​.
    
*   Let j2​ be the bitwise conjunction of i2​ and j3′​.
    
*   Return the bitwise disjunction of j1​ and j2​.
    

[ibitselect](#op-ibitselect)N​(i1​,i2​,i3​)​\=​[ior](#op-ior)N​([iand](#op-iand)N​(i1​,i3​),[iand](#op-iand)N​(i2​,[inot](#op-inot)N​(i3​)))​

##### 4.3.2.38. [iabs](#op-iabs)N​(i)[](#-hrefop-iabsmathrmiabs_n-i)

*   Let j be the [signed interpretation](#aux-signed) of i.
    
*   If j is greater than or equal to 0, then return i.
    
*   Else return the negation of j, modulo 2N.
    

[iabs](#op-iabs)N​(i)[iabs](#op-iabs)N​(i)​\=\=​i−[signed](#aux-signed)N​(i)mod2N​(if[signed](#aux-signed)N​(i)≥0)(otherwise)​​

##### 4.3.2.39. [ineg](#op-ineg)N​(i)[](#-hrefop-inegmathrmineg_n-i)

*   Return the result of negating i, modulo 2N.
    

[ineg](#op-ineg)N​(i)​\=​(2N−i)mod2N​

##### 4.3.2.40. [imin\_u](#op-imin)N​(i1​,i2​)[](#-hrefop-iminmathrmimin_u_n-i_1-i_2)

*   Return i1​ if [ilt\_u](#op-ilt)N​(i1​,i2​) is 1, return i2​ otherwise.
    

[imin\_u](#op-imin)N​(i1​,i2​)[imin\_u](#op-imin)N​(i1​,i2​)​\=\=​i1​i2​​(if[ilt\_u](#op-ilt)N​(i1​,i2​)\=1)(otherwise)​​

##### 4.3.2.41. [imin\_s](#op-imin)N​(i1​,i2​)[](#-hrefop-iminmathrmimin_s_n-i_1-i_2)

*   Return i1​ if [ilt\_s](#op-ilt)N​(i1​,i2​) is 1, return i2​ otherwise.
    

[imin\_s](#op-imin)N​(i1​,i2​)[imin\_s](#op-imin)N​(i1​,i2​)​\=\=​i1​i2​​(if[ilt\_s](#op-ilt)N​(i1​,i2​)\=1)(otherwise)​​

##### 4.3.2.42. [imax\_u](#op-imax)N​(i1​,i2​)[](#-hrefop-imaxmathrmimax_u_n-i_1-i_2)

*   Return i1​ if [igt\_u](#op-igt)N​(i1​,i2​) is 1, return i2​ otherwise.
    

[imax\_u](#op-imax)N​(i1​,i2​)[imax\_u](#op-imax)N​(i1​,i2​)​\=\=​i1​i2​​(if[igt\_u](#op-igt)N​(i1​,i2​)\=1)(otherwise)​​

##### 4.3.2.43. [imax\_s](#op-imax)N​(i1​,i2​)[](#-hrefop-imaxmathrmimax_s_n-i_1-i_2)

*   Return i1​ if [igt\_s](#op-igt)N​(i1​,i2​) is 1, return i2​ otherwise.
    

[imax\_s](#op-imax)N​(i1​,i2​)[imax\_s](#op-imax)N​(i1​,i2​)​\=\=​i1​i2​​(if[igt\_s](#op-igt)N​(i1​,i2​)\=1)(otherwise)​​

##### 4.3.2.44. [iadd\_sat\_u](#op-iadd-sat)N​(i1​,i2​)[](#-hrefop-iadd-satmathrmiadd_sat_u_n-i_1-i_2)

*   Let i be the result of adding i1​ and i2​.
    
*   Return [sat\_u](#aux-sat)N​(i).
    

[iadd\_sat\_u](#op-iadd-sat)N​(i1​,i2​)​\=​[sat\_u](#aux-sat)N​(i1​+i2​)​

##### 4.3.2.45. [iadd\_sat\_s](#op-iadd-sat)N​(i1​,i2​)[](#-hrefop-iadd-satmathrmiadd_sat_s_n-i_1-i_2)

*   Let j1​ be the signed interpretation of i1​
    
*   Let j2​ be the signed interpretation of i2​
    
*   Let j be the result of adding j1​ and j2​.
    
*   Return the value whose signed interpretation is [sat\_s](#aux-sat)N​(j).
    

[iadd\_sat\_s](#op-iadd-sat)N​(i1​,i2​)​\=​[signed](#aux-signed)N−1​([sat\_s](#aux-sat)N​([signed](#aux-signed)N​(i1​)+[signed](#aux-signed)N​(i2​)))​

##### 4.3.2.46. [isub\_sat\_u](#op-isub-sat)N​(i1​,i2​)[](#-hrefop-isub-satmathrmisub_sat_u_n-i_1-i_2)

*   Let i be the result of subtracting i2​ from i1​.
    
*   Return [sat\_u](#aux-sat)N​(i).
    

[isub\_sat\_u](#op-isub-sat)N​(i1​,i2​)​\=​[sat\_u](#aux-sat)N​(i1​−i2​)​

##### 4.3.2.47. [isub\_sat\_s](#op-isub-sat)N​(i1​,i2​)[](#-hrefop-isub-satmathrmisub_sat_s_n-i_1-i_2)

*   Let j1​ be the signed interpretation of i1​
    
*   Let j2​ be the signed interpretation of i2​
    
*   Let j be the result of subtracting j2​ from j1​.
    
*   Return the value whose signed interpretation is [sat\_s](#aux-sat)N​(j).
    

[isub\_sat\_s](#op-isub-sat)N​(i1​,i2​)​\=​[signed](#aux-signed)N−1​([sat\_s](#aux-sat)N​([signed](#aux-signed)N​(i1​)−[signed](#aux-signed)N​(i2​)))​

##### 4.3.2.48. [iavgr\_u](#op-iavgr)N​(i1​,i2​)[](#-hrefop-iavgrmathrmiavgr_u_n-i_1-i_2)

*   Let j be the result of adding i1​, i2​, and 1.
    
*   Return the result of dividing j by 2, truncated toward zero.
    

[iavgr\_u](#op-iavgr)N​(i1​,i2​)​\=​[trunc](#aux-trunc)((i1​+i2​+1)/2)​

##### 4.3.2.49. [iq15mulrsat\_s](#op-iq15mulrsat)N​(i1​,i2​)[](#-hrefop-iq15mulrsatmathrmiq15mulrsat_s_n-i_1-i_2)

*   Return the whose signed interpretation is the result of [sat\_s](#aux-sat)N​([ishr\_s](#op-ishr)N​(i1​⋅i2​+214,15)).
    

[iq15mulrsat\_s](#op-iq15mulrsat)N​(i1​,i2​)​\=​[signed](#aux-signed)N−1​([sat\_s](#aux-sat)N​([ishr\_s](#op-ishr)N​(i1​⋅i2​+214,15)))​

#### 4.3.3. Floating-Point Operations[](#floating-point-operations①)

Floating-point arithmetic follows the [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") standard, with the following qualifications:

*   All operators use round-to-nearest ties-to-even, except where otherwise specified. Non-default directed rounding attributes are not supported.
    
*   Following the recommendation that operators propagate [NaN](#syntax-nan) payloads from their operands is permitted but not required.
    
*   All operators use “non-stop” mode, and floating-point exceptions are not otherwise observable. In particular, neither alternate floating-point exception handling attributes nor operators on status flags are supported. There is no observable difference between quiet and signalling NaNs.
    

Note

Some of these limitations may be lifted in future versions of WebAssembly.

##### 4.3.3.1. Rounding[](#rounding①)

Rounding always is round-to-nearest ties-to-even, in correspondence with [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") (Section 4.3.1).

An _exact_ floating-point number is a rational number that is exactly representable as a [floating-point number](#syntax-float) of given bit width N.

A _limit_ number for a given floating-point bit width N is a positive or negative number whose magnitude is the smallest power of 2 that is not exactly representable as a floating-point number of width N (that magnitude is 2128 for N\=32 and 21024 for N\=64).

A _candidate_ number is either an exact floating-point number or a positive or negative limit number for the given bit width N.

A _candidate pair_ is a pair z1​,z2​ of candidate numbers, such that no candidate number exists that lies between the two.

A real number r is converted to a floating-point value of bit width N as follows:

*   If r is 0, then return +0.
    
*   Else if r is an exact floating-point number, then return r.
    
*   Else if r greater than or equal to the positive limit, then return +∞.
    
*   Else if r is less than or equal to the negative limit, then return −∞.
    
*   Else if z1​ and z2​ are a candidate pair such that z1​<r<z2​, then:
    
    *   If ∣r−z1​∣<∣r−z2​∣, then let z be z1​.
        
    *   Else if ∣r−z1​∣\>∣r−z2​∣, then let z be z2​.
        
    *   Else if ∣r−z1​∣\=∣r−z2​∣ and the [significand](#syntax-float) of z1​ is even, then let z be z1​.
        
    *   Else, let z be z2​.
        
*   If z is 0, then:
    
    *   If r<0, then return −0.
        
    *   Else, return +0.
        
*   Else if z is a limit number, then:
    
    *   If r<0, then return −∞.
        
    *   Else, return +∞.
        
*   Else, return z.
    

[float](#aux-ieee)N​(0)[float](#aux-ieee)N​(r)[float](#aux-ieee)N​(r)[float](#aux-ieee)N​(r)[float](#aux-ieee)N​(r)closestN​(r,z1​,z2​)closestN​(r,z1​,z2​)closestN​(r,z1​,z2​)closestN​(r,z1​,z2​)rectifyN​(r,±limitN​)rectifyN​(r,0)rectifyN​(r,0)rectifyN​(r,z)​\=\=\=\=\=\=\=\=\=\=\=\=\=​+0r+∞−∞closestN​(r,z1​,z2​)rectifyN​(r,z1​)rectifyN​(r,z2​)rectifyN​(r,z1​)rectifyN​(r,z2​)±∞+0(r≥0)−0(r<0)z​(ifr∈exactN​)(ifr≥+limitN​)(ifr≤−limitN​)(ifz1​<r<z2​∧(z1​,z2​)∈candidatepairN​)(if∣r−z1​∣<∣r−z2​∣)(if∣r−z1​∣\>∣r−z2​∣)(if∣r−z1​∣\=∣r−z2​∣∧evenN​(z1​))(if∣r−z1​∣\=∣r−z2​∣∧evenN​(z2​))​​

where:

exactN​limitN​candidateN​candidatepairN​evenN​((d+m⋅2−M)⋅2e)evenN​(±limitN​)​\=\=\=\=⇔⇔​[fN](#syntax-float)∩Q22[expon](#aux-expon)(N)−1exactN​∪{+limitN​,−limitN​}{(z1​,z2​)∈candidateN2​ ∣ z1​<z2​∧∀z∈candidateN​,z≤z1​∨z≥z2​}mmod2\=0true​​

##### 4.3.3.2. NaN Propagation[](#nan-propagation①)

When the result of a floating-point operator other than [fneg](#op-fneg), [fabs](#op-fabs), or [fcopysign](#op-fcopysign) is a [NaN](#syntax-nan), then its sign is non-deterministic and the [payload](#syntax-payload) is computed as follows:

*   If the payload of all NaN inputs to the operator is [canonical](#canonical-nan) (including the case that there are no NaN inputs), then the payload of the output is canonical as well.
    
*   Otherwise the payload is picked non-deterministically among all [arithmetic NaNs](#arithmetic-nan); that is, its most significant bit is 1 and all others are unspecified.
    
*   In the [deterministic profile](#profile-deterministic), however, a positive canonical NaNs is reliably produced in the latter case.
    

The non-deterministic result is expressed by the following auxiliary function producing a set of allowed outputs from a set of inputs:

\[![DET](#profile-deterministic)\]\[![DET](#profile-deterministic)\]​[nans](#aux-nans)N​{z∗}[nans](#aux-nans)N​{z∗}[nans](#aux-nans)N​{z∗}​\=\=\=​{+[nan](#syntax-float)([canon](#aux-canon)N​)}{+[nan](#syntax-float)(n),−[nan](#syntax-float)(n) ∣ n\=[canon](#aux-canon)N​}{+[nan](#syntax-float)(n),−[nan](#syntax-float)(n) ∣ n≥[canon](#aux-canon)N​}​(if{z∗}⊆{+[nan](#syntax-float)([canon](#aux-canon)N​),−[nan](#syntax-float)([canon](#aux-canon)N​)}(if{z∗}⊆{+[nan](#syntax-float)([canon](#aux-canon)N​),−[nan](#syntax-float)([canon](#aux-canon)N​)}​​

##### 4.3.3.3. [fadd](#op-fadd)N​(z1​,z2​)[](#-hrefop-faddmathrmfadd_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if both z1​ and z2​ are infinities of opposite signs, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ and z2​ are infinities of equal sign, then return that infinity.
    
*   Else if either z1​ or z2​ is an infinity, then return that infinity.
    
*   Else if both z1​ and z2​ are zeroes of opposite sign, then return positive zero.
    
*   Else if both z1​ and z2​ are zeroes of equal sign, then return that zero.
    
*   Else if either z1​ or z2​ is a zero, then return the other operand.
    
*   Else if both z1​ and z2​ are values with the same magnitude but opposite signs, then return positive zero.
    
*   Else return the result of adding z1​ and z2​, [rounded](#aux-ieee) to the nearest representable value.
    

[fadd](#op-fadd)N​(±[nan](#syntax-float)(n),z2​)[fadd](#op-fadd)N​(z1​,±[nan](#syntax-float)(n))[fadd](#op-fadd)N​(±∞,∓∞)[fadd](#op-fadd)N​(±∞,±∞)[fadd](#op-fadd)N​(z1​,±∞)[fadd](#op-fadd)N​(±∞,z2​)[fadd](#op-fadd)N​(±0,∓0)[fadd](#op-fadd)N​(±0,±0)[fadd](#op-fadd)N​(z1​,±0)[fadd](#op-fadd)N​(±0,z2​)[fadd](#op-fadd)N​(±q,∓q)[fadd](#op-fadd)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}[nans](#aux-nans)N​{}±∞±∞±∞+0±0z1​z2​+0[float](#aux-ieee)N​(z1​+z2​)​​

##### 4.3.3.4. [fsub](#op-fsub)N​(z1​,z2​)[](#-hrefop-fsubmathrmfsub_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if both z1​ and z2​ are infinities of equal signs, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ and z2​ are infinities of opposite sign, then return z1​.
    
*   Else if z1​ is an infinity, then return that infinity.
    
*   Else if z2​ is an infinity, then return that infinity negated.
    
*   Else if both z1​ and z2​ are zeroes of equal sign, then return positive zero.
    
*   Else if both z1​ and z2​ are zeroes of opposite sign, then return z1​.
    
*   Else if z2​ is a zero, then return z1​.
    
*   Else if z1​ is a zero, then return z2​ negated.
    
*   Else if both z1​ and z2​ are the same value, then return positive zero.
    
*   Else return the result of subtracting z2​ from z1​, [rounded](#aux-ieee) to the nearest representable value.
    

[fsub](#op-fsub)N​(±[nan](#syntax-float)(n),z2​)[fsub](#op-fsub)N​(z1​,±[nan](#syntax-float)(n))[fsub](#op-fsub)N​(±∞,±∞)[fsub](#op-fsub)N​(±∞,∓∞)[fsub](#op-fsub)N​(z1​,±∞)[fsub](#op-fsub)N​(±∞,z2​)[fsub](#op-fsub)N​(±0,±0)[fsub](#op-fsub)N​(±0,∓0)[fsub](#op-fsub)N​(z1​,±0)[fsub](#op-fsub)N​(±0,±q2​)[fsub](#op-fsub)N​(±q,±q)[fsub](#op-fsub)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}[nans](#aux-nans)N​{}±∞∓∞±∞+0±0z1​∓q2​+0[float](#aux-ieee)N​(z1​−z2​)​​

Note

Up to the non-determinism regarding NaNs, it always holds that [fsub](#op-fsub)N​(z1​,z2​)\=[fadd](#op-fadd)N​(z1​,[fneg](#op-fneg)N​(z2​)).

##### 4.3.3.5. [fmul](#op-fmul)N​(z1​,z2​)[](#-hrefop-fmulmathrmfmul_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if one of z1​ and z2​ is a zero and the other an infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ and z2​ are infinities of equal sign, then return positive infinity.
    
*   Else if both z1​ and z2​ are infinities of opposite sign, then return negative infinity.
    
*   Else if either z1​ or z2​ is an infinity and the other a value with equal sign, then return positive infinity.
    
*   Else if either z1​ or z2​ is an infinity and the other a value with opposite sign, then return negative infinity.
    
*   Else if both z1​ and z2​ are zeroes of equal sign, then return positive zero.
    
*   Else if both z1​ and z2​ are zeroes of opposite sign, then return negative zero.
    
*   Else return the result of multiplying z1​ and z2​, [rounded](#aux-ieee) to the nearest representable value.
    

[fmul](#op-fmul)N​(±[nan](#syntax-float)(n),z2​)[fmul](#op-fmul)N​(z1​,±[nan](#syntax-float)(n))[fmul](#op-fmul)N​(±∞,±0)[fmul](#op-fmul)N​(±∞,∓0)[fmul](#op-fmul)N​(±0,±∞)[fmul](#op-fmul)N​(±0,∓∞)[fmul](#op-fmul)N​(±∞,±∞)[fmul](#op-fmul)N​(±∞,∓∞)[fmul](#op-fmul)N​(±q1​,±∞)[fmul](#op-fmul)N​(±q1​,∓∞)[fmul](#op-fmul)N​(±∞,±q2​)[fmul](#op-fmul)N​(±∞,∓q2​)[fmul](#op-fmul)N​(±0,±0)[fmul](#op-fmul)N​(±0,∓0)[fmul](#op-fmul)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}+∞−∞+∞−∞+∞−∞+0−0[float](#aux-ieee)N​(z1​⋅z2​)​​

##### 4.3.3.6. [fdiv](#op-fdiv)N​(z1​,z2​)[](#-hrefop-fdivmathrmfdiv_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if both z1​ and z2​ are infinities, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ and z2​ are zeroes, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if z1​ is an infinity and z2​ a value with equal sign, then return positive infinity.
    
*   Else if z1​ is an infinity and z2​ a value with opposite sign, then return negative infinity.
    
*   Else if z2​ is an infinity and z1​ a value with equal sign, then return positive zero.
    
*   Else if z2​ is an infinity and z1​ a value with opposite sign, then return negative zero.
    
*   Else if z1​ is a zero and z2​ a value with equal sign, then return positive zero.
    
*   Else if z1​ is a zero and z2​ a value with opposite sign, then return negative zero.
    
*   Else if z2​ is a zero and z1​ a value with equal sign, then return positive infinity.
    
*   Else if z2​ is a zero and z1​ a value with opposite sign, then return negative infinity.
    
*   Else return the result of dividing z1​ by z2​, [rounded](#aux-ieee) to the nearest representable value.
    

[fdiv](#op-fdiv)N​(±[nan](#syntax-float)(n),z2​)[fdiv](#op-fdiv)N​(z1​,±[nan](#syntax-float)(n))[fdiv](#op-fdiv)N​(±∞,±∞)[fdiv](#op-fdiv)N​(±∞,∓∞)[fdiv](#op-fdiv)N​(±0,±0)[fdiv](#op-fdiv)N​(±0,∓0)[fdiv](#op-fdiv)N​(±∞,±q2​)[fdiv](#op-fdiv)N​(±∞,∓q2​)[fdiv](#op-fdiv)N​(±q1​,±∞)[fdiv](#op-fdiv)N​(±q1​,∓∞)[fdiv](#op-fdiv)N​(±0,±q2​)[fdiv](#op-fdiv)N​(±0,∓q2​)[fdiv](#op-fdiv)N​(±q1​,±0)[fdiv](#op-fdiv)N​(±q1​,∓0)[fdiv](#op-fdiv)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}+∞−∞+0−0+0−0+∞−∞[float](#aux-ieee)N​(z1​/z2​)​​

##### 4.3.3.7. [fma](#op-fma)N​(z1​,z2​,z3​)[](#-hrefop-fmamathrmfma_n-z_1-z_2-z_3)

The function [fma](#op-fma) is the same as _fusedMultiplyAdd_ defined by [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") (Section 5.4.1). It computes (z1​⋅z2​)+z3​ as if with unbounded range and precision, rounding only once for the final result.

*   If either z1​ or z2​ or z3​ is a NaN, return an element of [nans](#aux-nans)N​z1​,z2​,z3​.
    
*   Else if either z1​ or z2​ is a zero and the other is an infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ or z2​ are infinities of equal sign, and z3​ is a negative infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ or z2​ are infinities of opposite sign, and z3​ is a positive infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if either z1​ or z2​ is an infinity and the other is a value of the same sign, and z3​ is a negative infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if either z1​ or z2​ is an infinity and the other is a value of the opposite sign, and z3​ is a positive infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if both z1​ and z2​ are zeroes of the same sign and z3​ is a zero, then return positive zero.
    
*   Else if both z1​ and z2​ are zeroes of the opposite sign and z3​ is a positive zero, then return positive zero.
    
*   Else if both z1​ and z2​ are zeroes of the opposite sign and z3​ is a negative zero, then return negative zero.
    
*   Else return the result of multiplying z1​ and z2​, adding z3​ to the intermediate, and the final result ref:rounded <aux-ieee> to the nearest representable value.
    

​[fma](#op-fma)N​(±[nan](#syntax-float)(n),z2​,z3​)[fma](#op-fma)N​(z1​,±[nan](#syntax-float)(n),z3​)[fma](#op-fma)N​(z1​,z2​,±[nan](#syntax-float)(n))[fma](#op-fma)N​(±∞,±0,z3​)[fma](#op-fma)N​(±∞,∓0,z3​)[fma](#op-fma)N​(±∞,±∞,−∞)[fma](#op-fma)N​(±∞,∓∞,+∞)[fma](#op-fma)N​(±q1​,±∞,−∞)[fma](#op-fma)N​(±q1​,∓∞,+∞)[fma](#op-fma)N​(±∞,±q1​,−∞)[fma](#op-fma)N​(∓∞,±q1​,+∞)[fma](#op-fma)N​(±0,±0,∓0)[fma](#op-fma)N​(±0,±0,±0)[fma](#op-fma)N​(±0,∓0,+0)[fma](#op-fma)N​(±0,∓0,−0)[fma](#op-fma)N​(z1​,z2​,z3​)​\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​,z3​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​,z3​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​,z2​}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}[nans](#aux-nans)N​{}+0+0+0−0[float](#aux-ieee)N​(z1​⋅z2​+z3​)​​

##### 4.3.3.8. [fmin](#op-fmin)N​(z1​,z2​)[](#-hrefop-fminmathrmfmin_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if either z1​ or z2​ is a negative infinity, then return negative infinity.
    
*   Else if either z1​ or z2​ is a positive infinity, then return the other value.
    
*   Else if both z1​ and z2​ are zeroes of opposite signs, then return negative zero.
    
*   Else return the smaller value of z1​ and z2​.
    

[fmin](#op-fmin)N​(±[nan](#syntax-float)(n),z2​)[fmin](#op-fmin)N​(z1​,±[nan](#syntax-float)(n))[fmin](#op-fmin)N​(+∞,z2​)[fmin](#op-fmin)N​(−∞,z2​)[fmin](#op-fmin)N​(z1​,+∞)[fmin](#op-fmin)N​(z1​,−∞)[fmin](#op-fmin)N​(±0,∓0)[fmin](#op-fmin)N​(z1​,z2​)[fmin](#op-fmin)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}z2​−∞z1​−∞−0z1​z2​​(ifz1​≤z2​)(ifz2​≤z1​)​​

##### 4.3.3.9. [fmax](#op-fmax)N​(z1​,z2​)[](#-hrefop-fmaxmathrmfmax_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return an element of [nans](#aux-nans)N​{z1​,z2​}.
    
*   Else if either z1​ or z2​ is a positive infinity, then return positive infinity.
    
*   Else if either z1​ or z2​ is a negative infinity, then return the other value.
    
*   Else if both z1​ and z2​ are zeroes of opposite signs, then return positive zero.
    
*   Else return the larger value of z1​ and z2​.
    

[fmax](#op-fmax)N​(±[nan](#syntax-float)(n),z2​)[fmax](#op-fmax)N​(z1​,±[nan](#syntax-float)(n))[fmax](#op-fmax)N​(+∞,z2​)[fmax](#op-fmax)N​(−∞,z2​)[fmax](#op-fmax)N​(z1​,+∞)[fmax](#op-fmax)N​(z1​,−∞)[fmax](#op-fmax)N​(±0,∓0)[fmax](#op-fmax)N​(z1​,z2​)[fmax](#op-fmax)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z2​}[nans](#aux-nans)N​{±[nan](#syntax-float)(n),z1​}+∞z2​+∞z1​+0z1​z2​​(ifz1​≥z2​)(ifz2​≥z1​)​​

##### 4.3.3.10. [fcopysign](#op-fcopysign)N​(z1​,z2​)[](#-hrefop-fcopysignmathrmfcopysign_n-z_1-z_2)

*   If z1​ and z2​ have the same sign, then return z1​.
    
*   Else return z1​ with negated sign.
    

[fcopysign](#op-fcopysign)N​(±p1​,±p2​)[fcopysign](#op-fcopysign)N​(±p1​,∓p2​)​\=\=​±p1​∓p1​​​

##### 4.3.3.11. [fabs](#op-fabs)N​(z)[](#-hrefop-fabsmathrmfabs_n-z)

*   If z is a NaN, then return z with positive sign.
    
*   Else if z is an infinity, then return positive infinity.
    
*   Else if z is a zero, then return positive zero.
    
*   Else if z is a positive value, then z.
    
*   Else return z negated.
    

[fabs](#op-fabs)N​(±[nan](#syntax-float)(n))[fabs](#op-fabs)N​(±∞)[fabs](#op-fabs)N​(±0)[fabs](#op-fabs)N​(±q)​\=\=\=\=​+[nan](#syntax-float)(n)+∞+0+q​​

##### 4.3.3.12. [fneg](#op-fneg)N​(z)[](#-hrefop-fnegmathrmfneg_n-z)

*   If z is a NaN, then return z with negated sign.
    
*   Else if z is an infinity, then return that infinity negated.
    
*   Else if z is a zero, then return that zero negated.
    
*   Else return z negated.
    

[fneg](#op-fneg)N​(±[nan](#syntax-float)(n))[fneg](#op-fneg)N​(±∞)[fneg](#op-fneg)N​(±0)[fneg](#op-fneg)N​(±q)​\=\=\=\=​∓[nan](#syntax-float)(n)∓∞∓0∓q​​

##### 4.3.3.13. [fsqrt](#op-fsqrt)N​(z)[](#-hrefop-fsqrtmathrmfsqrt_n-z)

*   If z is a NaN, then return an element of [nans](#aux-nans)N​{z}.
    
*   Else if z is negative infinity, then return an element of [nans](#aux-nans)N​{}.
    
*   Else if z is positive infinity, then return positive infinity.
    
*   Else if z is a zero, then return that zero.
    
*   Else if z has a negative sign, then return an element of [nans](#aux-nans)N​{}.
    
*   Else return the square root of z.
    

[fsqrt](#op-fsqrt)N​(±[nan](#syntax-float)(n))[fsqrt](#op-fsqrt)N​(−∞)[fsqrt](#op-fsqrt)N​(+∞)[fsqrt](#op-fsqrt)N​(±0)[fsqrt](#op-fsqrt)N​(−q)[fsqrt](#op-fsqrt)N​(+q)​\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n)}[nans](#aux-nans)N​{}+∞±0[nans](#aux-nans)N​{}[float](#aux-ieee)N​(q​)​​

##### 4.3.3.14. [fceil](#op-fceil)N​(z)[](#-hrefop-fceilmathrmfceil_n-z)

*   If z is a NaN, then return an element of [nans](#aux-nans)N​{z}.
    
*   Else if z is an infinity, then return z.
    
*   Else if z is a zero, then return z.
    
*   Else if z is smaller than 0 but greater than −1, then return negative zero.
    
*   Else return the smallest integral value that is not smaller than z.
    

[fceil](#op-fceil)N​(±[nan](#syntax-float)(n))[fceil](#op-fceil)N​(±∞)[fceil](#op-fceil)N​(±0)[fceil](#op-fceil)N​(−q)[fceil](#op-fceil)N​(±q)​\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n)}±∞±0−0[float](#aux-ieee)N​(i)​(if−1<−q<0)(if±q≤i<±q+1)​​

##### 4.3.3.15. [ffloor](#op-ffloor)N​(z)[](#-hrefop-ffloormathrmffloor_n-z)

*   If z is a NaN, then return an element of [nans](#aux-nans)N​{z}.
    
*   Else if z is an infinity, then return z.
    
*   Else if z is a zero, then return z.
    
*   Else if z is greater than 0 but smaller than 1, then return positive zero.
    
*   Else return the largest integral value that is not larger than z.
    

[ffloor](#op-ffloor)N​(±[nan](#syntax-float)(n))[ffloor](#op-ffloor)N​(±∞)[ffloor](#op-ffloor)N​(±0)[ffloor](#op-ffloor)N​(+q)[ffloor](#op-ffloor)N​(±q)​\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n)}±∞±0+0[float](#aux-ieee)N​(i)​(if0<+q<1)(if±q−1<i≤±q)​​

##### 4.3.3.16. [ftrunc](#op-ftrunc)N​(z)[](#-hrefop-ftruncmathrmftrunc_n-z)

*   If z is a NaN, then return an element of [nans](#aux-nans)N​{z}.
    
*   Else if z is an infinity, then return z.
    
*   Else if z is a zero, then return z.
    
*   Else if z is greater than 0 but smaller than 1, then return positive zero.
    
*   Else if z is smaller than 0 but greater than −1, then return negative zero.
    
*   Else return the integral value with the same sign as z and the largest magnitude that is not larger than the magnitude of z.
    

[ftrunc](#op-ftrunc)N​(±[nan](#syntax-float)(n))[ftrunc](#op-ftrunc)N​(±∞)[ftrunc](#op-ftrunc)N​(±0)[ftrunc](#op-ftrunc)N​(+q)[ftrunc](#op-ftrunc)N​(−q)[ftrunc](#op-ftrunc)N​(±q)​\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n)}±∞±0+0−0[float](#aux-ieee)N​(±i)​(if0<+q<1)(if−1<−q<0)(if+q−1<i≤+q)​​

##### 4.3.3.17. [fnearest](#op-fnearest)N​(z)[](#-hrefop-fnearestmathrmfnearest_n-z)

*   If z is a NaN, then return an element of [nans](#aux-nans)N​{z}.
    
*   Else if z is an infinity, then return z.
    
*   Else if z is a zero, then return z.
    
*   Else if z is greater than 0 but smaller than or equal to 0.5, then return positive zero.
    
*   Else if z is smaller than 0 but greater than or equal to −0.5, then return negative zero.
    
*   Else return the integral value that is nearest to z; if two values are equally near, return the even one.
    

[fnearest](#op-fnearest)N​(±[nan](#syntax-float)(n))[fnearest](#op-fnearest)N​(±∞)[fnearest](#op-fnearest)N​(±0)[fnearest](#op-fnearest)N​(+q)[fnearest](#op-fnearest)N​(−q)[fnearest](#op-fnearest)N​(±q)[fnearest](#op-fnearest)N​(±q)​\=\=\=\=\=\=\=​[nans](#aux-nans)N​{±[nan](#syntax-float)(n)}±∞±0+0−0[float](#aux-ieee)N​(±i)[float](#aux-ieee)N​(±i)​(if0<+q≤0.5)(if−0.5≤−q<0)(if∣i−q∣<0.5)(if∣i−q∣\=0.5∧i even)​​

##### 4.3.3.18. [feq](#op-feq)N​(z1​,z2​)[](#-hrefop-feqmathrmfeq_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 0.
    
*   Else if both z1​ and z2​ are zeroes, then return 1.
    
*   Else if both z1​ and z2​ are the same value, then return 1.
    
*   Else return 0.
    

[feq](#op-feq)N​(±[nan](#syntax-float)(n),z2​)[feq](#op-feq)N​(z1​,±[nan](#syntax-float)(n))[feq](#op-feq)N​(±0,∓0)[feq](#op-feq)N​(z1​,z2​)​\=\=\=\=​001[bool](#aux-tobool)(z1​\=z2​)​​

##### 4.3.3.19. [fne](#op-fne)N​(z1​,z2​)[](#-hrefop-fnemathrmfne_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 1.
    
*   Else if both z1​ and z2​ are zeroes, then return 0.
    
*   Else if both z1​ and z2​ are the same value, then return 0.
    
*   Else return 1.
    

[fne](#op-fne)N​(±[nan](#syntax-float)(n),z2​)[fne](#op-fne)N​(z1​,±[nan](#syntax-float)(n))[fne](#op-fne)N​(±0,∓0)[fne](#op-fne)N​(z1​,z2​)​\=\=\=\=​110[bool](#aux-tobool)(z1​\=z2​)​​

##### 4.3.3.20. [flt](#op-flt)N​(z1​,z2​)[](#-hrefop-fltmathrmflt_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 0.
    
*   Else if z1​ and z2​ are the same value, then return 0.
    
*   Else if z1​ is positive infinity, then return 0.
    
*   Else if z1​ is negative infinity, then return 1.
    
*   Else if z2​ is positive infinity, then return 1.
    
*   Else if z2​ is negative infinity, then return 0.
    
*   Else if both z1​ and z2​ are zeroes, then return 0.
    
*   Else if z1​ is smaller than z2​, then return 1.
    
*   Else return 0.
    

[flt](#op-flt)N​(±[nan](#syntax-float)(n),z2​)[flt](#op-flt)N​(z1​,±[nan](#syntax-float)(n))[flt](#op-flt)N​(z,z)[flt](#op-flt)N​(+∞,z2​)[flt](#op-flt)N​(−∞,z2​)[flt](#op-flt)N​(z1​,+∞)[flt](#op-flt)N​(z1​,−∞)[flt](#op-flt)N​(±0,∓0)[flt](#op-flt)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​00001100[bool](#aux-tobool)(z1​<z2​)​​

##### 4.3.3.21. [fgt](#op-fgt)N​(z1​,z2​)[](#-hrefop-fgtmathrmfgt_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 0.
    
*   Else if z1​ and z2​ are the same value, then return 0.
    
*   Else if z1​ is positive infinity, then return 1.
    
*   Else if z1​ is negative infinity, then return 0.
    
*   Else if z2​ is positive infinity, then return 0.
    
*   Else if z2​ is negative infinity, then return 1.
    
*   Else if both z1​ and z2​ are zeroes, then return 0.
    
*   Else if z1​ is larger than z2​, then return 1.
    
*   Else return 0.
    

[fgt](#op-fgt)N​(±[nan](#syntax-float)(n),z2​)[fgt](#op-fgt)N​(z1​,±[nan](#syntax-float)(n))[fgt](#op-fgt)N​(z,z)[fgt](#op-fgt)N​(+∞,z2​)[fgt](#op-fgt)N​(−∞,z2​)[fgt](#op-fgt)N​(z1​,+∞)[fgt](#op-fgt)N​(z1​,−∞)[fgt](#op-fgt)N​(±0,∓0)[fgt](#op-fgt)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​00010010[bool](#aux-tobool)(z1​\>z2​)​​

##### 4.3.3.22. [fle](#op-fle)N​(z1​,z2​)[](#-hrefop-flemathrmfle_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 0.
    
*   Else if z1​ and z2​ are the same value, then return 1.
    
*   Else if z1​ is positive infinity, then return 0.
    
*   Else if z1​ is negative infinity, then return 1.
    
*   Else if z2​ is positive infinity, then return 1.
    
*   Else if z2​ is negative infinity, then return 0.
    
*   Else if both z1​ and z2​ are zeroes, then return 1.
    
*   Else if z1​ is smaller than or equal to z2​, then return 1.
    
*   Else return 0.
    

[fle](#op-fle)N​(±[nan](#syntax-float)(n),z2​)[fle](#op-fle)N​(z1​,±[nan](#syntax-float)(n))[fle](#op-fle)N​(z,z)[fle](#op-fle)N​(+∞,z2​)[fle](#op-fle)N​(−∞,z2​)[fle](#op-fle)N​(z1​,+∞)[fle](#op-fle)N​(z1​,−∞)[fle](#op-fle)N​(±0,∓0)[fle](#op-fle)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​00101101[bool](#aux-tobool)(z1​≤z2​)​​

##### 4.3.3.23. [fge](#op-fge)N​(z1​,z2​)[](#-hrefop-fgemathrmfge_n-z_1-z_2)

*   If either z1​ or z2​ is a NaN, then return 0.
    
*   Else if z1​ and z2​ are the same value, then return 1.
    
*   Else if z1​ is positive infinity, then return 1.
    
*   Else if z1​ is negative infinity, then return 0.
    
*   Else if z2​ is positive infinity, then return 0.
    
*   Else if z2​ is negative infinity, then return 1.
    
*   Else if both z1​ and z2​ are zeroes, then return 1.
    
*   Else if z1​ is larger than or equal to z2​, then return 1.
    
*   Else return 0.
    

[fge](#op-fge)N​(±[nan](#syntax-float)(n),z2​)[fge](#op-fge)N​(z1​,±[nan](#syntax-float)(n))[fge](#op-fge)N​(z,z)[fge](#op-fge)N​(+∞,z2​)[fge](#op-fge)N​(−∞,z2​)[fge](#op-fge)N​(z1​,+∞)[fge](#op-fge)N​(z1​,−∞)[fge](#op-fge)N​(±0,∓0)[fge](#op-fge)N​(z1​,z2​)​\=\=\=\=\=\=\=\=\=​00110011[bool](#aux-tobool)(z1​≥z2​)​​

##### 4.3.3.24. [fpmin](#op-fpmin)N​(z1​,z2​)[](#-hrefop-fpminmathrmfpmin_n-z_1-z_2)

*   If z2​ is less than z1​ then return z2​.
    
*   Else return z1​.
    

[fpmin](#op-fpmin)N​(z1​,z2​)[fpmin](#op-fpmin)N​(z1​,z2​)​\=\=​z2​z1​​(if[flt](#op-flt)N​(z2​,z1​)\=1)(otherwise)​​

##### 4.3.3.25. [fpmax](#op-fpmax)N​(z1​,z2​)[](#-hrefop-fpmaxmathrmfpmax_n-z_1-z_2)

*   If z1​ is less than z2​ then return z2​.
    
*   Else return z1​.
    

[fpmax](#op-fpmax)N​(z1​,z2​)[fpmax](#op-fpmax)N​(z1​,z2​)​\=\=​z2​z1​​(if[flt](#op-flt)N​(z1​,z2​)\=1)(otherwise)​​

#### 4.3.4. Conversions[](#conversions①)

##### 4.3.4.1. [extendu](#op-extend)M,N​(i)[](#-hrefop-extendmathrmextendmathsfu_m-n-i)

*   Return i.
    

[extendu](#op-extend)M,N​(i)​\=​i​​

Note

In the abstract syntax, unsigned extension just reinterprets the same value.

##### 4.3.4.2. [extends](#op-extend)M,N​(i)[](#-hrefop-extendmathrmextendmathsfs_m-n-i)

*   Let j be the [signed interpretation](#aux-signed) of i of size M.
    
*   Return the two’s complement of j relative to size N.
    

[extends](#op-extend)M,N​(i)​\=​[signed](#aux-signed)N−1​([signed](#aux-signed)M​(i))​​

##### 4.3.4.3. [wrap](#op-wrap)M,N​(i)[](#-hrefop-wrapmathrmwrap_m-n-i)

*   Return i modulo 2N.
    

[wrap](#op-wrap)M,N​(i)​\=​imod2N​​

##### 4.3.4.4. [truncu](#op-trunc)M,N​(z)[](#-hrefop-truncmathrmtruncmathsfu_m-n-z)

*   If z is a NaN, then the result is undefined.
    
*   Else if z is an infinity, then the result is undefined.
    
*   Else if z is a number and [trunc](#aux-trunc)(z) is a value within range of the target type, then return that value.
    
*   Else the result is undefined.
    

[truncu](#op-trunc)M,N​(±[nan](#syntax-float)(n))[truncu](#op-trunc)M,N​(±∞)[truncu](#op-trunc)M,N​(±q)[truncu](#op-trunc)M,N​(±q)​\=\=\=\=​{}{}[trunc](#aux-trunc)(±q){}​(if−1<[trunc](#aux-trunc)(±q)<2N)(otherwise)​​

Note

This operator is [partial](#exec-op-partial). It is not defined for NaNs, infinities, or values for which the result is out of range.

##### 4.3.4.5. [truncs](#op-trunc)M,N​(z)[](#-hrefop-truncmathrmtruncmathsfs_m-n-z)

*   If z is a NaN, then the result is undefined.
    
*   Else if z is an infinity, then the result is undefined.
    
*   If z is a number and [trunc](#aux-trunc)(z) is a value within range of the target type, then return that value.
    
*   Else the result is undefined.
    

[truncs](#op-trunc)M,N​(±[nan](#syntax-float)(n))[truncs](#op-trunc)M,N​(±∞)[truncs](#op-trunc)M,N​(±q)[truncs](#op-trunc)M,N​(±q)​\=\=\=\=​{}{}[trunc](#aux-trunc)(±q){}​(if−2N−1−1<[trunc](#aux-trunc)(±q)<2N−1)(otherwise)​​

Note

This operator is [partial](#exec-op-partial). It is not defined for NaNs, infinities, or values for which the result is out of range.

##### 4.3.4.6. [trunc\_sat\_u](#op-trunc-sat)M,N​(z)[](#-hrefop-trunc-satmathrmtrunc_sat_u_m-n-z)

*   If z is a NaN, then return 0.
    
*   Else if z is negative infinity, then return 0.
    
*   Else if z is positive infinity, then return 2N−1.
    
*   Else, return [sat\_u](#aux-sat)N​([trunc](#aux-trunc)(z)).
    

[trunc\_sat\_u](#op-trunc-sat)M,N​(±[nan](#syntax-float)(n))[trunc\_sat\_u](#op-trunc-sat)M,N​(−∞)[trunc\_sat\_u](#op-trunc-sat)M,N​(+∞)[trunc\_sat\_u](#op-trunc-sat)M,N​(z)​\=\=\=\=​002N−1[sat\_u](#aux-sat)N​([trunc](#aux-trunc)(z))​​

##### 4.3.4.7. [trunc\_sat\_s](#op-trunc-sat)M,N​(z)[](#-hrefop-trunc-satmathrmtrunc_sat_s_m-n-z)

*   If z is a NaN, then return 0.
    
*   Else if z is negative infinity, then return −2N−1.
    
*   Else if z is positive infinity, then return 2N−1−1.
    
*   Else, return the value whose signed interpretation is [sat\_s](#aux-sat)N​([trunc](#op-trunc)(z)).
    

[trunc\_sat\_s](#op-trunc-sat)M,N​(±[nan](#syntax-float)(n))[trunc\_sat\_s](#op-trunc-sat)M,N​(−∞)[trunc\_sat\_s](#op-trunc-sat)M,N​(+∞)[trunc\_sat\_s](#op-trunc-sat)M,N​(z)​\=\=\=\=​0−2N−12N−1−1[signed](#aux-signed)N−1​([sat\_s](#aux-sat)N​([trunc](#op-trunc)(z)))​​

##### 4.3.4.8. [promote](#op-promote)M,N​(z)[](#-hrefop-promotemathrmpromote_m-n-z)

*   If z is a [canonical NaN](#canonical-nan), then return an element of [nans](#aux-nans)N​{} (i.e., a canonical NaN of size N).
    
*   Else if z is a NaN, then return an element of [nans](#aux-nans)N​{±[nan](#syntax-float)(1)} (i.e., any [arithmetic NaN](#arithmetic-nan) of size N).
    
*   Else, return z.
    

[promote](#op-promote)M,N​(±[nan](#syntax-float)(n))[promote](#op-promote)M,N​(±[nan](#syntax-float)(n))[promote](#op-promote)M,N​(z)​\=\=\=​[nans](#aux-nans)N​{}[nans](#aux-nans)N​{+[nan](#syntax-float)(1)}z​(ifn\=[canon](#aux-canon)N​)(otherwise)​​

##### 4.3.4.9. [demote](#op-demote)M,N​(z)[](#-hrefop-demotemathrmdemote_m-n-z)

*   If z is a [canonical NaN](#canonical-nan), then return an element of [nans](#aux-nans)N​{} (i.e., a canonical NaN of size N).
    
*   Else if z is a NaN, then return an element of [nans](#aux-nans)N​{±[nan](#syntax-float)(1)} (i.e., any NaN of size N).
    
*   Else if z is an infinity, then return that infinity.
    
*   Else if z is a zero, then return that zero.
    
*   Else, return [float](#aux-ieee)N​(z).
    

[demote](#op-demote)M,N​(±[nan](#syntax-float)(n))[demote](#op-demote)M,N​(±[nan](#syntax-float)(n))[demote](#op-demote)M,N​(±∞)[demote](#op-demote)M,N​(±0)[demote](#op-demote)M,N​(±q)​\=\=\=\=\=​[nans](#aux-nans)N​{}[nans](#aux-nans)N​{+[nan](#syntax-float)(1)}±∞±0[float](#aux-ieee)N​(±q)​(ifn\=[canon](#aux-canon)N​)(otherwise)​

##### 4.3.4.10. [convertu](#op-convert)M,N​(i)[](#-hrefop-convertmathrmconvertmathsfu_m-n-i)

*   Return [float](#aux-ieee)N​(i).
    

[convertu](#op-convert)M,N​(i)​\=​[float](#aux-ieee)N​(i)​​

##### 4.3.4.11. [converts](#op-convert)M,N​(i)[](#-hrefop-convertmathrmconvertmathsfs_m-n-i)

*   Let j be the [signed interpretation](#aux-signed) of i.
    
*   Return [float](#aux-ieee)N​(j).
    

[converts](#op-convert)M,N​(i)​\=​[float](#aux-ieee)N​([signed](#aux-signed)M​(i))​​

##### 4.3.4.12. [reinterpret](#op-reinterpret)t1​,t2​​(c)[](#-hrefop-reinterpretmathrmreinterpret_t_1-t_2-c)

*   Let d∗ be the bit sequence [bits](#aux-bits)t1​​(c).
    
*   Return the constant c′ for which [bits](#aux-bits)t2​​(c′)\=d∗.
    

[reinterpret](#op-reinterpret)t1​,t2​​(c)​\=​[bits](#aux-bits)t2​−1​([bits](#aux-bits)t1​​(c))​​

##### 4.3.4.13. [narrows](#op-narrow)M,N​(i)[](#-hrefop-narrowmathrmnarrowmathsfs_m-n-i)

*   Let j be the [signed interpretation](#aux-signed) of i of size M.
    
*   Return the value whose signed interpretation is [sat\_s](#aux-sat)N​(j).
    

[narrows](#op-narrow)M,N​(i)​\=​[signed](#aux-signed)N−1​([sat\_s](#aux-sat)N​([signed](#aux-signed)M​(i)))​

##### 4.3.4.14. [narrowu](#op-narrow)M,N​(i)[](#-hrefop-narrowmathrmnarrowmathsfu_m-n-i)

*   Let j be the [signed interpretation](#aux-signed) of i of size M.
    
*   Return [sat\_u](#aux-sat)N​(j).
    

[narrowu](#op-narrow)M,N​(i)​\=​[sat\_u](#aux-sat)N​([signed](#aux-signed)M​(i))​

#### 4.3.5. Vector Operations[](#vector-operations①)

Most vector operations are performed by applying numeric operations lanewise. However, some operators consider multiple lanes at once.

##### 4.3.5.1. [ivbitmask](#op-ivbitmask)N​(im)[](#-hrefop-ivbitmaskmathrmivbitmask_n-im)

1.  For each ik​ in im, let bk​ be the result of computing [ilt\_s](#op-ilt)N​(i,0).
    
2.  Let bm be the concatenation of all bk​.
    
3.  Return the result of computing [ibits](#aux-ibits)32−1​((0)32−m bm).
    

[ivbitmask](#op-ivbitmask)N​(im)​\=​[ibits](#aux-ibits)32−1​((0)32−m [ilt\_s](#op-ilt)N​(i,0)m)​

##### 4.3.5.2. [ivswizzle](#op-ivswizzle)(in,jn)[](#-hrefop-ivswizzlemathrmivswizzle-in-jn)

1.  For each jk​ in jn, let rk​ be the value [ivswizzle\_lane](#op-ivswizzle-lane)(in,jk​).
    
2.  Let rn be the concatenation of all rk​.
    
3.  Return rn.
    

[ivswizzle](#op-ivswizzle)(in,jn)​\=​[ivswizzle\_lane](#op-ivswizzle-lane)(in,j)n​​

where:

[ivswizzle\_lane](#op-ivswizzle-lane)(in,j)[ivswizzle\_lane](#op-ivswizzle-lane)(in,j)​\=\=​in\[j\]0​(ifj<n)(otherwise)​​

##### 4.3.5.3. [ivshuffle](#op-ivshuffle)(jn,i1n​,i2n​)[](#-hrefop-ivshufflemathrmivshuffle-jn-i_1n-i_2n)

1.  Let i∗ ne the concatenation of i1n​ and i2n​.
    
2.  For each jk​ in jn, let rk​ be i∗\[jk​\].
    
3.  Let rn be the concatenation of all rk​.
    
4.  Return rn.
    

[ivshuffle](#op-ivshuffle)(jn,i1n​,i2n​)​\=​((i1n​ i2n​)\[j\])n​(if(j<2⋅n)n)​

##### 4.3.5.4. [ivadd\_pairwise](#op-ivadd-pairwise)N​(i2m)[](#-hrefop-ivadd-pairwisemathrmivadd_pairwise_n-i2m)

1.  Let (i1​ i2​)m be i2m, decomposed into pairwise elements.
    
2.  For each i1k​ in i1m​ and corresponding i2k​ in i2m​, let rk​ be [iadd](#op-iadd)N​(i1k​,i2k​).
    
3.  Let rm be the concatenation of all rk​.
    
4.  Return rm.
    

[ivadd\_pairwise](#op-ivadd-pairwise)N​(i2m)​\=​([iadd](#op-iadd)N​(i1​,i2​))m​(ifi2m\=(i1​ i2​)m)​

##### 4.3.5.5. [ivmul](#op-ivmul)N​(i1m​,i2m​)[](#-hrefop-ivmulmathrmivmul_n-i_1m-i_2m)

1.  For each i1k​ in i1m​ and corresponding i2k​ in i2m​, let rk​ be [imul](#op-imul)N​(i1k​,i2k​).
    
2.  Let rm be the concatenation of all rk​.
    
3.  Return rm.
    

[ivmul](#op-ivmul)N​(i1m​,i2m​)​\=​([imul](#op-imul)N​(i1​,i2​))m​

##### 4.3.5.6. [ivdot](#op-ivdot)N​(i12m​,i22m​)[](#-hrefop-ivdotmathrmivdot_n-i_12m-i_22m)

1.  For each i1k​ in i12m​ and corresponding i2k​ in i22m​, let jk​ be [imul](#op-imul)N​(i1k​,i2k​).
    
2.  Let j2m be the concatenation of all jk​.
    
3.  Let (j1​ j2​)m be j2m, decomposed into pairwise elements.
    
4.  For each i1k​ in i1m​ and corresponding i2k​ in i2m​, let rk​ be [iadd](#op-iadd)N​(i1k​,i2k​).
    
5.  Let rm be the concatenation of all rk​.
    
6.  Return rm.
    

[ivdot](#op-ivdot)N​(i12m​,i22m​)​\=​([iadd](#op-iadd)N​(j1​,j2​))m​(if([imul](#op-imul)N​(i1​,i2​))2m\=(j1​ j2​)m)​

##### 4.3.5.7. [ivdotsat](#op-ivdot-sat)N​(i1m​,i2m​)[](#-hrefop-ivdot-satmathrmivdotsat_n-i_1m-i_2m)

1.  For each i1k​ in i12m​ and corresponding i2k​ in i22m​, let jk​ be [imul](#op-imul)N​(i1k​,i2k​).
    
2.  Let j2m be the concatenation of all jk​.
    
3.  Let (j1​ j2​)m be j2m, decomposed into pairwise elements.
    
4.  For each i1k​ in i1m​ and corresponding i2k​ in i2m​, let rk​ be [iadd\_sat](#op-iadd-sat)N​(i1k​,i2k​).
    
5.  Let rm be the concatenation of all rk​.
    
6.  Return rm.
    

[ivdotsat](#op-ivdot-sat)N​(i12m​,i22m​)​\=​([iadd\_sat](#op-iadd-sat)N​(j1​,j2​))m​(if([imul](#op-imul)N​(i1​,i2​))2m\=(j1​ j2​)m)​

The previous operators are lifted to operators on arguments of vector type by wrapping them in corresponding lane projections and injections and intermediate extension operations:

##### 4.3.5.8. [vextunop](#syntax-vextunop)sh1​,sh2​​(c)[](#-hrefsyntax-vextunopmathitvextunop_mathitsh_1-mathitsh_2-c)

[extadd\_pairwise](#syntax-instr-vec)\_[sx](#syntax-sx)iN1​xM1​,iN2​xM2​​(c)​\=​[lanes](#aux-lanes)iN2​xM2​−1​(j∗)​(ifi∗\=[lanes](#aux-lanes)iN1​xM1​​(c)∧ i′∗\=[extend](#op-extend)N1​,N2​[sx](#syntax-sx)​(i)∗∧ j∗\=[ivadd\_pairwise](#op-ivadd-pairwise)N2​​(i′∗)​​​

##### 4.3.5.9. [vextbinop](#syntax-vextbinop)sh1​,sh2​​(c1​,c2​)[](#-hrefsyntax-vextbinopmathitvextbinop_mathitsh_1-mathitsh_2-c_1-c_2)

[vextbinop](#syntax-vextbinop)iN1​xM1​,iN2​xM2​​(c1​,c2​)​\=​[lanes](#aux-lanes)iN2​xM2​−1​(j∗)​(ifi1∗​\=[lanes](#aux-lanes)iN1​xM1​​(c1​)\[h[:](#notation-slice)k\]∧ i2∗​\=[lanes](#aux-lanes)iN1​xM1​​(c2​)\[h[:](#notation-slice)k\]∧ i1′​∗\=[extend](#op-extend)N1​,N2​[sx](#syntax-sx)​(i1​)∗∧ i2′​∗\=[extend](#op-extend)N1​,N2​[sx](#syntax-sx)​(i2​)∗∧ j∗\=fN2​​(i1′​∗,i1′​∗)​​​

where f, [sx](#syntax-sx)1​, [sx](#syntax-sx)2​, h, and k are instantiated as follows, depending on the operator:

[vextbinop](#syntax-vextbinop)[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[sx](#syntax-sx)[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[sx](#syntax-sx)[dot](#syntax-instr-vec)\_[s](#syntax-sx)[relaxed\_dot](#syntax-instr-vec)\_[s](#syntax-sx)​f[ivmul](#op-ivmul)[ivmul](#op-ivmul)[ivdot](#op-ivdot)[ivdotsat](#op-ivdot-sat)​[sx](#syntax-sx)1​[sx](#syntax-sx)[sx](#syntax-sx)[s](#syntax-sx)[s](#syntax-sx)​[sx](#syntax-sx)2​[sx](#syntax-sx)[sx](#syntax-sx)[s](#syntax-sx)[relaxed](#aux-relaxed)(Ridot​)\[[s](#syntax-sx),[u](#syntax-sx)\]​h0M2​00​kM2​M2​M1​M1​​​​

Note

Relaxed operations and the paramater Ridot​ are introduced [below](#relaxed-ops).

##### 4.3.5.10. [vextternop](#syntax-vextternop)sh1​,sh2​​(c1​,c2​,c3​)[](#-hrefsyntax-vextternopmathitvextternop_mathitsh_1-mathitsh_2-c_1-c_2-c_3)

[relaxed\_dot\_add](#syntax-instr-vec)\_[s](#syntax-sx)iN1​xM1​,iN2​xM2​​(c1​,c2​,c3​)​\=​c​(ifN\=2⋅N1​∧ M\=2⋅M2​∧ c′\=[relaxed\_dot](#syntax-instr-vec)\_[s](#syntax-sx)iN1​xM1​,iNxM​(c1​,c2​)∧ c′′\=[extadd\_pairwise](#syntax-instr-vec)\_[s](#syntax-sx)iNxM,iN2​xM2​​(c′)∧ c∈[add](#syntax-instr-vec)iN2​xM2​​(c′′,c3​)​​​

##### 4.3.5.11. [narrow](#syntax-instr-vec)\_[sx](#syntax-sx)sh1​,sh2​​(c1​,c2​)[](#-hrefsyntax-instr-vecmathsfnarrowmathsf_hrefsyntax-sxmathitsx_mathitsh_1-mathitsh_2-c_1-c_2)

[narrow](#syntax-instr-vec)\_[sx](#syntax-sx)iN1​xM1​,iN2​xM2​​(c1​,c2​)​\=​[lanes](#aux-lanes)iN2​xM2​−1​(j∗)​(ifi1∗​\=[lanes](#aux-lanes)iN1​xM1​​(c1​)∧ i2∗​\=[lanes](#aux-lanes)iN1​xM1​​(c2​)∧ i1′​∗\=[narrow](#op-narrow)N1​,N2​[sx](#syntax-sx)​(i1​)∗∧ i2′​∗\=[narrow](#op-narrow)N1​,N2​[sx](#syntax-sx)​(i2​)∗∧ j∗\=i1′​∗⊕i1′​∗​​​

##### 4.3.5.12. [vcvtop](#syntax-vcvtop)\_[half](#syntax-half)?\_[zero](#syntax-zero)sh1​,sh2​?​(i)[](#-hrefsyntax-vcvtopmathitvcvtopmathsf_hrefsyntax-halfmathithalfmathsf_hrefsyntax-zeromathitzero_mathitsh_1-mathitsh_2-i)

[vcvtop](#syntax-vcvtop)\_[half](#syntax-half)?\_[zero](#syntax-zero)t1​xM1​,t2​xM2​?​(i)​\=​j​(ifcondition∧ c∗\=[lanes](#aux-lanes)t1​xM1​​(i)\[h[:](#notation-slice)k\]∧ c′∗∗\=×([vcvtop](#syntax-vcvtop)∣t1​∣,∣t2​∣​(c)∗⊕(0)n)∧ j∈[lanes](#aux-lanes)t2​xM2​−1​(c′∗)∗​​​

where h, k, n, and condition are instantiated as follows, depending on the operator:

[half](#syntax-half)?ϵ[low](#syntax-instr-vec)[high](#syntax-instr-vec)ϵ​[zero](#syntax-zero)?ϵϵϵ[zero](#syntax-instr-vec)​h00M2​0​kM1​M2​M2​M1​​n000M1​​condition(M1​\=M2​)(M1​\=2⋅M2​)(M1​\=2⋅M2​)(2⋅M1​\=M2​)​​​

while ×{x∗}N transforms a sequence of N sets of non-deterministic values into a set of non-deterministic sequences of N values by computing the set product:

×(S1​…SN​)​\=​{x1​…xN​ ∣ x1​∈S1​∧⋯∧xN​∈SN​}​

#### 4.3.6. Relaxed Operations[](#relaxed-operations①)

The result of _relaxed_ operators are _implementation-dependent_, because the set of possible results may depend on properties of the host environment, such as its hardware. Technically, their behaviour is controlled by a set of _global parameters_ to the semantics that an implementation can instantiate in different ways. These choices are fixed, that is, parameters are constant during the execution of any given program.

Every such parameter is an index into a sequence of possible sets of results and must be instantiated to a defined index. In the [deterministic profile](#profile-deterministic), every parameter is prescribed to be 0. This behaviour is expressed by the following auxiliary function, where R is a global parameter selecting one of the allowed outcomes:

\[![DET](#profile-deterministic)\]​[relaxed](#aux-relaxed)(R)\[A0​,…,An​\]\=AR​[relaxed](#aux-relaxed)(R)\[A0​,…,An​\]\=A0​​​

Note

Each parameter can be thought of as inducing a family of operations that is fixed to one particular choice by an implementation. The fixed operation itself can still be non-deterministic or partial.

Implementations are expexted to either choose the behaviour that is the most efficient on the underlying hardware, or the behaviour of the deterministic profile.

##### 4.3.6.1. [frelaxed\_madd](#op-frelaxed-madd)N​(z1​,z2​,z3​)[](#-hrefop-frelaxed-maddmathrmfrelaxed_madd_n-z_1-z_2-z_3)

The implementation-specific behaviour of this operation is determined by the global parameter Rfmadd​∈{0,1}.

*   Return [relaxed](#aux-relaxed)(Rfmadd​)\[[fadd](#op-fadd)N​([fmul](#op-fmul)N​(z1​,z2​),z3​),[fma](#op-fma)N​(z1​,z2​,z3​)\].
    

[frelaxed\_madd](#op-frelaxed-madd)N​(z1​,z2​,z3​)​\=​[relaxed](#aux-relaxed)(Rfmadd​)\[[fadd](#op-fadd)N​([fmul](#op-fmul)N​(z1​,z2​),z3​),[fma](#op-fma)N​(z1​,z2​,z3​)\]​​

Note

Relaxed multiply-add allows for fused or unfused results, which leads to implementation-dependent rounding behaviour. In the [deterministic profile](#profile-deterministic), the unfused behaviour is used.

##### 4.3.6.2. [frelaxed\_nmadd](#op-frelaxed-nmadd)N​(z1​,z2​,z3​)[](#-hrefop-frelaxed-nmaddmathrmfrelaxed_nmadd_n-z_1-z_2-z_3)

*   Return [frelaxed\_madd](#op-frelaxed-madd)(−z1​,z2​,z3​).
    

[frelaxed\_nmadd](#op-frelaxed-nmadd)N​(z1​,z2​,z3​)​\=​[frelaxed\_madd](#op-frelaxed-madd)N​(−z1​,z2​,z3​)​​

Note

This operation is implementation-dependent because [frelaxed\_madd](#op-frelaxed-madd) is implementation-dependent.

##### 4.3.6.3. [frelaxed\_min](#op-frelaxed-min)N​(z1​,z2​)[](#-hrefop-frelaxed-minmathrmfrelaxed_min_n-z_1-z_2)

The implementation-specific behaviour of this operation is determined by the global parameter Rfmin​∈{0,1,2,3}.

*   If z1​ is a NaN, then return [relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(z1​,z2​),[nan](#syntax-float)(n),z2​,z2​\].
    
*   If z2​ is a NaN, then return [relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(z1​,z2​),z1​,[nan](#syntax-float)(n),z1​\].
    
*   If both z1​ and z2​ are zeroes of opposite sign, then return [relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(z1​,z2​), pm 0, mp 0, -0 \]\`.
    
*   Return [fmin](#op-fmin)N​(z1​,z2​).
    

[frelaxed\_min](#op-frelaxed-min)N​(±[nan](#syntax-float)(n),z2​)[frelaxed\_min](#op-frelaxed-min)N​(z1​,±[nan](#syntax-float)(n))[frelaxed\_min](#op-frelaxed-min)N​(±0,∓0)[frelaxed\_min](#op-frelaxed-min)N​(z1​,z2​)​\=\=\=\=​[relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(±[nan](#syntax-float)(n),z2​),[nan](#syntax-float)(n),z2​,z2​\][relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(z1​,±[nan](#syntax-float)(n)),z1​,[nan](#syntax-float)(n),z1​\][relaxed](#aux-relaxed)(Rfmin​)\[[fmin](#op-fmin)N​(±0,∓0),±0,∓0,−0\][fmin](#op-fmin)N​(z1​,z2​)​(otherwise)​​

Note

Relaxed minimum is implementation-dependent for NaNs and for zeroes with different signs. In the [deterministic profile](#profile-deterministic), it behaves like regular [fmin](#op-fmin).

##### 4.3.6.4. [frelaxed\_max](#op-frelaxed-max)N​(z1​,z2​)[](#-hrefop-frelaxed-maxmathrmfrelaxed_max_n-z_1-z_2)

The implementation-specific behaviour of this operation is determined by the global parameter Rfmax​∈{0,1,2,3}.

*   If z1​ is a NaN, then return [relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(z1​,z2​),[nan](#syntax-float)(n),z2​,z2​\].
    
*   If z2​ is a NaN, then return [relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(z1​,z2​),z1​,[nan](#syntax-float)(n),z1​\].
    
*   If both z1​ and z2​ are zeroes of opposite sign, then return [relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(z1​,z2​), pm 0, mp 0, +0 \]\`.
    
*   Return [fmax](#op-fmax)N​(z1​,z2​).
    

[frelaxed\_max](#op-frelaxed-max)N​(±[nan](#syntax-float)(n),z2​)[frelaxed\_max](#op-frelaxed-max)N​(z1​,±[nan](#syntax-float)(n))[frelaxed\_max](#op-frelaxed-max)N​(±0,∓0)[frelaxed\_max](#op-frelaxed-max)N​(z1​,z2​)​\=\=\=\=​[relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(±[nan](#syntax-float)(n),z2​),[nan](#syntax-float)(n),z2​,z2​\][relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(z1​,±[nan](#syntax-float)(n)),z1​,[nan](#syntax-float)(n),z1​\][relaxed](#aux-relaxed)(Rfmax​)\[[fmax](#op-fmax)N​(±0,∓0),±0,∓0,+0\][fmax](#op-fmax)N​(z1​,z2​)​(otherwise)​​

Note

Relaxed maximum is implementation-dependent for NaNs and for zeroes with different signs. In the [deterministic profile](#profile-deterministic), it behaves like regular [fmax](#op-fmax).

##### 4.3.6.5. [irelaxed\_q15mulr\_s](#op-irelaxed-q15mulr-s)N​(i1​,i2​)[](#-hrefop-irelaxed-q15mulr-smathrmirelaxed_q15mulr_s_n-i_1-i_2)

The implementation-specific behaviour of this operation is determined by the global parameter Riq15mulr​∈{0,1}.

*   If both i1​ and i2​ equal ([signed](#aux-signed)N−1​(−2N−1), then return [relaxed](#aux-relaxed)(Riq15mulr​)\[2N−1−1,[signed](#aux-signed)N−1​(−2N−1)\].
    
*   Return [iq15mulrsat\_s](#op-iq15mulrsat)(i1​,i2​)
    

[irelaxed\_q15mulr\_s](#op-irelaxed-q15mulr-s)N​([signed](#aux-signed)N−1​(−2N−1),[signed](#aux-signed)N−1​(−2N−1))[irelaxed\_q15mulr\_s](#op-irelaxed-q15mulr-s)N​(i1​,i2​)​\=\=​[relaxed](#aux-relaxed)(Riq15mulr​)\[2N−1−1,[signed](#aux-signed)N−1​(−2N−1)\][iq15mulrsat\_s](#op-iq15mulrsat)(i1​,i2​)​​

Note

Relaxed Q15 multiplication is implementation-dependent when the result overflows. In the [deterministic profile](#profile-deterministic), it behaves like regular [iq15mulrsat\_s](#op-iq15mulrsat).

##### 4.3.6.6. [relaxed\_trunc](#op-relaxed-trunc)M,Nu​(z)[](#-hrefop-relaxed-truncmathrmrelaxed_truncu_m-n-z)

The implementation-specific behaviour of this operation is determined by the global parameter Rtrunc\_u​∈{0,1}.

*   If z is normal or subnormal and [trunc](#op-trunc)(z) is non-negative and less than 2N, then return [truncu](#op-trunc)M,N​(z).
    
*   Else, return [relaxed](#aux-relaxed)(Rtrunc\_u​)\[[trunc\_sat\_u](#op-trunc-sat)M,N​(z),R\].
    

[relaxed\_trunc](#op-relaxed-trunc)M,Nu​(±q)[relaxed\_trunc](#op-relaxed-trunc)M,Nu​(z)​\=\=​[truncu](#op-trunc)M,N​(±q)[relaxed](#aux-relaxed)(Rtrunc\_u​)\[[trunc\_sat\_u](#op-trunc-sat)M,N​(z),R\]​(if0≤[trunc](#op-trunc)(±q)<2N)(otherwise)​​

Note

Relaxed unsigned truncation is non-deterministic for NaNs and out-of-range values. In the [deterministic profile](#profile-deterministic), it behaves like regular [trunc\_sat\_u](#op-trunc-sat).

##### 4.3.6.7. [relaxed\_trunc](#op-relaxed-trunc)M,Ns​(z)[](#-hrefop-relaxed-truncmathrmrelaxed_truncs_m-n-z)

The implementation-specific behaviour of this operation is determined by the global parameter Rtrunc\_s​∈{0,1}.

*   If z is normal or subnormal and [trunc](#op-trunc)(z) is greater than or equal to −2N−1 and less than 2N−1, then return [truncs](#op-trunc)M,N​(z).
    
*   Else, return [relaxed](#aux-relaxed)(Rtrunc\_s​)\[[trunc\_sat\_s](#op-trunc-sat)M,N​(z),R\].
    

[relaxed\_trunc](#op-relaxed-trunc)M,Ns​(±q)[relaxed\_trunc](#op-relaxed-trunc)M,Ns​(z)​\=\=​[truncs](#op-trunc)M,N​(±q)[relaxed](#aux-relaxed)(Rtrunc\_s​)\[[trunc\_sat\_s](#op-trunc-sat)M,N​(z),R\]​(if−2N−1≤[trunc](#op-trunc)(±q)<2N−1)(otherwise)​​

Note

Relaxed signed truncation is non-deterministic for NaNs and out-of-range values. In the [deterministic profile](#profile-deterministic), it behaves like regular [trunc\_sat\_s](#op-trunc-sat).

##### 4.3.6.8. [ivrelaxed\_swizzle](#op-ivrelaxed-swizzle)(in,jn)[](#-hrefop-ivrelaxed-swizzlemathrmivrelaxed_swizzle-in-jn)

The implementation-specific behaviour of this operation is determined by the global parameter Rswizzle​∈{0,1}.

*   For each jk​ in jn, let rk​ be the value [ivrelaxed\_swizzle\_lane](#op-ivrelaxed-swizzle-lane)(in,jk​).
    
*   Let rn be the concatenation of all rk​.
    
*   Return rn.
    

[ivrelaxed\_swizzle](#op-ivrelaxed-swizzle)(in,jn)​\=​[ivrelaxed\_swizzle\_lane](#op-ivrelaxed-swizzle-lane)(in,j)n​​

where:

[ivrelaxed\_swizzle\_lane](#op-ivrelaxed-swizzle-lane)(in,j)[ivrelaxed\_swizzle\_lane](#op-ivrelaxed-swizzle-lane)(in,j)[ivrelaxed\_swizzle\_lane](#op-ivrelaxed-swizzle-lane)(in,j)​\=\=\=​i\[j\]0[relaxed](#aux-relaxed)(Rswizzle​)\[0,in\[jmodn\]\]​(ifj<16)(if[signed](#aux-signed)8​(j)<0)(otherwise)​​

Note

Relaxed swizzle is implementation-dependent if the signed interpretation of any of the 8-bit indices in jn is larger than or equal to 16. In the [deterministic profile](#profile-deterministic), it behaves like regular [ivswizzle](#op-ivswizzle).

##### 4.3.6.9. [relaxed\_dot](#syntax-instr-vec)(i1​,i2​)[](#-hrefsyntax-instr-vecmathsfrelaxed_dot-i_1-i_2)

The implementation-specific behaviour of this operation is determined by the global parameter Ridot​∈{0,1}. It also affects the behaviour of [relaxed\_dot\_add](#syntax-instr-vec).

Its definition is part of the definition of [vextbinop](#syntax-vextbinop) specified [above](#op-vextbinop).

Note

Relaxed dot product is implementation-dependent when the second operand is negative in a signed intepretation. In the [deterministic profile](#profile-deterministic), it behaves like signed dot product.

##### 4.3.6.10. [irelaxed\_laneselect](#op-irelaxed-laneselect)N​(i1​,i2​,i3​)[](#-hrefop-irelaxed-laneselectmathrmirelaxed_laneselect_n-i_1-i_2-i_3)

The implementation-specific behaviour of this operation is determined by the global parameter Rlaneselect​∈{0,1}.

*   If i3​ is smaller than 2N−1, then let i3′​ be the value 0, otherwise 2N−1.
    
*   Let i3′′​ be [relaxed](#aux-relaxed)(Rlaneselect​)\[i3​,i3′​\].
    
*   Return [ibitselect](#op-ibitselect)N​(i1​,i2​,i3′′​).
    

[irelaxed\_laneselect](#op-irelaxed-laneselect)N​(i1​,i2​,i3​)​\=​[ibitselect](#op-ibitselect)N​(i1​,i2​,[relaxed](#aux-relaxed)(Rlaneselect​)\[i3​,[extends](#op-extend)1,N​([ishr\_u](#op-ishr)N​(i3​,N−1))\])​​

Note

Relaxed lane selection is non-deterministic when the mask mixes set and cleared bits, since the value of the high bit may or may not be expanded to all bits. In the [deterministic profile](#profile-deterministic), it behaves like [ibitselect](#op-ibitselect).

### 4.4. Types[](#types①①)

Execution has to check and compare [types](#syntax-type) in a few places, such as [executing](#exec-call-indirect) call\_indirect or [instantiating](#exec-instantiation) [modules](#syntax-module).

It is an invariant of the semantics that all types occurring during execution are [closed](#type-closed).

Note

Runtime type checks generally involve types from multiple modules or types not defined by a module at all, such that any module-local [type indices](#syntax-typeidx) occurring inside them would not generally be meaningful.

#### 4.4.1. Instantiation[](#instantiation②)

Any form of [type](#syntax-type) can be _instantiated_ into a [closed](#type-closed) type inside a [module instance](#syntax-moduleinst) by [substituting](#notation-subst) each [type index](#syntax-typeidx) x occurring in it with the corresponding [defined type](#syntax-deftype) [moduleinst](#syntax-moduleinst).[types](#syntax-moduleinst)\[x\].

[clos](#type-inst)[moduleinst](#syntax-moduleinst)​(t)​\=​t\[[:=](#notation-subst)dt∗\]​if dt∗\=[moduleinst](#syntax-moduleinst).[types](#syntax-moduleinst)​​

Note

This is the runtime equivalent to [type closure](#type-closure), which is applied at validation time.

### 4.5. Values[](#values⑥)

#### 4.5.1. Value Typing[](#value-typing①)

For the purpose of checking argument [values](#syntax-val) against the parameter types of exported [functions](#syntax-func), values are classified by [value types](#syntax-valtype). The following auxiliary typing rules specify this typing relation relative to a [store](#syntax-store) S in which possibly referenced [addresses](#syntax-addr) live.

##### 4.5.1.1. Numeric Values[](#numeric-values①)

The [number value](#syntax-num) (nt.[const](#syntax-instr-numeric) c) is [valid](#valid-num) with the [number type](#syntax-numtype) nt.

s[⊢](#valid-num)nt.[const](#syntax-instr-numeric) c:nt​​

##### 4.5.1.2. Vector Values[](#vector-values①)

The [vector value](#syntax-vec) (vt.[const](#syntax-instr-vec) c) is [valid](#valid-vec) with the [vector type](#syntax-vectype) vt.

s[⊢](#valid-vec)vt.[const](#syntax-instr-vec) c:vt​​

##### 4.5.1.3. Null References[](#null-references①)

The [reference value](#syntax-ref) ([ref.null](#syntax-instr-ref) ht) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [null](#syntax-reftype) ht′) if:

> *   The [heap type](#syntax-heaptype) ht′ [matches](#match-heaptype) the [heap type](#syntax-heaptype) ht.
>     

s[⊢](#valid-ref)[ref.null](#syntax-instr-ref) ht:([ref](#syntax-reftype) [null](#syntax-reftype) ht′){}[⊢](#match-heaptype)ht′[≤](#match-heaptype)ht​​

Note

A null reference can be typed with any smaller type. In particular, that allows it to be typed with the least type in its respective hierarchy. That ensures that the value is compatible with any nullable type in that hierarchy.

##### 4.5.1.4. Scalar References[](#scalar-references①)

The [reference value](#syntax-ref) ([ref.i31](#syntax-ref) i) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [i31](#syntax-heaptype)).

s[⊢](#valid-ref)[ref.i31](#syntax-ref) i:([ref](#syntax-reftype) [i31](#syntax-heaptype))​​

##### 4.5.1.5. Structure References[](#structure-references①)

The [reference value](#syntax-ref) ([ref.struct](#syntax-ref) a) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) dt) if:

> *   The [structure instance](#syntax-structinst) s.[structs](#syntax-store)\[a\] exists.
>     
> *   The [defined type](#syntax-deftype) s.[structs](#syntax-store)\[a\].[type](#syntax-structinst) is of the form dt.
>     

s[⊢](#valid-ref)[ref.struct](#syntax-ref) a:([ref](#syntax-reftype) dt)s.[structs](#syntax-store)\[a\].[type](#syntax-structinst)\=dt​​

##### 4.5.1.6. Array References[](#array-references①)

The [reference value](#syntax-ref) ([ref.array](#syntax-ref) a) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) dt) if:

> *   The [array instance](#syntax-arrayinst) s.[arrays](#syntax-store)\[a\] exists.
>     
> *   The [defined type](#syntax-deftype) s.[arrays](#syntax-store)\[a\].[type](#syntax-arrayinst) is of the form dt.
>     

s[⊢](#valid-ref)[ref.array](#syntax-ref) a:([ref](#syntax-reftype) dt)s.[arrays](#syntax-store)\[a\].[type](#syntax-arrayinst)\=dt​​

##### 4.5.1.7. Exception References[](#exception-references①)

The [reference value](#syntax-ref) ([ref.exn](#syntax-ref) a) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [exn](#syntax-heaptype)) if:

> *   The [exception instance](#syntax-exninst) s.[exns](#syntax-store)\[a\] exists.
>     

s[⊢](#valid-ref)[ref.exn](#syntax-ref) a:([ref](#syntax-reftype) [exn](#syntax-heaptype))s.[exns](#syntax-store)\[a\]\=exn​​

##### 4.5.1.8. Function References[](#function-references①)

The [reference value](#syntax-ref) ([ref.func](#syntax-ref) a) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) dt) if:

> *   The [function instance](#syntax-funcinst) s.[funcs](#syntax-store)\[a\] exists.
>     
> *   The [defined type](#syntax-deftype) s.[funcs](#syntax-store)\[a\].[type](#syntax-funcinst) is of the form dt.
>     

s[⊢](#valid-ref)[ref.func](#syntax-ref) a:([ref](#syntax-reftype) dt)s.[funcs](#syntax-store)\[a\].[type](#syntax-funcinst)\=dt​​

##### 4.5.1.9. Host References[](#host-references①)

The [reference value](#syntax-ref) ([ref.host](#syntax-ref) a) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [any](#syntax-heaptype)).

s[⊢](#valid-ref)[ref.host](#syntax-ref) a:([ref](#syntax-reftype) [any](#syntax-heaptype))​​

Note

A bare host reference is considered internalized.

##### 4.5.1.10. External References[](#external-references①)

The [reference value](#syntax-ref) ([ref.extern](#syntax-ref) [addrref](#syntax-addrref)) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [extern](#syntax-heaptype)) if:

> *   The [reference value](#syntax-ref) [addrref](#syntax-addrref) is [valid](#valid-ref) with the [reference type](#syntax-reftype) ([ref](#syntax-reftype) [any](#syntax-heaptype)).
>     

s[⊢](#valid-ref)[ref.extern](#syntax-ref) [addrref](#syntax-addrref):([ref](#syntax-reftype) [extern](#syntax-heaptype))s[⊢](#valid-ref)[addrref](#syntax-addrref):([ref](#syntax-reftype) [any](#syntax-heaptype))​​

##### 4.5.1.11. Subsumption[](#subsumption①)

The [reference value](#syntax-ref) [ref](#syntax-ref) is [valid](#valid-ref) with the [reference type](#syntax-reftype) rt if:

> *   The [reference value](#syntax-ref) [ref](#syntax-ref) is [valid](#valid-ref) with the [reference type](#syntax-reftype) rt′.
>     
> *   The [reference type](#syntax-reftype) rt′ [matches](#match-reftype) the [reference type](#syntax-reftype) rt.
>     

s[⊢](#valid-ref)[ref](#syntax-ref):rts[⊢](#valid-ref)[ref](#syntax-ref):rt′{}[⊢](#match-reftype)rt′[≤](#match-reftype)rt​​

#### 4.5.2. External Typing[](#external-typing①)

For the purpose of checking [external address](#syntax-externaddr) against [imports](#syntax-import), such values are classified by [external types](#syntax-externtype). The following auxiliary typing rules specify this typing relation relative to a [store](#syntax-store) S in which the referenced instances live.

##### 4.5.2.1. Functions[](#functions⑤)

The [external address](#syntax-externaddr) ([func](#syntax-externaddr) a) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) ([func](#syntax-externtype) [funcinst](#syntax-funcinst).[type](#syntax-funcinst)) if:

> *   The [function instance](#syntax-funcinst) s.[funcs](#syntax-store)\[a\] exists.
>     
> *   The [function instance](#syntax-funcinst) s.[funcs](#syntax-store)\[a\] is of the form [funcinst](#syntax-funcinst).
>     

s[⊢](#valid-externaddr)[func](#syntax-externaddr) a:[func](#syntax-externtype) [funcinst](#syntax-funcinst).[type](#syntax-funcinst)s.[funcs](#syntax-store)\[a\]\=[funcinst](#syntax-funcinst)​​

##### 4.5.2.2. Tables[](#tables⑤)

The [external address](#syntax-externaddr) ([table](#syntax-externaddr) a) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) ([table](#syntax-externtype) [tableinst](#syntax-tableinst).[type](#syntax-tableinst)) if:

> *   The [table instance](#syntax-tableinst) s.[tables](#syntax-store)\[a\] exists.
>     
> *   The [table instance](#syntax-tableinst) s.[tables](#syntax-store)\[a\] is of the form [tableinst](#syntax-tableinst).
>     

s[⊢](#valid-externaddr)[table](#syntax-externaddr) a:[table](#syntax-externtype) [tableinst](#syntax-tableinst).[type](#syntax-tableinst)s.[tables](#syntax-store)\[a\]\=[tableinst](#syntax-tableinst)​​

##### 4.5.2.3. Memories[](#memories⑤)

The [external address](#syntax-externaddr) ([mem](#syntax-externaddr) a) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) ([mem](#syntax-externtype) [meminst](#syntax-meminst).[type](#syntax-meminst)) if:

> *   The [memory instance](#syntax-meminst) s.[mems](#syntax-store)\[a\] exists.
>     
> *   The [memory instance](#syntax-meminst) s.[mems](#syntax-store)\[a\] is of the form [meminst](#syntax-meminst).
>     

s[⊢](#valid-externaddr)[mem](#syntax-externaddr) a:[mem](#syntax-externtype) [meminst](#syntax-meminst).[type](#syntax-meminst)s.[mems](#syntax-store)\[a\]\=[meminst](#syntax-meminst)​​

##### 4.5.2.4. Globals[](#globals⑤)

The [external address](#syntax-externaddr) ([global](#syntax-externaddr) a) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) ([global](#syntax-externtype) [globalinst](#syntax-globalinst).[type](#syntax-globalinst)) if:

> *   The [global instance](#syntax-globalinst) s.[globals](#syntax-store)\[a\] exists.
>     
> *   The [global instance](#syntax-globalinst) s.[globals](#syntax-store)\[a\] is of the form [globalinst](#syntax-globalinst).
>     

s[⊢](#valid-externaddr)[global](#syntax-externaddr) a:[global](#syntax-externtype) [globalinst](#syntax-globalinst).[type](#syntax-globalinst)s.[globals](#syntax-store)\[a\]\=[globalinst](#syntax-globalinst)​​

##### 4.5.2.5. Tags[](#tags⑤)

The [external address](#syntax-externaddr) ([tag](#syntax-externaddr) a) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) ([tag](#syntax-externtype) [taginst](#syntax-taginst).[type](#syntax-taginst)) if:

> *   The [tag instance](#syntax-taginst) s.[tags](#syntax-store)\[a\] exists.
>     
> *   The [tag instance](#syntax-taginst) s.[tags](#syntax-store)\[a\] is of the form [taginst](#syntax-taginst).
>     

s[⊢](#valid-externaddr)[tag](#syntax-externaddr) a:[tag](#syntax-externtype) [taginst](#syntax-taginst).[type](#syntax-taginst)s.[tags](#syntax-store)\[a\]\=[taginst](#syntax-taginst)​​

##### 4.5.2.6. Subsumption[](#subsumption②)

The [external address](#syntax-externaddr) [externaddr](#syntax-externaddr) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) xt if:

> *   The [external address](#syntax-externaddr) [externaddr](#syntax-externaddr) is [valid](#valid-externaddr) with the [external type](#syntax-externtype) xt′.
>     
> *   The [external type](#syntax-externtype) xt′ [matches](#match-externtype) the [external type](#syntax-externtype) xt.
>     

s[⊢](#valid-externaddr)[externaddr](#syntax-externaddr):xts[⊢](#valid-externaddr)[externaddr](#syntax-externaddr):xt′{}[⊢](#match-externtype)xt′[≤](#match-externtype)xt​​

### 4.6. Instructions[](#instructions⑤)

WebAssembly computation is performed by executing individual [instructions](#syntax-instr).

#### 4.6.1. Parametric Instructions[](#parametric-instructions⑤)

##### 4.6.1.1. [nop](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfnop①)

1.  Do nothing.
    

​[nop](#syntax-instr-control)​[↪](#exec-notation)​ϵ​​

##### 4.6.1.2. [unreachable](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfunreachable①)

1.  Trap.
    

​[unreachable](#syntax-instr-control)​[↪](#exec-notation)​[trap](#syntax-trap)​​

##### 4.6.1.3. [drop](#syntax-instr-parametric)[](#-hrefsyntax-instr-parametricmathsfdrop①)

1.  Assert: Due to [validation](#valid-drop), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    

​[val](#syntax-val) [drop](#syntax-instr-parametric)​[↪](#exec-notation)​ϵ​​

##### 4.6.1.4. [select](#syntax-instr-parametric) (t∗)?[](#-hrefsyntax-instr-parametricmathsfselect-tast①)

1.  Assert: Due to [validation](#valid-select), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) from the stack.
    
3.  Assert: Due to [validation](#valid-select), a value is on the top of the stack.
    
4.  Pop the value [val](#syntax-val)2​ from the stack.
    
5.  Assert: Due to [validation](#valid-select), a value is on the top of the stack.
    
6.  Pop the value [val](#syntax-val)1​ from the stack.
    
7.  If c\=0, then:
    
    1.  Push the value [val](#syntax-val)1​ to the stack.
        
8.  Else:
    
    1.  Push the value [val](#syntax-val)2​ to the stack.
        

​[val](#syntax-val)1​ [val](#syntax-val)2​ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([select](#syntax-instr-parametric) (t∗)?)[val](#syntax-val)1​ [val](#syntax-val)2​ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([select](#syntax-instr-parametric) (t∗)?)​[↪](#exec-notation)[↪](#exec-notation)​[val](#syntax-val)1​[val](#syntax-val)2​​if c\=0if c\=0​​

Note

In future versions of WebAssembly, select may allow more than one value per choice.

#### 4.6.2. Control Instructions[](#control-instructions⑤)

##### 4.6.2.1. [block](#syntax-instr-control) bt [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsfblockmathitbthrefsyntax-instrmathitinstrast)

1.  Let z be the current state.
    
2.  Let t1m​ [→](#syntax-instrtype)[localidx](#syntax-localidx)0∗​​t2n​ be the destructuring of [instrtype](#aux-blocktype)z​(bt).
    
3.  Assert: Due to [validation](#valid-block), [localidx](#syntax-localidx)0∗​\=ϵ.
    
4.  Assert: Due to [validation](#valid-block), there are at least m values on the top of the stack.
    
5.  Pop the values [val](#syntax-val)m from the stack.
    
6.  Let L be the [label](#syntax-label) whose arity is n and whose continuation is the end of the block.
    
7.  Enter the block [val](#syntax-val)m [instr](#syntax-instr)∗ with the [label](#syntax-label) L.
    

​z;[val](#syntax-val)m ([block](#syntax-instr-control) bt [instr](#syntax-instr)∗)​[↪](#exec-notation)​([label](#syntax-label)n​{ϵ} [val](#syntax-val)m [instr](#syntax-instr)∗)​if [instrtype](#aux-blocktype)z​(bt)\=t1m​→t2n​​​

##### 4.6.2.2. [loop](#syntax-instr-control) bt [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsfloopmathitbthrefsyntax-instrmathitinstrast)

1.  Let z be the current state.
    
2.  Let t1m​ [→](#syntax-instrtype)[localidx](#syntax-localidx)0∗​​t2n​ be the destructuring of [instrtype](#aux-blocktype)z​(bt).
    
3.  Assert: Due to [validation](#valid-loop), [localidx](#syntax-localidx)0∗​\=ϵ.
    
4.  Assert: Due to [validation](#valid-loop), there are at least m values on the top of the stack.
    
5.  Pop the values [val](#syntax-val)m from the stack.
    
6.  Let L be the [label](#syntax-label) whose arity is m and whose continuation is the start of the block.
    
7.  Enter the block [val](#syntax-val)m [instr](#syntax-instr)∗ with the [label](#syntax-label) L.
    

​z;[val](#syntax-val)m ([loop](#syntax-instr-control) bt [instr](#syntax-instr)∗)​[↪](#exec-notation)​([label](#syntax-label)m​{[loop](#syntax-instr-control) bt [instr](#syntax-instr)∗} [val](#syntax-val)m [instr](#syntax-instr)∗)​if [instrtype](#aux-blocktype)z​(bt)\=t1m​→t2n​​​

##### 4.6.2.3. [if](#syntax-instr-control) bt [instr](#syntax-instr)1∗​ [instr](#syntax-instr)2∗​[](#-hrefsyntax-instr-controlmathsfifmathitbthrefsyntax-instrmathitinstr_1asthrefsyntax-instrmathitinstr_2ast)

1.  Assert: Due to [validation](#valid-if), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) from the stack.
    
3.  If c\=0, then:
    
    1.  Execute the instruction ([block](#syntax-instr-control) bt [instr](#syntax-instr)1∗​).
        
4.  Else:
    
    1.  Execute the instruction ([block](#syntax-instr-control) bt [instr](#syntax-instr)2∗​).
        

​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([if](#syntax-instr-control) bt [instr](#syntax-instr)1∗​ [else](#syntax-instr-control) [instr](#syntax-instr)2∗​)([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([if](#syntax-instr-control) bt [instr](#syntax-instr)1∗​ [else](#syntax-instr-control) [instr](#syntax-instr)2∗​)​[↪](#exec-notation)[↪](#exec-notation)​([block](#syntax-instr-control) bt [instr](#syntax-instr)1∗​)([block](#syntax-instr-control) bt [instr](#syntax-instr)2∗​)​if c\=0if c\=0​​

##### 4.6.2.4. [br](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbrl①)

1.  If the first non-value entry of the stack is a [label](#syntax-label), then:
    
    1.  Let L be the topmost [label](#syntax-label).
        
    2.  Let n be the arity of L
        
    3.  If l\=0, then:
        
        1.  Assert: Due to [validation](#valid-br), there are at least n values on the top of the stack.
            
        2.  Pop the values [val](#syntax-val)n from the stack.
            
        3.  Pop all values [val](#syntax-val)′∗ from the top of the stack.
            
        4.  Pop the [label](#syntax-label) from the stack.
            
        5.  Push the values [val](#syntax-val)n to the stack.
            
        6.  Jump to the continuation of L.
            
    4.  Else:
        
        1.  Pop all values [val](#syntax-val)∗ from the top of the stack.
            
        2.  Pop the [label](#syntax-label) from the stack.
            
        3.  Push the values [val](#syntax-val)∗ to the stack.
            
        4.  Execute the instruction ([br](#syntax-instr-control) l−1).
            
2.  Else:
    
    1.  Assert: Due to [validation](#valid-br), the first non-value entry of the stack is a [handler](#syntax-handler).
        
    2.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    3.  Pop the [handler](#syntax-handler) from the stack.
        
    4.  Push the values [val](#syntax-val)∗ to the stack.
        
    5.  Execute the instruction ([br](#syntax-instr-control) l).
        

​([label](#syntax-label)n​{[instr](#syntax-instr)′∗} [val](#syntax-val)′∗ [val](#syntax-val)n ([br](#syntax-instr-control) l) [instr](#syntax-instr)∗)([label](#syntax-label)n​{[instr](#syntax-instr)′∗} [val](#syntax-val)∗ ([br](#syntax-instr-control) l) [instr](#syntax-instr)∗)([handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [val](#syntax-val)∗ ([br](#syntax-instr-control) l) [instr](#syntax-instr)∗)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[val](#syntax-val)n [instr](#syntax-instr)′∗[val](#syntax-val)∗ ([br](#syntax-instr-control) l−1)[val](#syntax-val)∗ ([br](#syntax-instr-control) l)​if l\=0if l\>0​​

##### 4.6.2.5. [br\_if](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_ifl①)

1.  Assert: Due to [validation](#valid-br-if), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) from the stack.
    
3.  If c\=0, then:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l).
        
4.  Else:
    
    1.  Do nothing.
        

​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([br\_if](#syntax-instr-control) l)([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) ([br\_if](#syntax-instr-control) l)​[↪](#exec-notation)[↪](#exec-notation)​([br](#syntax-instr-control) l)ϵ​if c\=0if c\=0​​

##### 4.6.2.6. [br\_table](#syntax-instr-control) l∗ l′[](#-hrefsyntax-instr-controlmathsfbr_tablelastl)

1.  Assert: Due to [validation](#valid-br-table), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
3.  If i<∣l∗∣, then:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l∗\[i\]).
        
4.  Else:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l′).
        

​([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([br\_table](#syntax-instr-control) l∗ l′)([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([br\_table](#syntax-instr-control) l∗ l′)​[↪](#exec-notation)[↪](#exec-notation)​([br](#syntax-instr-control) l∗\[i\])([br](#syntax-instr-control) l′)​if i<∣l∗∣if i≥∣l∗∣​​

##### 4.6.2.7. [br\_on\_null](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_on_nulll①)

1.  Assert: Due to [validation](#valid-br-on-null), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l).
        
4.  Else:
    
    1.  Push the value [val](#syntax-val) to the stack.
        

​[val](#syntax-val) ([br\_on\_null](#syntax-instr-control) l)[val](#syntax-val) ([br\_on\_null](#syntax-instr-control) l)​[↪](#exec-notation)[↪](#exec-notation)​([br](#syntax-instr-control) l)[val](#syntax-val)​if [val](#syntax-val)\=[ref.null](#syntax-instr-ref) htotherwise​​

##### 4.6.2.8. [br\_on\_non\_null](#syntax-instr-control) l[](#-hrefsyntax-instr-controlmathsfbr_on_non_nulll①)

1.  Assert: Due to [validation](#valid-br-on-non-null), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Do nothing.
        
4.  Else:
    
    1.  Push the value [val](#syntax-val) to the stack.
        
    2.  Execute the instruction ([br](#syntax-instr-control) l).
        

​[val](#syntax-val) ([br\_on\_non\_null](#syntax-instr-control) l)[val](#syntax-val) ([br\_on\_non\_null](#syntax-instr-control) l)​[↪](#exec-notation)[↪](#exec-notation)​ϵ[val](#syntax-val) ([br](#syntax-instr-control) l)​if [val](#syntax-val)\=[ref.null](#syntax-instr-ref) htotherwise​​

##### 4.6.2.9. [br\_on\_cast](#syntax-instr-control) l rt1​ rt2​[](#-hrefsyntax-instr-controlmathsfbr_on_castlmathitrt_1mathitrt_2①)

1.  Let f be the topmost frame.
    
2.  Assert: Due to [validation](#valid-br-on-cast), a [reference value](#syntax-ref) is on the top of the stack.
    
3.  Pop the value [ref](#syntax-ref) from the stack.
    
4.  Let rt be the type of [ref](#syntax-ref).
    
5.  Push the value [ref](#syntax-ref) to the stack.
    
6.  If rt matches [clos](#type-inst)f.[module](#syntax-frame)​(rt2​), then:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l).
        
7.  Else:
    
    1.  Do nothing.
        

​s;f;[ref](#syntax-ref) ([br\_on\_cast](#syntax-instr-control) l rt1​ rt2​)s;f;[ref](#syntax-ref) ([br\_on\_cast](#syntax-instr-control) l rt1​ rt2​)​[↪](#exec-notation)[↪](#exec-notation)​[ref](#syntax-ref) ([br](#syntax-instr-control) l)[ref](#syntax-ref)​if s[⊢](#valid-ref)[ref](#syntax-ref):rt∧ {}[⊢](#match-reftype)rt[≤](#match-reftype)[clos](#type-inst)f.[module](#syntax-frame)​(rt2​)​otherwise​​

##### 4.6.2.10. [br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​[](#-hrefsyntax-instr-controlmathsfbr_on_cast_faillmathitrt_1mathitrt_2①)

1.  Let f be the topmost frame.
    
2.  Assert: Due to [validation](#valid-br-on-cast-fail), a [reference value](#syntax-ref) is on the top of the stack.
    
3.  Pop the value [ref](#syntax-ref) from the stack.
    
4.  Let rt be the type of [ref](#syntax-ref).
    
5.  Push the value [ref](#syntax-ref) to the stack.
    
6.  If rt matches [clos](#type-inst)f.[module](#syntax-frame)​(rt2​), then:
    
    1.  Do nothing.
        
7.  Else:
    
    1.  Execute the instruction ([br](#syntax-instr-control) l).
        

​s;f;[ref](#syntax-ref) ([br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​)s;f;[ref](#syntax-ref) ([br\_on\_cast\_fail](#syntax-instr-control) l rt1​ rt2​)​[↪](#exec-notation)[↪](#exec-notation)​[ref](#syntax-ref)[ref](#syntax-ref) ([br](#syntax-instr-control) l)​if s[⊢](#valid-ref)[ref](#syntax-ref):rt∧ {}[⊢](#match-reftype)rt[≤](#match-reftype)[clos](#type-inst)f.[module](#syntax-frame)​(rt2​)​otherwise​​

##### 4.6.2.11. [return](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfreturn①)

1.  If the first non-value entry of the stack is a [frame](#syntax-frame), then:
    
    1.  Let f be the topmost [frame](#syntax-frame).
        
    2.  Let n be the arity of f
        
    3.  Assert: Due to [validation](#valid-return), there are at least n values on the top of the stack.
        
    4.  Pop the values [val](#syntax-val)n from the stack.
        
    5.  Pop all values [val](#syntax-val)′∗ from the top of the stack.
        
    6.  Pop the [frame](#syntax-frame) from the stack.
        
    7.  Push the values [val](#syntax-val)n to the stack.
        
2.  Else if the first non-value entry of the stack is a [label](#syntax-label), then:
    
    1.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    2.  Pop the [label](#syntax-label) from the stack.
        
    3.  Push the values [val](#syntax-val)∗ to the stack.
        
    4.  Execute the instruction [return](#syntax-instr-control).
        
3.  Else:
    
    1.  Assert: Due to [validation](#valid-return), the first non-value entry of the stack is a [handler](#syntax-handler).
        
    2.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    3.  Pop the [handler](#syntax-handler) from the stack.
        
    4.  Push the values [val](#syntax-val)∗ to the stack.
        
    5.  Execute the instruction [return](#syntax-instr-control).
        

​([frame](#syntax-frame)n​{f} [val](#syntax-val)′∗ [val](#syntax-val)n [return](#syntax-instr-control) [instr](#syntax-instr)∗)([label](#syntax-label)n​{[instr](#syntax-instr)′∗} [val](#syntax-val)∗ [return](#syntax-instr-control) [instr](#syntax-instr)∗)([handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [val](#syntax-val)∗ [return](#syntax-instr-control) [instr](#syntax-instr)∗)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[val](#syntax-val)n[val](#syntax-val)∗ [return](#syntax-instr-control)[val](#syntax-val)∗ [return](#syntax-instr-control)​​

##### 4.6.2.12. [call](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfcallx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-call), x<∣z.[module](#syntax-state).[funcs](#syntax-moduleinst)∣.
    
3.  Let a be the [address](#syntax-addr) z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\].
    
4.  Assert: Due to [validation](#valid-call), a<∣z.[funcs](#syntax-state)∣.
    
5.  Push the value ([ref.func](#syntax-ref) a) to the stack.
    
6.  Execute the instruction ([call\_ref](#syntax-instr-control) z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst)).
    

​z;([call](#syntax-instr-control) x)​[↪](#exec-notation)​([ref.func](#syntax-ref) a) ([call\_ref](#syntax-instr-control) z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst))​if z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\]\=a​​

##### 4.6.2.13. [call\_ref](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfcall_refx①)

Todo

(\*) Prose not spliced, for the prose merges the two cases of null and non-null references.

1.  Assert: due to [validation](#valid-call-ref), a null or [function reference](#syntax-ref) is on the top of the stack.
    
2.  Pop the reference value r from the stack.
    
3.  If r is [ref.null](#syntax-instr-ref) ht, then:
    
    > 1.  Trap.
    >     
    
4.  Assert: due to [validation](#valid-call-ref), r is a [function reference](#syntax-ref).
    
5.  Let [ref.func](#syntax-ref) a be the reference r.
    
6.  [Invoke](#exec-invoke) the function instance at address a.
    

​z;([ref.null](#syntax-instr-ref) ht) ([call\_ref](#syntax-instr-control) y)​[↪](#exec-notation)​[trap](#syntax-trap)​​

Note

The formal rule for calling a non-null function reference is described [below](#exec-invoke).

##### 4.6.2.14. [call\_indirect](#syntax-instr-control) x y[](#-hrefsyntax-instr-controlmathsfcall_indirectxy①)

1.  Execute the instruction ([table.get](#syntax-instr-table) x).
    
2.  Execute the instruction ([ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) y)).
    
3.  Execute the instruction ([call\_ref](#syntax-instr-control) y).
    

​([call\_indirect](#syntax-instr-control) x y)​[↪](#exec-notation)​([table.get](#syntax-instr-table) x) ([ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) y)) ([call\_ref](#syntax-instr-control) y)​​

##### 4.6.2.15. [return\_call](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfreturn_callx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-return-call), x<∣z.[module](#syntax-state).[funcs](#syntax-moduleinst)∣.
    
3.  Let a be the [address](#syntax-addr) z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\].
    
4.  Assert: Due to [validation](#valid-return-call), a<∣z.[funcs](#syntax-state)∣.
    
5.  Push the value ([ref.func](#syntax-ref) a) to the stack.
    
6.  Execute the instruction ([return\_call\_ref](#syntax-instr-control) z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst)).
    

​z;([return\_call](#syntax-instr-control) x)​[↪](#exec-notation)​([ref.func](#syntax-ref) a) ([return\_call\_ref](#syntax-instr-control) z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst))​if z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\]\=a​​

##### 4.6.2.16. [return\_call\_ref](#syntax-instr-control) y[](#-hrefsyntax-instr-controlmathsfreturn_call_refy)

1.  Let z be the current state.
    
2.  If the first non-value entry of the stack is a [label](#syntax-label), then:
    
    1.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    2.  Pop the [label](#syntax-label) from the stack.
        
    3.  Push the values [val](#syntax-val)∗ to the stack.
        
    4.  Execute the instruction ([return\_call\_ref](#syntax-instr-control) y).
        
3.  Else if the first non-value entry of the stack is a [handler](#syntax-handler), then:
    
    1.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    2.  Pop the [handler](#syntax-handler) from the stack.
        
    3.  Push the values [val](#syntax-val)∗ to the stack.
        
    4.  Execute the instruction ([return\_call\_ref](#syntax-instr-control) y).
        
4.  Else:
    
    1.  Assert: Due to [validation](#valid-return-call-ref), the first non-value entry of the stack is a [frame](#syntax-frame).
        
    2.  Assert: Due to [validation](#valid-return-call-ref), a value is on the top of the stack.
        
    3.  Pop the value [val](#syntax-val)′′ from the stack.
        
    4.  If [val](#syntax-val)′′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
        
        1.  Trap.
            
    5.  Assert: Due to [validation](#valid-return-call-ref), [val](#syntax-val)′′ is some [ref.func](#syntax-ref) [funcaddr](#syntax-funcaddr).
        
    6.  Let ([ref.func](#syntax-ref) a) be the destructuring of [val](#syntax-val)′′.
        
    7.  Assert: Due to [validation](#valid-return-call-ref), a<∣z.[funcs](#syntax-state)∣.
        
    8.  Assert: Due to [validation](#valid-return-call-ref), the [expansion](#aux-expand-deftype) of z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst) is some [func](#syntax-comptype) [resulttype](#syntax-resulttype)[→](#syntax-comptype)[resulttype](#syntax-resulttype).
        
    9.  Let ([func](#syntax-comptype) t1n​ [→](#syntax-comptype) t2m​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst).
        
    10.  Assert: Due to [validation](#valid-return-call-ref), there are at least n values on the top of the stack.
        
    11.  Pop the values [val](#syntax-val)n from the stack.
        
    12.  Pop all values [val](#syntax-val)′∗ from the top of the stack.
        
    13.  Pop the [frame](#syntax-frame) from the stack.
        
    14.  Push the values [val](#syntax-val)n to the stack.
        
    15.  Push the value ([ref.func](#syntax-ref) a) to the stack.
        
    16.  Execute the instruction ([call\_ref](#syntax-instr-control) y).
        

​z;([label](#syntax-label)k​{[instr](#syntax-instr)′∗} [val](#syntax-val)∗ ([return\_call\_ref](#syntax-instr-control) y) [instr](#syntax-instr)∗)z;([handler](#syntax-handler)k​{[catch](#syntax-catch)∗} [val](#syntax-val)∗ ([return\_call\_ref](#syntax-instr-control) y) [instr](#syntax-instr)∗)z;([frame](#syntax-frame)k​{f} [val](#syntax-val)∗ ([ref.null](#syntax-instr-ref) ht) ([return\_call\_ref](#syntax-instr-control) y) [instr](#syntax-instr)∗)z;([frame](#syntax-frame)k​{f} [val](#syntax-val)′∗ [val](#syntax-val)n ([ref.func](#syntax-ref) a) ([return\_call\_ref](#syntax-instr-control) y) [instr](#syntax-instr)∗)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[val](#syntax-val)∗ ([return\_call\_ref](#syntax-instr-control) y)[val](#syntax-val)∗ ([return\_call\_ref](#syntax-instr-control) y)[trap](#syntax-trap)[val](#syntax-val)n ([ref.func](#syntax-ref) a) ([call\_ref](#syntax-instr-control) y)if z.[funcs](#syntax-state)\[a\].[type](#syntax-funcinst)[≈](#aux-expand-deftype)[func](#syntax-comptype) t1n​[→](#syntax-comptype)t2m​​​​

##### 4.6.2.17. [return\_call\_indirect](#syntax-instr-control) x y[](#-hrefsyntax-instr-controlmathsfreturn_call_indirectxy①)

1.  Execute the instruction ([table.get](#syntax-instr-table) x).
    
2.  Execute the instruction ([ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) y)).
    
3.  Execute the instruction ([return\_call\_ref](#syntax-instr-control) y).
    

​([return\_call\_indirect](#syntax-instr-control) x y)​[↪](#exec-notation)​([table.get](#syntax-instr-table) x) ([ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) y)) ([return\_call\_ref](#syntax-instr-control) y)​​

##### 4.6.2.18. [throw](#syntax-instr-control) x[](#-hrefsyntax-instr-controlmathsfthrowx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-throw), x<∣z.[tags](#syntax-state)∣.
    
3.  Assert: Due to [validation](#valid-throw), the [expansion](#aux-expand-deftype) of z.[tags](#syntax-state)\[x\].[type](#syntax-taginst) is some [func](#syntax-comptype) [resulttype](#syntax-resulttype)[→](#syntax-comptype)[resulttype](#syntax-resulttype).
    
4.  Let ([func](#syntax-comptype) tn [→](#syntax-comptype) [resulttype](#syntax-resulttype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[tags](#syntax-state)\[x\].[type](#syntax-taginst).
    
5.  Assert: Due to [validation](#valid-throw), [resulttype](#syntax-resulttype)0​\=ϵ.
    
6.  Let a be the length of z.[exns](#syntax-state).
    
7.  Assert: Due to [validation](#valid-throw), there are at least n values on the top of the stack.
    
8.  Pop the values [val](#syntax-val)n from the stack.
    
9.  Let exn be the [exception instance](#syntax-exninst) {[tag](#syntax-exninst) z.[tags](#syntax-state)\[x\],[fields](#syntax-exninst) [val](#syntax-val)n}.
    
10.  Append exn to z.[exns](#syntax-state).
    
11.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
    
12.  Execute the instruction [throw\_ref](#syntax-instr-control).
    

​z;[val](#syntax-val)n ([throw](#syntax-instr-control) x)​[↪](#exec-notation)​z\[.[exns](#syntax-state)\=⊕exn\];([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)​if z.[tags](#syntax-state)\[x\].[type](#syntax-taginst)[≈](#aux-expand-deftype)[func](#syntax-comptype) tn[→](#syntax-comptype)ϵ∧ a\=∣z.[exns](#syntax-state)∣∧ exn\={[tag](#syntax-exninst) z.[tags](#syntax-state)\[x\],[fields](#syntax-exninst) [val](#syntax-val)n}​​​

##### 4.6.2.19. [throw\_ref](#syntax-instr-control)[](#-hrefsyntax-instr-controlmathsfthrow_ref①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-throw-ref), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val)′ from the stack.
    
4.  If [val](#syntax-val)′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
5.  If [val](#syntax-val)′ is some [ref.exn](#syntax-ref) [exnaddr](#syntax-exnaddr), then:
    
    1.  Let ([ref.exn](#syntax-ref) a) be the destructuring of [val](#syntax-val)′.
        
    2.  Pop all values [val](#syntax-val)∗ from the top of the stack.
        
    3.  If [val](#syntax-val)∗\=ϵ, then:
        
        1.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
            
        2.  Execute the instruction [throw\_ref](#syntax-instr-control).
            
    4.  Else if the first non-value entry of the stack is a [label](#syntax-label), then:
        
        1.  Pop the [label](#syntax-label) from the stack.
            
        2.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
            
        3.  Execute the instruction [throw\_ref](#syntax-instr-control).
            
    5.  Else:
        
        1.  If the first non-value entry of the stack is a [frame](#syntax-frame), then:
            
            1.  Pop the [frame](#syntax-frame) from the stack.
                
            2.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                
            3.  Execute the instruction [throw\_ref](#syntax-instr-control).
                
        2.  Else if the first non-value entry of the stack is not a [handler](#syntax-handler), then:
            
            1.  Throw the exception [val](#syntax-val)′ as a result.
                
        3.  Else:
            
            1.  Let H be the topmost [handler](#syntax-handler).
                
            2.  Let n be the arity of H
                
            3.  Let [catch](#syntax-catch)′′∗ be the catch handler of H
                
            4.  If [catch](#syntax-catch)′′∗\=ϵ, then:
                
                1.  Pop the [handler](#syntax-handler) from the stack.
                    
                2.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                    
                3.  Execute the instruction [throw\_ref](#syntax-instr-control).
                    
            5.  Else if a≥∣z.[exns](#syntax-state)∣, then:
                
                1.  Let [catch](#syntax-catch)0​ [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                    
                2.  If [catch](#syntax-catch)0​ is some [catch\_all](#syntax-instr-control) [labelidx](#syntax-labelidx), then:
                    
                    1.  Let ([catch\_all](#syntax-instr-control) l) be the destructuring of [catch](#syntax-catch)0​.
                        
                    2.  Pop the [handler](#syntax-handler) from the stack.
                        
                    3.  Execute the instruction ([br](#syntax-instr-control) l).
                        
                3.  Else if [catch](#syntax-catch)0​ is not some [catch\_all\_ref](#syntax-instr-control) [labelidx](#syntax-labelidx), then:
                    
                    1.  Let [catch](#syntax-catch) [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                        
                    2.  Pop the [handler](#syntax-handler) from the stack.
                        
                    3.  Let H′ be the [handler](#syntax-handler) whose arity is n and whose catch handler is [catch](#syntax-catch)′∗.
                        
                    4.  Push the [handler](#syntax-handler) H′.
                        
                    5.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                        
                    6.  Execute the instruction [throw\_ref](#syntax-instr-control).
                        
                4.  Else:
                    
                    1.  Let ([catch\_all\_ref](#syntax-instr-control) l) be the destructuring of [catch](#syntax-catch)0​.
                        
                    2.  Pop the [handler](#syntax-handler) from the stack.
                        
                    3.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                        
                    4.  Execute the instruction ([br](#syntax-instr-control) l).
                        
            6.  Else:
                
                1.  Let [val](#syntax-val)∗ be z.[exns](#syntax-state)\[a\].[fields](#syntax-exninst).
                    
                2.  Let [catch](#syntax-catch)0​ [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                    
                3.  If [catch](#syntax-catch)0​ is some [catch](#syntax-instr-control) [tagidx](#syntax-tagidx) [labelidx](#syntax-labelidx), then:
                    
                    1.  Let ([catch](#syntax-instr-control) x l) be the destructuring of [catch](#syntax-catch)0​.
                        
                    2.  If x<∣z.[tags](#syntax-state)∣ and z.[exns](#syntax-state)\[a\].[tag](#syntax-exninst)\=z.[tags](#syntax-state)\[x\], then:
                        
                        1.  Pop the [handler](#syntax-handler) from the stack.
                            
                        2.  Push the values [val](#syntax-val)∗ to the stack.
                            
                        3.  Execute the instruction ([br](#syntax-instr-control) l).
                            
                    3.  Else:
                        
                        1.  Let [catch](#syntax-catch) [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                            
                        2.  Pop the [handler](#syntax-handler) from the stack.
                            
                        3.  Let H′ be the [handler](#syntax-handler) whose arity is n and whose catch handler is [catch](#syntax-catch)′∗.
                            
                        4.  Push the [handler](#syntax-handler) H′.
                            
                        5.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                            
                        6.  Execute the instruction [throw\_ref](#syntax-instr-control).
                            
                4.  Else if [catch](#syntax-catch)0​ is some [catch\_ref](#syntax-instr-control) [tagidx](#syntax-tagidx) [labelidx](#syntax-labelidx), then:
                    
                    1.  Let ([catch\_ref](#syntax-instr-control) x l) be the destructuring of [catch](#syntax-catch)0​.
                        
                    2.  If x≥∣z.[tags](#syntax-state)∣ or z.[exns](#syntax-state)\[a\].[tag](#syntax-exninst)\=z.[tags](#syntax-state)\[x\], then:
                        
                        1.  Let [catch](#syntax-catch) [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                            
                        2.  Pop the [handler](#syntax-handler) from the stack.
                            
                        3.  Let H′ be the [handler](#syntax-handler) whose arity is n and whose catch handler is [catch](#syntax-catch)′∗.
                            
                        4.  Push the [handler](#syntax-handler) H′.
                            
                        5.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                            
                        6.  Execute the instruction [throw\_ref](#syntax-instr-control).
                            
                    3.  Else:
                        
                        1.  Pop the [handler](#syntax-handler) from the stack.
                            
                        2.  Push the values [val](#syntax-val)∗ to the stack.
                            
                        3.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                            
                        4.  Execute the instruction ([br](#syntax-instr-control) l).
                            
                5.  Else:
                    
                    1.  If [catch](#syntax-catch)0​ is some [catch\_all](#syntax-instr-control) [labelidx](#syntax-labelidx), then:
                        
                        1.  Let ([catch\_all](#syntax-instr-control) l) be the destructuring of [catch](#syntax-catch)0​.
                            
                        2.  Pop the [handler](#syntax-handler) from the stack.
                            
                        3.  Execute the instruction ([br](#syntax-instr-control) l).
                            
                    2.  Else if [catch](#syntax-catch)0​ is not some [catch\_all\_ref](#syntax-instr-control) [labelidx](#syntax-labelidx), then:
                        
                        1.  Let [catch](#syntax-catch) [catch](#syntax-catch)′∗ be [catch](#syntax-catch)′′∗.
                            
                        2.  Pop the [handler](#syntax-handler) from the stack.
                            
                        3.  Let H be the [handler](#syntax-handler) whose arity is n and whose catch handler is [catch](#syntax-catch)′∗.
                            
                        4.  Push the [handler](#syntax-handler) H.
                            
                        5.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                            
                        6.  Execute the instruction [throw\_ref](#syntax-instr-control).
                            
                    3.  Else:
                        
                        1.  Let ([catch\_all\_ref](#syntax-instr-control) l) be the destructuring of [catch](#syntax-catch)0​.
                            
                        2.  Pop the [handler](#syntax-handler) from the stack.
                            
                        3.  Push the value ([ref.exn](#syntax-ref) a) to the stack.
                            
                        4.  Execute the instruction ([br](#syntax-instr-control) l).
                            
6.  Else:
    
    1.  Assert: Due to [validation](#valid-throw-ref), the first non-value entry of the stack is not a [label](#syntax-label).
        
    2.  Assert: Due to [validation](#valid-throw-ref), the first non-value entry of the stack is not a [frame](#syntax-frame).
        
    3.  Assert: Due to [validation](#valid-throw-ref), the first non-value entry of the stack is not a [handler](#syntax-handler).
        
    4.  Throw the exception [val](#syntax-val)′ as a result.
        

​z;([ref.null](#syntax-instr-ref) ht) [throw\_ref](#syntax-instr-control)​[↪](#exec-notation)​[trap](#syntax-trap)0.8ex\]if [val](#syntax-val)∗\=ϵ∨[instr](#syntax-instr)∗\=ϵ0.8ex\]if z.[exns](#syntax-state)\[a\].[tag](#syntax-exninst)\=z.[tags](#syntax-state)\[x\]∧ [val](#syntax-val)∗\=z.[exns](#syntax-state)\[a\].[fields](#syntax-exninst)​0.8ex\]if z.[exns](#syntax-state)\[a\].[tag](#syntax-exninst)\=z.[tags](#syntax-state)\[x\]∧ [val](#syntax-val)∗\=z.[exns](#syntax-state)\[a\].[fields](#syntax-exninst)​0.8ex\]otherwise​z;[val](#syntax-val)∗ ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control) [instr](#syntax-instr)∗z;([label](#syntax-label)n​{[instr](#syntax-instr)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))z;([handler](#syntax-handler)n​{([catch\_ref](#syntax-instr-control) x l) [catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))z;([handler](#syntax-handler)n​{([catch\_all](#syntax-instr-control) l) [catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)0.8ex\][val](#syntax-val)∗ ([ref.exn](#syntax-ref) a) ([br](#syntax-instr-control) l)([br](#syntax-instr-control) l)0.8ex\]​z;([frame](#syntax-frame)n​{f} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))z;([handler](#syntax-handler)n​{([catch\_all\_ref](#syntax-instr-control) l) [catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))​[↪](#exec-notation)[↪](#exec-notation)​([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)0.8ex\]([ref.exn](#syntax-ref) a) ([br](#syntax-instr-control) l)0.8ex\]​z;([handler](#syntax-handler)n​{ϵ} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))z;([handler](#syntax-handler)n​{[catch](#syntax-catch) [catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))​[↪](#exec-notation)[↪](#exec-notation)​([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)0.8ex\]([handler](#syntax-handler)n​{[catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))​z;([handler](#syntax-handler)n​{([catch](#syntax-instr-control) x l) [catch](#syntax-catch)′∗} ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control))​[↪](#exec-notation)[val](#syntax-val)∗ ([br](#syntax-instr-control) l)​

##### 4.6.2.20. [try\_table](#syntax-instr-control) bt [catch](#syntax-catch)∗ [instr](#syntax-instr)∗[](#-hrefsyntax-instr-controlmathsftry_tablemathitbthrefsyntax-catchmathitcatchasthrefsyntax-instrmathitinstrast)

1.  Let z be the current state.
    
2.  Let t1m​ [→](#syntax-instrtype)[localidx](#syntax-localidx)0∗​​t2n​ be the destructuring of [instrtype](#aux-blocktype)z​(bt).
    
3.  Assert: Due to [validation](#valid-try-table), [localidx](#syntax-localidx)0∗​\=ϵ.
    
4.  Assert: Due to [validation](#valid-try-table), there are at least m values on the top of the stack.
    
5.  Pop the values [val](#syntax-val)m from the stack.
    
6.  Let H be the [handler](#syntax-handler) whose arity is n and whose catch handler is [catch](#syntax-catch)∗.
    
7.  Push the [handler](#syntax-handler) H.
    
8.  Let L be the [label](#syntax-label) whose arity is n and whose continuation is the end of the block.
    
9.  Enter the block [val](#syntax-val)m [instr](#syntax-instr)∗ with the [label](#syntax-label) L.
    

​z;[val](#syntax-val)m ([try\_table](#syntax-instr-control) bt [catch](#syntax-catch)∗ [instr](#syntax-instr)∗)​[↪](#exec-notation)​([handler](#syntax-handler)n​{[catch](#syntax-catch)∗} ([label](#syntax-label)n​{ϵ} [val](#syntax-val)m [instr](#syntax-instr)∗))if [instrtype](#aux-blocktype)z​(bt)\=t1m​→t2n​​​

#### 4.6.3. Blocks[](#blocks①)

The following auxiliary rules define the semantics of executing an [instruction sequence](#syntax-instrs) that forms a [block](#exec-instr-control).

##### 4.6.3.1. Entering [instr](#syntax-instr)∗ with label L and values [val](#syntax-val)∗[](#entering--hrefsyntax-instrmathitinstrast-with-label--l-and-values--hrefsyntax-valmathitvalast)

1.  Push L to the stack.
    
2.  Push the values [val](#syntax-val)∗ to the stack.
    
3.  Jump to the start of the instruction sequence [instr](#syntax-instr)∗.
    

Note

No formal reduction rule is needed for entering an instruction sequence, because the label L is embedded in the [administrative instruction](#syntax-instr-admin) that structured control instructions reduce to directly.

##### 4.6.3.2. Exiting [instr](#syntax-instr)∗ with label L[](#exiting--hrefsyntax-instrmathitinstrast-with-label--l)

When the end of a block is reached without a jump, [exception](#exception), or [trap](#trap) aborting it, then the following steps are performed.

1.  Pop all values [val](#syntax-val)∗ from the top of the stack.
    
2.  Assert: due to [validation](#valid-instrs), the label L is now on the top of the stack.
    
3.  Pop the label from the stack.
    
4.  Push [val](#syntax-val)∗ back to the stack.
    
5.  Jump to the position after the end of the [structured control instruction](#syntax-instr-control) associated with the label L.
    

​([label](#syntax-label)n​{[instr](#syntax-instr)∗} [val](#syntax-val)∗)​[↪](#exec-notation)​[val](#syntax-val)∗​​

Note

This semantics also applies to the instruction sequence contained in a loop instruction. Therefore, execution of a loop falls off the end, unless a backwards branch is performed explicitly.

#### 4.6.4. Exception Handling[](#exception-handling①)

The following auxiliary rules define the semantics of entering and exiting try\_table blocks.

##### 4.6.4.1. Entering [instr](#syntax-instr)∗ with label L and exception handler H[](#entering--hrefsyntax-instrmathitinstrast-with-label--l-and-exception-handler--h)

1.  Push H to the stack.
    
2.  Push L onto the stack.
    
3.  Jump to the start of the instruction sequence [instr](#syntax-instr)∗.
    

Note

No formal reduction rule is needed for entering an exception [handler](#syntax-handler) because it is an [administrative instruction](#syntax-instr-admin) that the try\_table instruction reduces to directly.

##### 4.6.4.2. Exiting an exception handler[](#exiting-an-exception-handler①)

When the end of a try\_table block is reached without a jump, [exception](#exception), or [trap](#trap), then the following steps are performed.

1.  Let m be the number of values on the top of the stack.
    
2.  Pop the values [val](#syntax-val)m from the stack.
    
3.  Assert: due to [validation](#valid-instrs), a handler and a label are now on the top of the stack.
    
4.  Pop the label from the stack.
    
5.  Pop the handler H from the stack.
    
6.  Push [val](#syntax-val)m back to the stack.
    
7.  Jump to the position after the end of the administrative instruction associated with the handler H.
    

​([handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [val](#syntax-val)∗)​[↪](#exec-notation)​[val](#syntax-val)∗​​

#### 4.6.5. Function Calls[](#function-calls①)

The following auxiliary rules define the semantics of invoking a [function instance](#syntax-funcinst) through one of the [call instructions](#exec-instr-control) and returning from it.

##### 4.6.5.1. Invocation of [function reference](#syntax-ref-func) ([ref.func](#syntax-ref) a)[](#invocation-of-function-reference--hrefsyntax-refmathsfreffunca)

1.  Assert: due to [validation](#valid-call), S.[funcs](#syntax-store)\[a\] exists.
    
2.  Let f be the [function instance](#syntax-funcinst), S.[funcs](#syntax-store)\[a\].
    
3.  Let [func](#syntax-comptype) \[t1n​\][→](#syntax-comptype)\[t2m​\] be the [composite type](#syntax-comptype) [expand](#aux-expand-deftype)(f.[type](#syntax-funcinst)).
    
4.  Let [func](#syntax-func) x [local](#syntax-local)∗ [instr](#syntax-instr)∗ be the [function](#syntax-func) f.[code](#syntax-funcinst).
    
5.  Assert: due to [validation](#valid-call), n values are on the top of the stack.
    
6.  Pop the values [val](#syntax-val)n from the stack.
    
7.  Let F be the [frame](#syntax-frame) {[module](#syntax-frame) F.[module](#syntax-funcinst),[locals](#syntax-frame) [val](#syntax-val)n ([default](#aux-default)t​)∗}.
    
8.  Push the activation of f with arity m to the stack.
    
9.  Let L be the [label](#syntax-label) whose arity is m and whose continuation is the end of the function.
    
10.  [Enter](#exec-instrs-enter) the instruction sequence [instr](#syntax-instr)∗ with label L and no values.
    

​z;[val](#syntax-val)n ([ref.func](#syntax-ref) a) ([call\_ref](#syntax-instr-control) y)​[↪](#exec-notation)​([frame](#syntax-frame)m​{f} ([label](#syntax-label)m​{ϵ} [instr](#syntax-instr)∗))if z.[funcs](#syntax-state)\[a\]\=fi∧ fi.[type](#syntax-funcinst)[≈](#aux-expand-deftype)[func](#syntax-comptype) t1n​[→](#syntax-comptype)t2m​∧ fi.[code](#syntax-funcinst)\=[func](#syntax-func) x ([local](#syntax-local) t)∗ ([instr](#syntax-instr)∗)∧ f\={[locals](#syntax-frame) [val](#syntax-val)n ([default](#aux-default)t​)∗,[module](#syntax-frame) fi.[module](#syntax-funcinst)}​​​

Note

For non-defaultable types, the respective local is left uninitialized by these rules.

##### 4.6.5.2. Returning from a function[](#returning-from-a-function①)

When the end of a function is reached without a jump (including through [return](#syntax-instr-control)), or an [exception](#exception) or [trap](#trap) aborting it, then the following steps are performed.

1.  Let F be the [current](#exec-notation-textual) [frame](#syntax-frame).
    
2.  Let n be the arity of the activation of F.
    
3.  Assert: due to [validation](#valid-instrs), there are n values on the top of the stack.
    
4.  Pop the results [val](#syntax-val)n from the stack.
    
5.  Assert: due to [validation](#valid-func), the frame F is now on the top of the stack.
    
6.  Pop the frame from the stack.
    
7.  Push [val](#syntax-val)n back to the stack.
    
8.  Jump to the instruction after the original call.
    

​([frame](#syntax-frame)n​{f} [val](#syntax-val)n)​[↪](#exec-notation)​[val](#syntax-val)n​​

##### 4.6.5.3. Host Functions[](#host-functions①)

Invoking a [host function](#syntax-hostfunc) has non-deterministic behavior. It may either terminate with a [trap](#trap), an [exception](#exception), or return regularly. However, in the latter case, it must consume and produce the right number and types of WebAssembly [values](#syntax-val) on the stack, according to its [function type](#syntax-functype).

A host function may also modify the [store](#syntax-store). However, all store modifications must result in an [extension](#extend-store) of the original store, i.e., they must only modify mutable contents and must not have instances removed. Furthermore, the resulting store must be [valid](#valid-store), i.e., all data and code in it is well-typed.

−1ex\]S;[val](#syntax-val)n ([ref.func](#syntax-ref) a) [call\_ref](#syntax-instr-control)​[↪](#exec-notation)​S′;[result](#syntax-result)​if∧∧​S.[funcs](#syntax-store)\[a\]\={[type](#syntax-funcinst) [deftype](#syntax-deftype),[hostfunc](#syntax-funcinst) hf}[deftype](#syntax-deftype)≈[func](#syntax-comptype) \[t1n​\][→](#syntax-comptype)\[t2m​\](S′;[result](#syntax-result))∈hf(S;[val](#syntax-val)n)​S;[val](#syntax-val)n ([ref.func](#syntax-ref) a) [call\_ref](#syntax-instr-control)​[↪](#exec-notation)​S;[val](#syntax-val)n ([ref.func](#syntax-ref) a) [call\_ref](#syntax-instr-control)​if∧∧​S.[funcs](#syntax-store)\[a\]\={[type](#syntax-funcinst) [deftype](#syntax-deftype),[hostfunc](#syntax-funcinst) hf}[deftype](#syntax-deftype)≈[func](#syntax-comptype) \[t1n​\][→](#syntax-comptype)\[t2m​\]⊥∈hf(S;[val](#syntax-val)n)​​​

Here, hf(S;[val](#syntax-val)n) denotes the implementation-defined execution of host function hf in current store S with arguments [val](#syntax-val)n. It yields a set of possible outcomes, where each element is either a pair of a modified store S′ and a [result](#syntax-result) or the special value ⊥ indicating divergence. A host function is non-deterministic if there is at least one argument for which the set of outcomes is not singular.

For a WebAssembly implementation to be [sound](#soundness) in the presence of host functions, every [host function instance](#syntax-funcinst) must be [valid](#valid-hostfuncinst), which means that it adheres to suitable pre- and post-conditions: under a [valid store](#valid-store) S, and given arguments [val](#syntax-val)n matching the ascribed parameter types t1n​, executing the host function must yield a non-empty set of possible outcomes each of which is either divergence or consists of a valid store S′ that is an [extension](#extend-store) of S and a result matching the ascribed return types t2m​. All these notions are made precise in the [Appendix](#soundness).

Note

A host function can call back into WebAssembly by [invoking](#exec-invocation) a function [exported](#syntax-export) from a [module](#syntax-module). However, the effects of any such call are subsumed by the non-deterministic behavior allowed for the host function.

#### 4.6.6. Variable Instructions[](#variable-instructions⑤)

##### 4.6.6.1. [local.get](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalgetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-local-get), z.[locals](#syntax-state)\[x\] is defined.
    
3.  Let [val](#syntax-val) be z.[locals](#syntax-state)\[x\].
    
4.  Push the value [val](#syntax-val) to the stack.
    

​z;([local.get](#syntax-instr-variable) x)​[↪](#exec-notation)​[val](#syntax-val)​if z.[locals](#syntax-state)\[x\]\=[val](#syntax-val)​​

##### 4.6.6.2. [local.set](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalsetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-local-set), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  Replace z.[locals](#syntax-state)\[x\] with [val](#syntax-val).
    

​z;[val](#syntax-val) ([local.set](#syntax-instr-variable) x)​[↪](#exec-notation)​z\[.[locals](#syntax-state)\[x\]\=[val](#syntax-val)\];ϵ​​

##### 4.6.6.3. [local.tee](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsflocalteex①)

1.  Assert: Due to [validation](#valid-local-tee), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  Push the value [val](#syntax-val) to the stack.
    
4.  Push the value [val](#syntax-val) to the stack.
    
5.  Execute the instruction ([local.set](#syntax-instr-variable) x).
    

​[val](#syntax-val) ([local.tee](#syntax-instr-variable) x)​[↪](#exec-notation)​[val](#syntax-val) [val](#syntax-val) ([local.set](#syntax-instr-variable) x)​​

##### 4.6.6.4. [global.get](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsfglobalgetx①)

1.  Let z be the current state.
    
2.  Let [val](#syntax-val) be the [value](#syntax-val) z.[globals](#syntax-state)\[x\].[value](#syntax-globalinst).
    
3.  Push the value [val](#syntax-val) to the stack.
    

​z;([global.get](#syntax-instr-variable) x)​[↪](#exec-notation)​[val](#syntax-val)​if z.[globals](#syntax-state)\[x\].[value](#syntax-globalinst)\=[val](#syntax-val)​​

##### 4.6.6.5. [global.set](#syntax-instr-variable) x[](#-hrefsyntax-instr-variablemathsfglobalsetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-global-set), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  Replace z.[globals](#syntax-state)\[x\].value with [val](#syntax-val).
    

​z;[val](#syntax-val) ([global.set](#syntax-instr-variable) x)​[↪](#exec-notation)​z\[.[globals](#syntax-state)\[x\].[value](#syntax-globalinst)\=[val](#syntax-val)\];ϵ​​

#### 4.6.7. Table Instructions[](#table-instructions⑤)

##### 4.6.7.1. [table.get](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablegetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-get), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
4.  If i≥∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
5.  Push the value z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)\[i\] to the stack.
    

​z;(at.[const](#syntax-instr-numeric) i) ([table.get](#syntax-instr-table) x)z;(at.[const](#syntax-instr-numeric) i) ([table.get](#syntax-instr-table) x)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)\[i\]​if i≥∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣if i<∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣​​

##### 4.6.7.2. [table.set](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablesetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-set), a [reference value](#syntax-ref) is on the top of the stack.
    
3.  Pop the value [ref](#syntax-ref) from the stack.
    
4.  Assert: Due to [validation](#valid-table-set), a [number value](#syntax-num) is on the top of the stack.
    
5.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
6.  If i≥∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
7.  Replace z.[tables](#syntax-state)\[x\].refs\[i\] with [ref](#syntax-ref).
    

​z;(at.[const](#syntax-instr-numeric) i) [ref](#syntax-ref) ([table.set](#syntax-instr-table) x)z;(at.[const](#syntax-instr-numeric) i) [ref](#syntax-ref) ([table.set](#syntax-instr-table) x)​[↪](#exec-notation)[↪](#exec-notation)​z;[trap](#syntax-trap)z\[.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)\[i\]\=[ref](#syntax-ref)\];ϵ​if i≥∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣if i<∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣​​

##### 4.6.7.3. [table.size](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablesizex①)

1.  Let z be the current state.
    
2.  Let (at lim rt) be the destructuring of z.[tables](#syntax-state)\[x\].[type](#syntax-tableinst).
    
3.  Let n be the length of z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst).
    
4.  Push the value (at.[const](#syntax-instr-numeric) n) to the stack.
    

​z;([table.size](#syntax-instr-table) x)​[↪](#exec-notation)​(at.[const](#syntax-instr-numeric) n)​if ∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣\=n∧ z.[tables](#syntax-state)\[x\].[type](#syntax-tableinst)\=at lim rt​​​

##### 4.6.7.4. [table.grow](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablegrowx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-grow), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-table-grow), a [reference value](#syntax-ref) is on the top of the stack.
    
5.  Pop the value [ref](#syntax-ref) from the stack.
    
6.  Either:
    
    1.  Let ti be the [table instance](#syntax-tableinst) [growtable](#grow-table)(z.[tables](#syntax-state)\[x\],n,[ref](#syntax-ref)).
        
    2.  Push the value (at.[const](#syntax-instr-numeric) ∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣) to the stack.
        
    3.  Replace z.[tables](#syntax-state)\[x\] with ti.
        
7.  Or:
    
    1.  Push the value (at.[const](#syntax-instr-numeric) [signed](#aux-signed)∣at∣−1​(−1)) to the stack.
        

​z;[ref](#syntax-ref) (at.[const](#syntax-instr-numeric) n) ([table.grow](#syntax-instr-table) x)z;[ref](#syntax-ref) (at.[const](#syntax-instr-numeric) n) ([table.grow](#syntax-instr-table) x)​[↪](#exec-notation)[↪](#exec-notation)​z\[.[tables](#syntax-state)\[x\]\=ti\];(at.[const](#syntax-instr-numeric) ∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣)if ti\=[growtable](#grow-table)(z.[tables](#syntax-state)\[x\],n,[ref](#syntax-ref))z;(at.[const](#syntax-instr-numeric) [signed](#aux-signed)∣at∣−1​(−1))​​

Note

The [table.grow](#syntax-instr-table) instruction is non-deterministic. It may either succeed, returning the old table size sz, or fail, returning −1. Failure _must_ occur if the referenced table instance has a maximum size defined that would be exceeded. However, failure _can_ occur in other cases as well. In practice, the choice depends on the [resources](#impl-exec) available to the [embedder](#embedder).

##### 4.6.7.5. [table.fill](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsftablefillx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-fill), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-table-fill), a value is on the top of the stack.
    
5.  Pop the value [val](#syntax-val) from the stack.
    
6.  Assert: Due to [validation](#valid-table-fill), a value of [number type](#syntax-numtype) at is on the top of the stack.
    
7.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) i) from the stack.
    
8.  If i+n\>∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
9.  If n\=0, then:
    
    1.  Do nothing.
        
10.  Else:
    
    1.  Push the value (at.[const](#syntax-instr-numeric) i) to the stack.
        
    2.  Push the value [val](#syntax-val) to the stack.
        
    3.  Execute the instruction ([table.set](#syntax-instr-table) x).
        
    4.  Push the value (at.[const](#syntax-instr-numeric) i+1) to the stack.
        
    5.  Push the value [val](#syntax-val) to the stack.
        
    6.  Push the value (at.[const](#syntax-instr-numeric) n−1) to the stack.
        
    7.  Execute the instruction ([table.fill](#syntax-instr-table) x).
        

​z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([table.fill](#syntax-instr-table) x)z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([table.fill](#syntax-instr-table) x)z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([table.fill](#syntax-instr-table) x)(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) ([table.set](#syntax-instr-table) x)(at.[const](#syntax-instr-numeric) i+1) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n−1) ([table.fill](#syntax-instr-table) x)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​if i+n\>∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣otherwise, if n\=0​​

##### 4.6.7.6. [table.copy](#syntax-instr-table) x1​ x2​[](#-hrefsyntax-instr-tablemathsftablecopyx_1x_2)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-copy), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-table-copy), a [number value](#syntax-num) is on the top of the stack.
    
5.  Pop the value (at2​.[const](#syntax-instr-numeric) i2​) from the stack.
    
6.  Assert: Due to [validation](#valid-table-copy), a [number value](#syntax-num) is on the top of the stack.
    
7.  Pop the value (at1​.[const](#syntax-instr-numeric) i1​) from the stack.
    
8.  If i1​+n\>∣z.[tables](#syntax-state)\[x1​\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
9.  If i2​+n\>∣z.[tables](#syntax-state)\[x2​\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
10.  If n\=0, then:
    
    1.  Do nothing.
        
11.  Else:
    
    1.  If i1​≤i2​, then:
        
        1.  Push the value (at1​.[const](#syntax-instr-numeric) i1​) to the stack.
            
        2.  Push the value (at2​.[const](#syntax-instr-numeric) i2​) to the stack.
            
        3.  Execute the instruction ([table.get](#syntax-instr-table) x2​).
            
        4.  Execute the instruction ([table.set](#syntax-instr-table) x1​).
            
        5.  Push the value (at1​.[const](#syntax-instr-numeric) i1​+1) to the stack.
            
        6.  Push the value (at2​.[const](#syntax-instr-numeric) i2​+1) to the stack.
            
    2.  Else:
        
        1.  Push the value (at1​.[const](#syntax-instr-numeric) i1​+n−1) to the stack.
            
        2.  Push the value (at2​.[const](#syntax-instr-numeric) i2​+n−1) to the stack.
            
        3.  Execute the instruction ([table.get](#syntax-instr-table) x2​).
            
        4.  Execute the instruction ([table.set](#syntax-instr-table) x1​).
            
        5.  Push the value (at1​.[const](#syntax-instr-numeric) i1​) to the stack.
            
        6.  Push the value (at2​.[const](#syntax-instr-numeric) i2​) to the stack.
            
    3.  Push the value (at.[const](#syntax-instr-numeric) n−1) to the stack.
        
    4.  Execute the instruction ([table.copy](#syntax-instr-table) x1​ x2​).
        

​z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([table.copy](#syntax-instr-table) x1​ x2​)if i1​+n\>∣z.[tables](#syntax-state)\[x1​\].[refs](#syntax-tableinst)∣∨i2​+n\>∣z.[tables](#syntax-state)\[x2​\].[refs](#syntax-tableinst)∣z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([table.copy](#syntax-instr-table) x y)z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([table.copy](#syntax-instr-table) x y)(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) ([table.get](#syntax-instr-table) y) ([table.set](#syntax-instr-table) x)(at1​.[const](#syntax-instr-numeric) i1​+1) (at2​.[const](#syntax-instr-numeric) i2​+1) (at′.[const](#syntax-instr-numeric) n−1) ([table.copy](#syntax-instr-table) x y)​​otherwise, if i1​≤i2​​z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([table.copy](#syntax-instr-table) x y)(at1​.[const](#syntax-instr-numeric) i1​+n−1) (at2​.[const](#syntax-instr-numeric) i2​+n−1) ([table.get](#syntax-instr-table) y) ([table.set](#syntax-instr-table) x)(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n−1) ([table.copy](#syntax-instr-table) x y)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​otherwise, if n\=0​​

##### 4.6.7.7. [table.init](#syntax-instr-table) x y[](#-hrefsyntax-instr-tablemathsftableinitxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-table-init), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-table-init), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) from the stack.
    
6.  Assert: Due to [validation](#valid-table-init), a [number value](#syntax-num) is on the top of the stack.
    
7.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
8.  If i+n\>∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣, then:
    
    1.  Trap.
        
9.  If j+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣, then:
    
    1.  Trap.
        
10.  If n\=0, then:
    
    1.  Do nothing.
        
11.  Else:
    
    1.  Assert: Due to [validation](#valid-table-init), j<∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣.
        
    2.  Push the value (at.[const](#syntax-instr-numeric) i) to the stack.
        
    3.  Push the value z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[j\] to the stack.
        
    4.  Execute the instruction ([table.set](#syntax-instr-table) x).
        
    5.  Push the value (at.[const](#syntax-instr-numeric) i+1) to the stack.
        
    6.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) to the stack.
        
    7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
        
    8.  Execute the instruction ([table.init](#syntax-instr-table) x y).
        

​z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([table.init](#syntax-instr-table) x y)if i+n\>∣z.[tables](#syntax-state)\[x\].[refs](#syntax-tableinst)∣∨j+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([table.init](#syntax-instr-table) x y)z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([table.init](#syntax-instr-table) x y)(at.[const](#syntax-instr-numeric) i) z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[j\] ([table.set](#syntax-instr-table) x)(at.[const](#syntax-instr-numeric) i+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([table.init](#syntax-instr-table) x y)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​otherwise, if n\=0​​

##### 4.6.7.8. [elem.drop](#syntax-instr-table) x[](#-hrefsyntax-instr-tablemathsfelemdropx①)

1.  Let z be the current state.
    
2.  Replace z.[elems](#syntax-state)\[x\].refs with ϵ.
    

​z;([elem.drop](#syntax-instr-table) x)​[↪](#exec-notation)​z\[.[elems](#syntax-state)\[x\].[refs](#syntax-eleminst)\=ϵ\];ϵ​​

#### 4.6.8. Memory Instructions[](#memory-instructions⑤)

Note

The alignment [memarg](#syntax-memarg).[align](#syntax-instr-memory) in load and store instructions does not affect the semantics. It is a hint that the offset ea at which the memory is accessed is intended to satisfy the property eamod2[memarg](#syntax-memarg).[align](#syntax-instr-memory)\=0. A WebAssembly implementation can use this hint to optimize for the intended use. Unaligned access violating that property is still allowed and must succeed regardless of the annotation. However, it may be substantially slower on some hardware.

##### 4.6.8.1. nt.[load](#syntax-instr-memory)[loadop](#syntax-loadop)? x ao[](#-mathitnthrefsyntax-instr-memorymathsfloadhrefsyntax-loadopmathitloadopxmathitao)

1.  Let z be the current state.
    
2.  Assert: Due to validation, a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
4.  If [loadop](#syntax-loadop)? is not defined, then:
    
    1.  If i+ao.[offset](#syntax-instr-memory)+∣nt∣/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
        
        1.  Trap.
            
    2.  Let c be the result for which [bytes](#aux-bytes)nt​(c) \= z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):∣nt∣/8\].
        
    3.  Push the value (nt.[const](#syntax-instr-numeric) c) to the stack.
        
5.  Else:
    
    1.  Assert: Due to validation, nt is [i](#syntax-numtype)[N](#syntax-numtype).
        
    2.  Let [loadop](#syntax-loadop)0​ be [loadop](#syntax-loadop)?.
        
    3.  Let n\_[sx](#syntax-sx) be the destructuring of [loadop](#syntax-loadop)0​.
        
    4.  If i+ao.[offset](#syntax-instr-memory)+n/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
        
        1.  Trap.
            
    5.  Let c be the result for which [bytes](#aux-bytes)[i](#syntax-numtype)n​(c) \= z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):n/8\].
        
    6.  Push the value (nt.[const](#syntax-instr-numeric) [extend](#op-extend)n,∣nt∣[sx](#syntax-sx)​(c)) to the stack.
        

​z;(at.[const](#syntax-instr-numeric) i) (nt.[load](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) (nt.[load](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) ([i](#syntax-numtype)[N](#syntax-numtype).[load](#syntax-instr-memory)n\_[sx](#syntax-sx) x ao)z;(at.[const](#syntax-instr-numeric) i) ([i](#syntax-numtype)[N](#syntax-numtype).[load](#syntax-instr-memory)n\_[sx](#syntax-sx) x ao)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+∣nt∣/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣(nt.[const](#syntax-instr-numeric) c)if [bytes](#aux-bytes)nt​(c)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):∣nt∣/8\][trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+n/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣([i](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-numeric) [extend](#op-extend)n,∣[i](#syntax-numtype)[N](#syntax-numtype)∣[sx](#syntax-sx)​(c))if [bytes](#aux-bytes)[i](#syntax-numtype)n​(c)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):n/8\]​​​

##### 4.6.8.2. [v128](#syntax-vectype).[load](#syntax-instr-memory)M[x](#syntax-shape)K\_[sx](#syntax-sx) x ao[](#-hrefsyntax-vectypemathsfvscriptstyle128hrefsyntax-instr-memorymathsfloadmhrefsyntax-shapemathsfxkmathsf_hrefsyntax-sxmathitsxxmathitao)

1.  Let z be the current state.
    
2.  Assert: Due to validation, a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
4.  If i+ao.[offset](#syntax-instr-memory)+M⋅K/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
5.  Let jK be the result for which ([bytes](#aux-bytes)[i](#syntax-numtype)M​(jK)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory)+k⋅M/8:M/8\])k<K.
    
6.  Let [i](#syntax-numtype)[N](#syntax-numtype) be the result for which N \= M⋅2.
    
7.  Let c be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)K−1​([extend](#op-extend)M,N[sx](#syntax-sx)​(j)K).
    
8.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)M[x](#syntax-shape)K\_[sx](#syntax-sx) x ao)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)M[x](#syntax-shape)K\_[sx](#syntax-sx) x ao)if ([bytes](#aux-bytes)[i](#syntax-numtype)M​(j)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory)+k⋅M/8:M/8\])k<K∧ c\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)K−1​([extend](#op-extend)M,N[sx](#syntax-sx)​(j)K)∧N\=M⋅2​​[↪](#exec-notation)[↪](#exec-notation)[trap](#syntax-trap)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if i+ao.[offset](#syntax-instr-memory)+M⋅K/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣​

##### 4.6.8.3. [v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[splat](#syntax-instr-memory) x ao[](#-hrefsyntax-vectypemathsfvscriptstyle128hrefsyntax-instr-memorymathsfloadnmathsf_hrefsyntax-instr-memorymathsfsplatxmathitao)

1.  Let z be the current state.
    
2.  Assert: Due to validation, a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
4.  If i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
5.  Let M be 128/N.
    
6.  Let [i](#syntax-numtype)[N](#syntax-numtype) be the result for which ∣[i](#syntax-numtype)[N](#syntax-numtype)∣ \= N.
    
7.  Let j be the result for which [bytes](#aux-bytes)[i](#syntax-numtype)N​(j) \= z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\].
    
8.  Let c be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​(jM).
    
9.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[splat](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[splat](#syntax-instr-memory) x ao)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if [bytes](#aux-bytes)[i](#syntax-numtype)N​(j)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\]∧ N\=∣[i](#syntax-numtype)[N](#syntax-numtype)∣∧ M\=128/N∧ c\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​(jM)​​if i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣​

##### 4.6.8.4. [v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[zero](#syntax-instr-memory) x ao[](#-hrefsyntax-vectypemathsfvscriptstyle128hrefsyntax-instr-memorymathsfloadnmathsf_hrefsyntax-instr-memorymathsfzeroxmathitao)

1.  Let z be the current state.
    
2.  Assert: Due to validation, a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
4.  If i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
5.  Let j be the result for which [bytes](#aux-bytes)[i](#syntax-numtype)N​(j) \= z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\].
    
6.  Let c be [extend](#op-extend)N,128[u](#syntax-sx)​(j).
    
7.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[zero](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[zero](#syntax-instr-memory) x ao)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if [bytes](#aux-bytes)[i](#syntax-numtype)N​(j)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\]∧ c\=[extend](#op-extend)N,128[u](#syntax-sx)​(j)​​if i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣​

##### 4.6.8.5. [v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j[](#-hrefsyntax-vectypemathsfvscriptstyle128hrefsyntax-instr-memorymathsfloadnmathsf_hrefsyntax-instr-memorymathsflanexmathitaoj)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-vload-lane), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
3.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
4.  Assert: Due to [validation](#valid-vload-lane), a [number value](#syntax-num) is on the top of the stack.
    
5.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
6.  If i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
7.  Let M be ∣[v128](#syntax-vectype)∣/N.
    
8.  Let [i](#syntax-numtype)[N](#syntax-numtype) be the result for which ∣[i](#syntax-numtype)[N](#syntax-numtype)∣ \= N.
    
9.  Let k be the result for which [bytes](#aux-bytes)[i](#syntax-numtype)N​(k) \= z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\].
    
10.  Let c be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​)\[\[j\]\=k\]).
    
11.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[load](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if [bytes](#aux-bytes)[i](#syntax-numtype)N​(k)\=z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\]∧ N\=∣[i](#syntax-numtype)[N](#syntax-numtype)∣∧ M\=∣[v128](#syntax-vectype)∣/N∧ c\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​)\[\[j\]\=k\])​​if i+ao.[offset](#syntax-instr-memory)+N/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣​

##### 4.6.8.6. nt.[store](#syntax-instr-memory)[storeop](#syntax-storeop)? x ao[](#-mathitnthrefsyntax-instr-memorymathsfstorehrefsyntax-storeopmathitstoreopxmathitao)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-store), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (nt′.[const](#syntax-instr-numeric) c) from the stack.
    
4.  Assert: Due to [validation](#valid-store), a value is on the top of the stack.
    
5.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
6.  Assert: Due to [validation](#valid-store), nt\=nt′.
    
7.  If [storeop](#syntax-storeop)? is not defined, then:
    
    1.  If i+ao.[offset](#syntax-instr-memory)+∣nt′∣/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
        
        1.  Trap.
            
    2.  Let b∗ be [bytes](#aux-bytes)nt′​(c).
        
    3.  Replace z.[mems](#syntax-state)\[x\].bytes\[i+ao.[offset](#syntax-instr-memory):∣nt′∣/8\] with b∗.
        
8.  Else:
    
    1.  Assert: Due to [validation](#valid-store), nt′ is [i](#syntax-numtype)[N](#syntax-numtype).
        
    2.  Let n be [storeop](#syntax-storeop)?.
        
    3.  If i+ao.[offset](#syntax-instr-memory)+n/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
        
        1.  Trap.
            
    4.  Let b∗ be [bytes](#aux-bytes)[i](#syntax-numtype)n​([wrap](#op-wrap)∣nt′∣,n​(c)).
        
    5.  Replace z.[mems](#syntax-state)\[x\].bytes\[i+ao.[offset](#syntax-instr-memory):n/8\] with b∗.
        

​z;(at.[const](#syntax-instr-numeric) i) (nt.[const](#syntax-instr-numeric) c) (nt.[store](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) (nt.[const](#syntax-instr-numeric) c) (nt.[store](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) ([i](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-numeric) c) ([i](#syntax-numtype)[N](#syntax-numtype).[store](#syntax-instr-memory)n x ao)z;(at.[const](#syntax-instr-numeric) i) ([i](#syntax-numtype)[N](#syntax-numtype).[const](#syntax-instr-numeric) c) ([i](#syntax-numtype)[N](#syntax-numtype).[store](#syntax-instr-memory)n x ao)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) ([v128](#syntax-vectype).[store](#syntax-instr-memory) x ao)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) ([v128](#syntax-vectype).[store](#syntax-instr-memory) x ao)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​z;[trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+∣nt∣/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣z\[.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):∣nt∣/8\]\=b∗\];ϵif b∗\=[bytes](#aux-bytes)nt​(c)z;[trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+n/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣z\[.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):n/8\]\=b∗\];ϵif b∗\=[bytes](#aux-bytes)[i](#syntax-numtype)n​([wrap](#op-wrap)∣[i](#syntax-numtype)[N](#syntax-numtype)∣,n​(c))z;[trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+∣[v128](#syntax-vectype)∣/8\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣z\[.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):∣[v128](#syntax-vectype)∣/8\]\=b∗\];ϵif b∗\=[bytes](#aux-bytes)[v128](#syntax-vectype)​(c)​​​

##### 4.6.8.7. [v128](#syntax-vectype).[store](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j[](#-hrefsyntax-vectypemathsfvscriptstyle128hrefsyntax-instr-memorymathsfstorenmathsf_hrefsyntax-instr-memorymathsflanexmathitaoj)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-vstore-lane), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
3.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) from the stack.
    
4.  Assert: Due to [validation](#valid-vstore-lane), a [number value](#syntax-num) is on the top of the stack.
    
5.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
6.  If i+ao.[offset](#syntax-instr-memory)+N\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
7.  Let M be 128/N.
    
8.  Let [i](#syntax-numtype)[N](#syntax-numtype) be the result for which ∣[i](#syntax-numtype)[N](#syntax-numtype)∣ \= N.
    
9.  Assert: Due to [validation](#valid-vstore-lane), j<∣[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c)∣.
    
10.  Let b∗ be [bytes](#aux-bytes)[i](#syntax-numtype)N​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c)\[j\]).
    
11.  Replace z.[mems](#syntax-state)\[x\].bytes\[i+ao.[offset](#syntax-instr-memory):N/8\] with b∗.
    

​z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) ([v128](#syntax-vectype).[store](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j)z;(at.[const](#syntax-instr-numeric) i) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) ([v128](#syntax-vectype).[store](#syntax-instr-memory)N\_[lane](#syntax-instr-memory) x ao j)​[↪](#exec-notation)[↪](#exec-notation)​z;[trap](#syntax-trap)if i+ao.[offset](#syntax-instr-memory)+N\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣z\[.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)\[i+ao.[offset](#syntax-instr-memory):N/8\]\=b∗\];ϵif N\=∣[i](#syntax-numtype)[N](#syntax-numtype)∣∧ M\=128/N∧ b∗\=[bytes](#aux-bytes)[i](#syntax-numtype)N​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c)\[j\])​​​

##### 4.6.8.8. [memory.size](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemorysizex①)

1.  Let z be the current state.
    
2.  Let (at lim [page](#syntax-memtype)) be the destructuring of z.[mems](#syntax-state)\[x\].[type](#syntax-meminst).
    
3.  Let n⋅64Ki be the length of z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst).
    
4.  Push the value (at.[const](#syntax-instr-numeric) n) to the stack.
    

​z;([memory.size](#syntax-instr-memory) x)​[↪](#exec-notation)​(at.[const](#syntax-instr-numeric) n)​if n⋅64Ki\=∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣∧ z.[mems](#syntax-state)\[x\].[type](#syntax-meminst)\=at lim [page](#syntax-memtype)​​​

##### 4.6.8.9. [memory.grow](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemorygrowx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-memory-grow), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Either:
    
    1.  Let mi be the [memory instance](#syntax-meminst) [growmem](#grow-mem)(z.[mems](#syntax-state)\[x\],n).
        
    2.  Push the value (at.[const](#syntax-instr-numeric) ∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣/(64Ki)) to the stack.
        
    3.  Replace z.[mems](#syntax-state)\[x\] with mi.
        
5.  Or:
    
    1.  Push the value (at.[const](#syntax-instr-numeric) [signed](#aux-signed)∣at∣−1​(−1)) to the stack.
        

​z;(at.[const](#syntax-instr-numeric) n) ([memory.grow](#syntax-instr-memory) x)z;(at.[const](#syntax-instr-numeric) n) ([memory.grow](#syntax-instr-memory) x)​[↪](#exec-notation)[↪](#exec-notation)​z\[.[mems](#syntax-state)\[x\]\=mi\];(at.[const](#syntax-instr-numeric) ∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣/64Ki)if mi\=[growmem](#grow-mem)(z.[mems](#syntax-state)\[x\],n)z;(at.[const](#syntax-instr-numeric) [signed](#aux-signed)∣at∣−1​(−1))​​

Note

The [memory.grow](#syntax-instr-memory) instruction is non-deterministic. It may either succeed, returning the old memory size sz, or fail, returning −1. Failure _must_ occur if the referenced memory instance has a maximum size defined that would be exceeded. However, failure _can_ occur in other cases as well. In practice, the choice depends on the [resources](#impl-exec) available to the [embedder](#embedder).

##### 4.6.8.10. [memory.fill](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfmemoryfillx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-memory-fill), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-memory-fill), a value is on the top of the stack.
    
5.  Pop the value [val](#syntax-val) from the stack.
    
6.  Assert: Due to [validation](#valid-memory-fill), a value of [number type](#syntax-numtype) at is on the top of the stack.
    
7.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) i) from the stack.
    
8.  If i+n\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
9.  If n\=0, then:
    
    1.  Do nothing.
        
10.  Else:
    
    1.  Push the value (at.[const](#syntax-instr-numeric) i) to the stack.
        
    2.  Push the value [val](#syntax-val) to the stack.
        
    3.  Execute the instruction ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x).
        
    4.  Push the value (at.[const](#syntax-instr-numeric) i+1) to the stack.
        
    5.  Push the value [val](#syntax-val) to the stack.
        
    6.  Push the value (at.[const](#syntax-instr-numeric) n−1) to the stack.
        
    7.  Execute the instruction ([memory.fill](#syntax-instr-memory) x).
        

​z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([memory.fill](#syntax-instr-memory) x)z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([memory.fill](#syntax-instr-memory) x)z;(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n) ([memory.fill](#syntax-instr-memory) x)(at.[const](#syntax-instr-numeric) i) [val](#syntax-val) ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x)(at.[const](#syntax-instr-numeric) i+1) [val](#syntax-val) (at.[const](#syntax-instr-numeric) n−1) ([memory.fill](#syntax-instr-memory) x)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​if i+n\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣otherwise, if n\=0​​

##### 4.6.8.11. [memory.copy](#syntax-instr-memory) x1​ x2​[](#-hrefsyntax-instr-memorymathsfmemorycopyx_1x_2)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-memory-copy), a [number value](#syntax-num) is on the top of the stack.
    
3.  Pop the value (at.[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-memory-copy), a [number value](#syntax-num) is on the top of the stack.
    
5.  Pop the value (at2​.[const](#syntax-instr-numeric) i2​) from the stack.
    
6.  Assert: Due to [validation](#valid-memory-copy), a [number value](#syntax-num) is on the top of the stack.
    
7.  Pop the value (at1​.[const](#syntax-instr-numeric) i1​) from the stack.
    
8.  If i1​+n\>∣z.[mems](#syntax-state)\[x1​\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
9.  If i2​+n\>∣z.[mems](#syntax-state)\[x2​\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
10.  If n\=0, then:
    
    1.  Do nothing.
        
11.  Else:
    
    1.  If i1​≤i2​, then:
        
        1.  Push the value (at1​.[const](#syntax-instr-numeric) i1​) to the stack.
            
        2.  Push the value (at2​.[const](#syntax-instr-numeric) i2​) to the stack.
            
        3.  Execute the instruction ([i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x2​).
            
        4.  Execute the instruction ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x1​).
            
        5.  Push the value (at1​.[const](#syntax-instr-numeric) i1​+1) to the stack.
            
        6.  Push the value (at2​.[const](#syntax-instr-numeric) i2​+1) to the stack.
            
    2.  Else:
        
        1.  Push the value (at1​.[const](#syntax-instr-numeric) i1​+n−1) to the stack.
            
        2.  Push the value (at2​.[const](#syntax-instr-numeric) i2​+n−1) to the stack.
            
        3.  Execute the instruction ([i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x2​).
            
        4.  Execute the instruction ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x1​).
            
        5.  Push the value (at1​.[const](#syntax-instr-numeric) i1​) to the stack.
            
        6.  Push the value (at2​.[const](#syntax-instr-numeric) i2​) to the stack.
            
    3.  Push the value (at.[const](#syntax-instr-numeric) n−1) to the stack.
        
    4.  Execute the instruction ([memory.copy](#syntax-instr-memory) x1​ x2​).
        

​z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([memory.copy](#syntax-instr-memory) x1​ x2​)if i1​+n\>∣z.[mems](#syntax-state)\[x1​\].[bytes](#syntax-meminst)∣∨i2​+n\>∣z.[mems](#syntax-state)\[x2​\].[bytes](#syntax-meminst)∣z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([memory.copy](#syntax-instr-memory) x1​ x2​)z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([memory.copy](#syntax-instr-memory) x1​ x2​)(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x2​) ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x1​)(at1​.[const](#syntax-instr-numeric) i1​+1) (at2​.[const](#syntax-instr-numeric) i2​+1) (at′.[const](#syntax-instr-numeric) n−1) ([memory.copy](#syntax-instr-memory) x1​ x2​)​​otherwise, if i1​≤i2​​z;(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n) ([memory.copy](#syntax-instr-memory) x1​ x2​)(at1​.[const](#syntax-instr-numeric) i1​+n−1) (at2​.[const](#syntax-instr-numeric) i2​+n−1) ([i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x2​) ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x1​)(at1​.[const](#syntax-instr-numeric) i1​) (at2​.[const](#syntax-instr-numeric) i2​) (at′.[const](#syntax-instr-numeric) n−1) ([memory.copy](#syntax-instr-memory) x1​ x2​)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​otherwise, if n\=0​​

##### 4.6.8.12. [memory.init](#syntax-instr-memory) x y[](#-hrefsyntax-instr-memorymathsfmemoryinitxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-memory-init), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-memory-init), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) from the stack.
    
6.  Assert: Due to [validation](#valid-memory-init), a [number value](#syntax-num) is on the top of the stack.
    
7.  Pop the value (at.[const](#syntax-instr-numeric) i) from the stack.
    
8.  If i+n\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣, then:
    
    1.  Trap.
        
9.  If j+n\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣, then:
    
    1.  Trap.
        
10.  If n\=0, then:
    
    1.  Do nothing.
        
11.  Else:
    
    1.  Assert: Due to [validation](#valid-memory-init), j<∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣.
        
    2.  Push the value (at.[const](#syntax-instr-numeric) i) to the stack.
        
    3.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[j\]) to the stack.
        
    4.  Execute the instruction ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x).
        
    5.  Push the value (at.[const](#syntax-instr-numeric) i+1) to the stack.
        
    6.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) to the stack.
        
    7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
        
    8.  Execute the instruction ([memory.init](#syntax-instr-memory) x y).
        

​z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([memory.init](#syntax-instr-memory) x y)if i+n\>∣z.[mems](#syntax-state)\[x\].[bytes](#syntax-meminst)∣∨j+n\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([memory.init](#syntax-instr-memory) x y)z;(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([memory.init](#syntax-instr-memory) x y)(at.[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[j\]) ([i32](#syntax-numtype).[store](#syntax-instr-memory)8 x)(at.[const](#syntax-instr-numeric) i+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([memory.init](#syntax-instr-memory) x y)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)ϵ​otherwise, if n\=0​​

##### 4.6.8.13. [data.drop](#syntax-instr-memory) x[](#-hrefsyntax-instr-memorymathsfdatadropx①)

1.  Let z be the current state.
    
2.  Replace z.[datas](#syntax-state)\[x\].bytes with ϵ.
    

​z;([data.drop](#syntax-instr-memory) x)​[↪](#exec-notation)​z\[.[datas](#syntax-state)\[x\].[bytes](#syntax-datainst)\=ϵ\];ϵ​​

#### 4.6.9. Reference Instructions[](#reference-instructions⑤)

##### 4.6.9.1. [ref.null](#syntax-instr-ref) x[](#-hrefsyntax-instr-refmathsfrefnullx)

1.  Let F be the [current](#exec-notation-textual) [frame](#syntax-frame).
    
2.  Assert: due to [validation](#valid-ref-null), the [defined type](#syntax-deftype) F.[module](#syntax-frame).[types](#syntax-moduleinst)\[x\] exists.
    
3.  Let [deftype](#syntax-deftype) be the [defined type](#syntax-deftype) F.[module](#syntax-frame).[types](#syntax-moduleinst)\[x\].
    
4.  Push the value [ref.null](#syntax-instr-ref) [deftype](#syntax-deftype) to the stack.
    

​z;([ref.null](#syntax-instr-ref) x)​[↪](#exec-notation)​([ref.null](#syntax-instr-ref) z.[types](#syntax-state)\[x\])​​

Note

No formal reduction rule is required for the case [ref.null](#syntax-instr-ref) [absheaptype](#syntax-absheaptype), since the instruction form is already a [value](#syntax-val).

##### 4.6.9.2. [ref.func](#syntax-instr-ref) x[](#-hrefsyntax-instr-refmathsfreffuncx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-ref-func), x<∣z.[module](#syntax-state).[funcs](#syntax-moduleinst)∣.
    
3.  Push the value ([ref.func](#syntax-ref) z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\]) to the stack.
    

​z;([ref.func](#syntax-instr-ref) x)​[↪](#exec-notation)​([ref.func](#syntax-ref) z.[module](#syntax-state).[funcs](#syntax-moduleinst)\[x\])​​

##### 4.6.9.3. [ref.is\_null](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefis_null①)

1.  Assert: Due to [validation](#valid-ref-is-null), a [reference value](#syntax-ref) is on the top of the stack.
    
2.  Pop the value [ref](#syntax-ref) from the stack.
    
3.  If [ref](#syntax-ref) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) to the stack.
        
4.  Else:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) to the stack.
        

​[ref](#syntax-ref) [ref.is\_null](#syntax-instr-ref)[ref](#syntax-ref) [ref.is\_null](#syntax-instr-ref)​[↪](#exec-notation)[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1)([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0)​if [ref](#syntax-ref)\=([ref.null](#syntax-instr-ref) ht)otherwise​​

##### 4.6.9.4. [ref.as\_non\_null](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefas_non_null①)

1.  Assert: Due to [validation](#valid-ref-as-non-null), a [reference value](#syntax-ref) is on the top of the stack.
    
2.  Pop the value [ref](#syntax-ref) from the stack.
    
3.  If [ref](#syntax-ref) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
4.  Push the value [ref](#syntax-ref) to the stack.
    

​[ref](#syntax-ref) [ref.as\_non\_null](#syntax-instr-ref)[ref](#syntax-ref) [ref.as\_non\_null](#syntax-instr-ref)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[ref](#syntax-ref)​if [ref](#syntax-ref)\=([ref.null](#syntax-instr-ref) ht)otherwise​​

##### 4.6.9.5. [ref.eq](#syntax-instr-ref)[](#-hrefsyntax-instr-refmathsfrefeq①)

1.  Assert: Due to [validation](#valid-ref-eq), a [reference value](#syntax-ref) is on the top of the stack.
    
2.  Pop the value [ref](#syntax-ref)2​ from the stack.
    
3.  Assert: Due to [validation](#valid-ref-eq), a [reference value](#syntax-ref) is on the top of the stack.
    
4.  Pop the value [ref](#syntax-ref)1​ from the stack.
    
5.  If [ref](#syntax-ref)1​ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype) and [ref](#syntax-ref)2​ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) to the stack.
        
6.  Else if [ref](#syntax-ref)1​\=[ref](#syntax-ref)2​, then:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) to the stack.
        
7.  Else:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) to the stack.
        

​[ref](#syntax-ref)1​ [ref](#syntax-ref)2​ [ref.eq](#syntax-instr-ref)[ref](#syntax-ref)1​ [ref](#syntax-ref)2​ [ref.eq](#syntax-instr-ref)[ref](#syntax-ref)1​ [ref](#syntax-ref)2​ [ref.eq](#syntax-instr-ref)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1)([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1)([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0)​if [ref](#syntax-ref)1​\=([ref.null](#syntax-instr-ref) ht1​)∧[ref](#syntax-ref)2​\=([ref.null](#syntax-instr-ref) ht2​)otherwise, if [ref](#syntax-ref)1​\=[ref](#syntax-ref)2​otherwise​​

##### 4.6.9.6. [ref.test](#syntax-instr-ref) rt[](#-hrefsyntax-instr-refmathsfreftestmathitrt①)

1.  Let f be the topmost frame.
    
2.  Assert: Due to [validation](#valid-ref-test), a [reference value](#syntax-ref) is on the top of the stack.
    
3.  Pop the value [ref](#syntax-ref) from the stack.
    
4.  Let rt′ be the type of [ref](#syntax-ref).
    
5.  If rt′ matches [clos](#type-inst)f.[module](#syntax-frame)​(rt), then:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1) to the stack.
        
6.  Else:
    
    1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) to the stack.
        

​s;f;[ref](#syntax-ref) ([ref.test](#syntax-instr-ref) rt)s;f;[ref](#syntax-ref) ([ref.test](#syntax-instr-ref) rt)​[↪](#exec-notation)[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) 1)([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0)​if s[⊢](#valid-ref)[ref](#syntax-ref):rt′∧ {}[⊢](#match-reftype)rt′[≤](#match-reftype)[clos](#type-inst)f.[module](#syntax-frame)​(rt)​otherwise​​

##### 4.6.9.7. [ref.cast](#syntax-instr-ref) rt[](#-hrefsyntax-instr-refmathsfrefcastmathitrt①)

1.  Let f be the topmost frame.
    
2.  Assert: Due to [validation](#valid-ref-cast), a [reference value](#syntax-ref) is on the top of the stack.
    
3.  Pop the value [ref](#syntax-ref) from the stack.
    
4.  Let rt′ be the type of [ref](#syntax-ref).
    
5.  If rt′ does not match [clos](#type-inst)f.[module](#syntax-frame)​(rt), then:
    
    1.  Trap.
        
6.  Push the value [ref](#syntax-ref) to the stack.
    

​s;f;[ref](#syntax-ref) ([ref.cast](#syntax-instr-ref) rt)s;f;[ref](#syntax-ref) ([ref.cast](#syntax-instr-ref) rt)​[↪](#exec-notation)[↪](#exec-notation)​[ref](#syntax-ref)[trap](#syntax-trap)​if s[⊢](#valid-ref)[ref](#syntax-ref):rt′∧ {}[⊢](#match-reftype)rt′[≤](#match-reftype)[clos](#type-inst)f.[module](#syntax-frame)​(rt)​otherwise​​

##### 4.6.9.8. [ref.i31](#syntax-instr-i31)[](#-hrefsyntax-instr-i31mathsfrefiscriptstyle31①)

1.  Assert: Due to [validation](#valid-ref-i31), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
3.  Push the value ([ref.i31](#syntax-ref) [wrap](#op-wrap)32,31​(i)) to the stack.
    

​([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [ref.i31](#syntax-instr-i31)​[↪](#exec-notation)​([ref.i31](#syntax-ref) [wrap](#op-wrap)32,31​(i))​​

##### 4.6.9.9. [i31.get](#syntax-instr-i31)\_[sx](#syntax-sx)[](#-hrefsyntax-instr-i31mathsfiscriptstyle31getmathsf_hrefsyntax-sxmathitsx①)

1.  Assert: Due to [validation](#valid-i31-get), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
4.  Assert: Due to [validation](#valid-i31-get), [val](#syntax-val) is some [ref.i31](#syntax-ref) [u31](#syntax-int).
    
5.  Let ([ref.i31](#syntax-ref) i) be the destructuring of [val](#syntax-val).
    
6.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) [extend](#op-extend)31,32[sx](#syntax-sx)​(i)) to the stack.
    

​([ref.null](#syntax-instr-ref) ht) ([i31.get](#syntax-instr-i31)\_[sx](#syntax-sx))([ref.i31](#syntax-ref) i) ([i31.get](#syntax-instr-i31)\_[sx](#syntax-sx))​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)([i32](#syntax-numtype).[const](#syntax-instr-numeric) [extend](#op-extend)31,32[sx](#syntax-sx)​(i))​​

##### 4.6.9.10. [struct.new](#syntax-instr-struct) x[](#-hrefsyntax-instr-structmathsfstructnewx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-struct-new), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [struct](#syntax-comptype) [list](#syntax-list)([fieldtype](#syntax-fieldtype)).
    
3.  Let ([struct](#syntax-comptype) [list](#syntax-list)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
4.  Let ([mut](#syntax-mut)? zt)n be [list](#syntax-list)0​.
    
5.  Let a be the length of z.[structs](#syntax-state).
    
6.  Assert: Due to [validation](#valid-struct-new), there are at least n values on the top of the stack.
    
7.  Pop the values [val](#syntax-val)n from the stack.
    
8.  Let si be the [structure instance](#syntax-structinst) {[type](#syntax-structinst) z.[types](#syntax-state)\[x\],[fields](#syntax-structinst) [pack](#aux-packfield)zt​([val](#syntax-val))n}.
    
9.  Push the value ([ref.struct](#syntax-ref) a) to the stack.
    
10.  Append si to z.[structs](#syntax-state).
    

​z;[val](#syntax-val)n ([struct.new](#syntax-instr-struct) x)​[↪](#exec-notation)​z\[.[structs](#syntax-state)\=⊕si\];([ref.struct](#syntax-ref) a)​if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)n∧ a\=∣z.[structs](#syntax-state)∣∧ si\={[type](#syntax-structinst) z.[types](#syntax-state)\[x\],[fields](#syntax-structinst) ([pack](#aux-packfield)zt​([val](#syntax-val)))n}​​​

##### 4.6.9.11. [struct.new\_default](#syntax-instr-struct) x[](#-hrefsyntax-instr-structmathsfstructnew_defaultx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-struct-new-default), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [struct](#syntax-comptype) [list](#syntax-list)([fieldtype](#syntax-fieldtype)).
    
3.  Let ([struct](#syntax-comptype) [list](#syntax-list)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
4.  Let ([mut](#syntax-mut)? zt)∗ be [list](#syntax-list)0​.
    
5.  Assert: Due to [validation](#valid-struct-new-default), for all zt in zt∗, [default](#aux-default)[unpack](#aux-unpack)(zt)​ is defined.
    
6.  Let [val](#syntax-val)∗ be the value sequence ϵ.
    
7.  For each zt in zt∗, do:
    
    1.  Let [val](#syntax-val) be [default](#aux-default)[unpack](#aux-unpack)(zt)​.
        
    2.  Append [val](#syntax-val) to [val](#syntax-val)∗.
        
8.  Assert: Due to [validation](#valid-struct-new-default), ∣[val](#syntax-val)∗∣\=∣zt∗∣.
    
9.  Push the values [val](#syntax-val)∗ to the stack.
    
10.  Execute the instruction ([struct.new](#syntax-instr-struct) x).
    

​z;([struct.new\_default](#syntax-instr-struct) x)​[↪](#exec-notation)​[val](#syntax-val)∗ ([struct.new](#syntax-instr-struct) x)​if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗∧ ([default](#aux-default)[unpack](#aux-unpack)(zt)​\=[val](#syntax-val))∗​​​

##### 4.6.9.12. [struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x i[](#-hrefsyntax-instr-structmathsfstructgetmathsf_hrefsyntax-sxmathitsxxi)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-struct-get), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
5.  Assert: Due to [validation](#valid-struct-get), [val](#syntax-val) is some [ref.struct](#syntax-ref) [structaddr](#syntax-structaddr).
    
6.  Let ([ref.struct](#syntax-ref) a) be the destructuring of [val](#syntax-val).
    
7.  Assert: Due to [validation](#valid-struct-get), i<∣z.[structs](#syntax-state)\[a\].[fields](#syntax-structinst)∣.
    
8.  Assert: Due to [validation](#valid-struct-get), a<∣z.[structs](#syntax-state)∣.
    
9.  Assert: Due to [validation](#valid-struct-get), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [struct](#syntax-comptype) [list](#syntax-list)([fieldtype](#syntax-fieldtype)).
    
10.  Let ([struct](#syntax-comptype) [list](#syntax-list)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
11.  Let ([mut](#syntax-mut)? zt)∗ be [list](#syntax-list)0​.
    
12.  Assert: Due to [validation](#valid-struct-get), i<∣zt∗∣.
    
13.  Push the value [unpack](#aux-unpackfield)zt∗\[i\][sx](#syntax-sx)?​(z.[structs](#syntax-state)\[a\].[fields](#syntax-structinst)\[i\]) to the stack.
    

​z;([ref.null](#syntax-instr-ref) ht) ([struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x i)z;([ref.struct](#syntax-ref) a) ([struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)? x i)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[unpack](#aux-unpackfield)zt∗\[i\][sx](#syntax-sx)?​(z.[structs](#syntax-state)\[a\].[fields](#syntax-structinst)\[i\])if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗​​​

##### 4.6.9.13. [struct.set](#syntax-instr-struct) x i[](#-hrefsyntax-instr-structmathsfstructsetxi)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-struct-set), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  Assert: Due to [validation](#valid-struct-set), a value is on the top of the stack.
    
5.  Pop the value [val](#syntax-val)′ from the stack.
    
6.  If [val](#syntax-val)′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
7.  Assert: Due to [validation](#valid-struct-set), [val](#syntax-val)′ is some [ref.struct](#syntax-ref) [structaddr](#syntax-structaddr).
    
8.  Let ([ref.struct](#syntax-ref) a) be the destructuring of [val](#syntax-val)′.
    
9.  Assert: Due to [validation](#valid-struct-set), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [struct](#syntax-comptype) [list](#syntax-list)([fieldtype](#syntax-fieldtype)).
    
10.  Let ([struct](#syntax-comptype) [list](#syntax-list)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
11.  Let ([mut](#syntax-mut)? zt)∗ be [list](#syntax-list)0​.
    
12.  Assert: Due to [validation](#valid-struct-set), i<∣zt∗∣.
    
13.  Replace z.[structs](#syntax-state)\[a\].fields\[i\] with [pack](#aux-packfield)zt∗\[i\]​([val](#syntax-val)).
    

​z;([ref.null](#syntax-instr-ref) ht) [val](#syntax-val) ([struct.set](#syntax-instr-struct) x i)z;([ref.struct](#syntax-ref) a) [val](#syntax-val) ([struct.set](#syntax-instr-struct) x i)​[↪](#exec-notation)[↪](#exec-notation)​z;[trap](#syntax-trap)z\[.[structs](#syntax-state)\[a\].[fields](#syntax-structinst)\[i\]\=[pack](#aux-packfield)zt∗\[i\]​([val](#syntax-val))\];ϵif z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[struct](#syntax-comptype) ([mut](#syntax-mut)? zt)∗​​​

##### 4.6.9.14. [array.new](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraynewx①)

1.  Assert: Due to [validation](#valid-array-new), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
3.  Assert: Due to [validation](#valid-array-new), a value is on the top of the stack.
    
4.  Pop the value [val](#syntax-val) from the stack.
    
5.  Push the values [val](#syntax-val)n to the stack.
    
6.  Execute the instruction ([array.new\_fixed](#syntax-instr-array) x n).
    

​[val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new](#syntax-instr-array) x)​[↪](#exec-notation)​[val](#syntax-val)n ([array.new\_fixed](#syntax-instr-array) x n)​​

##### 4.6.9.15. [array.new\_default](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraynew_defaultx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-new-default), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-new-default), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
    
5.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
6.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
    
7.  Assert: Due to [validation](#valid-array-new-default), [default](#aux-default)[unpack](#aux-unpack)(zt)​ is defined.
    
8.  Let [val](#syntax-val) be [default](#aux-default)[unpack](#aux-unpack)(zt)​.
    
9.  Push the values [val](#syntax-val)n to the stack.
    
10.  Execute the instruction ([array.new\_fixed](#syntax-instr-array) x n).
    

​z;([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new\_default](#syntax-instr-array) x)​[↪](#exec-notation)​[val](#syntax-val)n ([array.new\_fixed](#syntax-instr-array) x n)​if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ [default](#aux-default)[unpack](#aux-unpack)(zt)​\=[val](#syntax-val)​​​

##### 4.6.9.16. [array.new\_fixed](#syntax-instr-array) x n[](#-hrefsyntax-instr-arraymathsfarraynew_fixedxn①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-new-fixed), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
    
3.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
4.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
    
5.  Let a be the length of z.[arrays](#syntax-state).
    
6.  Assert: Due to [validation](#valid-array-new-fixed), there are at least n values on the top of the stack.
    
7.  Pop the values [val](#syntax-val)n from the stack.
    
8.  Let ai be the [array instance](#syntax-arrayinst) {[type](#syntax-arrayinst) z.[types](#syntax-state)\[x\],[fields](#syntax-arrayinst) [pack](#aux-packfield)zt​([val](#syntax-val))n}.
    
9.  Push the value ([ref.array](#syntax-ref) a) to the stack.
    
10.  Append ai to z.[arrays](#syntax-state).
    

​z;[val](#syntax-val)n ([array.new\_fixed](#syntax-instr-array) x n)​[↪](#exec-notation)​z\[.[arrays](#syntax-state)\=⊕ai\];([ref.array](#syntax-ref) a)if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ a\=∣z.[arrays](#syntax-state)∣∧ai\={[type](#syntax-arrayinst) z.[types](#syntax-state)\[x\],[fields](#syntax-arrayinst) ([pack](#aux-packfield)zt​([val](#syntax-val)))n}​​​

##### 4.6.9.17. [array.new\_data](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarraynew_dataxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-new-data), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-new-data), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
6.  Assert: Due to [validation](#valid-array-new-data), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
    
7.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
8.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
    
9.  If i+n⋅∣zt∣/8\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣, then:
    
    1.  Trap.
        
10.  Let [byte](#syntax-byte)∗∗ be the result for which each [byte](#syntax-byte)∗ has length ∣zt∣/8, and the [concatenation](#notation-concat) of [byte](#syntax-byte)∗∗ is z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[i:n⋅∣zt∣/8\].
    
11.  Let cn be the result for which ([bytes](#aux-bytes)zt​(cn)\=[byte](#syntax-byte)∗)∗.
    
12.  Push the values [unpack](#aux-unpack)(zt).[const](#syntax-instr-numeric) [unpack](#aux-unpacknum)zt​(c)n to the stack.
    
13.  Execute the instruction ([array.new\_fixed](#syntax-instr-array) x n).
    

​z;([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new\_data](#syntax-instr-array) x y)z;([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new\_data](#syntax-instr-array) x y)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ i+n⋅∣zt∣/8\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣​([unpack](#aux-unpack)(zt).[const](#syntax-instr-numeric) [unpack](#aux-unpacknum)zt​(c))n ([array.new\_fixed](#syntax-instr-array) x n)if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ [⨁](#notation-concat)[bytes](#aux-bytes)zt​(c)n\=z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[i:n⋅∣zt∣/8\]​​​​

##### 4.6.9.18. [array.new\_elem](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarraynew_elemxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-new-elem), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-new-elem), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
6.  If i+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣, then:
    
    1.  Trap.
        
7.  Let [ref](#syntax-ref)n be z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[i:n\].
    
8.  Push the values [ref](#syntax-ref)n to the stack.
    
9.  Execute the instruction ([array.new\_fixed](#syntax-instr-array) x n).
    

​z;([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new\_elem](#syntax-instr-array) x y)z;([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.new\_elem](#syntax-instr-array) x y)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[ref](#syntax-ref)n ([array.new\_fixed](#syntax-instr-array) x n)if [ref](#syntax-ref)n\=z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[i:n\]​if i+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣​​

##### 4.6.9.19. [array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x[](#-hrefsyntax-instr-arraymathsfarraygetmathsf_hrefsyntax-sxmathitsxx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-get), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
4.  Assert: Due to [validation](#valid-array-get), a value is on the top of the stack.
    
5.  Pop the value [val](#syntax-val) from the stack.
    
6.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
7.  Assert: Due to [validation](#valid-array-get), [val](#syntax-val) is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
8.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val).
    
9.  If a<∣z.[arrays](#syntax-state)∣ and i≥∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣, then:
    
    1.  Trap.
        
10.  If i<∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣ and a<∣z.[arrays](#syntax-state)∣, then:
    
    1.  Assert: Due to [validation](#valid-array-get), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
        
    2.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
        
    3.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
        
    4.  Push the value [unpack](#aux-unpackfield)zt[sx](#syntax-sx)?​(z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)\[i\]) to the stack.
        

​z;([ref.null](#syntax-instr-ref) ht) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[trap](#syntax-trap)[unpack](#aux-unpackfield)zt[sx](#syntax-sx)?​(z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)\[i\])if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)​if i≥∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣​​

##### 4.6.9.20. [array.set](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarraysetx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-set), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  Assert: Due to [validation](#valid-array-set), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
6.  Assert: Due to [validation](#valid-array-set), a value is on the top of the stack.
    
7.  Pop the value [val](#syntax-val)′ from the stack.
    
8.  If [val](#syntax-val)′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
9.  Assert: Due to [validation](#valid-array-set), [val](#syntax-val)′ is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
10.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val)′.
    
11.  If a<∣z.[arrays](#syntax-state)∣ and i≥∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣, then:
    
    1.  Trap.
        
12.  Assert: Due to [validation](#valid-array-set), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
    
13.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
    
14.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
    
15.  Replace z.[arrays](#syntax-state)\[a\].fields\[i\] with [pack](#aux-packfield)zt​([val](#syntax-val)).
    

​z;([ref.null](#syntax-instr-ref) ht) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([array.set](#syntax-instr-array) x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([array.set](#syntax-instr-array) x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([array.set](#syntax-instr-array) x)​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​z;[trap](#syntax-trap)z;[trap](#syntax-trap)z\[.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)\[i\]\=[pack](#aux-packfield)zt​([val](#syntax-val))\];ϵif z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)​if i≥∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣​​

##### 4.6.9.21. [array.len](#syntax-instr-array)[](#-hrefsyntax-instr-arraymathsfarraylen①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-len), a value is on the top of the stack.
    
3.  Pop the value [val](#syntax-val) from the stack.
    
4.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
5.  Assert: Due to [validation](#valid-array-len), [val](#syntax-val) is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
6.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val).
    
7.  Assert: Due to [validation](#valid-array-len), a<∣z.[arrays](#syntax-state)∣.
    
8.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) ∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣) to the stack.
    

​z;([ref.null](#syntax-instr-ref) ht) [array.len](#syntax-instr-array)z;([ref.array](#syntax-ref) a) [array.len](#syntax-instr-array)​[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)([i32](#syntax-numtype).[const](#syntax-instr-numeric) ∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣)​​

##### 4.6.9.22. [array.fill](#syntax-instr-array) x[](#-hrefsyntax-instr-arraymathsfarrayfillx①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-fill), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-fill), a value is on the top of the stack.
    
5.  Pop the value [val](#syntax-val) from the stack.
    
6.  Assert: Due to [validation](#valid-array-fill), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
7.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
8.  Assert: Due to [validation](#valid-array-fill), a value is on the top of the stack.
    
9.  Pop the value [val](#syntax-val)′ from the stack.
    
10.  If [val](#syntax-val)′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
11.  Assert: Due to [validation](#valid-array-fill), [val](#syntax-val)′ is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
12.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val)′.
    
13.  If a≥∣z.[arrays](#syntax-state)∣, then:
    
    1.  Do nothing.
        
14.  Else if i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣, then:
    
    1.  Trap.
        
15.  If n\=0, then:
    
    1.  Do nothing.
        
16.  Else:
    
    1.  Push the value ([ref.array](#syntax-ref) a) to the stack.
        
    2.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) to the stack.
        
    3.  Push the value [val](#syntax-val) to the stack.
        
    4.  Execute the instruction ([array.set](#syntax-instr-array) x).
        
    5.  Push the value ([ref.array](#syntax-ref) a) to the stack.
        
    6.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) to the stack.
        
    7.  Push the value [val](#syntax-val) to the stack.
        
    8.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
        
    9.  Execute the instruction ([array.fill](#syntax-instr-array) x).
        

​z;([ref.null](#syntax-instr-ref) ht) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.fill](#syntax-instr-array) x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.fill](#syntax-instr-array) x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.fill](#syntax-instr-array) x)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.fill](#syntax-instr-array) x)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [val](#syntax-val) ([array.set](#syntax-instr-array) x)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) [val](#syntax-val) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([array.fill](#syntax-instr-array) x)​​otherwise​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[trap](#syntax-trap)ϵ​if i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣otherwise, if n\=0​​

##### 4.6.9.23. [array.copy](#syntax-instr-array) x1​ x2​[](#-hrefsyntax-instr-arraymathsfarraycopyx_1x_2)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-copy), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-copy), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) from the stack.
    
6.  Assert: Due to [validation](#valid-array-copy), a value is on the top of the stack.
    
7.  Pop the value [val](#syntax-val) from the stack.
    
8.  Assert: Due to [validation](#valid-array-copy), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
9.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) from the stack.
    
10.  Assert: Due to [validation](#valid-array-copy), a value is on the top of the stack.
    
11.  Pop the value [val](#syntax-val)′ from the stack.
    
12.  If [val](#syntax-val)′ is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype) and [val](#syntax-val) is reference value, then:
    
    1.  Trap.
        
13.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype) and [val](#syntax-val)′ is reference value, then:
    
    1.  Trap.
        
14.  If [val](#syntax-val)′ is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr), then:
    
    1.  Let ([ref.array](#syntax-ref) a1​) be the destructuring of [val](#syntax-val)′.
        
    2.  If [val](#syntax-val) is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr), then:
        
        1.  If a1​<∣z.[arrays](#syntax-state)∣ and i1​+n\>∣z.[arrays](#syntax-state)\[a1​\].[fields](#syntax-arrayinst)∣, then:
            
            1.  Trap.
                
        2.  Let ([ref.array](#syntax-ref) a2​) be the destructuring of [val](#syntax-val).
            
        3.  If a2​≥∣z.[arrays](#syntax-state)∣, then:
            
            1.  Do nothing.
                
        4.  Else if i2​+n\>∣z.[arrays](#syntax-state)\[a2​\].[fields](#syntax-arrayinst)∣, then:
            
            1.  Trap.
                
        5.  If n\=0, then:
            
            1.  Do nothing.
                
        6.  Else:
            
            1.  Assert: Due to [validation](#valid-array-copy), the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x2​\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
                
            2.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x2​\].
                
            3.  Let ([mut](#syntax-mut)? zt2​) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
                
            4.  Let [sx](#syntax-sx)? be [sx](#syntax-sx)(zt2​).
                
            5.  Push the value ([ref.array](#syntax-ref) a1​) to the stack.
                
            6.  If i1​≤i2​, then:
                
                1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) to the stack.
                    
                2.  Push the value ([ref.array](#syntax-ref) a2​) to the stack.
                    
                3.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) to the stack.
                    
                4.  Execute the instruction ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x2​).
                    
                5.  Execute the instruction ([array.set](#syntax-instr-array) x1​).
                    
                6.  Push the value ([ref.array](#syntax-ref) a1​) to the stack.
                    
                7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​+1) to the stack.
                    
                8.  Push the value ([ref.array](#syntax-ref) a2​) to the stack.
                    
                9.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​+1) to the stack.
                    
            7.  Else:
                
                1.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​+n−1) to the stack.
                    
                2.  Push the value ([ref.array](#syntax-ref) a2​) to the stack.
                    
                3.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​+n−1) to the stack.
                    
                4.  Execute the instruction ([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x2​).
                    
                5.  Execute the instruction ([array.set](#syntax-instr-array) x1​).
                    
                6.  Push the value ([ref.array](#syntax-ref) a1​) to the stack.
                    
                7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) to the stack.
                    
                8.  Push the value ([ref.array](#syntax-ref) a2​) to the stack.
                    
                9.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) to the stack.
                    
            8.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
                
            9.  Execute the instruction ([array.copy](#syntax-instr-array) x1​ x2​).
                

​z;([ref.null](#syntax-instr-ref) ht1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) [ref](#syntax-ref) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)z;[ref](#syntax-ref) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.null](#syntax-instr-ref) ht2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)z;([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)if i1​+n\>∣z.[arrays](#syntax-state)\[a1​\].[fields](#syntax-arrayinst)∣z;([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)if i2​+n\>∣z.[arrays](#syntax-state)\[a2​\].[fields](#syntax-arrayinst)∣z;([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)otherwise, if n\=0z;([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​)([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​)([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x2​) ([array.set](#syntax-instr-array) x1​)([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​+1) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([array.copy](#syntax-instr-array) x1​ x2​)​otherwise, if z.[types](#syntax-state)\[x2​\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt2​)∧ i1​≤i2​∧[sx](#syntax-sx)?\=[sx](#syntax-sx)(zt2​)​​​​​z;([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.copy](#syntax-instr-array) x1​ x2​)([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​+n−1)([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​+n−1)([array.get](#syntax-instr-array)\_[sx](#syntax-sx)? x2​) ([array.set](#syntax-instr-array) x1​)([ref.array](#syntax-ref) a1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i1​) ([ref.array](#syntax-ref) a2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i2​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([array.copy](#syntax-instr-array) x1​ x2​)​otherwise, if z.[types](#syntax-state)\[x2​\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt2​)∧ [sx](#syntax-sx)?\=[sx](#syntax-sx)(zt2​)​​​​​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[trap](#syntax-trap)[trap](#syntax-trap)[trap](#syntax-trap)ϵ​​​

Where:

[sx](#syntax-sx)([consttype](#syntax-consttype))[sx](#syntax-sx)([packtype](#syntax-packtype))​\=\=​ϵ[s](#syntax-sx)​​

##### 4.6.9.24. [array.init\_data](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarrayinit_dataxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-init-data), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-init-data), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) from the stack.
    
6.  Assert: Due to [validation](#valid-array-init-data), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
7.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
8.  Assert: Due to [validation](#valid-array-init-data), a value is on the top of the stack.
    
9.  Pop the value [val](#syntax-val) from the stack.
    
10.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
11.  Assert: Due to [validation](#valid-array-init-data), [val](#syntax-val) is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
12.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val).
    
13.  If a<∣z.[arrays](#syntax-state)∣ and i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣, then:
    
    1.  Trap.
        
14.  If the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\] is some [array](#syntax-comptype) [fieldtype](#syntax-fieldtype), then:
    
    1.  Let ([array](#syntax-comptype) [fieldtype](#syntax-fieldtype)0​) be the destructuring of the [expansion](#aux-expand-deftype) of z.[types](#syntax-state)\[x\].
        
    2.  Let ([mut](#syntax-mut)? zt) be the destructuring of [fieldtype](#syntax-fieldtype)0​.
        
    3.  If j+n⋅∣zt∣/8\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣, then:
        
        1.  Trap.
            
    4.  If n\=0, then:
        
        1.  Do nothing.
            
    5.  Else:
        
        1.  Let c be the result for which [bytes](#aux-bytes)zt​(c) \= z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[j:∣zt∣/8\].
            
        2.  Push the value ([ref.array](#syntax-ref) a) to the stack.
            
        3.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) to the stack.
            
        4.  Push the value [unpack](#aux-unpack)(zt).[const](#syntax-instr-numeric) [unpack](#aux-unpacknum)zt​(c) to the stack.
            
        5.  Execute the instruction ([array.set](#syntax-instr-array) x).
            
        6.  Push the value ([ref.array](#syntax-ref) a) to the stack.
            
        7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) to the stack.
            
        8.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+∣zt∣/8) to the stack.
            
        9.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
            
        10.  Execute the instruction ([array.init\_data](#syntax-instr-array) x y).
            
15.  Else if n\=0, then:
    
    1.  Do nothing.
        

​z;([ref.null](#syntax-instr-ref) ht) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_data](#syntax-instr-array) x y)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_data](#syntax-instr-array) x y)if i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_data](#syntax-instr-array) x y)if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ j+n⋅∣zt∣/8\>∣z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)∣​z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_data](#syntax-instr-array) x y)otherwise, if n\=0z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_data](#syntax-instr-array) x y)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([unpack](#aux-unpack)(zt).[const](#syntax-instr-numeric) [unpack](#aux-unpacknum)zt​(c)) ([array.set](#syntax-instr-array) x)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+∣zt∣/8) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([array.init\_data](#syntax-instr-array) x y)​otherwise, if z.[types](#syntax-state)\[x\][≈](#aux-expand-deftype)[array](#syntax-comptype) ([mut](#syntax-mut)? zt)∧ [bytes](#aux-bytes)zt​(c)\=z.[datas](#syntax-state)\[y\].[bytes](#syntax-datainst)\[j:∣zt∣/8\]​​​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[trap](#syntax-trap)[trap](#syntax-trap)ϵ​​​

##### 4.6.9.25. [array.init\_elem](#syntax-instr-array) x y[](#-hrefsyntax-instr-arraymathsfarrayinit_elemxy①)

1.  Let z be the current state.
    
2.  Assert: Due to [validation](#valid-array-init-elem), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
3.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) from the stack.
    
4.  Assert: Due to [validation](#valid-array-init-elem), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
5.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) from the stack.
    
6.  Assert: Due to [validation](#valid-array-init-elem), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
7.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
8.  Assert: Due to [validation](#valid-array-init-elem), a value is on the top of the stack.
    
9.  Pop the value [val](#syntax-val) from the stack.
    
10.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Trap.
        
11.  Assert: Due to [validation](#valid-array-init-elem), [val](#syntax-val) is some [ref.array](#syntax-ref) [arrayaddr](#syntax-arrayaddr).
    
12.  Let ([ref.array](#syntax-ref) a) be the destructuring of [val](#syntax-val).
    
13.  If a<∣z.[arrays](#syntax-state)∣ and i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣, then:
    
    1.  Trap.
        
14.  If j+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣, then:
    
    1.  Trap.
        
15.  If n\=0, then:
    
    1.  Do nothing.
        
16.  Else if j<∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣, then:
    
    1.  Let [ref](#syntax-ref) be the [reference value](#syntax-ref) z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[j\].
        
    2.  Push the value ([ref.array](#syntax-ref) a) to the stack.
        
    3.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) to the stack.
        
    4.  Push the value [ref](#syntax-ref) to the stack.
        
    5.  Execute the instruction ([array.set](#syntax-instr-array) x).
        
    6.  Push the value ([ref.array](#syntax-ref) a) to the stack.
        
    7.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) to the stack.
        
    8.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) to the stack.
        
    9.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) to the stack.
        
    10.  Execute the instruction ([array.init\_elem](#syntax-instr-array) x y).
        

​z;([ref.null](#syntax-instr-ref) ht) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_elem](#syntax-instr-array) x y)z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_elem](#syntax-instr-array) x y)if i+n\>∣z.[arrays](#syntax-state)\[a\].[fields](#syntax-arrayinst)∣z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_elem](#syntax-instr-array) x y)if j+n\>∣z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)∣z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_elem](#syntax-instr-array) x y)otherwise, if n\=0z;([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([array.init\_elem](#syntax-instr-array) x y)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) [ref](#syntax-ref) ([array.set](#syntax-instr-array) x)([ref.array](#syntax-ref) a) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) j+1) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n−1) ([array.init\_elem](#syntax-instr-array) x y)​otherwise, if [ref](#syntax-ref)\=z.[elems](#syntax-state)\[y\].[refs](#syntax-eleminst)\[j\]​​​​​[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)[↪](#exec-notation)​[trap](#syntax-trap)[trap](#syntax-trap)[trap](#syntax-trap)ϵ​​​

##### 4.6.9.26. [any.convert\_extern](#syntax-instr-extern)[](#-hrefsyntax-instr-externmathsfanyconvert_extern①)

1.  Assert: Due to [validation](#valid-any-convert-extern), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Push the value ([ref.null](#syntax-instr-ref) [any](#syntax-heaptype)) to the stack.
        
4.  If [val](#syntax-val) is some [ref.extern](#syntax-ref) [addrref](#syntax-addrref), then:
    
    1.  Let ([ref.extern](#syntax-ref) [addrref](#syntax-addrref)) be the destructuring of [val](#syntax-val).
        
    2.  Push the value [addrref](#syntax-addrref) to the stack.
        

​([ref.null](#syntax-instr-ref) ht) [any.convert\_extern](#syntax-instr-extern)([ref.extern](#syntax-ref) [addrref](#syntax-addrref)) [any.convert\_extern](#syntax-instr-extern)​[↪](#exec-notation)[↪](#exec-notation)​([ref.null](#syntax-instr-ref) [any](#syntax-heaptype))[addrref](#syntax-addrref)​​

##### 4.6.9.27. [extern.convert\_any](#syntax-instr-extern)[](#-hrefsyntax-instr-externmathsfexternconvert_any①)

1.  Assert: Due to [validation](#valid-extern-convert-any), a value is on the top of the stack.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  If [val](#syntax-val) is some [ref.null](#syntax-instr-ref) [heaptype](#syntax-heaptype), then:
    
    1.  Push the value ([ref.null](#syntax-instr-ref) [extern](#syntax-heaptype)) to the stack.
        
4.  If [val](#syntax-val) is address value, then:
    
    1.  Push the value ([ref.extern](#syntax-ref) [val](#syntax-val)) to the stack.
        

​([ref.null](#syntax-instr-ref) ht) [extern.convert\_any](#syntax-instr-extern)[addrref](#syntax-addrref) [extern.convert\_any](#syntax-instr-extern)​[↪](#exec-notation)[↪](#exec-notation)​([ref.null](#syntax-instr-ref) [extern](#syntax-heaptype))([ref.extern](#syntax-ref) [addrref](#syntax-addrref))​​

#### 4.6.10. Numeric Instructions[](#numeric-instructions⑤)

Numeric instructions are defined in terms of the generic [numeric operators](#exec-numeric). The mapping of numeric instructions to their underlying operators is expressed by the following definition:

op[iN](#syntax-numtype)​(i1​,…,ik​)op[fN](#syntax-numtype)​(z1​,…,zk​)​\=\=​[iop](#int-ops)N​(i1​,…,ik​)[fop](#float-ops)N​(z1​,…,zk​)​​

And for [conversion operators](#exec-cvtop):

[cvtop](#syntax-cvtop)t1​,t2​[sx](#syntax-sx)?​(c)​\=​[cvtop](#convert-ops)∣t1​∣,∣t2​∣[sx](#syntax-sx)?​(c)​​

Where the underlying operators are partial, the corresponding instruction will [trap](#trap) when the result is not defined. Where the underlying operators are non-deterministic, because they may return one of multiple possible [NaN](#syntax-nan) values, so are the corresponding instructions.

Note

For example, the result of instruction [i32](#syntax-numtype).[add](#syntax-instr-numeric) applied to operands i1​,i2​ invokes [add](#syntax-instr-numeric)[i32](#syntax-numtype)​(i1​,i2​), which maps to the generic [iadd](#op-iadd)32​(i1​,i2​) via the above definition. Similarly, [i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[f32](#syntax-numtype)\_s applied to z invokes [trunc](#syntax-instr-numeric)[f32](#syntax-numtype),[i64](#syntax-numtype)s​(z), which maps to the generic [truncs](#op-trunc)32,64​(z).

##### 4.6.10.1. nt.[const](#syntax-instr-numeric) c[](#-mathitntmathsfhrefsyntax-instr-numericmathsfconstc)

1.  Push the value (nt.[const](#syntax-instr-numeric) c) to the stack.
    

Note

No formal reduction rule is required for this instruction, since const instructions already are [values](#syntax-val).

##### 4.6.10.2. nt.[unop](#syntax-unop)[](#-mathitnt--hrefsyntax-unopmathitunop)

1.  Assert: Due to [validation](#valid-unop), a value of [number type](#syntax-numtype) nt is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  If [unop](#syntax-unop)nt​(c1​) is empty, then:
    
    1.  Trap.
        
4.  Let c be an element of [unop](#syntax-unop)nt​(c1​).
    
5.  Push the value (nt.[const](#syntax-instr-numeric) c) to the stack.
    

​(nt.[const](#syntax-instr-numeric) c1​) (nt.[unop](#syntax-unop))(nt.[const](#syntax-instr-numeric) c1​) (nt.[unop](#syntax-unop))​[↪](#exec-notation)[↪](#exec-notation)​(nt.[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[unop](#syntax-unop)nt​(c1​)if [unop](#syntax-unop)nt​(c1​)\=ϵ​​

##### 4.6.10.3. nt.[binop](#syntax-binop)[](#-mathitnt--hrefsyntax-binopmathitbinop)

1.  Assert: Due to [validation](#valid-binop), a value of [number type](#syntax-numtype) nt is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-binop), a [number value](#syntax-num) is on the top of the stack.
    
4.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  If [binop](#syntax-binop)nt​(c1​,c2​) is empty, then:
    
    1.  Trap.
        
6.  Let c be an element of [binop](#syntax-binop)nt​(c1​,c2​).
    
7.  Push the value (nt.[const](#syntax-instr-numeric) c) to the stack.
    

​(nt.[const](#syntax-instr-numeric) c1​) (nt.[const](#syntax-instr-numeric) c2​) (nt.[binop](#syntax-binop))(nt.[const](#syntax-instr-numeric) c1​) (nt.[const](#syntax-instr-numeric) c2​) (nt.[binop](#syntax-binop))​[↪](#exec-notation)[↪](#exec-notation)​(nt.[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[binop](#syntax-binop)nt​(c1​,c2​)if [binop](#syntax-binop)nt​(c1​,c2​)\=ϵ​​

##### 4.6.10.4. nt.[testop](#syntax-testop)[](#-mathitnt--hrefsyntax-testopmathittestop)

1.  Assert: Due to [validation](#valid-testop), a value of [number type](#syntax-numtype) nt is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let c be [testop](#syntax-testop)nt​(c1​).
    
4.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) to the stack.
    

​(nt.[const](#syntax-instr-numeric) c1​) (nt.[testop](#syntax-testop))​[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c)​if c\=[testop](#syntax-testop)nt​(c1​)​​

##### 4.6.10.5. nt.[relop](#syntax-relop)[](#-mathitnt--hrefsyntax-relopmathitrelop)

1.  Assert: Due to [validation](#valid-relop), a value of [number type](#syntax-numtype) nt is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-relop), a [number value](#syntax-num) is on the top of the stack.
    
4.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [relop](#syntax-relop)nt​(c1​,c2​).
    
6.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) to the stack.
    

​(nt.[const](#syntax-instr-numeric) c1​) (nt.[const](#syntax-instr-numeric) c2​) (nt.[relop](#syntax-relop))​[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c)​if c\=[relop](#syntax-relop)nt​(c1​,c2​)​​

##### 4.6.10.6. nt2​.[cvtop](#syntax-cvtop)\_nt1​[](#-mathitnt_2--hrefsyntax-cvtopmathitcvtopmathsf_mathitnt_1)

1.  Assert: Due to [validation](#valid-cvtop), a value of [number type](#syntax-numtype) nt1​ is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  If [cvtop](#syntax-cvtop)nt1​,nt2​​(c1​) is empty, then:
    
    1.  Trap.
        
4.  Let c be an element of [cvtop](#syntax-cvtop)nt1​,nt2​​(c1​).
    
5.  Push the value (nt2​.[const](#syntax-instr-numeric) c) to the stack.
    

​(nt1​.[const](#syntax-instr-numeric) c1​) (nt2​.[cvtop](#syntax-cvtop)\_nt1​)(nt1​.[const](#syntax-instr-numeric) c1​) (nt2​.[cvtop](#syntax-cvtop)\_nt1​)​[↪](#exec-notation)[↪](#exec-notation)​(nt2​.[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[cvtop](#syntax-cvtop)nt1​,nt2​​(c1​)if [cvtop](#syntax-cvtop)nt1​,nt2​​(c1​)\=ϵ​​

#### 4.6.11. Vector Instructions[](#vector-instructions⑤)

Vector instructions that operate bitwise are handled as integer operations of respective bit width.

op[vN](#syntax-vectype)​(i1​,…,ik​)​\=​[iop](#int-ops)N​(i1​,…,ik​)​​

Most other vector instructions are defined in terms of [numeric operators](#exec-numeric) that are applied lane-wise according to the given [shape](#syntax-shape).

optxN​(n1​,…,nk​)​\=​[lanes](#aux-lanes)txN−1​([op](#exec-instr-numeric)t​(i1​,…,ik​)∗)​(ifi1∗​\=[lanes](#aux-lanes)txN​(n1​)∧⋯∧ik∗​\=[lanes](#aux-lanes)txN​(nk​)​​

Note

For example, the result of instruction i32x4.[add](#syntax-instr-numeric) applied to operands v1​,v2​ invokes [add](#syntax-instr-numeric)i32x4​(v1​,v2​), which maps to [lanes](#aux-lanes)i32x4−1​([add](#syntax-instr-numeric)[i32](#syntax-numtype)​(i1​,i2​)∗), where i1∗​ and i2∗​ are sequences resulting from invoking [lanes](#aux-lanes)i32x4​(v1​) and [lanes](#aux-lanes)i32x4​(v2​) respectively.

For non-deterministic operators this definition is generalized to sets:

optxN​(n1​,…,nk​)​\=​{[lanes](#aux-lanes)txN−1​(i∗) ∣ i∗∈×([op](#exec-instr-numeric)t​(i1​,…,ik​)∗)∧i1∗​\=[lanes](#aux-lanes)txN​(n1​)∧⋯∧ik∗​\=[lanes](#aux-lanes)txN​(nk​)}​​

where ×{x∗}N transforms a sequence of N sets of values into a set of sequences of N values by computing the set product:

×(S1​…SN​)​\=​{x1​…xN​ ∣ x1​∈S1​∧⋯∧xN​∈SN​}​

The remaining vector operators use [individual definitions](#op-vec).

##### 4.6.11.1. [v128](#syntax-vectype).[const](#syntax-instr-vec) c[](#-hrefsyntax-vectypemathsfvscriptstyle128mathsfhrefsyntax-instr-vecmathsfconstc①)

1.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

Note

No formal reduction rule is required for this instruction, since const instructions are already [values](#syntax-val).

##### 4.6.11.2. [v128](#syntax-vectype).[vvunop](#syntax-vvunop)[](#-hrefsyntax-vectypemathsfvscriptstyle128--hrefsyntax-vvunopmathitvvunop)

1.  Assert: Due to [validation](#valid-vvunop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Assert: Due to [validation](#valid-vvunop), ∣[vvunop](#syntax-vvunop)[v128](#syntax-vectype)​(c1​)∣\>0.
    
4.  Let c be an element of [vvunop](#syntax-vvunop)[v128](#syntax-vectype)​(c1​).
    
5.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[vvunop](#syntax-vvunop))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c∈[vvunop](#syntax-vvunop)[v128](#syntax-vectype)​(c1​)​​

##### 4.6.11.3. [v128](#syntax-vectype).[vvbinop](#syntax-vvbinop)[](#-hrefsyntax-vectypemathsfvscriptstyle128--hrefsyntax-vvbinopmathitvvbinop)

1.  Assert: Due to [validation](#valid-vvbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vvbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Assert: Due to [validation](#valid-vvbinop), ∣[vvbinop](#syntax-vvbinop)[v128](#syntax-vectype)​(c1​,c2​)∣\>0.
    
6.  Let c be an element of [vvbinop](#syntax-vvbinop)[v128](#syntax-vectype)​(c1​,c2​).
    
7.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) ([v128](#syntax-vectype).[vvbinop](#syntax-vvbinop))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c∈[vvbinop](#syntax-vvbinop)[v128](#syntax-vectype)​(c1​,c2​)​​

##### 4.6.11.4. [v128](#syntax-vectype).[vvternop](#syntax-vvternop)[](#-hrefsyntax-vectypemathsfvscriptstyle128--hrefsyntax-vvternopmathitvvternop)

1.  Assert: Due to [validation](#valid-vvternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) from the stack.
    
3.  Assert: Due to [validation](#valid-vvternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
5.  Assert: Due to [validation](#valid-vvternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
6.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
7.  Assert: Due to [validation](#valid-vvternop), ∣[vvternop](#syntax-vvternop)[v128](#syntax-vectype)​(c1​,c2​,c3​)∣\>0.
    
8.  Let c be an element of [vvternop](#syntax-vvternop)[v128](#syntax-vectype)​(c1​,c2​,c3​).
    
9.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) ([v128](#syntax-vectype).[vvternop](#syntax-vvternop))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if c∈[vvternop](#syntax-vvternop)[v128](#syntax-vectype)​(c1​,c2​,c3​)​​

##### 4.6.11.5. [v128](#syntax-vectype).[any\_true](#syntax-instr-vec)[](#-hrefsyntax-vectypemathsfvscriptstyle128--hrefsyntax-instr-vecmathsfany_true)

1.  Assert: Due to [validation](#valid-vvtestop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let c be [inez](#op-inez)∣[v128](#syntax-vectype)∣​(c1​).
    
4.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[any\_true](#syntax-instr-vec))​[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c)​if c\=[inez](#op-inez)∣[v128](#syntax-vectype)∣​(c1​)​​

##### 4.6.11.6. sh.[vunop](#syntax-vunop)[](#-mathitsh--hrefsyntax-vunopmathitvunop)

1.  Assert: Due to [validation](#valid-vunop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  If [vunop](#syntax-vunop)sh​(c1​) is empty, then:
    
    1.  Trap.
        
4.  Let c be an element of [vunop](#syntax-vunop)sh​(c1​).
    
5.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (sh.[vunop](#syntax-vunop))([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (sh.[vunop](#syntax-vunop))​[↪](#exec-notation)[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[vunop](#syntax-vunop)sh​(c1​)if [vunop](#syntax-vunop)sh​(c1​)\=ϵ​​

##### 4.6.11.7. sh.[vbinop](#syntax-vbinop)[](#-mathitsh--hrefsyntax-vbinopmathitvbinop)

1.  Assert: Due to [validation](#valid-vbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  If [vbinop](#syntax-vbinop)sh​(c1​,c2​) is empty, then:
    
    1.  Trap.
        
6.  Let c be an element of [vbinop](#syntax-vbinop)sh​(c1​,c2​).
    
7.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh.[vbinop](#syntax-vbinop))([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh.[vbinop](#syntax-vbinop))​[↪](#exec-notation)[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[vbinop](#syntax-vbinop)sh​(c1​,c2​)if [vbinop](#syntax-vbinop)sh​(c1​,c2​)\=ϵ​​

##### 4.6.11.8. sh.[vternop](#syntax-vternop)[](#-mathitsh--hrefsyntax-vternopmathitvternop)

1.  Assert: Due to [validation](#valid-vternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) from the stack.
    
3.  Assert: Due to [validation](#valid-vternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
5.  Assert: Due to [validation](#valid-vternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
6.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
7.  If [vternop](#syntax-vternop)sh​(c1​,c2​,c3​) is empty, then:
    
    1.  Trap.
        
8.  Let c be an element of [vternop](#syntax-vternop)sh​(c1​,c2​,c3​).
    
9.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) (sh.[vternop](#syntax-vternop))([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) (sh.[vternop](#syntax-vternop))​[↪](#exec-notation)[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)[trap](#syntax-trap)​if c∈[vternop](#syntax-vternop)sh​(c1​,c2​,c3​)if [vternop](#syntax-vternop)sh​(c1​,c2​,c3​)\=ϵ​​

##### 4.6.11.9. [i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[all\_true](#syntax-instr-vec)[](#-hrefsyntax-numtypemathsfihrefsyntax-numtypescriptstylekern-01emnhrefsyntax-shapemathsfxm--hrefsyntax-instr-vecmathsfall_true)

1.  Assert: Due to [validation](#valid-vtestop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let i∗ be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​).
    
4.  Let c be Π[inez](#op-inez)N​(i)∗.
    
5.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[all\_true](#syntax-instr-vec))​[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c)​if i∗\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​)∧ c\=Π([inez](#op-inez)N​(i)∗)​​​

##### 4.6.11.10. sh.[vrelop](#syntax-vrelop)[](#-mathitsh--hrefsyntax-vrelopmathitvrelop)

1.  Assert: Due to [validation](#valid-vrelop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vrelop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [vrelop](#syntax-vrelop)sh​(c1​,c2​).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh.[vrelop](#syntax-vrelop))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[vrelop](#syntax-vrelop)sh​(c1​,c2​)​​

##### 4.6.11.11. sh.[vshiftop](#syntax-vshiftop)[](#-mathitsh--hrefsyntax-vshiftopmathitvshiftop)

1.  Assert: Due to [validation](#valid-vshiftop), a value of [number type](#syntax-numtype) [i32](#syntax-numtype) is on the top of the stack.
    
2.  Pop the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) from the stack.
    
3.  Assert: Due to [validation](#valid-vshiftop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [vshiftop](#syntax-vshiftop)sh​(c1​,i).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) i) (sh.[vshiftop](#syntax-vshiftop))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[vshiftop](#syntax-vshiftop)sh​(c1​,i)​​

##### 4.6.11.12. sh.[bitmask](#syntax-instr-vec)[](#-mathitshhrefsyntax-instr-vecmathsfbitmask)

1.  Assert: Due to [validation](#valid-vbitmask), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let c be [bitmask](#syntax-instr-vec)sh​(c1​).
    
4.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (sh.[bitmask](#syntax-instr-vec))​[↪](#exec-notation)​([i32](#syntax-numtype).[const](#syntax-instr-numeric) c)​if c\=[bitmask](#syntax-instr-vec)sh​(c1​)​​

##### 4.6.11.13. sh.swizzlop[](#-mathitsh--mathitswizzlop)

1.  Assert: Due to [validation](#valid-vswizzlop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vswizzlop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be swizzlopsh​(c1​,c2​).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh.swizzlop)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=swizzlopsh​(c1​,c2​)​​

##### 4.6.11.14. sh.[shuffle](#syntax-instr-vec) i∗[](#-mathitshhrefsyntax-instr-vecmathsfshuffleiast)

1.  Assert: Due to [validation](#valid-vshuffle), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vshuffle), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [shuffle](#syntax-instr-vec)sh​(i∗,c1​,c2​).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh.[shuffle](#syntax-instr-vec) i∗)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[shuffle](#syntax-instr-vec)sh​(i∗,c1​,c2​)​​

##### 4.6.11.15. [i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[splat](#syntax-instr-vec)[](#-hrefsyntax-numtypemathsfihrefsyntax-numtypescriptstylekern-01emnhrefsyntax-shapemathsfxmhrefsyntax-instr-vecmathsfsplat)

1.  Assert: Due to [validation](#valid-vsplat), a value is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Assert: Due to [validation](#valid-vsplat), [numtype](#syntax-numtype)0​\=[unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype)).
    
4.  Let c be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([pack](#aux-packnum)[i](#syntax-numtype)[N](#syntax-numtype)​(c1​)M).
    
5.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype)).[const](#syntax-instr-numeric) c1​) ([i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[splat](#syntax-instr-vec))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([pack](#aux-packnum)[i](#syntax-numtype)[N](#syntax-numtype)​(c1​)M)​​

##### 4.6.11.16. [lanetype](#syntax-lanetype)[x](#syntax-shape)M.[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx)′? i[](#-hrefsyntax-lanetypemathitlanetypehrefsyntax-shapemathsfxmhrefsyntax-instr-vecmathsfextract_lanemathsf_hrefsyntax-sxmathitsxi)

1.  Assert: Due to [validation](#valid-vextract-lane), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  If [sx](#syntax-sx)′? is not defined, then:
    
    1.  Assert: Due to [validation](#valid-vextract-lane), [lanetype](#syntax-lanetype) is number type.
        
    2.  Assert: Due to [validation](#valid-vextract-lane), i<∣[lanes](#aux-lanes)[lanetype](#syntax-lanetype)[x](#syntax-shape)M​(c1​)∣.
        
    3.  Let c2​ be [lanes](#aux-lanes)[lanetype](#syntax-lanetype)[x](#syntax-shape)M​(c1​)\[i\].
        
    4.  Push the value ([lanetype](#syntax-lanetype).[const](#syntax-instr-numeric) c2​) to the stack.
        
4.  Else:
    
    1.  Assert: Due to [validation](#valid-vextract-lane), [lanetype](#syntax-lanetype) is packed type.
        
    2.  Let [sx](#syntax-sx) be [sx](#syntax-sx)′?.
        
    3.  Assert: Due to [validation](#valid-vextract-lane), i<∣[lanes](#aux-lanes)[lanetype](#syntax-lanetype)[x](#syntax-shape)M​(c1​)∣.
        
    4.  Let c2​ be [extend](#op-extend)∣[lanetype](#syntax-lanetype)∣,32[sx](#syntax-sx)​([lanes](#aux-lanes)[lanetype](#syntax-lanetype)[x](#syntax-shape)M​(c1​)\[i\]).
        
    5.  Push the value ([i32](#syntax-numtype).[const](#syntax-instr-numeric) c2​) to the stack.
        

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (nt[x](#syntax-shape)M.[extract\_lane](#syntax-instr-vec) i)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (pt[x](#syntax-shape)M.[extract\_lane](#syntax-instr-vec)\_[sx](#syntax-sx) i)​[↪](#exec-notation)[↪](#exec-notation)​(nt.[const](#syntax-instr-numeric) c2​)([i32](#syntax-numtype).[const](#syntax-instr-numeric) c2​)​if c2​\=[lanes](#aux-lanes)nt[x](#syntax-shape)M​(c1​)\[i\]if c2​\=[extend](#op-extend)∣pt∣,32[sx](#syntax-sx)​([lanes](#aux-lanes)pt[x](#syntax-shape)M​(c1​)\[i\])​​

##### 4.6.11.17. [i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[replace\_lane](#syntax-instr-vec) i[](#-hrefsyntax-numtypemathsfihrefsyntax-numtypescriptstylekern-01emnhrefsyntax-shapemathsfxmhrefsyntax-instr-vecmathsfreplace_lanei)

1.  Assert: Due to [validation](#valid-vreplace-lane), a value is on the top of the stack.
    
2.  Pop the value ([numtype](#syntax-numtype)0​.[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vreplace-lane), [numtype](#syntax-numtype)0​\=[unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype)).
    
4.  Assert: Due to [validation](#valid-vreplace-lane), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
5.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
6.  Let c be [lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​)\[\[i\]\=[pack](#aux-packnum)[i](#syntax-numtype)[N](#syntax-numtype)​(c2​)\]).
    
7.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([unpack](#aux-unpack)([i](#syntax-numtype)[N](#syntax-numtype)).[const](#syntax-instr-numeric) c2​) ([i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M.[replace\_lane](#syntax-instr-vec) i)if c\=[lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M−1​([lanes](#aux-lanes)[i](#syntax-numtype)[N](#syntax-numtype)[x](#syntax-shape)M​(c1​)\[\[i\]\=[pack](#aux-packnum)[i](#syntax-numtype)[N](#syntax-numtype)​(c2​)\])​[↪](#exec-notation)([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​

##### 4.6.11.18. sh2​.[vextunop](#syntax-vextunop)\_sh1​[](#-mathitsh_2--hrefsyntax-vextunopmathitvextunopmathsf_mathitsh_1)

1.  Assert: Due to [validation](#valid-vextunop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let c be [vextunop](#syntax-vextunop)sh1​,sh2​​(c1​).
    
4.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (sh2​.[vextunop](#syntax-vextunop)\_sh1​)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if [vextunop](#syntax-vextunop)sh1​,sh2​​(c1​)\=c​​

##### 4.6.11.19. sh2​.[vextbinop](#syntax-vextbinop)\_sh1​[](#-mathitsh_2--hrefsyntax-vextbinopmathitvextbinopmathsf_mathitsh_1)

1.  Assert: Due to [validation](#valid-vextbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vextbinop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [vextbinop](#syntax-vextbinop)sh1​,sh2​​(c1​,c2​).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh2​.[vextbinop](#syntax-vextbinop)\_sh1​)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if [vextbinop](#syntax-vextbinop)sh1​,sh2​​(c1​,c2​)\=c​​

##### 4.6.11.20. sh2​.[vextternop](#syntax-vextternop)\_sh1​[](#-mathitsh_2--hrefsyntax-vextternopmathitvextternopmathsf_mathitsh_1)

1.  Assert: Due to [validation](#valid-vextternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) from the stack.
    
3.  Assert: Due to [validation](#valid-vextternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
5.  Assert: Due to [validation](#valid-vextternop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
6.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
7.  Let c be [vextternop](#syntax-vextternop)sh1​,sh2​​(c1​,c2​,c3​).
    
8.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c3​) (sh2​.[vextternop](#syntax-vextternop)\_sh1​)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)if [vextternop](#syntax-vextternop)sh1​,sh2​​(c1​,c2​,c3​)\=c​​

##### 4.6.11.21. sh2​.[narrow](#syntax-instr-vec)\_sh1​\_[sx](#syntax-sx)[](#-mathitsh_2hrefsyntax-instr-vecmathsfnarrowmathsf_mathitsh_1mathsf_hrefsyntax-sxmathitsx)

1.  Assert: Due to [validation](#valid-vnarrow), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) from the stack.
    
3.  Assert: Due to [validation](#valid-vnarrow), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
4.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
5.  Let c be [narrow](#syntax-instr-vec)sh1​,sh2​[sx](#syntax-sx)​(c1​,c2​).
    
6.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c2​) (sh2​.[narrow](#syntax-instr-vec)\_sh1​\_[sx](#syntax-sx))​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[narrow](#syntax-instr-vec)sh1​,sh2​[sx](#syntax-sx)​(c1​,c2​)​​

##### 4.6.11.22. sh2​.[vcvtop](#syntax-vcvtop)\_sh1​[](#-mathitsh_2--hrefsyntax-vcvtopmathitvcvtopmathsf_mathitsh_1)

1.  Assert: Due to [validation](#valid-vcvtop), a value of [vector type](#syntax-vectype) [v128](#syntax-vectype) is on the top of the stack.
    
2.  Pop the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) from the stack.
    
3.  Let c be [vcvtop](#syntax-vcvtop)sh1​,sh2​​([vcvtop](#syntax-vcvtop),c1​).
    
4.  Push the value ([v128](#syntax-vectype).[const](#syntax-instr-numeric) c) to the stack.
    

​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c1​) (sh2​.[vcvtop](#syntax-vcvtop)\_sh1​)​[↪](#exec-notation)​([v128](#syntax-vectype).[const](#syntax-instr-numeric) c)​if c\=[vcvtop](#syntax-vcvtop)sh1​,sh2​​([vcvtop](#syntax-vcvtop),c1​)​​

#### 4.6.12. Expressions[](#expressions⑤)

An [expression](#syntax-expr) is _evaluated_ relative to a [current](#exec-notation-textual) [frame](#syntax-frame) pointing to its containing [module instance](#syntax-moduleinst).

##### 4.6.12.1. eval\_expr [instr](#syntax-instr)∗[](#-mathsfeval_exprhrefsyntax-instrmathitinstrast)

1.  Execute the sequence [instr](#syntax-instr)∗.
    
2.  Pop the value [val](#syntax-val) from the stack.
    
3.  Return [val](#syntax-val).
    

​z;[instr](#syntax-instr)∗​[↪∗](#exec-notation)​z′;[val](#syntax-val)∗​if z;[instr](#syntax-instr)∗[↪∗](#exec-notation)z′;[val](#syntax-val)∗​​

Note

Evaluation iterates this reduction rule until reaching a value. Expressions constituting [function](#syntax-func) bodies are executed during function [invocation](#exec-invoke).

### 4.7. Modules[](#modules⑥)

For modules, the execution semantics primarily defines [instantiation](#exec-instantiation), which [allocates](#alloc) instances for a module and its contained definitions, initializes [memories](#syntax-mem) and [tables](#syntax-table) from contained [data](#syntax-data) and [element](#syntax-elem) segments, and invokes the [start function](#syntax-start) if present. It also includes [invocation](#exec-invocation) of exported functions.

#### 4.7.1. Allocation[](#allocation①)

New instances of [tags](#syntax-taginst), [globals](#syntax-globalinst), [memories](#syntax-meminst), [tables](#syntax-tableinst), [functions](#syntax-funcinst), [data segments](#syntax-datainst), and [element segments](#syntax-eleminst) are _allocated_ in a [store](#syntax-store) s, as defined by the following auxiliary functions.

##### 4.7.1.1. [Tags](#syntax-taginst)[](#tags⑦)

##### 4.7.1.2. [alloctag](#alloc-tag)(s,[tagtype](#syntax-tagtype))[](#-hrefalloc-tagmathrmalloctag-s-hrefsyntax-tagtypemathittagtype)

1.  Let [taginst](#syntax-taginst) be the [tag instance](#syntax-taginst) {[type](#syntax-taginst) [tagtype](#syntax-tagtype)}.
    
2.  Let a be the length of s.[tags](#syntax-store).
    
3.  Append [taginst](#syntax-taginst) to s.[tags](#syntax-store).
    
4.  Return a.
    

[alloctag](#alloc-tag)(s,[tagtype](#syntax-tagtype))if [taginst](#syntax-taginst)\={[type](#syntax-taginst) [tagtype](#syntax-tagtype)}​\=(s⊕{[tags](#syntax-store) [taginst](#syntax-taginst)},∣s.[tags](#syntax-store)∣)​

##### 4.7.1.3. [Globals](#syntax-globalinst)[](#globals⑦)

##### 4.7.1.4. [allocglobal](#alloc-global)(s,[globaltype](#syntax-globaltype),[val](#syntax-val))[](#-hrefalloc-globalmathrmallocglobal-s-hrefsyntax-globaltypemathitglobaltype-hrefsyntax-valmathitval)

1.  Let [globalinst](#syntax-globalinst) be the [global instance](#syntax-globalinst) {[type](#syntax-globalinst) [globaltype](#syntax-globaltype),[value](#syntax-globalinst) [val](#syntax-val)}.
    
2.  Let a be the length of s.[globals](#syntax-store).
    
3.  Append [globalinst](#syntax-globalinst) to s.[globals](#syntax-store).
    
4.  Return a.
    

[allocglobal](#alloc-global)(s,[globaltype](#syntax-globaltype),[val](#syntax-val))if [globalinst](#syntax-globalinst)\={[type](#syntax-globalinst) [globaltype](#syntax-globaltype),[value](#syntax-globalinst) [val](#syntax-val)}​\=(s⊕{[globals](#syntax-store) [globalinst](#syntax-globalinst)},∣s.[globals](#syntax-store)∣)​

##### 4.7.1.5. [Memories](#syntax-meminst)[](#memories⑦)

##### 4.7.1.6. [allocmem](#alloc-mem)(s,at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype))[](#-hrefalloc-memmathrmallocmem-s-mathitat-i-hrefsyntax-limits---j-hrefsyntax-memtypemathsfpage)

1.  Let [meminst](#syntax-meminst) be the [memory instance](#syntax-meminst) {[type](#syntax-meminst) (at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) 0x00i⋅64Ki}.
    
2.  Let a be the length of s.[mems](#syntax-store).
    
3.  Append [meminst](#syntax-meminst) to s.[mems](#syntax-store).
    
4.  Return a.
    

[allocmem](#alloc-mem)(s,at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype))if [meminst](#syntax-meminst)\={[type](#syntax-meminst) (at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) (0x00)i⋅64Ki}​\=(s⊕{[mems](#syntax-store) [meminst](#syntax-meminst)},∣s.[mems](#syntax-store)∣)​

##### 4.7.1.7. [Tables](#syntax-tableinst)[](#tables⑦)

##### 4.7.1.8. [alloctable](#alloc-table)(s,at \[i[..](#syntax-limits)j?\] rt,[ref](#syntax-ref))[](#-hrefalloc-tablemathrmalloctable-s-mathitat-i-hrefsyntax-limits---j-mathitrt-hrefsyntax-refmathitref)

1.  Let [tableinst](#syntax-tableinst) be the [table instance](#syntax-tableinst) {[type](#syntax-tableinst) (at \[i[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) [ref](#syntax-ref)i}.
    
2.  Let a be the length of s.[tables](#syntax-store).
    
3.  Append [tableinst](#syntax-tableinst) to s.[tables](#syntax-store).
    
4.  Return a.
    

[alloctable](#alloc-table)(s,at \[i[..](#syntax-limits)j?\] rt,[ref](#syntax-ref))if [tableinst](#syntax-tableinst)\={[type](#syntax-tableinst) (at \[i[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) [ref](#syntax-ref)i}​\=(s⊕{[tables](#syntax-store) [tableinst](#syntax-tableinst)},∣s.[tables](#syntax-store)∣)​

##### 4.7.1.9. [Functions](#syntax-funcinst)[](#functions⑦)

##### 4.7.1.10. [allocfunc](#alloc-func)(s,[deftype](#syntax-deftype),[code](#syntax-funcinst),[moduleinst](#syntax-moduleinst))[](#-hrefalloc-funcmathrmallocfunc-s-hrefsyntax-deftypemathitdeftype-hrefsyntax-funcinstmathitcode-hrefsyntax-moduleinstmathitmoduleinst)

1.  Let [funcinst](#syntax-funcinst) be the [function instance](#syntax-funcinst) {[type](#syntax-funcinst) [deftype](#syntax-deftype),[module](#syntax-funcinst) [moduleinst](#syntax-moduleinst),[code](#syntax-funcinst) [code](#syntax-funcinst)}.
    
2.  Let a be the length of s.[funcs](#syntax-store).
    
3.  Append [funcinst](#syntax-funcinst) to s.[funcs](#syntax-store).
    
4.  Return a.
    

[allocfunc](#alloc-func)(s,[deftype](#syntax-deftype),[code](#syntax-funcinst),[moduleinst](#syntax-moduleinst))if [funcinst](#syntax-funcinst)\={[type](#syntax-funcinst) [deftype](#syntax-deftype),[module](#syntax-funcinst) [moduleinst](#syntax-moduleinst),[code](#syntax-funcinst) [code](#syntax-funcinst)}​\=(s⊕{[funcs](#syntax-store) [funcinst](#syntax-funcinst)},∣s.[funcs](#syntax-store)∣)​

##### 4.7.1.11. [Data segments](#syntax-datainst)[](#data-segments⑤)

##### 4.7.1.12. [allocdata](#alloc-data)(s,[ok](#valid-data),[byte](#syntax-byte)∗)[](#-hrefalloc-datamathrmallocdata-s-hrefvalid-datamathsfok-hrefsyntax-bytemathitbyteast)

1.  Let [datainst](#syntax-datainst) be the [data instance](#syntax-datainst) {[bytes](#syntax-datainst) [byte](#syntax-byte)∗}.
    
2.  Let a be the length of s.[datas](#syntax-store).
    
3.  Append [datainst](#syntax-datainst) to s.[datas](#syntax-store).
    
4.  Return a.
    

[allocdata](#alloc-data)(s,[ok](#valid-data),[byte](#syntax-byte)∗)if [datainst](#syntax-datainst)\={[bytes](#syntax-datainst) [byte](#syntax-byte)∗}​\=(s⊕{[datas](#syntax-store) [datainst](#syntax-datainst)},∣s.[datas](#syntax-store)∣)​

##### 4.7.1.13. [Element segments](#syntax-eleminst)[](#element-segments⑤)

##### 4.7.1.14. [allocelem](#alloc-elem)(s,[elemtype](#syntax-elemtype),[ref](#syntax-ref)∗)[](#-hrefalloc-elemmathrmallocelem-s-hrefsyntax-elemtypemathitelemtype-hrefsyntax-refmathitrefast)

1.  Let [eleminst](#syntax-eleminst) be the [element instance](#syntax-eleminst) {[type](#syntax-eleminst) [elemtype](#syntax-elemtype),[refs](#syntax-eleminst) [ref](#syntax-ref)∗}.
    
2.  Let a be the length of s.[elems](#syntax-store).
    
3.  Append [eleminst](#syntax-eleminst) to s.[elems](#syntax-store).
    
4.  Return a.
    

[allocelem](#alloc-elem)(s,[elemtype](#syntax-elemtype),[ref](#syntax-ref)∗)if [eleminst](#syntax-eleminst)\={[type](#syntax-eleminst) [elemtype](#syntax-elemtype),[refs](#syntax-eleminst) [ref](#syntax-ref)∗}​\=(s⊕{[elems](#syntax-store) [eleminst](#syntax-eleminst)},∣s.[elems](#syntax-store)∣)​

##### 4.7.1.15. Growing [memories](#syntax-meminst)[](#growing-memories①)

##### 4.7.1.16. [growmem](#grow-mem)([meminst](#syntax-meminst),n)[](#-hrefgrow-memmathrmgrowmem-hrefsyntax-meminstmathitmeminst-n)

1.  Let {[type](#syntax-meminst) (at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) b∗} be the destructuring of [meminst](#syntax-meminst).
    
2.  Let i′ be ∣b∗∣/(64Ki)+n.
    
3.  If (i′≤j)?, then:
    
    1.  Let [meminst](#syntax-meminst)′ be the [memory instance](#syntax-meminst) {[type](#syntax-meminst) (at \[i′[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) b∗ 0x00n⋅64Ki}.
        
    2.  Return [meminst](#syntax-meminst)′.
        
4.  Fail.
    

[growmem](#grow-mem)([meminst](#syntax-meminst),n)​\=​[meminst](#syntax-meminst)′​if [meminst](#syntax-meminst)\={[type](#syntax-meminst) (at \[i[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) b∗}∧ [meminst](#syntax-meminst)′\={[type](#syntax-meminst) (at \[i′[..](#syntax-limits)j?\] [page](#syntax-memtype)),[bytes](#syntax-meminst) b∗ (0x00)n⋅64Ki}∧ i′\=∣b∗∣/(64Ki)+n∧ (i′≤j)?​​​

##### 4.7.1.17. Growing [tables](#syntax-tableinst)[](#growing-tables①)

##### 4.7.1.18. [growtable](#grow-table)([tableinst](#syntax-tableinst),n,r)[](#-hrefgrow-tablemathrmgrowtable-hrefsyntax-tableinstmathittableinst-n-r)

1.  Let {[type](#syntax-tableinst) (at \[i[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) r′∗} be the destructuring of [tableinst](#syntax-tableinst).
    
2.  Let i′ be ∣r′∗∣+n.
    
3.  If (i′≤j)?, then:
    
    1.  Let [tableinst](#syntax-tableinst)′ be the [table instance](#syntax-tableinst) {[type](#syntax-tableinst) (at \[i′[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) r′∗ rn}.
        
    2.  Return [tableinst](#syntax-tableinst)′.
        
4.  Fail.
    

[growtable](#grow-table)([tableinst](#syntax-tableinst),n,r)​\=​[tableinst](#syntax-tableinst)′​if [tableinst](#syntax-tableinst)\={[type](#syntax-tableinst) (at \[i[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) r′∗}∧ [tableinst](#syntax-tableinst)′\={[type](#syntax-tableinst) (at \[i′[..](#syntax-limits)j?\] rt),[refs](#syntax-tableinst) r′∗ rn}∧ i′\=∣r′∗∣+n∧ (i′≤j)?​​​

##### 4.7.1.19. [Modules](#syntax-moduleinst)[](#modules⑦)

##### 4.7.1.20. [allocmodule](#alloc-module)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗,[val](#syntax-val)g∗​,[ref](#syntax-ref)t∗​,[ref](#syntax-ref)e∗​∗)[](#-hrefalloc-modulemathrmallocmodule-s-hrefsyntax-modulemathitmodule-hrefsyntax-externaddrmathitexternaddrast-hrefsyntax-valmathitval_mathsfgast-hrefsyntax-refmathitref_mathsftast-hrefsyntax-refmathitref_mathsfeastast)

1.  Let ([module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗) be the destructuring of [module](#syntax-module).
    
2.  Let aai∗​ be [tags](#syntax-externaddr)([externaddr](#syntax-externaddr)∗).
    
3.  Let gai∗​ be [globals](#syntax-externaddr)([externaddr](#syntax-externaddr)∗).
    
4.  Let fai∗​ be [funcs](#syntax-externaddr)([externaddr](#syntax-externaddr)∗).
    
5.  Let mai∗​ be [mems](#syntax-externaddr)([externaddr](#syntax-externaddr)∗).
    
6.  Let tai∗​ be [tables](#syntax-externaddr)([externaddr](#syntax-externaddr)∗).
    
7.  Let fa∗ be ∣s.[funcs](#syntax-store)∣+if​ for all if​ from 0 to ∣[func](#syntax-func)∗∣−1.
    
8.  Let [tagtype](#syntax-tagtype)∗ be the tag type sequence ϵ.
    
9.  For each [tag](#syntax-tag) in [tag](#syntax-tag)∗, do:
    
    1.  Let ([tag](#syntax-tag) [tagtype](#syntax-tagtype)) be the destructuring of [tag](#syntax-tag).
        
    2.  Append [tagtype](#syntax-tagtype) to [tagtype](#syntax-tagtype)∗.
        
10.  Let [byte](#syntax-byte)∗∗ be the byte sequence sequence ϵ.
    
11.  For each [data](#syntax-data) in [data](#syntax-data)∗, do:
    
    1.  Let ([data](#syntax-data) [byte](#syntax-byte)∗ [datamode](#syntax-datamode)) be the destructuring of [data](#syntax-data).
        
    2.  Append [byte](#syntax-byte)∗ to [byte](#syntax-byte)∗∗.
        
12.  Let [globaltype](#syntax-globaltype)∗ be the global type sequence ϵ.
    
13.  For each [global](#syntax-global) in [global](#syntax-global)∗, do:
    
    1.  Let ([global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)g​) be the destructuring of [global](#syntax-global).
        
    2.  Append [globaltype](#syntax-globaltype) to [globaltype](#syntax-globaltype)∗.
        
14.  Let [tabletype](#syntax-tabletype)∗ be the table type sequence ϵ.
    
15.  For each [table](#syntax-table) in [table](#syntax-table)∗, do:
    
    1.  Let ([table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)t​) be the destructuring of [table](#syntax-table).
        
    2.  Append [tabletype](#syntax-tabletype) to [tabletype](#syntax-tabletype)∗.
        
16.  Let [memtype](#syntax-memtype)∗ be the memory type sequence ϵ.
    
17.  For each [mem](#syntax-mem) in [mem](#syntax-mem)∗, do:
    
    1.  Let ([memory](#syntax-mem) [memtype](#syntax-memtype)) be the destructuring of [mem](#syntax-mem).
        
    2.  Append [memtype](#syntax-memtype) to [memtype](#syntax-memtype)∗.
        
18.  Let dt∗ be [alloctype](#alloc-type)∗([type](#syntax-rectype)∗).
    
19.  Let [elemtype](#syntax-elemtype)∗ be the reference type sequence ϵ.
    
20.  For each [elem](#syntax-elem) in [elem](#syntax-elem)∗, do:
    
    1.  Let ([elem](#syntax-elem) [elemtype](#syntax-elemtype) [expr](#syntax-expr)e∗​ [elemmode](#syntax-elemmode)) be the destructuring of [elem](#syntax-elem).
        
    2.  Append [elemtype](#syntax-elemtype) to [elemtype](#syntax-elemtype)∗.
        
21.  Let [expr](#syntax-expr)f∗​ be the expression sequence ϵ.
    
22.  Let [local](#syntax-local)∗∗ be the local sequence sequence ϵ.
    
23.  Let x∗ be the type index sequence ϵ.
    
24.  For each [func](#syntax-func) in [func](#syntax-func)∗, do:
    
    1.  Let ([func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr)f​) be the destructuring of [func](#syntax-func).
        
    2.  Append [expr](#syntax-expr)f​ to [expr](#syntax-expr)f∗​.
        
    3.  Append [local](#syntax-local)∗ to [local](#syntax-local)∗∗.
        
    4.  Append x to x∗.
        
25.  Let aa∗ be ϵ.
    
26.  For each [tagtype](#syntax-tagtype) in [tagtype](#syntax-tagtype)∗, do:
    
    1.  Let aa be the [tag address](#syntax-tagaddr) [alloctag](#alloc-tag)(s,[tagtype](#syntax-tagtype)\[[:=](#notation-subst)dt∗\]).
        
    2.  Append aa to aa∗.
        
27.  Let ga∗ be ϵ.
    
28.  For each [globaltype](#syntax-globaltype) in [globaltype](#syntax-globaltype)∗ and [val](#syntax-val)g​ in [val](#syntax-val)g∗​, do:
    
    1.  Let ga be the [global address](#syntax-globaladdr) [allocglobal](#alloc-global)(s,[globaltype](#syntax-globaltype)\[[:=](#notation-subst)dt∗\],[val](#syntax-val)g​).
        
    2.  Append ga to ga∗.
        
29.  Let ma∗ be ϵ.
    
30.  For each [memtype](#syntax-memtype) in [memtype](#syntax-memtype)∗, do:
    
    1.  Let ma be the [memory address](#syntax-memaddr) [allocmem](#alloc-mem)(s,[memtype](#syntax-memtype)\[[:=](#notation-subst)dt∗\]).
        
    2.  Append ma to ma∗.
        
31.  Let ta∗ be ϵ.
    
32.  For each [tabletype](#syntax-tabletype) in [tabletype](#syntax-tabletype)∗ and [ref](#syntax-ref)t​ in [ref](#syntax-ref)t∗​, do:
    
    1.  Let ta be the [table address](#syntax-tableaddr) [alloctable](#alloc-table)(s,[tabletype](#syntax-tabletype)\[[:=](#notation-subst)dt∗\],[ref](#syntax-ref)t​).
        
    2.  Append ta to ta∗.
        
33.  Let xi∗ be ϵ.
    
34.  For each [export](#syntax-export) in [export](#syntax-export)∗, do:
    
    1.  Let xi be the [export instance](#syntax-exportinst) [allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export)).
        
    2.  Append xi to xi∗.
        
35.  Let da∗ be ϵ.
    
36.  For each [byte](#syntax-byte)∗ in [byte](#syntax-byte)∗∗, do:
    
    1.  Let da be the [data address](#syntax-dataaddr) [allocdata](#alloc-data)(s,[ok](#valid-data),[byte](#syntax-byte)∗).
        
    2.  Append da to da∗.
        
37.  Let ea∗ be ϵ.
    
38.  For each [elemtype](#syntax-elemtype) in [elemtype](#syntax-elemtype)∗ and [ref](#syntax-ref)e∗​ in [ref](#syntax-ref)e∗​∗, do:
    
    1.  Let ea be the [elem address](#syntax-elemaddr) [allocelem](#alloc-elem)(s,[elemtype](#syntax-elemtype)\[[:=](#notation-subst)dt∗\],[ref](#syntax-ref)e∗​).
        
    2.  Append ea to ea∗.
        
39.  Let [moduleinst](#syntax-moduleinst) be the [module instance](#syntax-moduleinst) {[types](#syntax-moduleinst) dt∗,[tags](#syntax-moduleinst) aai∗​ aa∗,[globals](#syntax-moduleinst) gai∗​ ga∗,[mems](#syntax-moduleinst) mai∗​ ma∗,[tables](#syntax-moduleinst) tai∗​ ta∗,[funcs](#syntax-moduleinst) fai∗​ fa∗,[datas](#syntax-moduleinst) da∗,[elems](#syntax-moduleinst) ea∗,[exports](#syntax-moduleinst) xi∗}.
    
40.  Let [funcaddr](#syntax-funcaddr)0∗​ be ϵ.
    
41.  For each [expr](#syntax-expr)f​ in [expr](#syntax-expr)f∗​ and [local](#syntax-local)∗ in [local](#syntax-local)∗∗ and x in x∗, do:
    
    1.  Let [funcaddr](#syntax-funcaddr)0​ be the [function address](#syntax-funcaddr) [allocfunc](#alloc-func)(s,dt∗\[x\],[func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr)f​,[moduleinst](#syntax-moduleinst)).
        
    2.  Append [funcaddr](#syntax-funcaddr)0​ to [funcaddr](#syntax-funcaddr)0∗​.
        
42.  Assert: Due to validation, [funcaddr](#syntax-funcaddr)0∗​\=fa∗.
    
43.  Return [moduleinst](#syntax-moduleinst).
    

[allocmodule](#alloc-module)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗,[val](#syntax-val)g∗​,[ref](#syntax-ref)t∗​,([ref](#syntax-ref)e∗​)∗)if [module](#syntax-module)\=[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗∧ [tag](#syntax-tag)∗\=([tag](#syntax-tag) [tagtype](#syntax-tagtype))∗∧ [global](#syntax-global)∗\=([global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)g​)∗∧ [mem](#syntax-mem)∗\=([memory](#syntax-mem) [memtype](#syntax-memtype))∗∧ [table](#syntax-table)∗\=([table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)t​)∗∧ [func](#syntax-func)∗\=([func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr)f​)∗∧ [data](#syntax-data)∗\=([data](#syntax-data) [byte](#syntax-byte)∗ [datamode](#syntax-datamode))∗∧ [elem](#syntax-elem)∗\=([elem](#syntax-elem) [elemtype](#syntax-elemtype) [expr](#syntax-expr)e∗​ [elemmode](#syntax-elemmode))∗∧ aai∗​\=[tags](#syntax-externaddr)([externaddr](#syntax-externaddr)∗)∧ gai∗​\=[globals](#syntax-externaddr)([externaddr](#syntax-externaddr)∗)∧ mai∗​\=[mems](#syntax-externaddr)([externaddr](#syntax-externaddr)∗)∧ tai∗​\=[tables](#syntax-externaddr)([externaddr](#syntax-externaddr)∗)∧ fai∗​\=[funcs](#syntax-externaddr)([externaddr](#syntax-externaddr)∗)∧ dt∗\=[alloctype](#alloc-type)∗([type](#syntax-rectype)∗)∧ fa∗\=(∣s.[funcs](#syntax-store)∣+if​)if​<∣[func](#syntax-func)∗∣∧ (s1​,aa∗)\=[alloctag](#alloc-tag)∗(s,[tagtype](#syntax-tagtype)\[[:=](#notation-subst)dt∗\]∗)∧ (s2​,ga∗)\=[allocglobal](#alloc-global)∗(s1​,[globaltype](#syntax-globaltype)\[[:=](#notation-subst)dt∗\]∗,[val](#syntax-val)g∗​)∧ (s3​,ma∗)\=[allocmem](#alloc-mem)∗(s2​,[memtype](#syntax-memtype)\[[:=](#notation-subst)dt∗\]∗)∧ (s4​,ta∗)\=[alloctable](#alloc-table)∗(s3​,[tabletype](#syntax-tabletype)\[[:=](#notation-subst)dt∗\]∗,[ref](#syntax-ref)t∗​)∧ (s5​,da∗)\=[allocdata](#alloc-data)∗(s4​,[ok](#valid-data)∣[data](#syntax-data)∗∣,([byte](#syntax-byte)∗)∗)∧ (s6​,ea∗)\=[allocelem](#alloc-elem)∗(s5​,[elemtype](#syntax-elemtype)\[[:=](#notation-subst)dt∗\]∗,([ref](#syntax-ref)e∗​)∗)∧ (s7​,fa∗)\=[allocfunc](#alloc-func)∗(s6​,dt∗\[x\]∗,([func](#syntax-func) x [local](#syntax-local)∗ [expr](#syntax-expr)f​)∗,[moduleinst](#syntax-moduleinst)∣[func](#syntax-func)∗∣)∧ xi∗\=[allocexport](#alloc-export)∗({[tags](#syntax-moduleinst) aai∗​ aa∗,[globals](#syntax-moduleinst) gai∗​ ga∗,[mems](#syntax-moduleinst) mai∗​ ma∗,[tables](#syntax-moduleinst) tai∗​ ta∗,[funcs](#syntax-moduleinst) fai∗​ fa∗},[export](#syntax-export)∗)∧ [moduleinst](#syntax-moduleinst)\={[types](#syntax-moduleinst) dt∗,[tags](#syntax-moduleinst) aai∗​ aa∗,[globals](#syntax-moduleinst) gai∗​ ga∗,[mems](#syntax-moduleinst) mai∗​ ma∗,[tables](#syntax-moduleinst) tai∗​ ta∗,[funcs](#syntax-moduleinst) fai∗​ fa∗,[datas](#syntax-moduleinst) da∗,[elems](#syntax-moduleinst) ea∗,[exports](#syntax-moduleinst) xi∗}​​​\=(s7​,[moduleinst](#syntax-moduleinst))​

Here, the notation allocx∗ is shorthand for multiple [allocations](#alloc) of object kind X, defined as follows:

allocX∗(s,ϵ,ϵ)allocX∗(s,X X′∗,Y Y′∗)​\=\=​(s,ϵ)(s2​,a a′∗)​if (s1​,a)\=allocX(X,Y,s,X,Y)∧ (s2​,a′∗)\=allocX∗(s1​,X′∗,Y′∗)​​​

For types, however, allocation is defined in terms of [rolling](#aux-roll-rectype) and [substitution](#notation-subst) of all preceding types to produce a list of [closed](#type-closed) [defined types](#syntax-deftype):

##### 4.7.1.21. [alloctype](#alloc-type)∗([type](#syntax-rectype)′′∗)[](#-hrefalloc-typemathrmalloctypeast-hrefsyntax-rectypemathittypeast)

1.  If [type](#syntax-rectype)′′∗\=ϵ, then:
    
    1.  Return ϵ.
        
2.  Let [type](#syntax-rectype)′∗ [type](#syntax-rectype) be [type](#syntax-rectype)′′∗.
    
3.  Let ([type](#syntax-type) [rectype](#syntax-rectype)) be the destructuring of [type](#syntax-rectype).
    
4.  Let [deftype](#syntax-deftype)′∗ be [alloctype](#alloc-type)∗([type](#syntax-rectype)′∗).
    
5.  Let x be the length of [deftype](#syntax-deftype)′∗.
    
6.  Let [deftype](#syntax-deftype)∗ be [roll](#aux-roll-deftype)x∗​([rectype](#syntax-rectype))\[[:=](#notation-subst)[deftype](#syntax-deftype)′∗\].
    
7.  Return [deftype](#syntax-deftype)′∗ [deftype](#syntax-deftype)∗.
    

[alloctype](#alloc-type)∗(ϵ)[alloctype](#alloc-type)∗([type](#syntax-rectype)′∗ [type](#syntax-rectype))​\=\=​ϵ[deftype](#syntax-deftype)′∗ [deftype](#syntax-deftype)∗​if [deftype](#syntax-deftype)′∗\=[alloctype](#alloc-type)∗([type](#syntax-rectype)′∗)∧ [type](#syntax-rectype)\=[type](#syntax-type) [rectype](#syntax-rectype)∧ [deftype](#syntax-deftype)∗\=[roll](#aux-roll-deftype)x∗​([rectype](#syntax-rectype))\[[:=](#notation-subst)[deftype](#syntax-deftype)′∗\]∧ x\=∣[deftype](#syntax-deftype)′∗∣​​​

Finally, export instances are produced with the help of the following definition:

##### 4.7.1.22. [allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) [externidx](#syntax-externidx))[](#-hrefalloc-exportmathrmallocexport-hrefsyntax-moduleinstmathitmoduleinst-hrefsyntax-exportmathsfexporthrefsyntax-namemathitnamehrefsyntax-externidxmathitexternidx)

1.  If [externidx](#syntax-externidx) is some [tag](#syntax-externidx) [tagidx](#syntax-tagidx), then:
    
    1.  Let ([tag](#syntax-externidx) x) be the destructuring of [externidx](#syntax-externidx).
        
    2.  Return {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([tag](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[tags](#syntax-moduleinst)\[x\])}.
        
2.  If [externidx](#syntax-externidx) is some [global](#syntax-externidx) [globalidx](#syntax-globalidx), then:
    
    1.  Let ([global](#syntax-externidx) x) be the destructuring of [externidx](#syntax-externidx).
        
    2.  Return {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([global](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[globals](#syntax-moduleinst)\[x\])}.
        
3.  If [externidx](#syntax-externidx) is some [memory](#syntax-externidx) [memidx](#syntax-memidx), then:
    
    1.  Let ([memory](#syntax-externidx) x) be the destructuring of [externidx](#syntax-externidx).
        
    2.  Return {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([mem](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[mems](#syntax-moduleinst)\[x\])}.
        
4.  If [externidx](#syntax-externidx) is some [table](#syntax-externidx) [tableidx](#syntax-tableidx), then:
    
    1.  Let ([table](#syntax-externidx) x) be the destructuring of [externidx](#syntax-externidx).
        
    2.  Return {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([table](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[tables](#syntax-moduleinst)\[x\])}.
        
5.  Assert: Due to validation, [externidx](#syntax-externidx) is some [func](#syntax-externidx) [funcidx](#syntax-funcidx).
    
6.  Let ([func](#syntax-externidx) x) be the destructuring of [externidx](#syntax-externidx).
    
7.  Return {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([func](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[funcs](#syntax-moduleinst)\[x\])}.
    

[allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) ([tag](#syntax-externidx) x))[allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) ([global](#syntax-externidx) x))[allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) ([memory](#syntax-externidx) x))[allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) ([table](#syntax-externidx) x))[allocexport](#alloc-export)([moduleinst](#syntax-moduleinst),[export](#syntax-export) [name](#syntax-name) ([func](#syntax-externidx) x))​\=\=\=\=\=​{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([tag](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[tags](#syntax-moduleinst)\[x\])}{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([global](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[globals](#syntax-moduleinst)\[x\])}{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([mem](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[mems](#syntax-moduleinst)\[x\])}{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([table](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[tables](#syntax-moduleinst)\[x\])}{[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) ([func](#syntax-externaddr) [moduleinst](#syntax-moduleinst).[funcs](#syntax-moduleinst)\[x\])}​​

Note

The definition of module allocation is mutually recursive with the allocation of its associated functions, because the resulting module instance is passed to the allocators as an argument, in order to form the necessary closures. In an implementation, this recursion is easily unraveled by mutating one or the other in a secondary step.

#### 4.7.2. Instantiation[](#instantiation④)

Given a [store](#syntax-store) s, a [module](#syntax-module) is instantiated with a list of [external addresses](#syntax-externaddr) [externaddr](#syntax-externaddr)∗ supplying the required imports as follows.

Instantiation checks that the module is [valid](#valid) and the provided imports [match](#match-externtype) the declared types, and may _fail_ with an error otherwise. Instantiation can also result in an [exception](#exception) or [trap](#trap) when initializing a [table](#syntax-table) or [memory](#syntax-mem) from an [active segment](#syntax-data) or when executing the [start](#syntax-start) function. It is up to the [embedder](#embedder) to define how such conditions are reported.

##### 4.7.2.1. [instantiate](#exec-instantiation)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗)[](#-hrefexec-instantiationmathrminstantiate-s-hrefsyntax-modulemathitmodule-hrefsyntax-externaddrmathitexternaddrast)

1.  If [module](#syntax-module) is not [valid](#valid-module), then:
    
    1.  Fail.
        
2.  Let xti∗​ [→](#syntax-moduletype) xte∗​ be the destructuring of the type of [module](#syntax-module).
    
3.  Let ([module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗) be the destructuring of [module](#syntax-module).
    
4.  If ∣[externaddr](#syntax-externaddr)∗∣\=∣xti∗​∣, then:
    
    1.  Fail.
        
5.  For all [externaddr](#syntax-externaddr) in [externaddr](#syntax-externaddr)∗, and corresponding xti​ in xti∗​:
    
    1.  If [externaddr](#syntax-externaddr) is not [valid](#valid-val) with type xti​, then:
        
        1.  Fail.
            
6.  Let [instr](#syntax-instr)d∗​ be the [concatenation](#notation-concat) of [rundata](#aux-rundata)id​​([data](#syntax-data)∗\[id​\])id​<∣[data](#syntax-data)∗∣.
    
7.  Let [instr](#syntax-instr)e∗​ be the [concatenation](#notation-concat) of [runelem](#aux-runelem)ie​​([elem](#syntax-elem)∗\[ie​\])ie​<∣[elem](#syntax-elem)∗∣.
    
8.  Let [moduleinst](#syntax-moduleinst)0​ be the [module instance](#syntax-moduleinst) {[types](#syntax-moduleinst) [alloctype](#alloc-type)∗([type](#syntax-rectype)∗),[globals](#syntax-moduleinst) [globals](#syntax-externaddr)([externaddr](#syntax-externaddr)∗),[funcs](#syntax-moduleinst) [funcs](#syntax-externaddr)([externaddr](#syntax-externaddr)∗) (∣s.[funcs](#syntax-store)∣+if​)if​<∣[func](#syntax-func)∗∣}.
    
9.  Let [expr](#syntax-expr)t∗​ be the expression sequence ϵ.
    
10.  For each [table](#syntax-table) in [table](#syntax-table)∗, do:
    
    1.  Let ([table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)t​) be the destructuring of [table](#syntax-table).
        
    2.  Append [expr](#syntax-expr)t​ to [expr](#syntax-expr)t∗​.
        
11.  Let [expr](#syntax-expr)g∗​ be the expression sequence ϵ.
    
12.  Let [globaltype](#syntax-globaltype)∗ be the global type sequence ϵ.
    
13.  For each [global](#syntax-global) in [global](#syntax-global)∗, do:
    
    1.  Let ([global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)g​) be the destructuring of [global](#syntax-global).
        
    2.  Append [expr](#syntax-expr)g​ to [expr](#syntax-expr)g∗​.
        
    3.  Append [globaltype](#syntax-globaltype) to [globaltype](#syntax-globaltype)∗.
        
14.  Let [expr](#syntax-expr)e∗​∗ be the expression sequence sequence ϵ.
    
15.  For each [elem](#syntax-elem) in [elem](#syntax-elem)∗, do:
    
    1.  Let ([elem](#syntax-elem) [reftype](#syntax-reftype) [expr](#syntax-expr)e∗​ [elemmode](#syntax-elemmode)) be the destructuring of [elem](#syntax-elem).
        
    2.  Append [expr](#syntax-expr)e∗​ to [expr](#syntax-expr)e∗​∗.
        
16.  Let z be the [state](#syntax-state) (s,{[module](#syntax-frame) [moduleinst](#syntax-moduleinst)0​}).
    
17.  Let F be the frame z.[frame](#syntax-state).
    
18.  Push the frame F.
    
19.  Let [val](#syntax-val)g∗​ be [evalglobal](#eval-globals)∗(z,[globaltype](#syntax-globaltype)∗,[expr](#syntax-expr)g∗​).
    
20.  Let [ref](#syntax-ref)t∗​ be the reference value sequence ϵ.
    
21.  For each [expr](#syntax-expr)t​ in [expr](#syntax-expr)t∗​, do:
    
    1.  Let [ref](#syntax-ref)t​ be the result of [evaluating](#exec-expr) [expr](#syntax-expr)t​ with state z.
        
    2.  Append [ref](#syntax-ref)t​ to [ref](#syntax-ref)t∗​.
        
22.  Let [ref](#syntax-ref)e∗​∗ be the reference value sequence sequence ϵ.
    
23.  For each [expr](#syntax-expr)e∗​ in [expr](#syntax-expr)e∗​∗, do:
    
    1.  Let [ref](#syntax-ref)e∗​ be the reference value sequence ϵ.
        
    2.  For each [expr](#syntax-expr)e​ in [expr](#syntax-expr)e∗​, do:
        
        1.  Let [ref](#syntax-ref)e​ be the result of [evaluating](#exec-expr) [expr](#syntax-expr)e​ with state z.
            
        2.  Append [ref](#syntax-ref)e​ to [ref](#syntax-ref)e∗​.
            
    3.  Append [ref](#syntax-ref)e∗​ to [ref](#syntax-ref)e∗​∗.
        
24.  Pop the frame from the stack.
    
25.  Let [moduleinst](#syntax-moduleinst) be [allocmodule](#alloc-module)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗,[val](#syntax-val)g∗​,[ref](#syntax-ref)t∗​,[ref](#syntax-ref)e∗​∗).
    
26.  Let F′ be the frame {[module](#syntax-frame) [moduleinst](#syntax-moduleinst)}.
    
27.  Push the frame F′.
    
28.  Execute the sequence [instr](#syntax-instr)e∗​.
    
29.  Execute the sequence [instr](#syntax-instr)d∗​.
    
30.  If [start](#syntax-start)? is defined, then:
    
    1.  Let ([start](#syntax-start) x) be [start](#syntax-start)?.
        
    2.  Let [instr](#syntax-instr)s​ be the [instruction](#syntax-instr) ([call](#syntax-instr-control) x).
        
    3.  Execute the instruction [instr](#syntax-instr)s​.
        
31.  Pop the frame from the stack.
    
32.  Return [moduleinst](#syntax-moduleinst).
    

[instantiate](#exec-instantiation)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗)if [⊢](#valid-module)[module](#syntax-module):xti∗​[→](#syntax-moduletype)xte∗​∧ (s[⊢](#valid-externaddr)[externaddr](#syntax-externaddr):xti​)∗0.8ex\]∧ [module](#syntax-module)\=[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗∧ [global](#syntax-global)∗\=([global](#syntax-global) [globaltype](#syntax-globaltype) [expr](#syntax-expr)g​)∗∧ [table](#syntax-table)∗\=([table](#syntax-table) [tabletype](#syntax-tabletype) [expr](#syntax-expr)t​)∗∧ [data](#syntax-data)∗\=([data](#syntax-data) [byte](#syntax-byte)∗ [datamode](#syntax-datamode))∗∧ [elem](#syntax-elem)∗\=([elem](#syntax-elem) [reftype](#syntax-reftype) [expr](#syntax-expr)e∗​ [elemmode](#syntax-elemmode))∗∧ [start](#syntax-start)?\=([start](#syntax-start) x)?∧ [moduleinst](#syntax-moduleinst)0​\={[types](#syntax-moduleinst) [alloctype](#alloc-type)∗([type](#syntax-rectype)∗),[globals](#syntax-moduleinst) [globals](#syntax-externaddr)([externaddr](#syntax-externaddr)∗),[funcs](#syntax-moduleinst) [funcs](#syntax-externaddr)([externaddr](#syntax-externaddr)∗) (∣s.[funcs](#syntax-store)∣+if​)if​<∣[func](#syntax-func)∗∣}​∧ z\=s;{[module](#syntax-frame) [moduleinst](#syntax-moduleinst)0​}∧ (z′,[val](#syntax-val)g∗​)\=[evalglobal](#eval-globals)∗(z,[globaltype](#syntax-globaltype)∗,[expr](#syntax-expr)g∗​)∧ (z′;[expr](#syntax-expr)t​[↪∗](#exec-notation)z′;[ref](#syntax-ref)t​)∗∧ (z′;[expr](#syntax-expr)e​[↪∗](#exec-notation)z′;[ref](#syntax-ref)e​)∗∗∧ (s′,[moduleinst](#syntax-moduleinst))\=[allocmodule](#alloc-module)(s,[module](#syntax-module),[externaddr](#syntax-externaddr)∗,[val](#syntax-val)g∗​,[ref](#syntax-ref)t∗​,([ref](#syntax-ref)e∗​)∗)∧ [instr](#syntax-instr)d∗​\=[⨁](#notation-concat)[rundata](#aux-rundata)id​​([data](#syntax-data)∗\[id​\])id​<∣[data](#syntax-data)∗∣∧ [instr](#syntax-instr)e∗​\=[⨁](#notation-concat)[runelem](#aux-runelem)ie​​([elem](#syntax-elem)∗\[ie​\])ie​<∣[elem](#syntax-elem)∗∣∧ [instr](#syntax-instr)s?​\=([call](#syntax-instr-control) x)?​​\=s′;{[module](#syntax-frame) [moduleinst](#syntax-moduleinst)};[instr](#syntax-instr)e∗​ [instr](#syntax-instr)d∗​ [instr](#syntax-instr)s?​​

where:

##### 4.7.2.2. [evalglobal](#eval-globals)∗(z,[globaltype](#syntax-globaltype)∗,[expr](#syntax-expr)′′∗)[](#-hrefeval-globalsmathrmevalglobalast-z-hrefsyntax-globaltypemathitglobaltypeast-hrefsyntax-exprmathitexprast)

1.  If [expr](#syntax-expr)′′∗\=ϵ, then:
    
    1.  Assert: Due to validation, [globaltype](#syntax-globaltype)∗\=ϵ.
        
    2.  Return ϵ.
        
2.  Else:
    
    1.  Let [expr](#syntax-expr) [expr](#syntax-expr)′∗ be [expr](#syntax-expr)′′∗.
        
    2.  Assert: Due to validation, ∣[globaltype](#syntax-globaltype)∗∣≥1.
        
    3.  Let gt gt′∗ be [globaltype](#syntax-globaltype)∗.
        
    4.  Let (s,f) be the destructuring of z.
        
    5.  Let [val](#syntax-val) be the result of [evaluating](#exec-expr) [expr](#syntax-expr) with state z.
        
    6.  Let a be [allocglobal](#alloc-global)(s,gt,[val](#syntax-val)).
        
    7.  Append a to f.[module](#syntax-frame).[globals](#syntax-moduleinst).
        
    8.  Let [val](#syntax-val)′∗ be [evalglobal](#eval-globals)∗((s,f),gt′∗,[expr](#syntax-expr)′∗).
        
    9.  Return [val](#syntax-val) [val](#syntax-val)′∗.
        

[evalglobal](#eval-globals)∗(z,ϵ,ϵ)[evalglobal](#eval-globals)∗(z,gt gt′∗,[expr](#syntax-expr) [expr](#syntax-expr)′∗)​\=\=​(z,ϵ)(z′,[val](#syntax-val) [val](#syntax-val)′∗)if z;[expr](#syntax-expr)[↪∗](#exec-notation)z;[val](#syntax-val)∧ z\=s;f∧ (s′,a)\=[allocglobal](#alloc-global)(s,gt,[val](#syntax-val))∧ (z′,[val](#syntax-val)′∗)\=[evalglobal](#eval-globals)∗((s′;f\[.[module](#syntax-frame).[globals](#syntax-moduleinst)\=⊕a\]),gt′∗,[expr](#syntax-expr)′∗)​​​

##### 4.7.2.3. [rundata](#aux-rundata)x​([data](#syntax-data) bn [datamode](#syntax-datamode))[](#-hrefaux-rundatamathrmrundata_x-hrefsyntax-datamathsfdatabnhrefsyntax-datamodemathitdatamode)

1.  If [datamode](#syntax-datamode)\=[passive](#syntax-datamode), then:
    
    1.  Return ϵ.
        
2.  Assert: Due to validation, [datamode](#syntax-datamode) is some [active](#syntax-datamode) [memidx](#syntax-memidx) [expr](#syntax-expr).
    
3.  Let ([active](#syntax-datamode) y [instr](#syntax-instr)∗) be the destructuring of [datamode](#syntax-datamode).
    
4.  Return [instr](#syntax-instr)∗ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([memory.init](#syntax-instr-memory) y x) ([data.drop](#syntax-instr-memory) x).
    

##### 4.7.2.4. [runelem](#aux-runelem)x​([elem](#syntax-elem) rt en [elemmode](#syntax-elemmode))[](#-hrefaux-runelemmathrmrunelem_x-hrefsyntax-elemmathsfelemmathitrtenhrefsyntax-elemmodemathitelemmode)

1.  If [elemmode](#syntax-elemmode)\=[passive](#syntax-elemmode), then:
    
    1.  Return ϵ.
        
2.  If [elemmode](#syntax-elemmode)\=[declare](#syntax-elemmode), then:
    
    1.  Return ([elem.drop](#syntax-instr-table) x).
        
3.  Assert: Due to validation, [elemmode](#syntax-elemmode) is some [active](#syntax-elemmode) [tableidx](#syntax-tableidx) [expr](#syntax-expr).
    
4.  Let ([active](#syntax-elemmode) y [instr](#syntax-instr)∗) be the destructuring of [elemmode](#syntax-elemmode).
    
5.  Return [instr](#syntax-instr)∗ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([table.init](#syntax-instr-table) y x) ([elem.drop](#syntax-instr-table) x).
    

[rundata](#aux-rundata)x​([data](#syntax-data) bn ([passive](#syntax-datamode)))[rundata](#aux-rundata)x​([data](#syntax-data) bn ([active](#syntax-datamode) y [instr](#syntax-instr)∗))[instr](#syntax-instr)∗ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([memory.init](#syntax-instr-memory) y x) ([data.drop](#syntax-instr-memory) x)​0.8ex\][runelem](#aux-runelem)x​([elem](#syntax-elem) rt en ([passive](#syntax-elemmode)))[runelem](#aux-runelem)x​([elem](#syntax-elem) rt en ([declare](#syntax-elemmode)))[runelem](#aux-runelem)x​([elem](#syntax-elem) rt en ([active](#syntax-elemmode) y [instr](#syntax-instr)∗))[instr](#syntax-instr)∗ ([i32](#syntax-numtype).[const](#syntax-instr-numeric) 0) ([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) ([table.init](#syntax-instr-table) y x) ([elem.drop](#syntax-instr-table) x)​​\=\=\=\=\=​ϵϵ([elem.drop](#syntax-instr-table) x)​​​

Note

Checking import types assumes that the [module instance](#syntax-moduleinst) has already been [allocated](#alloc-module) to compute the respective [closed](#type-closed) [defined types](#syntax-deftype). However, this forward reference merely is a way to simplify the specification. In practice, implementations will likely allocate or canonicalize types beforehand, when _compiling_ a module, in a stage before instantiation and before imports are checked.

Similarly, module [allocation](#alloc-module) and the [evaluation](#exec-expr) of [global](#syntax-global) and [table](#syntax-table) initializers as well as [element segments](#syntax-elem) are mutually recursive because the global initialization [values](#syntax-val) [val](#syntax-val)g∗​, [ref](#syntax-ref)t​, and element segment contents [ref](#syntax-ref)e∗​∗ are passed to the module allocator while depending on the module instance [moduleinst](#syntax-moduleinst) and store s′ returned by allocation. Again, this recursion is just a specification device. In practice, the initialization values can [be determined](#exec-initvals) beforehand by staging module allocation such that first, the module’s own [function instances](#syntax-funcinst) are pre-allocated in the store, then the initializer expressions are evaluated in order, allocating globals on the way, then the rest of the module instance is allocated, and finally the new function instances’ module fields are set to that module instance. This is possible because [validation](#valid-module) ensures that initialization expressions cannot actually call a function, only take their reference.

All failure conditions are checked before any observable mutation of the store takes place. Store mutation is not atomic; it happens in individual steps that may be interleaved with other threads.

[Evaluation](#exec-expr) of [constant expressions](#valid-constant) does not affect the store.

#### 4.7.3. Invocation[](#invocation②)

Once a [module](#syntax-module) has been [instantiated](#exec-instantiation), any exported function can be _invoked_ externally via its [function address](#syntax-funcaddr) [funcaddr](#syntax-funcaddr) in the [store](#syntax-store) s and an appropriate list [val](#syntax-val)∗ of argument [values](#syntax-val).

Invocation may _fail_ with an error if the arguments do not fit the [function type](#syntax-functype). Invocation can also result in an [exception](#exception) or [trap](#trap). It is up to the [embedder](#embedder) to define how such conditions are reported.

Note

If the [embedder](#embedder) API performs type checks itself, either statically or dynamically, before performing an invocation, then no failure other than traps or exceptions can occur.

##### 4.7.3.1. [invoke](#exec-invocation)(s,[funcaddr](#syntax-funcaddr),[val](#syntax-val)∗)[](#-hrefexec-invocationmathrminvoke-s-hrefsyntax-funcaddrmathitfuncaddr-hrefsyntax-valmathitvalast)

1.  Assert: Due to validation, the [expansion](#aux-expand-deftype) of s.[funcs](#syntax-store)\[[funcaddr](#syntax-funcaddr)\].[type](#syntax-funcinst) is some [func](#syntax-comptype) [resulttype](#syntax-resulttype)[→](#syntax-comptype)[resulttype](#syntax-resulttype).
    
2.  Let ([func](#syntax-comptype) t1∗​ [→](#syntax-comptype) t2∗​) be the destructuring of the [expansion](#aux-expand-deftype) of s.[funcs](#syntax-store)\[[funcaddr](#syntax-funcaddr)\].[type](#syntax-funcinst).
    
3.  If ∣t1∗​∣\=∣[val](#syntax-val)∗∣, then:
    
    1.  Fail.
        
4.  For all t1​ in t1∗​, and corresponding [val](#syntax-val) in [val](#syntax-val)∗:
    
    1.  If [val](#syntax-val) is not [valid](#valid-val) with type t1​, then:
        
        1.  Fail.
            
5.  Let k be the length of t2∗​.
    
6.  Let F be the frame {[module](#syntax-frame) {}} whose arity is k.
    
7.  Push the frame F.
    
8.  Push the values [val](#syntax-val)∗ to the stack.
    
9.  Push the value ([ref.func](#syntax-ref) [funcaddr](#syntax-funcaddr)) to the stack.
    
10.  Execute the instruction ([call\_ref](#syntax-instr-control) s.[funcs](#syntax-store)\[[funcaddr](#syntax-funcaddr)\].[type](#syntax-funcinst)).
    
11.  Pop the values [val](#syntax-val)′k from the stack.
    
12.  Pop the frame from the stack.
    
13.  Return [val](#syntax-val)′k.
    

[invoke](#exec-invocation)(s,[funcaddr](#syntax-funcaddr),[val](#syntax-val)∗)​\=​s;{[module](#syntax-frame) {}};[val](#syntax-val)∗ ([ref.func](#syntax-ref) [funcaddr](#syntax-funcaddr)) ([call\_ref](#syntax-instr-control) s.[funcs](#syntax-store)\[[funcaddr](#syntax-funcaddr)\].[type](#syntax-funcinst))if s.[funcs](#syntax-store)\[[funcaddr](#syntax-funcaddr)\].[type](#syntax-funcinst)[≈](#aux-expand-deftype)[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​∧ (s[⊢](#valid-val)[val](#syntax-val):t1​)∗​​​

5\. Binary Format[](#binary-format①)
------------------------------------

### 5.1. Conventions[](#conventions③①)

The binary format for WebAssembly [modules](#module) is a dense linear _encoding_ of their [abstract syntax](#syntax-module). [\[1\]](#compression)

The format is defined by an _attribute grammar_ whose only terminal symbols are [bytes](#syntax-byte). A byte sequence is a well-formed encoding of a module if and only if it is generated by the grammar.

Each production of this grammar has exactly one synthesized attribute: the abstract syntax that the respective byte sequence encodes. Thus, the attribute grammar implicitly defines a _decoding_ function (i.e., a parsing function for the binary format).

Except for a few exceptions, the binary grammar closely mirrors the grammar of the abstract syntax.

Note

Some phrases of abstract syntax have multiple possible encodings in the binary format. For example, numbers may be encoded as if they had optional leading zeros. Implementations of decoders must support all possible alternatives; implementations of encoders can pick any allowed encoding.

The recommended extension for files containing WebAssembly modules in binary format is “.wasm” and the recommended [Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml) is “application/wasm”.

\[[1](#id1)\]

Additional encoding layers – for example, introducing compression – may be defined on top of the basic representation defined here. However, such layers are outside the scope of the current specification.

#### 5.1.1. Grammar[](#grammar②)

The following conventions are adopted in defining grammar rules for the binary format. They mirror the conventions used for [abstract syntax](#grammar). In order to distinguish symbols of the binary syntax from symbols of the abstract syntax, typewriter font is adopted for the former.

*   Terminal symbols are [bytes](#syntax-byte) expressed in hexadecimal notation: 0x0F.
    
*   Nonterminal symbols are written in typewriter font: [valtype](#binary-valtype), [instr](#binary-instr).
    
*   Bn is a sequence of n≥0 iterations of B.
    
*   B∗ is a possibly empty sequence of iterations of B. (This is a shorthand for Bn used where n is not relevant.)
    
*   B? is an optional occurrence of B. (This is a shorthand for Bn where n≤1.)
    
*   x:B denotes the same language as the nonterminal B, but also binds the variable x to the attribute synthesized for B. A pattern may also be used instead of a variable, e.g., 7:B.
    
*   Productions are written ​sym​::=​B1​ ⇒ A1​ ∣ … ∣ Bn​ ⇒ An​​, where each Ai​ is the attribute that is synthesized for sym in the given case, usually from attribute variables bound in Bi​.
    
*   Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, ​sym​::=​B1​​, and starting continuations with ellipses, ​sym​::=​… ∣ B2​​.
    
*   Some productions are augmented by side conditions in parentheses, which restrict the applicability of the production. They provide a shorthand for a combinatorial expansion of the production into many separate cases.
    
*   If the same meta variable or non-terminal symbol appears multiple times in a production (in the syntax or in an attribute), then all those occurrences must have the same instantiation. (This is a shorthand for a side condition requiring multiple different variables to be equal.)
    

Note

For example, the [binary grammar](#binary-numtype) for [number types](#syntax-numtype) is given as follows:

​[numtype](#binary-numtype)​::=∣∣∣​0x7C0x7D0x7E0x7F​⇒⇒⇒⇒​[f64](#syntax-numtype)[f32](#syntax-numtype)[i64](#syntax-numtype)[i32](#syntax-numtype)​​

Consequently, the byte 0x7F encodes the type [i32](#syntax-numtype), 0x7E encodes the type [i64](#syntax-numtype), and so forth. No other byte value is allowed as the encoding of a number type.

The [binary grammar](#binary-limits) for [limits](#syntax-limits) is defined as follows:

​[limits](#binary-limits)​::=∣∣∣​0x00 n:[u64](#binary-int)0x01 n:[u64](#binary-int) m:[u64](#binary-int)0x04 n:[u64](#binary-int)0x05 n:[u64](#binary-int) m:[u64](#binary-int)​⇒⇒⇒⇒​([i32](#syntax-numtype),\[n[..](#syntax-limits)ϵ\])([i32](#syntax-numtype),\[n[..](#syntax-limits)m\])([i64](#syntax-numtype),\[n[..](#syntax-limits)ϵ\])([i64](#syntax-numtype),\[n[..](#syntax-limits)m\])​​

That is, a limits pair is encoded as either the byte 0x00 followed by the encoding of a [u64](#syntax-int) value, or the byte 0x01 followed by two such encodings. The variables n and m name the attributes of the respective [u64](#binary-int) nonterminals, which in this case are the actual [unsigned integers](#syntax-uint) those decode into. The attribute of the complete production then is the abstract syntax for the limit, expressed in terms of the former values.

#### 5.1.2. Auxiliary Notation[](#auxiliary-notation③)

When dealing with binary encodings the following notation is also used:

*   ϵ denotes the empty byte sequence.
    
*   ∣∣B∣∣ is the length of the byte sequence generated from the production B in a derivation.
    

#### 5.1.3. Lists[](#lists③)

[Lists](#syntax-list) are encoded with their [u32](#binary-int) length followed by the encoding of their element sequence.

​[list](#binary-list)(X)​::=​n:[u32](#binary-int) (el:X)n​⇒​eln​​

### 5.2. Values[](#values⑧)

#### 5.2.1. Bytes[](#bytes③)

[Bytes](#syntax-byte) encode themselves.

​[byte](#binary-byte)​::=​0x00 ∣ … ∣ 0xFF​​

#### 5.2.2. Integers[](#integers⑤)

All [integers](#syntax-int) are encoded using the [LEB128](https://en.wikipedia.org/wiki/LEB128) variable-length integer encoding, in either unsigned or signed variant.

[Unsigned integers](#syntax-uint) are encoded in [unsigned LEB128](https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128) format. As an additional constraint, the total number of bytes encoding a [u](#syntax-int)N value must not exceed ceil(N/7) bytes.

​[u](#binary-int)N​::=∣​n:[byte](#binary-byte)n:[byte](#binary-byte) m:[u](#binary-int)(N−7)​⇒⇒​n27⋅m+(n−27)​if n<27∧n<2Nif n≥27∧N\>7​​

[Signed integers](#syntax-sint) are encoded in [signed LEB128](https://en.wikipedia.org/wiki/LEB128#Signed_LEB128) format, which uses a two’s complement representation. As an additional constraint, the total number of bytes encoding an [s](#syntax-int)N value must not exceed ceil(N/7) bytes.

​[s](#binary-int)N​::=∣∣​n:[byte](#binary-byte)n:[byte](#binary-byte)n:[byte](#binary-byte) i:[s](#binary-int)(N−7)​⇒⇒⇒​nn−2727⋅i+(n−27)​if n<26∧n<2N−1if 26≤n<27∧n≥27−2N−1if n≥27∧N\>7​​

[Uninterpreted integers](#syntax-int) are encoded as signed integers.

​[i](#binary-int)N​::=​i:[s](#binary-int)N​⇒​[signed](#aux-signed)N−1​(i)​​

Note

The side conditions N\>7 in the productions for non-terminal bytes of the [u](#syntax-int)N and [s](#syntax-int)N encodings restrict the encoding’s length. However, “trailing zeros” are still allowed within these bounds. For example, 0x03 and 0x83 0x00 are both well-formed encodings for the value 3 as a [u8](#syntax-int). Similarly, either of 0x7E and 0xFE 0x7F and 0xFE 0xFF 0x7F are well-formed encodings of the value −2 as an s16.

The side conditions on the value n of terminal bytes further enforce that any unused bits in these bytes must be 0 for positive values and 1 for negative ones. For example, 0x83 0x10 is malformed as a [u8](#syntax-int) encoding. Similarly, both 0x83 0x3E and 0xFF 0x7B are malformed as s8 encodings.

#### 5.2.3. Floating-Point[](#floating-point⑤)

[Floating-point](#syntax-float) values are encoded directly by their [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") (Section 3.4) bit pattern in [little endian](https://en.wikipedia.org/wiki/Endianness#Little-endian) byte order:

​[f](#binary-float)N​::=​b∗:[byte](#binary-byte)N/8​⇒​[bytes](#aux-bytes)[f](#syntax-numtype)N−1​(b∗)​​

#### 5.2.4. Names[](#names③)

[Names](#syntax-name) are encoded as a [list](#binary-list) of bytes containing the [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 3.9) UTF-8 encoding of the name’s character sequence.

​[name](#binary-name)​::=​b∗:[list](#binary-list)([byte](#binary-byte))​⇒​[name](#syntax-name)​if [utf8](#binary-utf8)([name](#syntax-name))\=b∗​​

The auxiliary [utf8](#binary-utf8) function expressing this encoding is defined as follows:

[utf8](#binary-utf8)(ch∗)[utf8](#binary-utf8)(ch)[utf8](#binary-utf8)(ch)[utf8](#binary-utf8)(ch)[utf8](#binary-utf8)(ch)​\=\=\=\=\=​[⨁](#notation-concat)[utf8](#binary-utf8)(ch)∗bb1​ b2​b1​ b2​ b3​b1​ b2​ b3​ b4​​if ch<U+80∧ ch\=b​if U+80≤ch<U+0800∧ ch\=26⋅(b1​−0xC0)+cont(b2​)​if U+0800≤ch<U+D800∨U+E000≤ch<U+10000∧ ch\=212⋅(b1​−0xE0)+26⋅cont(b2​)+cont(b3​)​if U+10000≤ch<U+11000∧ ch\=218⋅(b1​−0xF0)+212⋅cont(b2​)+26⋅cont(b3​)+cont(b4​)​​​

where cont(b)​\=​b−0x80​if (0x80<b<0xC0)​

Note

Unlike in some other formats, name strings are not 0-terminated.

### 5.3. Types[](#types①③)

Note

In some places, possible types include both type constructors or types denoted by [type indices](#syntax-typeidx). Thus, the binary format for type constructors corresponds to the encodings of small negative [s](#syntax-int)N values, such that they can unambiguously occur in the same place as (positive) type indices.

#### 5.3.1. Number Types[](#number-types⑦)

[Number types](#syntax-numtype) are encoded by a single byte.

​[numtype](#binary-numtype)​::=∣∣∣​0x7C0x7D0x7E0x7F​⇒⇒⇒⇒​[f64](#syntax-numtype)[f32](#syntax-numtype)[i64](#syntax-numtype)[i32](#syntax-numtype)​​

#### 5.3.2. Vector Types[](#vector-types⑦)

[Vector types](#syntax-vectype) are also encoded by a single byte.

​[vectype](#binary-vectype)​::=​0x7B​⇒​[v128](#syntax-vectype)​​

#### 5.3.3. Heap Types[](#heap-types⑦)

[Heap types](#syntax-reftype) are encoded as either a single byte, or as a [type index](#binary-typeidx) encoded as a positive [signed integer](#binary-sint).

​[absheaptype](#binary-absheaptype)​::=∣∣∣∣∣∣∣∣∣∣∣∣​0x690x6A0x6B0x6C0x6D0x6E0x6F0x700x710x720x730x74x:[s33](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[exn](#syntax-heaptype)[array](#syntax-heaptype)[struct](#syntax-heaptype)[i31](#syntax-heaptype)[eq](#syntax-heaptype)[any](#syntax-heaptype)[extern](#syntax-heaptype)[func](#syntax-heaptype)[none](#syntax-heaptype)[noextern](#syntax-heaptype)[nofunc](#syntax-heaptype)[noexn](#syntax-heaptype)0.8ex\]x​[heaptype](#binary-heaptype)if x≥0​::=​ht:[absheaptype](#binary-absheaptype)​⇒​ht​​

Note

The heap type [bot](#syntax-valtype-ext) cannot occur in a module.

#### 5.3.4. Reference Types[](#reference-types⑦)

[Reference types](#syntax-reftype) are either encoded by a single byte followed by a [heap type](#binary-heaptype), or, as a short form, directly as an [abstract heap type](#binary-absheaptype).

​[reftype](#binary-reftype)​::=∣∣​0x63 ht:[heaptype](#binary-heaptype)0x64 ht:[heaptype](#binary-heaptype)ht:[absheaptype](#binary-absheaptype)​⇒⇒⇒​[ref](#syntax-reftype) [null](#syntax-reftype) ht[ref](#syntax-reftype) ht[ref](#syntax-reftype) [null](#syntax-reftype) ht​​

#### 5.3.5. Value Types[](#value-types⑦)

[Value types](#syntax-valtype) are encoded with their respective encoding as a [number type](#binary-numtype), [vector type](#binary-vectype), or [reference type](#binary-reftype).

​[valtype](#binary-valtype)​::=∣∣​nt:[numtype](#binary-numtype)vt:[vectype](#binary-vectype)rt:[reftype](#binary-reftype)​⇒⇒⇒​ntvtrt​​

Note

The value type [bot](#syntax-valtype-ext) cannot occur in a module.

Value types can occur in contexts where [type indices](#syntax-typeidx) are also allowed, such as in the case of [block types](#binary-blocktype). Thus, the binary format for types corresponds to the [signed LEB128](https://en.wikipedia.org/wiki/LEB128#Signed_LEB128) [encoding](#binary-sint) of small negative [s](#syntax-int)N values, so that they can coexist with (positive) type indices in the future.

#### 5.3.6. Result Types[](#result-types⑦)

[Result types](#syntax-resulttype) are encoded by the respective [lists](#binary-list) of [value types](#binary-valtype).

​[resulttype](#binary-resulttype)​::=​t∗:[list](#binary-list)([valtype](#binary-valtype))​⇒​t∗​​

#### 5.3.7. Composite Types[](#composite-types⑦)

[Composite types](#syntax-comptype) are encoded by a distinct byte followed by a type encoding of the respective form.

​[mut](#binary-mut)​::=∣∣∣∣∣​0x000x010x5F ft∗:[list](#binary-list)([fieldtype](#binary-fieldtype))0x60 t1∗​:[resulttype](#binary-resulttype) t2∗​:[resulttype](#binary-resulttype)pt:[packtype](#binary-packtype)0x78​⇒⇒⇒⇒⇒⇒​ϵ[mut](#syntax-mut)0.8ex\][struct](#syntax-comptype) ft∗[func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​0.8ex\]pt0.8ex\][i8](#syntax-storagetype)​[comptype](#binary-comptype)[fieldtype](#binary-fieldtype)[packtype](#binary-packtype)​::=::=::=​0x5E ft:[fieldtype](#binary-fieldtype)zt:[storagetype](#binary-storagetype) [mut](#syntax-mut)?:[mut](#binary-mut)0x77​⇒⇒⇒​[array](#syntax-comptype) ft[mut](#syntax-mut)? zt0.8ex\][i16](#syntax-storagetype)​[storagetype](#binary-storagetype)​::=​t:[valtype](#binary-valtype)​⇒​t​​

#### 5.3.8. Recursive Types[](#recursive-types⑤)

[Recursive types](#syntax-rectype) are encoded by the byte 0x4E followed by a [list](#binary-list) of [sub types](#syntax-subtype). Additional shorthands are recognized for unary recursions and sub types without super types.

​[rectype](#binary-rectype)​::=∣∣∣​0x4E st∗:[list](#binary-list)([subtype](#binary-subtype))st:[subtype](#binary-subtype)0x50 x∗:[list](#binary-list)([typeidx](#binary-typeidx)) ct:[comptype](#binary-comptype)ct:[comptype](#binary-comptype)​⇒⇒⇒⇒​[rec](#syntax-rectype) st∗[rec](#syntax-rectype) st0.8ex\][sub](#syntax-subtype) x∗ ct[sub](#syntax-subtype) [final](#syntax-subtype) ϵ ct​[subtype](#binary-subtype)::=0x4F x∗:[list](#binary-list)([typeidx](#binary-typeidx)) ct:[comptype](#binary-comptype)⇒[sub](#syntax-subtype) [final](#syntax-subtype) x∗ ct​

#### 5.3.9. Limits[](#limits⑦)

[Limits](#syntax-limits) are encoded with a preceding flag indicating whether a maximum is present, and a flag for the [address type](#syntax-addrtype).

​[limits](#binary-limits)​::=∣∣∣​0x00 n:[u64](#binary-int)0x01 n:[u64](#binary-int) m:[u64](#binary-int)0x04 n:[u64](#binary-int)0x05 n:[u64](#binary-int) m:[u64](#binary-int)​⇒⇒⇒⇒​([i32](#syntax-numtype),\[n[..](#syntax-limits)ϵ\])([i32](#syntax-numtype),\[n[..](#syntax-limits)m\])([i64](#syntax-numtype),\[n[..](#syntax-limits)ϵ\])([i64](#syntax-numtype),\[n[..](#syntax-limits)m\])​​

#### 5.3.10. Tag Types[](#tag-types⑦)

[Tag types](#syntax-tagtype) are encoded by a [type index](#syntax-typeidx) denoting a [function type](#syntax-functype).

​[tagtype](#binary-tagtype)​::=​0x00 x:[typeidx](#binary-typeidx)​⇒​x​​

Note

In future versions of WebAssembly, the preceding zero byte may encode additional attributes.

#### 5.3.11. Global Types[](#global-types⑦)

[Global types](#syntax-globaltype) are encoded by their [value type](#binary-valtype) and a flag for their [mutability](#syntax-mut).

​[globaltype](#binary-globaltype)​::=​t:[valtype](#binary-valtype) [mut](#syntax-mut)?:[mut](#binary-mut)​⇒​[mut](#syntax-mut)? t​​

#### 5.3.12. Memory Types[](#memory-types⑦)

[Memory types](#syntax-memtype) are encoded with their [limits](#binary-limits).

​[memtype](#binary-memtype)​::=​(at,lim):[limits](#binary-limits)​⇒​at lim [page](#syntax-memtype)​​

#### 5.3.13. Table Types[](#table-types⑦)

[Table types](#syntax-tabletype) are encoded with their [limits](#binary-limits) and the encoding of their element [reference type](#syntax-reftype).

​[tabletype](#binary-tabletype)​::=​rt:[reftype](#binary-reftype) (at,lim):[limits](#binary-limits)​⇒​at lim rt​​

#### 5.3.14. External Types[](#external-types⑦)

[External types](#syntax-externtype) are encoded by a distiguishing byte followed by an encoding of the respective form of type.

​[externtype](#binary-externtype)​::=∣∣∣∣​0x00 x:[typeidx](#binary-typeidx)0x01 tt:[tabletype](#binary-tabletype)0x02 mt:[memtype](#binary-memtype)0x03 gt:[globaltype](#binary-globaltype)0x04 jt:[tagtype](#binary-tagtype)​⇒⇒⇒⇒⇒​[func](#syntax-externtype) x[table](#syntax-externtype) tt[mem](#syntax-externtype) mt[global](#syntax-externtype) gt[tag](#syntax-externtype) jt​​

### 5.4. Instructions[](#instructions⑦)

[Instructions](#syntax-instr) are encoded by _opcodes_. Each opcode is represented by a single byte, and is followed by the instruction’s immediate arguments, where present. The only exception are [structured control instructions](#binary-instr-control), which consist of several opcodes bracketing their nested instruction sequences.

Note

The byte codes chosen to encode instructions are historical and do not follow a consistent pattern. In this section, instructions are hence not presented in opcode order, but instead grouped consistently with other sections in this document. An instruction index ordered by opcode can be found in the [Appendix](#index-instr).

Gaps in the byte code ranges are reserved for future extensions.

#### 5.4.1. Parametric Instructions[](#parametric-instructions⑦)

[Parametric instructions](#syntax-instr-parametric) are represented by single byte codes, possibly followed by a type annotation.

​[instr](#binary-instr)​::=∣∣∣∣​0x000x010x1A0x1B0x1C t∗:[list](#binary-list)([valtype](#binary-valtype))​⇒⇒⇒⇒⇒​[unreachable](#syntax-instr-control)[nop](#syntax-instr-control)[drop](#syntax-instr-parametric)[select](#syntax-instr-parametric)[select](#syntax-instr-parametric) t∗​​

#### 5.4.2. Control Instructions[](#control-instructions⑦)

[Control instructions](#syntax-instr-control) have varying encodings. For structured instructions, the instruction sequences forming nested blocks are delimited with explicit opcodes for end and else.

[Block types](#syntax-blocktype) are encoded in special compressed form, by either the byte 0x40 indicating the empty type, as a single [value type](#binary-valtype), or as a [type index](#binary-typeidx) encoded as a positive [signed integer](#binary-sint).

​[blocktype](#binary-blocktype)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​0x40t:[valtype](#binary-valtype)i:[s33](#binary-int)0x02 bt:[blocktype](#binary-blocktype) (in:[instr](#binary-instr))∗ 0x0B0x03 bt:[blocktype](#binary-blocktype) (in:[instr](#binary-instr))∗ 0x0B0x04 bt:[blocktype](#binary-blocktype) (in:[instr](#binary-instr))∗ 0x0B0x04 bt:[blocktype](#binary-blocktype) (in1​:[instr](#binary-instr))∗0x05 (in2​:[instr](#binary-instr))∗ 0x0B​0x08 x:[tagidx](#binary-tagidx)0x0A0x0C l:[labelidx](#binary-labelidx)0x0D l:[labelidx](#binary-labelidx)0x0E l∗:[list](#binary-list)([labelidx](#binary-labelidx)) ln​:[labelidx](#binary-labelidx)0x0F0x10 x:[funcidx](#binary-funcidx)0x11 y:[typeidx](#binary-typeidx) x:[tableidx](#binary-tableidx)0x12 x:[funcidx](#binary-funcidx)0x13 y:[typeidx](#binary-typeidx) x:[tableidx](#binary-tableidx)0x14 x:[typeidx](#binary-typeidx)0x15 x:[typeidx](#binary-typeidx)0x1F bt:[blocktype](#binary-blocktype) c∗:[list](#binary-list)([catch](#binary-catch)) (in:[instr](#binary-instr))∗ 0x0B0xD5 l:[labelidx](#binary-labelidx)0xD6 l:[labelidx](#binary-labelidx)0xFB 24:[u32](#binary-int) ([null](#syntax-reftype)1?​,[null](#syntax-reftype)2?​):[castop](#binary-castop)l:[labelidx](#binary-labelidx) ht1​:[heaptype](#binary-heaptype) ht2​:[heaptype](#binary-heaptype)​0xFB 25:[u32](#binary-int) ([null](#syntax-reftype)1?​,[null](#syntax-reftype)2?​):[castop](#binary-castop)l:[labelidx](#binary-labelidx) ht1​:[heaptype](#binary-heaptype) ht2​:[heaptype](#binary-heaptype)​0x01 x:[tagidx](#binary-tagidx) l:[labelidx](#binary-labelidx)0x02 l:[labelidx](#binary-labelidx)0x03 l:[labelidx](#binary-labelidx)0x010x020x03​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​ϵti[block](#syntax-instr-control) bt in∗[loop](#syntax-instr-control) bt in∗[if](#syntax-instr-control) bt in∗ [else](#syntax-instr-control) ϵ[if](#syntax-instr-control) bt in1∗​ [else](#syntax-instr-control) in2∗​[throw](#syntax-instr-control) x[throw\_ref](#syntax-instr-control)[br](#syntax-instr-control) l[br\_if](#syntax-instr-control) l[br\_table](#syntax-instr-control) l∗ ln​[return](#syntax-instr-control)[call](#syntax-instr-control) x[call\_indirect](#syntax-instr-control) x y[return\_call](#syntax-instr-control) x[return\_call\_indirect](#syntax-instr-control) x y[call\_ref](#syntax-instr-control) x[return\_call\_ref](#syntax-instr-control) x[try\_table](#syntax-instr-control) bt c∗ in∗[br\_on\_null](#syntax-instr-control) l[br\_on\_non\_null](#syntax-instr-control) l[br\_on\_cast](#syntax-instr-control) l ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​) ([ref](#syntax-reftype) [null](#syntax-reftype)2?​ ht2​)[br\_on\_cast\_fail](#syntax-instr-control) l ([ref](#syntax-reftype) [null](#syntax-reftype)1?​ ht1​) ([ref](#syntax-reftype) [null](#syntax-reftype)2?​ ht2​)0.8ex\][catch\_ref](#syntax-instr-control) x l[catch\_all](#syntax-instr-control) l[catch\_all\_ref](#syntax-instr-control) l0.8ex\]([null](#syntax-reftype),ϵ)(ϵ,[null](#syntax-reftype))([null](#syntax-reftype),[null](#syntax-reftype))​if i≥00.8ex\][catch](#binary-catch)[castop](#binary-castop)​[instr](#binary-instr)::=::=​::=0x00 x:[tagidx](#binary-tagidx) l:[labelidx](#binary-labelidx)0x00​…⇒⇒​[catch](#syntax-instr-control) x l(ϵ,ϵ)​​

Note

The else opcode 0x05 in the encoding of an if instruction can be omitted if the following instruction sequence is empty.

Unlike any [other occurrence](#binary-typeidx), the [type index](#syntax-typeidx) in a [block type](#syntax-blocktype) is encoded as a positive [signed integer](#syntax-sint), so that its signed LEB128 bit pattern cannot collide with the encoding of [value types](#binary-valtype) or the special code 0x40, which correspond to the LEB128 encoding of negative integers. To avoid any loss in the range of allowed indices, it is treated as a 33 bit signed integer.

#### 5.4.3. Variable Instructions[](#variable-instructions⑦)

[Variable instructions](#syntax-instr-variable) are represented by byte codes followed by the encoding of the respective [index](#syntax-index).

​[instr](#binary-instr)​::=∣∣∣∣∣​…0x20 x:[localidx](#binary-localidx)0x21 x:[localidx](#binary-localidx)0x22 x:[localidx](#binary-localidx)0x23 x:[globalidx](#binary-globalidx)0x24 x:[globalidx](#binary-globalidx)​⇒⇒⇒⇒⇒​[local.get](#syntax-instr-variable) x[local.set](#syntax-instr-variable) x[local.tee](#syntax-instr-variable) x[global.get](#syntax-instr-variable) x[global.set](#syntax-instr-variable) x​​

#### 5.4.4. Table Instructions[](#table-instructions⑦)

[Table instructions](#syntax-instr-table) are represented either by a single byte or a one byte prefix followed by a variable-length [unsigned integer](#binary-uint).

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣​…0x25 x:[tableidx](#binary-tableidx)0x26 x:[tableidx](#binary-tableidx)0xFC 12:[u32](#binary-int) y:[elemidx](#binary-elemidx) x:[tableidx](#binary-tableidx)0xFC 13:[u32](#binary-int) x:[elemidx](#binary-elemidx)0xFC 14:[u32](#binary-int) x1​:[tableidx](#binary-tableidx) x2​:[tableidx](#binary-tableidx)0xFC 15:[u32](#binary-int) x:[tableidx](#binary-tableidx)0xFC 16:[u32](#binary-int) x:[tableidx](#binary-tableidx)0xFC 17:[u32](#binary-int) x:[tableidx](#binary-tableidx)​⇒⇒⇒⇒⇒⇒⇒⇒​[table.get](#syntax-instr-table) x[table.set](#syntax-instr-table) x[table.init](#syntax-instr-table) x y[elem.drop](#syntax-instr-table) x[table.copy](#syntax-instr-table) x1​ x2​[table.grow](#syntax-instr-table) x[table.size](#syntax-instr-table) x[table.fill](#syntax-instr-table) x​​

#### 5.4.5. Memory Instructions[](#memory-instructions⑦)

Each variant of [memory instruction](#syntax-instr-memory) is encoded with a different byte code. Loads and stores are followed by the encoding of their [memarg](#syntax-memarg) immediate, which includes the [memory index](#binary-memidx) if bit 6 of the flags field containing alignment is set; the memory index defaults to 0 otherwise.

​[memarg](#binary-memarg)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​n:[u32](#binary-int) m:[u64](#binary-int)n:[u32](#binary-int) x:[memidx](#binary-memidx) m:[u64](#binary-int)0x28 (x,ao):[memarg](#binary-memarg)0x29 (x,ao):[memarg](#binary-memarg)0x2A (x,ao):[memarg](#binary-memarg)0x2B (x,ao):[memarg](#binary-memarg)0x2C (x,ao):[memarg](#binary-memarg)0x2D (x,ao):[memarg](#binary-memarg)0x2E (x,ao):[memarg](#binary-memarg)0x2F (x,ao):[memarg](#binary-memarg)0x30 (x,ao):[memarg](#binary-memarg)0x31 (x,ao):[memarg](#binary-memarg)0x32 (x,ao):[memarg](#binary-memarg)0x33 (x,ao):[memarg](#binary-memarg)0x34 (x,ao):[memarg](#binary-memarg)0x35 (x,ao):[memarg](#binary-memarg)0x36 (x,ao):[memarg](#binary-memarg)0x37 (x,ao):[memarg](#binary-memarg)0x38 (x,ao):[memarg](#binary-memarg)0x39 (x,ao):[memarg](#binary-memarg)0x3A (x,ao):[memarg](#binary-memarg)0x3B (x,ao):[memarg](#binary-memarg)0x3C (x,ao):[memarg](#binary-memarg)0x3D (x,ao):[memarg](#binary-memarg)0x3E (x,ao):[memarg](#binary-memarg)0x3F x:[memidx](#binary-memidx)0x40 x:[memidx](#binary-memidx)0xFC 8:[u32](#binary-int) y:[dataidx](#binary-dataidx) x:[memidx](#binary-memidx)0xFC 9:[u32](#binary-int) x:[dataidx](#binary-dataidx)0xFC 10:[u32](#binary-int) x1​:[memidx](#binary-memidx) x2​:[memidx](#binary-memidx)0xFC 11:[u32](#binary-int) x:[memidx](#binary-memidx)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​(0,{[align](#syntax-instr-memory) n,[offset](#syntax-instr-memory) m})(x,{[align](#syntax-instr-memory) (n−26),[offset](#syntax-instr-memory) m})[i32](#syntax-numtype).[load](#syntax-instr-memory) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory) x ao[f32](#syntax-numtype).[load](#syntax-instr-memory) x ao[f64](#syntax-numtype).[load](#syntax-instr-memory) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[s](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)16\_[s](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)16\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)8\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)16\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)16\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)32\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)32\_[u](#syntax-sx) x ao[i32](#syntax-numtype).[store](#syntax-instr-memory) x ao[i64](#syntax-numtype).[store](#syntax-instr-memory) x ao[f32](#syntax-numtype).[store](#syntax-instr-memory) x ao[f64](#syntax-numtype).[store](#syntax-instr-memory) x ao[i32](#syntax-numtype).[store](#syntax-instr-memory)8 x ao[i32](#syntax-numtype).[store](#syntax-instr-memory)16 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)8 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)16 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)32 x ao[memory.size](#syntax-instr-memory) x[memory.grow](#syntax-instr-memory) x[memory.init](#syntax-instr-memory) x y[data.drop](#syntax-instr-memory) x[memory.copy](#syntax-instr-memory) x1​ x2​[memory.fill](#syntax-instr-memory) x​if n<26if 26≤n<270.8ex\][instr](#binary-instr)::=…​

#### 5.4.6. Reference Instructions[](#reference-instructions⑦)

Generic [reference instructions](#syntax-instr-ref) are represented by single byte codes, others use prefixes and type operands.

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣​…0xD0 ht:[heaptype](#binary-heaptype)0xD10xD2 x:[funcidx](#binary-funcidx)0xD30xD40xFB 20:[u32](#binary-int) ht:[heaptype](#binary-heaptype)0xFB 21:[u32](#binary-int) ht:[heaptype](#binary-heaptype)0xFB 22:[u32](#binary-int) ht:[heaptype](#binary-heaptype)0xFB 23:[u32](#binary-int) ht:[heaptype](#binary-heaptype)​⇒⇒⇒⇒⇒⇒⇒⇒⇒​[ref.null](#syntax-instr-ref) ht[ref.is\_null](#syntax-instr-ref)[ref.func](#syntax-instr-ref) x[ref.eq](#syntax-instr-ref)[ref.as\_non\_null](#syntax-instr-ref)[ref.test](#syntax-instr-ref) ([ref](#syntax-reftype) ht)[ref.test](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) ht)[ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) ht)[ref.cast](#syntax-instr-ref) ([ref](#syntax-reftype) [null](#syntax-reftype) ht)​​

#### 5.4.7. Aggregate Instructions[](#aggregate-instructions③)

[Aggregate instructions](#syntax-instr-aggr) all use a prefix.

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFB 0:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 1:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 2:[u32](#binary-int) x:[typeidx](#binary-typeidx) i:[u32](#binary-int)0xFB 3:[u32](#binary-int) x:[typeidx](#binary-typeidx) i:[u32](#binary-int)0xFB 4:[u32](#binary-int) x:[typeidx](#binary-typeidx) i:[u32](#binary-int)0xFB 5:[u32](#binary-int) x:[typeidx](#binary-typeidx) i:[u32](#binary-int)0xFB 6:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 7:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 8:[u32](#binary-int) x:[typeidx](#binary-typeidx) n:[u32](#binary-int)0xFB 9:[u32](#binary-int) x:[typeidx](#binary-typeidx) y:[dataidx](#binary-dataidx)0xFB 10:[u32](#binary-int) x:[typeidx](#binary-typeidx) y:[elemidx](#binary-elemidx)0xFB 11:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 12:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 13:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 14:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 15:[u32](#binary-int)0xFB 16:[u32](#binary-int) x:[typeidx](#binary-typeidx)0xFB 17:[u32](#binary-int) x1​:[typeidx](#binary-typeidx) x2​:[typeidx](#binary-typeidx)0xFB 18:[u32](#binary-int) x:[typeidx](#binary-typeidx) y:[dataidx](#binary-dataidx)0xFB 19:[u32](#binary-int) x:[typeidx](#binary-typeidx) y:[elemidx](#binary-elemidx)0xFB 26:[u32](#binary-int)0xFB 27:[u32](#binary-int)0xFB 28:[u32](#binary-int)0xFB 29:[u32](#binary-int)0xFB 30:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[struct.new](#syntax-instr-struct) x[struct.new\_default](#syntax-instr-struct) x[struct.get](#syntax-instr-struct) x i[struct.get](#syntax-instr-struct)\_[s](#syntax-sx) x i[struct.get](#syntax-instr-struct)\_[u](#syntax-sx) x i[struct.set](#syntax-instr-struct) x i[array.new](#syntax-instr-array) x[array.new\_default](#syntax-instr-array) x[array.new\_fixed](#syntax-instr-array) x n[array.new\_data](#syntax-instr-array) x y[array.new\_elem](#syntax-instr-array) x y[array.get](#syntax-instr-array) x[array.get](#syntax-instr-array)\_[s](#syntax-sx) x[array.get](#syntax-instr-array)\_[u](#syntax-sx) x[array.set](#syntax-instr-array) x[array.len](#syntax-instr-array)[array.fill](#syntax-instr-array) x[array.copy](#syntax-instr-array) x1​ x2​[array.init\_data](#syntax-instr-array) x y[array.init\_elem](#syntax-instr-array) x y[any.convert\_extern](#syntax-instr-extern)[extern.convert\_any](#syntax-instr-extern)[ref.i31](#syntax-instr-i31)[i31.get](#syntax-instr-i31)\_[s](#syntax-sx)[i31.get](#syntax-instr-i31)\_[u](#syntax-sx)​​

#### 5.4.8. Numeric Instructions[](#numeric-instructions⑦)

All variants of [numeric instructions](#syntax-instr-numeric) are represented by separate byte codes.

The const instructions are followed by the respective literal.

​[instr](#binary-instr)​::=∣∣∣∣​…0x41 i:[i32](#binary-int)0x42 i:[i64](#binary-int)0x43 p:[f32](#binary-float)0x44 p:[f64](#binary-float)​⇒⇒⇒⇒​[i32](#syntax-numtype).[const](#syntax-instr-numeric) i[i64](#syntax-numtype).[const](#syntax-instr-numeric) i[f32](#syntax-numtype).[const](#syntax-instr-numeric) p[f64](#syntax-numtype).[const](#syntax-instr-numeric) p​​

All other numeric instructions are plain opcodes without any immediates.

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0x450x460x470x480x490x4A0x4B0x4C0x4D0x4E0x4F0x500x510x520x530x540x550x560x570x580x590x5A​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[eqz](#syntax-instr-numeric)[i32](#syntax-numtype).[eq](#syntax-instr-numeric)[i32](#syntax-numtype).[ne](#syntax-instr-numeric)[i32](#syntax-numtype).[lt](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[lt](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[gt](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[gt](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[le](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[le](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[ge](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[ge](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[eqz](#syntax-instr-numeric)[i64](#syntax-numtype).[eq](#syntax-instr-numeric)[i64](#syntax-numtype).[ne](#syntax-instr-numeric)[i64](#syntax-numtype).[lt](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[lt](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[gt](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[gt](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[le](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[le](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[ge](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[ge](#syntax-instr-numeric)\_[u](#syntax-sx)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣​…0x5B0x5C0x5D0x5E0x5F0x600x610x620x630x640x650x66​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype).[eq](#syntax-instr-numeric)[f32](#syntax-numtype).[ne](#syntax-instr-numeric)[f32](#syntax-numtype).[lt](#syntax-instr-numeric)[f32](#syntax-numtype).[gt](#syntax-instr-numeric)[f32](#syntax-numtype).[le](#syntax-instr-numeric)[f32](#syntax-numtype).[ge](#syntax-instr-numeric)[f64](#syntax-numtype).[eq](#syntax-instr-numeric)[f64](#syntax-numtype).[ne](#syntax-instr-numeric)[f64](#syntax-numtype).[lt](#syntax-instr-numeric)[f64](#syntax-numtype).[gt](#syntax-instr-numeric)[f64](#syntax-numtype).[le](#syntax-instr-numeric)[f64](#syntax-numtype).[ge](#syntax-instr-numeric)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0x670x680x690x6A0x6B0x6C0x6D0x6E0x6F0x700x710x720x730x740x750x760x770x780x790x7A0x7B0x7C0x7D0x7E0x7F0x800x810x820x830x840x850x860x870x880x890x8A​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[clz](#syntax-instr-numeric)[i32](#syntax-numtype).[ctz](#syntax-instr-numeric)[i32](#syntax-numtype).[popcnt](#syntax-instr-numeric)[i32](#syntax-numtype).[add](#syntax-instr-numeric)[i32](#syntax-numtype).[sub](#syntax-instr-numeric)[i32](#syntax-numtype).[mul](#syntax-instr-numeric)[i32](#syntax-numtype).[div](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[div](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[rem](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[rem](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[and](#syntax-instr-numeric)[i32](#syntax-numtype).[or](#syntax-instr-numeric)[i32](#syntax-numtype).[xor](#syntax-instr-numeric)[i32](#syntax-numtype).[shl](#syntax-instr-numeric)[i32](#syntax-numtype).[shr](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[shr](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[rotl](#syntax-instr-numeric)[i32](#syntax-numtype).[rotr](#syntax-instr-numeric)[i64](#syntax-numtype).[clz](#syntax-instr-numeric)[i64](#syntax-numtype).[ctz](#syntax-instr-numeric)[i64](#syntax-numtype).[popcnt](#syntax-instr-numeric)[i64](#syntax-numtype).[add](#syntax-instr-numeric)[i64](#syntax-numtype).[sub](#syntax-instr-numeric)[i64](#syntax-numtype).[mul](#syntax-instr-numeric)[i64](#syntax-numtype).[div](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[div](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[rem](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[rem](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[and](#syntax-instr-numeric)[i64](#syntax-numtype).[or](#syntax-instr-numeric)[i64](#syntax-numtype).[xor](#syntax-instr-numeric)[i64](#syntax-numtype).[shl](#syntax-instr-numeric)[i64](#syntax-numtype).[shr](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[shr](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[rotl](#syntax-instr-numeric)[i64](#syntax-numtype).[rotr](#syntax-instr-numeric)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0x8B0x8C0x8D0x8E0x8F0x900x910x920x930x940x950x960x970x980x990x9A0x9B0x9C0x9D0x9E0x9F0xA00xA10xA20xA30xA40xA50xA6​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype).[abs](#syntax-instr-numeric)[f32](#syntax-numtype).[neg](#syntax-instr-numeric)[f32](#syntax-numtype).[ceil](#syntax-instr-numeric)[f32](#syntax-numtype).[floor](#syntax-instr-numeric)[f32](#syntax-numtype).[trunc](#syntax-instr-numeric)[f32](#syntax-numtype).[nearest](#syntax-instr-numeric)[f32](#syntax-numtype).[sqrt](#syntax-instr-numeric)[f32](#syntax-numtype).[add](#syntax-instr-numeric)[f32](#syntax-numtype).[sub](#syntax-instr-numeric)[f32](#syntax-numtype).[mul](#syntax-instr-numeric)[f32](#syntax-numtype).[div](#syntax-instr-numeric)[f32](#syntax-numtype).[min](#syntax-instr-numeric)[f32](#syntax-numtype).[max](#syntax-instr-numeric)[f32](#syntax-numtype).[copysign](#syntax-instr-numeric)[f64](#syntax-numtype).[abs](#syntax-instr-numeric)[f64](#syntax-numtype).[neg](#syntax-instr-numeric)[f64](#syntax-numtype).[ceil](#syntax-instr-numeric)[f64](#syntax-numtype).[floor](#syntax-instr-numeric)[f64](#syntax-numtype).[trunc](#syntax-instr-numeric)[f64](#syntax-numtype).[nearest](#syntax-instr-numeric)[f64](#syntax-numtype).[sqrt](#syntax-instr-numeric)[f64](#syntax-numtype).[add](#syntax-instr-numeric)[f64](#syntax-numtype).[sub](#syntax-instr-numeric)[f64](#syntax-numtype).[mul](#syntax-instr-numeric)[f64](#syntax-numtype).[div](#syntax-instr-numeric)[f64](#syntax-numtype).[min](#syntax-instr-numeric)[f64](#syntax-numtype).[max](#syntax-instr-numeric)[f64](#syntax-numtype).[copysign](#syntax-instr-numeric)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xA70xA80xA90xAA0xAB0xAC0xAD0xAE0xAF0xB00xB10xB20xB30xB40xB50xB60xB70xB80xB90xBA0xBB0xBC0xBD0xBE0xBF​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[wrap](#syntax-instr-numeric)\_[i64](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i64](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i64](#syntax-numtype)[f32](#syntax-numtype).[demote](#syntax-instr-numeric)\_[f64](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i64](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i64](#syntax-numtype)[f64](#syntax-numtype).[promote](#syntax-instr-numeric)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[f64](#syntax-numtype)[f32](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[i64](#syntax-numtype)​​

​[instr](#binary-instr)​::=∣∣∣∣∣​…0xC00xC10xC20xC30xC4​⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[extend](#syntax-instr-numeric)8\_[s](#syntax-sx)[i32](#syntax-numtype).[extend](#syntax-instr-numeric)16\_[s](#syntax-sx)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)8\_[s](#syntax-sx)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)16\_[s](#syntax-sx)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)32\_[s](#syntax-sx)​​

The saturating truncation instructions all have a one byte prefix, whereas the actual opcode is encoded by a variable-length [unsigned integer](#binary-uint).

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣​…0xFC 0:[u32](#binary-int)0xFC 1:[u32](#binary-int)0xFC 2:[u32](#binary-int)0xFC 3:[u32](#binary-int)0xFC 4:[u32](#binary-int)0xFC 5:[u32](#binary-int)0xFC 6:[u32](#binary-int)0xFC 7:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)​​

#### 5.4.9. Vector Instructions[](#vector-instructions⑦)

All variants of [vector instructions](#syntax-instr-vec) are represented by separate byte codes. They all have a one byte prefix, whereas the actual opcode is encoded by a variable-length [unsigned integer](#binary-uint).

Vector loads and stores are followed by the encoding of their [memarg](#syntax-memarg) immediate.

​[laneidx](#binary-laneidx)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​l:[byte](#binary-byte)0xFD 0:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 1:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 2:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 3:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 4:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 5:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 6:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 7:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 8:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 9:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 10:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 11:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 84:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 85:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 86:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 87:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 88:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 89:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 90:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 91:[u32](#binary-int) (x,ao):[memarg](#binary-memarg) i:[laneidx](#binary-laneidx)0xFD 92:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)0xFD 93:[u32](#binary-int) (x,ao):[memarg](#binary-memarg)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​l0.8ex\][v128](#syntax-vectype).[load](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8[x](#syntax-shape)8\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8[x](#syntax-shape)8\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16[x](#syntax-shape)4\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16[x](#syntax-shape)4\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32[x](#syntax-shape)2\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32[x](#syntax-shape)2\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[store](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)16\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)8\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)16\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)32\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)64\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[zero](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[zero](#syntax-instr-memory) x ao​[instr](#binary-instr)::=…​

The const instruction for vectors is followed by 16 immediate bytes, which are converted into an u128 in [littleendian](#aux-littleendian) byte order:

​[instr](#binary-instr)​::=∣​…0xFD 12:[u32](#binary-int) (b:[byte](#binary-byte))16​⇒​[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​((b)16)​​

The shuffle instruction is also followed by the encoding of 16 [laneidx](#syntax-laneidx) immediates.

​[instr](#binary-instr)​::=∣∣∣​…0xFD 13:[u32](#binary-int) (l:[laneidx](#binary-laneidx))160xFD 14:[u32](#binary-int)0xFD 256:[u32](#binary-int)​⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[shuffle](#syntax-instr-vec) l16[i8](#syntax-storagetype)[x](#syntax-shape)16.[swizzle](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[relaxed\_swizzle](#syntax-instr-vec)​​

Lane instructions are followed by the encoding of a [laneidx](#syntax-laneidx) immediate.

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 21:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 22:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 23:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 24:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 25:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 26:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 27:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 28:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 29:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 30:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 31:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 32:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 33:[u32](#binary-int) l:[laneidx](#binary-laneidx)0xFD 34:[u32](#binary-int) l:[laneidx](#binary-laneidx)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[extract\_lane](#syntax-instr-vec)\_[s](#syntax-sx) l[i8](#syntax-storagetype)[x](#syntax-shape)16.[extract\_lane](#syntax-instr-vec)\_[u](#syntax-sx) l[i8](#syntax-storagetype)[x](#syntax-shape)16.[replace\_lane](#syntax-instr-vec) l[i16](#syntax-storagetype)[x](#syntax-shape)8.[extract\_lane](#syntax-instr-vec)\_[s](#syntax-sx) l[i16](#syntax-storagetype)[x](#syntax-shape)8.[extract\_lane](#syntax-instr-vec)\_[u](#syntax-sx) l[i16](#syntax-storagetype)[x](#syntax-shape)8.[replace\_lane](#syntax-instr-vec) l[i32](#syntax-numtype)[x](#syntax-shape)4.[extract\_lane](#syntax-instr-vec) l[i32](#syntax-numtype)[x](#syntax-shape)4.[replace\_lane](#syntax-instr-vec) l[i64](#syntax-numtype)[x](#syntax-shape)2.[extract\_lane](#syntax-instr-vec) l[i64](#syntax-numtype)[x](#syntax-shape)2.[replace\_lane](#syntax-instr-vec) l[f32](#syntax-numtype)[x](#syntax-shape)4.[extract\_lane](#syntax-instr-vec) l[f32](#syntax-numtype)[x](#syntax-shape)4.[replace\_lane](#syntax-instr-vec) l[f64](#syntax-numtype)[x](#syntax-shape)2.[extract\_lane](#syntax-instr-vec) l[f64](#syntax-numtype)[x](#syntax-shape)2.[replace\_lane](#syntax-instr-vec) l​​

All other vector instructions are plain opcodes without any immediates.

​[instr](#binary-instr)​::=∣∣∣∣∣∣​…0xFD 15:[u32](#binary-int)0xFD 16:[u32](#binary-int)0xFD 17:[u32](#binary-int)0xFD 18:[u32](#binary-int)0xFD 19:[u32](#binary-int)0xFD 20:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[splat](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[splat](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[splat](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[splat](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[splat](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[splat](#syntax-instr-vec)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 35:[u32](#binary-int)0xFD 36:[u32](#binary-int)0xFD 37:[u32](#binary-int)0xFD 38:[u32](#binary-int)0xFD 39:[u32](#binary-int)0xFD 40:[u32](#binary-int)0xFD 41:[u32](#binary-int)0xFD 42:[u32](#binary-int)0xFD 43:[u32](#binary-int)0xFD 44:[u32](#binary-int)0xFD 45:[u32](#binary-int)0xFD 46:[u32](#binary-int)0xFD 47:[u32](#binary-int)0xFD 48:[u32](#binary-int)0xFD 49:[u32](#binary-int)0xFD 50:[u32](#binary-int)0xFD 51:[u32](#binary-int)0xFD 52:[u32](#binary-int)0xFD 53:[u32](#binary-int)0xFD 54:[u32](#binary-int)0xFD 55:[u32](#binary-int)0xFD 56:[u32](#binary-int)0xFD 57:[u32](#binary-int)0xFD 58:[u32](#binary-int)0xFD 59:[u32](#binary-int)0xFD 60:[u32](#binary-int)0xFD 61:[u32](#binary-int)0xFD 62:[u32](#binary-int)0xFD 63:[u32](#binary-int)0xFD 64:[u32](#binary-int)0xFD 214:[u32](#binary-int)0xFD 215:[u32](#binary-int)0xFD 216:[u32](#binary-int)0xFD 217:[u32](#binary-int)0xFD 218:[u32](#binary-int)0xFD 219:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[eq](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ne](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[eq](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ne](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[eq](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[ne](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[eq](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[ne](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[ge](#syntax-instr-vec)\_[s](#syntax-sx)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 65:[u32](#binary-int)0xFD 66:[u32](#binary-int)0xFD 67:[u32](#binary-int)0xFD 68:[u32](#binary-int)0xFD 69:[u32](#binary-int)0xFD 70:[u32](#binary-int)0xFD 71:[u32](#binary-int)0xFD 72:[u32](#binary-int)0xFD 73:[u32](#binary-int)0xFD 74:[u32](#binary-int)0xFD 75:[u32](#binary-int)0xFD 76:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype)[x](#syntax-shape)4.[eq](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[ne](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[eq](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[ne](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[lt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[gt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[le](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[ge](#syntax-instr-vec)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣​…0xFD 77:[u32](#binary-int)0xFD 78:[u32](#binary-int)0xFD 79:[u32](#binary-int)0xFD 80:[u32](#binary-int)0xFD 81:[u32](#binary-int)0xFD 82:[u32](#binary-int)0xFD 83:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒​[v128](#syntax-vectype).[not](#syntax-instr-vec)[v128](#syntax-vectype).[and](#syntax-instr-vec)[v128](#syntax-vectype).[andnot](#syntax-instr-vec)[v128](#syntax-vectype).[or](#syntax-instr-vec)[v128](#syntax-vectype).[xor](#syntax-instr-vec)[v128](#syntax-vectype).[bitselect](#syntax-instr-vec)[v128](#syntax-vectype).[any\_true](#syntax-instr-vec)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 96:[u32](#binary-int)0xFD 97:[u32](#binary-int)0xFD 98:[u32](#binary-int)0xFD 99:[u32](#binary-int)0xFD 100:[u32](#binary-int)0xFD 101:[u32](#binary-int)0xFD 102:[u32](#binary-int)0xFD 107:[u32](#binary-int)0xFD 108:[u32](#binary-int)0xFD 109:[u32](#binary-int)0xFD 110:[u32](#binary-int)0xFD 111:[u32](#binary-int)0xFD 112:[u32](#binary-int)0xFD 113:[u32](#binary-int)0xFD 114:[u32](#binary-int)0xFD 115:[u32](#binary-int)0xFD 118:[u32](#binary-int)0xFD 119:[u32](#binary-int)0xFD 120:[u32](#binary-int)0xFD 121:[u32](#binary-int)0xFD 123:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[abs](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[neg](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[popcnt](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[all\_true](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[bitmask](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[narrow](#syntax-instr-vec)\_[i16](#syntax-storagetype)[x](#syntax-shape)8\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[narrow](#syntax-instr-vec)\_[i16](#syntax-storagetype)[x](#syntax-shape)8\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shl](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[avgr](#syntax-instr-vec)\_[u](#syntax-sx)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 124:[u32](#binary-int)0xFD 125:[u32](#binary-int)0xFD 128:[u32](#binary-int)0xFD 129:[u32](#binary-int)0xFD 131:[u32](#binary-int)0xFD 132:[u32](#binary-int)0xFD 133:[u32](#binary-int)0xFD 134:[u32](#binary-int)0xFD 135:[u32](#binary-int)0xFD 136:[u32](#binary-int)0xFD 137:[u32](#binary-int)0xFD 138:[u32](#binary-int)0xFD 139:[u32](#binary-int)0xFD 140:[u32](#binary-int)0xFD 141:[u32](#binary-int)0xFD 130:[u32](#binary-int)0xFD 142:[u32](#binary-int)0xFD 143:[u32](#binary-int)0xFD 144:[u32](#binary-int)0xFD 145:[u32](#binary-int)0xFD 146:[u32](#binary-int)0xFD 147:[u32](#binary-int)0xFD 149:[u32](#binary-int)0xFD 150:[u32](#binary-int)0xFD 151:[u32](#binary-int)0xFD 152:[u32](#binary-int)0xFD 153:[u32](#binary-int)0xFD 155:[u32](#binary-int)0xFD 273:[u32](#binary-int)0xFD 156:[u32](#binary-int)0xFD 157:[u32](#binary-int)0xFD 158:[u32](#binary-int)0xFD 159:[u32](#binary-int)0xFD 274:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i16](#syntax-storagetype)[x](#syntax-shape)8.[extadd\_pairwise](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extadd\_pairwise](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[abs](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[neg](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[all\_true](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[bitmask](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[narrow](#syntax-instr-vec)\_[i32](#syntax-numtype)[x](#syntax-shape)4\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[narrow](#syntax-instr-vec)\_[i32](#syntax-numtype)[x](#syntax-shape)4\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[shl](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[q15mulr\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[mul](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[avgr](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[relaxed\_q15mulr](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[relaxed\_dot](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 126:[u32](#binary-int)0xFD 127:[u32](#binary-int)0xFD 160:[u32](#binary-int)0xFD 161:[u32](#binary-int)0xFD 163:[u32](#binary-int)0xFD 164:[u32](#binary-int)0xFD 167:[u32](#binary-int)0xFD 168:[u32](#binary-int)0xFD 169:[u32](#binary-int)0xFD 170:[u32](#binary-int)0xFD 171:[u32](#binary-int)0xFD 172:[u32](#binary-int)0xFD 173:[u32](#binary-int)0xFD 174:[u32](#binary-int)0xFD 177:[u32](#binary-int)0xFD 181:[u32](#binary-int)0xFD 182:[u32](#binary-int)0xFD 183:[u32](#binary-int)0xFD 184:[u32](#binary-int)0xFD 185:[u32](#binary-int)0xFD 186:[u32](#binary-int)0xFD 188:[u32](#binary-int)0xFD 189:[u32](#binary-int)0xFD 190:[u32](#binary-int)0xFD 191:[u32](#binary-int)0xFD 275:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype)[x](#syntax-shape)4.[extadd\_pairwise](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extadd\_pairwise](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[abs](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[neg](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[all\_true](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[bitmask](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[shl](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[add](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[sub](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[mul](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[dot](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_dot\_add](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 192:[u32](#binary-int)0xFD 193:[u32](#binary-int)0xFD 195:[u32](#binary-int)0xFD 196:[u32](#binary-int)0xFD 199:[u32](#binary-int)0xFD 200:[u32](#binary-int)0xFD 201:[u32](#binary-int)0xFD 202:[u32](#binary-int)0xFD 203:[u32](#binary-int)0xFD 204:[u32](#binary-int)0xFD 205:[u32](#binary-int)0xFD 206:[u32](#binary-int)0xFD 209:[u32](#binary-int)0xFD 213:[u32](#binary-int)0xFD 220:[u32](#binary-int)0xFD 221:[u32](#binary-int)0xFD 222:[u32](#binary-int)0xFD 223:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i64](#syntax-numtype)[x](#syntax-shape)2.[abs](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[neg](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[all\_true](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[bitmask](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[shl](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[add](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[sub](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[mul](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 103:[u32](#binary-int)0xFD 104:[u32](#binary-int)0xFD 105:[u32](#binary-int)0xFD 106:[u32](#binary-int)0xFD 224:[u32](#binary-int)0xFD 225:[u32](#binary-int)0xFD 227:[u32](#binary-int)0xFD 228:[u32](#binary-int)0xFD 229:[u32](#binary-int)0xFD 230:[u32](#binary-int)0xFD 231:[u32](#binary-int)0xFD 232:[u32](#binary-int)0xFD 233:[u32](#binary-int)0xFD 234:[u32](#binary-int)0xFD 235:[u32](#binary-int)0xFD 269:[u32](#binary-int)0xFD 270:[u32](#binary-int)0xFD 261:[u32](#binary-int)0xFD 262:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype)[x](#syntax-shape)4.[ceil](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[floor](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[trunc](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[nearest](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[abs](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[neg](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[sqrt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[add](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[sub](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[mul](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[div](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[pmin](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[pmax](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_min](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_max](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_madd](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_nmadd](#syntax-instr-vec)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 116:[u32](#binary-int)0xFD 117:[u32](#binary-int)0xFD 122:[u32](#binary-int)0xFD 148:[u32](#binary-int)0xFD 236:[u32](#binary-int)0xFD 237:[u32](#binary-int)0xFD 239:[u32](#binary-int)0xFD 240:[u32](#binary-int)0xFD 241:[u32](#binary-int)0xFD 242:[u32](#binary-int)0xFD 243:[u32](#binary-int)0xFD 244:[u32](#binary-int)0xFD 245:[u32](#binary-int)0xFD 246:[u32](#binary-int)0xFD 247:[u32](#binary-int)0xFD 271:[u32](#binary-int)0xFD 272:[u32](#binary-int)0xFD 263:[u32](#binary-int)0xFD 264:[u32](#binary-int)0xFD 265:[u32](#binary-int)0xFD 266:[u32](#binary-int)0xFD 267:[u32](#binary-int)0xFD 268:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f64](#syntax-numtype)[x](#syntax-shape)2.[ceil](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[floor](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[trunc](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[nearest](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[abs](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[neg](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[sqrt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[add](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[sub](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[mul](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[div](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[min](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[max](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[pmin](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[pmax](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_min](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_max](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_madd](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_nmadd](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[relaxed\_laneselect](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[relaxed\_laneselect](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_laneselect](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_laneselect](#syntax-instr-vec)​​

​[instr](#binary-instr)​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…0xFD 94:[u32](#binary-int)0xFD 95:[u32](#binary-int)0xFD 248:[u32](#binary-int)0xFD 249:[u32](#binary-int)0xFD 250:[u32](#binary-int)0xFD 251:[u32](#binary-int)0xFD 252:[u32](#binary-int)0xFD 253:[u32](#binary-int)0xFD 254:[u32](#binary-int)0xFD 255:[u32](#binary-int)0xFD 257:[u32](#binary-int)0xFD 258:[u32](#binary-int)0xFD 259:[u32](#binary-int)0xFD 260:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype)[x](#syntax-shape)4.[demote](#syntax-instr-vec)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[f64](#syntax-numtype)[x](#syntax-shape)2.[promote](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[f32](#syntax-numtype)[x](#syntax-shape)4.[convert](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f32](#syntax-numtype)[x](#syntax-shape)4.[convert](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[s](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[u](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[f64](#syntax-numtype)[x](#syntax-shape)2.[convert](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f64](#syntax-numtype)[x](#syntax-shape)2.[convert](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[s](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[u](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2​​

#### 5.4.10. Expressions[](#expressions⑦)

[Expressions](#syntax-expr) are encoded by their instruction sequence terminated with an explicit 0x0B opcode for end.

​[expr](#binary-expr)​::=​(in:[instr](#binary-instr))∗ 0x0B​⇒​in∗​​

### 5.5. Modules[](#modules⑨)

The binary encoding of modules is organized into _sections_. Most sections correspond to one component of a [module](#syntax-module) record, except that [function definitions](#syntax-func) are split into two sections, separating their type declarations in the [function section](#binary-funcsec) from their bodies in the [code section](#binary-codesec).

Note

This separation enables _parallel_ and _streaming_ compilation of the functions in a module.

#### 5.5.1. Indices[](#indices③)

All basic [indices](#syntax-index) are encoded with their respective value.

​[typeidx](#binary-typeidx)[funcidx](#binary-funcidx)[tableidx](#binary-tableidx)[memidx](#binary-memidx)[globalidx](#binary-globalidx)[tagidx](#binary-tagidx)[elemidx](#binary-elemidx)[dataidx](#binary-dataidx)[localidx](#binary-localidx)[labelidx](#binary-labelidx)​::=::=::=::=::=::=::=::=::=::=​x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)x:[u32](#binary-int)l:[u32](#binary-int)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​xxxxxxxxxl​​

[External indices](#syntax-externidx) are encoded by a distiguishing byte followed by an encoding of their respective value.

​[externidx](#binary-externidx)​::=∣∣∣∣​0x00 x:[funcidx](#binary-funcidx)0x01 x:[tableidx](#binary-tableidx)0x02 x:[memidx](#binary-memidx)0x03 x:[globalidx](#binary-globalidx)0x04 x:[tagidx](#binary-tagidx)​⇒⇒⇒⇒⇒​[func](#syntax-externidx) x[table](#syntax-externidx) x[memory](#syntax-externidx) x[global](#syntax-externidx) x[tag](#syntax-externidx) x​​

#### 5.5.2. Sections[](#sections①)

Each section consists of

*   a one-byte section _id_,
    
*   the [u32](#syntax-int) _length_ of the contents, in bytes,
    
*   the actual _contents_, whose structure is dependent on the section id.
    

Every section is optional; an omitted section is equivalent to the section being present with empty contents.

The following parameterized grammar rule defines the generic structure of a section with id N and contents described by the grammar X.

​[section](#binary-section)N​(X)​::=∣​N:[byte](#binary-byte) len:[u32](#binary-int) en∗:Xϵ​⇒⇒​en∗ϵ​if len\=∣∣X∣∣​

For most sections, the contents X encodes a [list](#binary-list). In these cases, the empty result ϵ is interpreted as the empty list.

Note

Other than for unknown [custom sections](#binary-customsec), the size is not required for decoding, but can be used to skip sections when navigating through a binary. The module is malformed if the size does not match the length of the binary contents X.

The following section ids are used:

Id

Section

0

[custom section](#binary-customsec)

1

[type section](#binary-typesec)

2

[import section](#binary-importsec)

3

[function section](#binary-funcsec)

4

[table section](#binary-tablesec)

5

[memory section](#binary-memsec)

6

[global section](#binary-globalsec)

7

[export section](#binary-exportsec)

8

[start section](#binary-startsec)

9

[element section](#binary-elemsec)

10

[code section](#binary-codesec)

11

[data section](#binary-datasec)

12

[data count section](#binary-datacntsec)

13

[tag section](#binary-tagsec)

Note

Section ids do not always correspond to the [order of sections](#binary-module) in the encoding of a module.

#### 5.5.3. Custom Section[](#custom-section①)

_Custom sections_ have the id 0. They are intended to be used for debugging information or third-party extensions, and are ignored by the WebAssembly semantics. Their contents consist of a [name](#syntax-name) further identifying the custom section, followed by an uninterpreted sequence of bytes for custom use.

​[customsec](#binary-customsec)[custom](#binary-customsec)​::=::=​[section](#binary-section)0​([custom](#binary-customsec))[name](#binary-name) [byte](#binary-byte)∗​​

Note

If an implementation interprets the data of a custom section, then errors in that data, or the placement of the section, must not invalidate the module.

#### 5.5.4. Type Section[](#type-section①)

The _type section_ has the id 1. It decodes into the list of [recursive types](#syntax-rectype) of a [module](#syntax-module).

​[typesec](#binary-typesec)[type](#binary-type)​::=::=​ty∗:[section](#binary-section)1​([list](#binary-list)([type](#binary-type)))qt:[rectype](#binary-rectype)​⇒⇒​ty∗[type](#syntax-type) qt​​

#### 5.5.5. Import Section[](#import-section①)

The _import section_ has the id 2. It decodes into the list of [imports](#syntax-import) of a [module](#syntax-module).

​[importsec](#binary-importsec)[import](#binary-import)​::=::=​im∗:[section](#binary-section)2​([list](#binary-list)([import](#binary-import)))nm1​:[name](#binary-name) nm2​:[name](#binary-name) xt:[externtype](#binary-externtype)​⇒⇒​im∗[import](#syntax-import) nm1​ nm2​ xt​​

#### 5.5.6. Function Section[](#function-section①)

The _function section_ has the id 3. It decodes into a list of [type indices](#syntax-typeidx) that classify the [functions](#syntax-func) defined by a [module](#syntax-module). The bodies of the respective functions are encoded separately in the [code section](#binary-codesec).

​[funcsec](#binary-funcsec)​::=​x∗:[section](#binary-section)3​([list](#binary-list)([typeidx](#binary-typeidx)))​⇒​x∗​​

#### 5.5.7. Table Section[](#table-section①)

The _table section_ has the id 4. It decodes into the list of [tables](#syntax-table) defined by a [module](#syntax-module).

​[tablesec](#binary-tablesec)[table](#binary-table)​::=::=∣​tab∗:[section](#binary-section)4​([list](#binary-list)([table](#binary-table)))tt:[tabletype](#binary-tabletype)0x40 0x00 tt:[tabletype](#binary-tabletype) e:[expr](#binary-expr)​⇒⇒⇒​tab∗[table](#syntax-table) tt ([ref.null](#syntax-instr-ref) ht)[table](#syntax-table) tt e​if tt\=at lim ([ref](#syntax-reftype) [null](#syntax-reftype)? ht)​​

Note

The encoding of a table type cannot start with byte 0x40, hence decoding is unambiguous. The zero byte following it is reserved for future extensions.

#### 5.5.8. Memory Section[](#memory-section①)

The _memory section_ has the id 5. It decodes into the list of [memories](#syntax-mem) defined by a [module](#syntax-module).

​[memsec](#binary-memsec)[mem](#binary-mem)​::=::=​[mem](#syntax-mem)∗:[section](#binary-section)5​([list](#binary-list)([mem](#binary-mem)))mt:[memtype](#binary-memtype)​⇒⇒​[mem](#syntax-mem)∗[memory](#syntax-mem) mt​​

#### 5.5.9. Global Section[](#global-section①)

The _global section_ has the id 6. It decodes into the list of [globals](#syntax-global) defined by a [module](#syntax-module).

​[globalsec](#binary-globalsec)[global](#binary-global)​::=::=​glob∗:[section](#binary-section)6​([list](#binary-list)([global](#binary-global)))gt:[globaltype](#binary-globaltype) e:[expr](#binary-expr)​⇒⇒​glob∗[global](#syntax-global) gt e​​

#### 5.5.10. Export Section[](#export-section①)

The _export section_ has the id 7. It decodes into the list of [exports](#syntax-export) of a [module](#syntax-module).

​[exportsec](#binary-exportsec)[export](#binary-export)​::=::=​ex∗:[section](#binary-section)7​([list](#binary-list)([export](#binary-export)))nm:[name](#binary-name) xx:[externidx](#binary-externidx)​⇒⇒​ex∗[export](#syntax-export) nm xx​​

#### 5.5.11. Start Section[](#start-section①)

The _start section_ has the id 8. It decodes into the optional [start function](#syntax-start) of a [module](#syntax-module).

​[startsec](#binary-startsec)[start](#binary-start)​::=::=​[start](#syntax-start)?:[section](#binary-section)8​([start](#binary-start))x:[funcidx](#binary-funcidx)​⇒⇒​[start](#syntax-start)?([start](#syntax-start) x)​​

#### 5.5.12. Element Section[](#element-section①)

The _element section_ has the id 9. It decodes into the list of [element segments](#syntax-elem) defined by a [module](#syntax-module).

​[elemsec](#binary-elemsec)[elemkind](#binary-elemkind)[elem](#binary-elem)​::=::=::=∣∣∣∣∣∣∣​[elem](#syntax-elem)∗:[section](#binary-section)9​([list](#binary-list)([elem](#binary-elem)))0x000:[u32](#binary-int) eo​:[expr](#binary-expr) y∗:[list](#binary-list)([funcidx](#binary-funcidx))[elem](#syntax-elem) ([ref](#syntax-reftype) [func](#syntax-heaptype)) ([ref.func](#syntax-instr-ref) y)∗ ([active](#syntax-elemmode) 0 eo​)​1:[u32](#binary-int) rt:[elemkind](#binary-elemkind) y∗:[list](#binary-list)([funcidx](#binary-funcidx))[elem](#syntax-elem) rt ([ref.func](#syntax-instr-ref) y)∗ [passive](#syntax-elemmode)​2:[u32](#binary-int) x:[tableidx](#binary-tableidx) e:[expr](#binary-expr) rt:[elemkind](#binary-elemkind) y∗:[list](#binary-list)([funcidx](#binary-funcidx))[elem](#syntax-elem) rt ([ref.func](#syntax-instr-ref) y)∗ ([active](#syntax-elemmode) x e)​3:[u32](#binary-int) rt:[elemkind](#binary-elemkind) y∗:[list](#binary-list)([funcidx](#binary-funcidx))[elem](#syntax-elem) rt ([ref.func](#syntax-instr-ref) y)∗ [declare](#syntax-elemmode)​4:[u32](#binary-int) eo​:[expr](#binary-expr) e∗:[list](#binary-list)([expr](#binary-expr))[elem](#syntax-elem) ([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)) e∗ ([active](#syntax-elemmode) 0 eo​)​5:[u32](#binary-int) rt:[reftype](#binary-reftype) e∗:[list](#binary-list)([expr](#binary-expr))[elem](#syntax-elem) rt e∗ [passive](#syntax-elemmode)​6:[u32](#binary-int) x:[tableidx](#binary-tableidx) eo​:[expr](#binary-expr) e∗:[list](#binary-list)([expr](#binary-expr))[elem](#syntax-elem) ([ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)) e∗ ([active](#syntax-elemmode) x eo​)​7:[u32](#binary-int) rt:[reftype](#binary-reftype) e∗:[list](#binary-list)([expr](#binary-expr))[elem](#syntax-elem) rt e∗ [declare](#syntax-elemmode)​​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[elem](#syntax-elem)∗[ref](#syntax-reftype) [null](#syntax-reftype) [func](#syntax-heaptype)​​​

Note

The initial integer can be interpreted as a bitfield. Bit 0 distinguishes a passive or declarative segment from an active segment, bit 1 indicates the presence of an explicit table index for an active segment and otherwise distinguishes passive from declarative segments, bit 2 indicates the use of element type and element [expressions](#binary-expr) instead of element kind and element indices.

Additional element kinds may be added in future versions of WebAssembly.

#### 5.5.13. Code Section[](#code-section①)

The _code section_ has the id 10. It decodes into the list of _code_ entries that are pairs of lists of [locals](#syntax-list) and [expressions](#syntax-expr). They represent the body of the [functions](#syntax-func) defined by a [module](#syntax-module). The types of the respective functions are encoded separately in the [function section](#binary-funcsec).

The encoding of each code entry consists of

*   the [u32](#syntax-int) _length_ of the function code in bytes,
    
*   the actual _function code_, which in turn consists of
    
    *   the declaration of _locals_,
        
    *   the function _body_ as an [expression](#binary-expr).
        

Local declarations are compressed into a list whose entries consist of

*   a [u32](#syntax-int) _count_,
    
*   a [value type](#binary-valtype),
    

denoting _count_ locals of the same value type.

​[codesec](#binary-codesec)[code](#binary-code)[func](#binary-func)[locals](#binary-local)​::=::=::=::=​code∗:[section](#binary-section)10​([list](#binary-list)([code](#binary-code)))len:[u32](#binary-int) code:[func](#binary-func)loc∗∗:[list](#binary-list)([locals](#binary-local)) e:[expr](#binary-expr)n:[u32](#binary-int) t:[valtype](#binary-valtype)​⇒⇒⇒⇒​code∗code([⨁](#notation-concat)loc∗∗,e)([local](#syntax-local) t)n​if len\=∣∣[func](#binary-func)∣∣if ∣[⨁](#notation-concat)loc∗∗∣<232​​

Here, code ranges over pairs ([local](#syntax-local)∗,[expr](#syntax-expr)). Any code for which the length of the resulting sequence is out of bounds of the maximum size of a [list](#syntax-list) is malformed.

Note

Like with [sections](#binary-section), the code size is not needed for decoding, but can be used to skip functions when navigating through a binary. The module is malformed if a size does not match the length of the respective function code.

#### 5.5.14. Data Section[](#data-section①)

The _data section_ has the id 11. It decodes into the list of [data segments](#syntax-data) defined by a [module](#syntax-module).

​[datasec](#binary-datasec)[data](#binary-data)​::=::=∣∣​[data](#syntax-data)∗:[section](#binary-section)11​([list](#binary-list)([data](#binary-data)))0:[u32](#binary-int) e:[expr](#binary-expr) b∗:[list](#binary-list)([byte](#binary-byte))1:[u32](#binary-int) b∗:[list](#binary-list)([byte](#binary-byte))2:[u32](#binary-int) x:[memidx](#binary-memidx) e:[expr](#binary-expr) b∗:[list](#binary-list)([byte](#binary-byte))​⇒⇒⇒⇒​[data](#syntax-data)∗[data](#syntax-data) b∗ ([active](#syntax-datamode) 0 e)[data](#syntax-data) b∗ [passive](#syntax-datamode)[data](#syntax-data) b∗ ([active](#syntax-datamode) x e)​​

Note

The initial integer can be interpreted as a bitfield. Bit 0 indicates a passive segment, bit 1 indicates the presence of an explicit memory index for an active segment.

#### 5.5.15. Data Count Section[](#data-count-section①)

The _data count section_ has the id 12. It decodes into an optional [u32](#syntax-int) count that represents the number of [data segments](#syntax-data) in the [data section](#binary-datasec). If this count does not match the length of the data segment list, the module is malformed.

​[datacntsec](#binary-datacntsec)[datacnt](#binary-datacnt)​::=::=​n?:[section](#binary-section)12​([datacnt](#binary-datacnt))n:[u32](#binary-int)​⇒⇒​n?n​​

Note

The data count section is used to simplify single-pass validation. Since the data section occurs after the code section, the memory.init and data.drop instructions would not be able to check whether the data segment index is valid until the data section is read. The data count section occurs before the code section, so a single-pass validator can use this count instead of deferring validation.

#### 5.5.16. Tag Section[](#tag-section①)

The _tag section_ has the id 13. It decodes into the list of [tags](#syntax-tag) defined by a [module](#syntax-module).

​[tagsec](#binary-tagsec)[tag](#binary-tag)​::=::=​[tag](#syntax-tag)∗:[section](#binary-section)13​([list](#binary-list)([tag](#binary-tag)))jt:[tagtype](#binary-tagtype)​⇒⇒​[tag](#syntax-tag)∗[tag](#syntax-tag) jt​​

#### 5.5.17. Modules[](#modules①⓪)

The encoding of a [module](#syntax-module) starts with a preamble containing a 4-byte magic number (the string ‘\\0asm’) and a version field. The current version of the WebAssembly binary format is 1.

The preamble is followed by a sequence of [sections](#binary-section). [Custom sections](#binary-customsec) may be inserted at any place in this sequence, while other sections must occur at most once and in the prescribed order. All sections can be empty.

The lengths of lists produced by the (possibly empty) [function](#binary-funcsec) and [code](#binary-codesec) section must match up.

Similarly, the optional data count must match the length of the [data segment](#binary-datasec) list. Furthermore, it must be present if any [data index](#syntax-dataidx) occurs in the code section.

​[magic](#binary-magic)[version](#binary-version)[module](#binary-module)​::=::=::=​0x00 0x61 0x73 0x6D0x01 0x00 0x00 0x00[magic](#binary-magic) [version](#binary-version)[customsec](#binary-customsec)∗ [type](#syntax-rectype)∗:[typesec](#binary-typesec)[customsec](#binary-customsec)∗ [import](#syntax-import)∗:[importsec](#binary-importsec)[customsec](#binary-customsec)∗ [typeidx](#syntax-typeidx)∗:[funcsec](#binary-funcsec)[customsec](#binary-customsec)∗ [table](#syntax-table)∗:[tablesec](#binary-tablesec)[customsec](#binary-customsec)∗ [mem](#syntax-mem)∗:[memsec](#binary-memsec)[customsec](#binary-customsec)∗ [tag](#syntax-tag)∗:[tagsec](#binary-tagsec)[customsec](#binary-customsec)∗ [global](#syntax-global)∗:[globalsec](#binary-globalsec)[customsec](#binary-customsec)∗ [export](#syntax-export)∗:[exportsec](#binary-exportsec)[customsec](#binary-customsec)∗ [start](#syntax-start)?:[startsec](#binary-startsec)[customsec](#binary-customsec)∗ [elem](#syntax-elem)∗:[elemsec](#binary-elemsec)[customsec](#binary-customsec)∗ n?:[datacntsec](#binary-datacntsec)[customsec](#binary-customsec)∗ ([local](#syntax-local)∗,[expr](#syntax-expr))∗:[codesec](#binary-codesec)[customsec](#binary-customsec)∗ [data](#syntax-data)∗:[datasec](#binary-datasec)[customsec](#binary-customsec)∗​[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗if (n\=∣[data](#syntax-data)∗∣)?∧ (n?\=ϵ∨[dataidx](#syntax-dataidx)([func](#syntax-func)∗)\=ϵ)∧ ([func](#syntax-func)\=[func](#syntax-func) [typeidx](#syntax-typeidx) [local](#syntax-local)∗ [expr](#syntax-expr))∗​​​​⇒​​​​

Note

The version of the WebAssembly binary format may increase in the future if backward-incompatible changes have to be made to the format. However, such changes are expected to occur very infrequently, if ever. The binary format is intended to be extensible, such that future features can be added without incrementing its version.

6\. Text Format[](#text-format①)
--------------------------------

### 6.1. Conventions[](#conventions③③)

The textual format for WebAssembly [modules](#module) is a rendering of their [abstract syntax](#syntax-module) into [S-expressions](https://en.wikipedia.org/wiki/S-expression).

Like the [binary format](#binary), the text format is defined by an _attribute grammar_. A text string is a well-formed description of a module if and only if it is generated by the grammar. Each production of this grammar has at most one synthesized attribute: the abstract syntax that the respective character sequence expresses. Thus, the attribute grammar implicitly defines a _parsing_ function. Some productions also take a [context](#text-context) as an inherited attribute that records bound [identifiers](#text-id).

Except for a few exceptions, the core of the text grammar closely mirrors the grammar of the abstract syntax. However, it also defines a number of _abbreviations_ that are “syntactic sugar” over the core syntax.

The recommended extension for files containing WebAssembly modules in text format is “`.wat`”. Files with this extension are assumed to be encoded in UTF-8, as per [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 2.5).

#### 6.1.1. Grammar[](#grammar④)

The following conventions are adopted in defining grammar rules of the text format. They mirror the conventions used for [abstract syntax](#grammar) and for the [binary format](#binary). In order to distinguish symbols of the textual syntax from symbols of the abstract syntax, typewriter font is adopted for the former.

*   Terminal symbols are either literal strings of characters enclosed in quotes or expressed as [\[UNICODE\]](#biblio-unicode "The Unicode Standard") scalar values: ‘module’, U+0A. (All characters written literally are unambiguously drawn from the 7-bit [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d) subset of Unicode.)
    
*   Nonterminal symbols are written in typewriter font: valtype, instr.
    
*   Tn is a sequence of n≥0 iterations of T.
    
*   T∗ is a possibly empty sequence of iterations of T. (This is a shorthand for Tn used where n is not relevant.)
    
*   T+ is a possibly empty sequence of iterations of T. (This is a shorthand for Tn used where n is not relevant.)
    
*   T? is an optional occurrence of T. (This is a shorthand for Tn where n≤1.)
    
*   x:T denotes the same language as the nonterminal T, but also binds the variable x to the attribute synthesized for T. A pattern may also be used instead of a variable, e.g., 7:T.
    
*   Productions are written ​sym​::=​T1​ ⇒ A1​ ∣ … ∣ Tn​ ⇒ An​​, where each Ai​ is the attribute that is synthesized for sym in the given case, usually from attribute variables bound in Ti​.
    
*   Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, ​sym​::=​B1​​, and starting continuations with ellipses, ​sym​::=​… ∣ B2​​.
    
*   Some productions are augmented by side conditions in parentheses, which restrict the applicability of the production. They provide a shorthand for a combinatorial expansion of the production into many separate cases.
    
*   If the same meta variable or non-terminal symbol appears multiple times in a production (in the syntax or in an attribute), then all those occurrences must have the same instantiation.
    

*   A distinction is made between _lexical_ and _syntactic_ productions. For the latter, arbitrary [white space](#text-space) is allowed in any place where the grammar contains spaces. The productions defining [lexical syntax](#text-lexical) and the syntax of [values](#text-value) are considered lexical, all others are syntactic.
    

Note

For example, the [textual grammar](#text-numtype) for [number types](#syntax-numtype) is given as follows:

​[numtype](#text-numtype)​::=∣∣∣​‘i32’‘i64’‘f32’‘f64’​⇒⇒⇒⇒​[i32](#syntax-numtype)[i64](#syntax-numtype)[f32](#syntax-numtype)[f64](#syntax-numtype)​​

The [textual grammar](#text-limits) for [limits](#syntax-limits) is defined as follows:

​[limits](#text-limits)​::=∣​n:[u64](#text-int)n:[u64](#text-int) m:[u64](#text-int)​⇒⇒​\[n[..](#syntax-limits)ϵ\]\[n[..](#syntax-limits)m\]​​

The variables n and m name the attributes of the respective [u64](#text-int) nonterminals, which in this case are the actual [unsigned integers](#syntax-uint) those parse into. The attribute of the complete production then is the abstract syntax for the limit, expressed in terms of the former values.

#### 6.1.2. Abbreviations[](#abbreviations①)

In addition to the core grammar, which corresponds directly to the [abstract syntax](#syntax), the textual syntax also defines a number of _abbreviations_ that can be used for convenience and readability.

Abbreviations are defined by _rewrite rules_ specifying their expansion into the core syntax:

​sym​::=​abbreviated syntax​≡​expanded syntax​​

These expansions are assumed to be applied, recursively and in order of appearance, before applying the core grammar rules to construct the abstract syntax.

#### 6.1.3. Contexts[](#contexts③)

The text format allows the use of symbolic [identifiers](#text-id) in place of [indices](#syntax-index). To resolve these identifiers into concrete indices, some grammar productions are indexed by an _identifier context_ [I](#text-context) as a synthesized attribute that records the declared identifiers in each [index space](#syntax-index). In addition, the context records the types defined in the module, so that [parameter](#text-param) indices can be computed for [functions](#text-func).

It is convenient to define identifier contexts as [records](#notation-record) [I](#text-context) with abstract syntax as follows:

​[I](#text-context)​::=​{[types](#text-context) ([name](#syntax-name)?)∗[tags](#text-context) ([name](#syntax-name)?)∗[globals](#text-context) ([name](#syntax-name)?)∗[mems](#text-context) ([name](#syntax-name)?)∗[tables](#text-context) ([name](#syntax-name)?)∗[funcs](#text-context) ([name](#syntax-name)?)∗[datas](#text-context) ([name](#syntax-name)?)∗[elems](#text-context) ([name](#syntax-name)?)∗[locals](#text-context) ([name](#syntax-name)?)∗[labels](#text-context) ([name](#syntax-name)?)∗[fields](#text-context) (([name](#syntax-name)?)∗)∗[typedefs](#text-context) ([deftype](#syntax-deftype)?)∗}​​​

For each index space, such a context contains the list of [names](#syntax-name) assigned to the defined indices, which were denoted by the corresponding [identifiers](#text-id). Unnamed indices are associated with empty (ϵ) entries in these lists. Fields have _dependent_ name spaces, and hence a separate list of field identifiers per type.

In addition, the field typedefs records the [defined type](#syntax-deftype) associated with each [type index](#syntax-typeidx). They are needed to look up the number of parameters of [function types](#syntax-functype) when used in a [function definition](#text-func), in order to produce the correct indices for [locals](#syntax-local).

An identifier context is _well-formed_ if no index space contains duplicate identifiers. For fields, names need only be unique within a single type.

##### 6.1.3.1. Conventions[](#conventions③④)

To avoid unnecessary clutter, empty components are omitted when writing out identifier contexts. For example, the record {} is shorthand for an [identifier context](#text-context) whose components are all empty.

#### 6.1.4. Lists[](#lists⑤)

[Lists](#syntax-list) are written as plain sequences, but with a restriction on the length of these sequence.

​[list](#text-list)(X)​::=​(el:X)∗​⇒​el∗​if ∣el∗∣<232​​

### 6.2. Lexical Format[](#lexical-format①)

#### 6.2.1. Characters[](#characters①)

The text format assigns meaning to _source text_, which consists of a sequence of _characters_. Characters are assumed to be represented as valid [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 2.4) _scalar values_.

​[source](#text-source)​::=​[char](#text-char)∗0.8ex\]​[char](#text-char)​::=​U+00 ∣ … ∣ U+D7FF ∣ U+E000 ∣ … ∣ U+10FFFF​​

Note

While source text may contain any Unicode character in [comments](#text-comment) or [string](#text-string) literals, the rest of the grammar is formed exclusively from the characters supported by the 7-bit [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d) subset of Unicode.

#### 6.2.2. Tokens[](#tokens①)

The character stream in the source text is divided, from left to right, into a sequence of _tokens_, as defined by the following grammar.

​[token](#text-token)​::=​[keyword](#text-keyword) ∣ [u](#text-int) ∣ [s](#text-int) ∣ [f](#text-int) ∣ [string](#text-string) ∣ [id](#text-id) ∣ ‘(’ ∣ ‘)’ ∣ [reserved](#text-reserved)0.8ex\]​[keyword](#text-keyword)​::=​(‘a’ ∣ … ∣ ‘z’) [idchar](#text-idchar)∗0.8ex\]​[reserved](#text-reserved)​::=​([idchar](#text-idchar) ∣ [string](#text-string) ∣ ‘,’ ∣ ‘;’ ∣ ‘\[’ ∣ ‘\]’ ∣ ‘{’ ∣ ‘}’)+​​

Tokens are formed from the input character stream according to the _longest match_ rule. That is, the next token always consists of the longest possible sequence of characters that is recognized by the above lexical grammar. Tokens can be separated by [white space](#text-space), but except for strings, they cannot themselves contain whitespace.

_Keyword_ tokens always start with a lower-case letter. The set of keywords is defined implicitly: only those tokens are defined to be keywords that occur as a [terminal symbol](#text-grammar) in literal form, such as ‘keyword’, in a [syntactic](#text-syntactic) production of this chapter.

Any token that does not fall into any of the other categories is considered _reserved_, and cannot occur in source text.

Note

The effect of defining the set of reserved tokens is that all tokens must be separated by either parentheses, [white space](#text-space), or [comments](#text-comment). For example, ‘0$x’ is a single reserved token, as is ‘’’a’’’’b’’’. Consequently, they are not recognized as two separate tokens ‘0’ and ‘$x’, or ‘’’a’’’ and ‘’’b’’’, respectively, but instead disallowed. This property of tokenization is not affected by the fact that the definition of reserved tokens overlaps with other token classes.

#### 6.2.3. White Space[](#white-space①)

_White space_ is any sequence of literal space characters, formatting characters, [comments](#text-comment), or [annotations](#text-annot). The allowed formatting characters correspond to a subset of the [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d) _format effectors_, namely, _horizontal tabulation_ (U+09), _line feed_ (U+0A), and _carriage return_ (U+0D).

​[space](#text-space)​::=​(‘’ ∣ [format](#text-format) ∣ [comment](#text-comment) ∣ [annot](#text-annot))∗0.8ex\]​[format](#text-format)​::=​[newline](#text-newline) ∣ U+090.8ex\]​[newline](#text-newline)​::=​U+0A ∣ U+0D ∣ U+0D U+0A​​

The only relevance of white space is to separate [tokens](#text-token). It is otherwise ignored.

#### 6.2.4. Comments[](#comments①)

A _comment_ can either be a _line comment_, started with a double semicolon ‘;;’ and extending to the end of the line, or a _block comment_, enclosed in delimiters ‘(;’…‘;)’. Block comments can be nested.

​[comment](#text-comment)[linechar](#text-comment)[blockchar](#text-comment)​::=::=::=∣∣∣​[linecomment](#text-comment) ∣ [blockcomment](#text-comment)0.8ex\]c:[char](#text-char)c:[char](#text-char)‘;’+ c:[char](#text-char)‘(’+ c:[char](#text-char)[blockcomment](#text-comment)​[linecomment](#text-comment)if c\=U+0A∧c\=U+0D0.8ex\]if c\=‘;’∧c\=‘(’if c\=‘;’∧c\=‘)’if c\=‘;’∧c\=‘(’​::=[blockcomment](#text-comment)‘;;’ [linechar](#text-comment)∗ ([newline](#text-newline) ∣ [eof](#text-eof))::=‘(;’ [blockchar](#text-comment)∗ ‘;)’​

Here, the pseudo token [eof](#text-eof) indicates the end of the input. The _look-ahead_ restrictions on the productions for [blockchar](#text-comment) disambiguate the grammar such that only well-bracketed uses of block comment delimiters are allowed.

Note

Any formatting and control characters are allowed inside comments.

#### 6.2.5. Annotations[](#annotations①)

An _annotation_ is a bracketed token sequence headed by an _annotation id_ of the form ‘@id’ or ‘@’’...’’’. No [space](#text-space) is allowed between the opening parenthesis and this id. Annotations are intended to be used for third-party extensions; they can appear anywhere in a program but are ignored by the WebAssembly semantics itself, which treats them as [white space](#text-space).

Annotations can contain other parenthesized token sequences (including nested annotations), as long as they are well-nested. [String literals](#text-string) and [comments](#text-comment) occurring in an annotation must also be properly nested and closed.

​[annot](#text-annot)​::=​‘(@’ [annotid](#text-annot) ([space](#text-space) ∣ [token](#text-token))∗ ‘)’0.8ex\]​[annotid](#text-annot)​::=​[idchar](#text-idchar)+ ∣ [name](#text-name)​​

Note

The annotation id is meant to be an identifier categorising the extension, and plays a role similar to the name of a [custom section](#binary-customsec). By convention, annotations corresponding to a custom section should use the custom section’s name as an id.

Implementations are expected to ignore annotations with ids that they do not recognize. On the other hand, they may impose restrictions on annotations that they do recognize, e.g., requiring a specific structure by superimposing a more concrete grammar. It is up to an implementation how it deals with errors in such annotations.

### 6.3. Values[](#values①⓪)

The grammar productions in this section define _lexical syntax_, hence no [white space](#text-space) is allowed.

#### 6.3.1. Integers[](#integers⑦)

All [integers](#syntax-int) can be written in either decimal or hexadecimal notation. In both cases, digits can optionally be separated by underscores.

​[sign](#text-sign)[hexdigit](#text-hexdigit)[hexnum](#text-hexnum)​::=::=∣∣∣::=∣​ϵ ⇒ +1 ∣ ‘+’ ⇒ +1 ∣ ‘\-’ ⇒ −10.8ex\]d:[digit](#text-digit) ⇒ d‘A’ ⇒ 10 ∣ … ∣ ‘F’ ⇒ 15‘a’ ⇒ 10 ∣ … ∣ ‘f’ ⇒ 150.8ex\]n:[num](#text-num) ‘\_’? d:[digit](#text-digit)h:[hexdigit](#text-hexdigit)n:[hexnum](#text-hexnum) ‘\_’? h:[hexdigit](#text-hexdigit)​[digit](#text-digit)[num](#text-num)⇒⇒⇒​::=::=10n+dh16n+h​‘0’ ⇒ 0 ∣ … ∣ ‘9’ ⇒ 9d:[digit](#text-digit)​⇒​d​​

The allowed syntax for integer literals depends on size and signedness. Moreover, their value must lie within the range of the respective type.

​[u](#text-int)N[s](#text-int)N​::=∣::=​n:[num](#text-num)‘0x’ n:[hexnum](#text-hexnum)s:[sign](#text-sign) n:[u](#text-int)N​⇒⇒⇒​nns⋅n​if n<2Nif n<2Nif −2N−1≤s⋅n<2N−1​​

[Uninterpreted integers](#syntax-int) can be written as either signed or unsigned, and are normalized to unsigned in the abstract syntax.

​[i](#text-int)N​::=∣​n:[u](#text-int)Ni:[s](#text-int)N​⇒⇒​n[signed](#aux-signed)N−1​(i)​​

#### 6.3.2. Floating-Point[](#floating-point⑦)

[Floating-point](#syntax-float) values can be represented in either decimal or hexadecimal notation.

​[frac](#text-frac)[hexfrac](#text-hexfrac)[hexmant](#text-hexmant)[hexfloat](#text-hexfloat)​::=∣::=∣∣::=∣::=​d:[digit](#text-digit)d:[digit](#text-digit) ‘\_’? p:[frac](#text-frac)h:[hexdigit](#text-hexdigit)h:[hexdigit](#text-hexdigit) ‘\_’? p:[hexfrac](#text-hexfrac)p:[num](#text-num) ‘.’ q:[frac](#text-frac)p:[hexnum](#text-hexnum) ‘.’?p:[hexnum](#text-hexnum) ‘.’ q:[hexfrac](#text-hexfrac)‘0x’ p:[hexmant](#text-hexmant) (‘P’ ∣ ‘p’) s:[sign](#text-sign) e:[num](#text-num)​⇒⇒⇒⇒⇒⇒⇒⇒​d/10(d+p/10)/10h/16(h+p/16)/160.8ex\]p+qpp+q0.8ex\]p⋅2s⋅e​[mant](#text-mant)[float](#text-float)​::=::=​p:[num](#text-num) ‘.’?p:[mant](#text-mant) (‘E’ ∣ ‘e’) s:[sign](#text-sign) e:[num](#text-num)​⇒⇒​pp⋅10s⋅e​​

The value of a literal must not lie outside the representable range of the corresponding [\[IEEE-754-2019\]](#biblio-ieee-754-2019 "IEEE Standard for Floating-Point Arithmetic") type (that is, a numeric value must not overflow to ±∞), but it may be [rounded](#aux-ieee) to the nearest representable value.

Note

Rounding can be prevented by using hexadecimal notation with no more significant bits than supported by the required type.

Floating-point values may also be written as constants for _infinity_ or _canonical NaN_ (_not a number_). Furthermore, arbitrary NaN values may be expressed by providing an explicit payload value.

​[f](#text-int)N[fNmag](#text-float)​::=∣::=∣∣∣∣​(+1):[sign](#text-sign) q:[fNmag](#text-float)(−1):[sign](#text-sign) q:[fNmag](#text-float)q:[float](#text-float)q:[hexfloat](#text-hexfloat)‘inf’‘nan’‘nan:0x’ n:[hexnum](#text-hexnum)​⇒⇒⇒⇒⇒⇒⇒​+q−q[float](#aux-ieee)N​(q)[float](#aux-ieee)N​(q)∞[nan](#syntax-float)([canon](#aux-canon)N​)[nan](#syntax-float)(n)​if [float](#aux-ieee)N​(q)\=∞if [float](#aux-ieee)N​(q)\=∞if 1≤n<2[signif](#aux-signif)(N)​​

#### 6.3.3. Strings[](#strings①)

_Strings_ denote sequences of bytes that can represent both textual and binary data. They are enclosed in quotation marks and may contain any character other than [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d) control characters, quotation marks (‘’’’), or backslash (‘\\’), except when expressed with an _escape sequence_.

​[string](#text-string)​::=∣​‘’’’ (b∗:[stringelem](#text-string))∗ ‘’’’‘\\’ h1​:[hexdigit](#text-hexdigit) h2​:[hexdigit](#text-hexdigit)​⇒⇒​[⨁](#notation-concat)b∗∗16h1​+h2​​if ∣[⨁](#notation-concat)b∗∗∣<2320.8ex\][stringelem](#text-string)::=c:[stringchar](#text-string)⇒[utf8](#binary-utf8)(c)​

Each character in a string literal represents the byte sequence corresponding to its UTF-8 [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 2.5) encoding, except for hexadecimal escape sequences ‘\\hh’, which represent raw bytes of the respective value.

​[stringchar](#text-string)​::=∣∣∣∣∣∣∣​c:[char](#text-char)‘\\t’‘\\n’‘\\r’‘\\’’’‘\\’’‘\\\\’‘\\u{’ n:[hexnum](#text-hexnum) ‘}’​⇒⇒⇒⇒⇒⇒⇒⇒​cU+09U+0AU+0DU+22U+27U+5Cn​if c≥U+20∧c\=U+7F∧c\=‘’’’∧c\=‘\\’if n<0xD800∨0xE800≤n<0x110000​​

#### 6.3.4. Names[](#names⑤)

[Names](#syntax-name) are strings denoting a literal character sequence. A name string must form a valid UTF-8 encoding as defined by [\[UNICODE\]](#biblio-unicode "The Unicode Standard") (Section 2.5) and is interpreted as a string of Unicode scalar values.

​[name](#text-name)​::=​b∗:[string](#text-string)​⇒​c∗​if b∗\=[utf8](#binary-utf8)(c∗)​​

Note

Presuming the source text is itself encoded correctly, strings that do not contain any uses of hexadecimal byte escapes are always valid names.

#### 6.3.5. Identifiers[](#identifiers①)

[Indices](#syntax-index) can be given in both numeric and symbolic form. Symbolic _identifiers_ that stand in lieu of indices start with ‘$’, followed by either a sequence of printable [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d) characters that does not contain a space, quotation mark, comma, semicolon, or bracket, or by a quoted [name](#text-name).

​[id](#text-id)[idchar](#text-idchar)​::=∣::=∣∣∣∣​‘$’ c∗:[idchar](#text-idchar)+‘$’ c∗:[name](#text-name)‘0’ ∣ … ∣ ‘9’‘A’ ∣ … ∣ ‘Z’‘a’ ∣ … ∣ ‘z’‘!’ ∣ ‘#’ ∣ ‘$’ ∣ ‘%’ ∣ ‘&’ ∣ ‘’’ ∣ ‘\*’ ∣ ‘+’ ∣ ‘\-’ ∣ ‘.’ ∣ ‘/’‘:’ ∣ ‘<’ ∣ ‘\=’ ∣ ‘\>’ ∣ ‘?’ ∣ ‘@’ ∣ ‘\\’ ∣ ‘ ^’ ∣ ‘\_’ ∣ ‘ ˋ’ ∣ ‘|’ ∣ ‘ ~’​⇒⇒c∗c∗if ∣c∗∣\>0​

Note

The value of an identifier character is the Unicode codepoint denoting it.

##### 6.3.5.1. Conventions[](#conventions③⑥)

The expansion rules of some abbreviations require insertion of a _fresh_ identifier. That may be any syntactically valid identifier that does not already occur in the given source text.

### 6.4. Types[](#types①⑤)

#### 6.4.1. Number Types[](#number-types⑨)

​[numtype](#text-numtype)​::=∣∣∣​‘i32’‘i64’‘f32’‘f64’​⇒⇒⇒⇒​[i32](#syntax-numtype)[i64](#syntax-numtype)[f32](#syntax-numtype)[f64](#syntax-numtype)​​

#### 6.4.2. Vector Types[](#vector-types⑨)

​[vectype](#text-vectype)​::=​‘v128’​⇒​[v128](#syntax-vectype)​​

#### 6.4.3. Heap Types[](#heap-types⑨)

​[absheaptype](#text-absheaptype)​::=∣∣∣∣∣∣∣∣∣∣∣∣​‘any’‘eq’‘i31’‘struct’‘array’‘none’‘func’‘nofunc’‘exn’‘noexn’‘extern’‘noextern’x:[typeidx](#text-typeidx)[I](#text-context)​​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[any](#syntax-heaptype)[eq](#syntax-heaptype)[i31](#syntax-heaptype)[struct](#syntax-heaptype)[array](#syntax-heaptype)[none](#syntax-heaptype)[func](#syntax-heaptype)[nofunc](#syntax-heaptype)[exn](#syntax-heaptype)[noexn](#syntax-heaptype)[extern](#syntax-heaptype)[noextern](#syntax-heaptype)0.8ex\]x​[heaptype](#text-heaptype)[I](#text-context)​​::=​ht:[absheaptype](#text-absheaptype)​⇒​ht​​

#### 6.4.4. Reference Types[](#reference-types⑨)

​[null](#text-null)​::=​‘null’​⇒​[null](#syntax-reftype)0.8ex\]​[reftype](#text-reftype)[I](#text-context)​​::=​‘(’ ‘ref’ [null](#syntax-reftype)?:[null](#text-null)? ht:[heaptype](#text-heaptype)[I](#text-context)​ ‘)’​⇒​[ref](#syntax-reftype) [null](#syntax-reftype)? ht​​

##### 6.4.4.1. Abbreviations[](#abbreviations③)

There are shorthands for references to abstract heap types.

​[reftype](#text-reftype)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣​…‘anyref’‘eqref’‘i31ref’‘structref’‘arrayref’‘nullref’‘funcref’‘nullfuncref’‘exnref’‘nullexnref’‘externref’‘nullexternref’​≡≡≡≡≡≡≡≡≡≡≡≡​‘(’ ‘ref’ ‘null’ ‘any’ ‘)’‘(’ ‘ref’ ‘null’ ‘eq’ ‘)’‘(’ ‘ref’ ‘null’ ‘i31’ ‘)’‘(’ ‘ref’ ‘null’ ‘struct’ ‘)’‘(’ ‘ref’ ‘null’ ‘array’ ‘)’‘(’ ‘ref’ ‘null’ ‘none’ ‘)’‘(’ ‘ref’ ‘null’ ‘func’ ‘)’‘(’ ‘ref’ ‘null’ ‘nofunc’ ‘)’‘(’ ‘ref’ ‘null’ ‘exn’ ‘)’‘(’ ‘ref’ ‘null’ ‘noexn’ ‘)’‘(’ ‘ref’ ‘null’ ‘extern’ ‘)’‘(’ ‘ref’ ‘null’ ‘noextern’ ‘)’​​

#### 6.4.5. Value Types[](#value-types⑨)

​[valtype](#text-valtype)[I](#text-context)​​::=∣∣​nt:[numtype](#text-numtype)vt:[vectype](#text-vectype)rt:[reftype](#text-reftype)[I](#text-context)​​⇒⇒⇒​ntvtrt​​

#### 6.4.6. Composite Types[](#composite-types⑨)

Composite types are parsed into their respective abstract representation, paired with the local [identifier context](#text-context) generated by their bound field or parameter identifiers:

​[comptype](#text-comptype)[I](#text-context)​[param](#text-comptype)[I](#text-context)​[result](#text-comptype)[I](#text-context)​​::=∣∣::=::=∣∣∣​‘(’ ‘struct’ (ft,id?)∗:[list](#text-list)([field](#text-comptype)[I](#text-context)​) ‘)’‘(’ ‘array’ ft:[fieldtype](#text-fieldtype)[I](#text-context)​ ‘)’‘(’ ‘func’ (t1​,id?)∗:[list](#text-list)([param](#text-comptype)[I](#text-context)​) t2∗​:[list](#text-list)([result](#text-comptype)[I](#text-context)​) ‘)’‘(’ ‘param’ id?:[id](#text-id)? t:[valtype](#text-valtype)[I](#text-context)​ ‘)’‘(’ ‘result’ t:[valtype](#text-valtype)[I](#text-context)​ ‘)’‘(’ ‘mut’ zt:[storagetype](#text-storagetype)[I](#text-context)​ ‘)’pt:[packtype](#text-packtype)‘i16’​⇒⇒⇒⇒⇒⇒⇒⇒​([struct](#syntax-comptype) ft∗,{[fields](#text-context) (id?)∗})([array](#syntax-comptype) ft,{})([func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​,{})0.8ex\](t,id?)t0.8ex\][mut](#syntax-mut) zt0.8ex\]pt0.8ex\][i16](#syntax-storagetype)​[field](#text-comptype)[I](#text-context)​[fieldtype](#text-fieldtype)[I](#text-context)​[storagetype](#text-storagetype)[I](#text-context)​[packtype](#text-packtype)​::=::=::=::=​‘(’ ‘field’ id?:[id](#text-id)? ft:[fieldtype](#text-fieldtype)[I](#text-context)​ ‘)’zt:[storagetype](#text-storagetype)[I](#text-context)​t:[valtype](#text-valtype)[I](#text-context)​‘i8’​⇒⇒⇒⇒​(ft,id?)ztt[i8](#syntax-storagetype)​​

Note

The optional identifier names for parameters in a function type only have documentation purpose. They cannot be referenced from anywhere.

##### 6.4.6.1. Abbreviations[](#abbreviations④)

Multiple anonymous structure fields or parameters or multiple results may be combined into a single declaration:

​[field](#text-comptype)[I](#text-context)​[param](#text-comptype)[I](#text-context)​[result](#text-comptype)[I](#text-context)​​::=::=::=​… ∣ ‘(’ ‘field’ [fieldtype](#text-fieldtype)[I](#text-context)∗​ ‘)’… ∣ ‘(’ ‘param’ [valtype](#text-valtype)[I](#text-context)∗​ ‘)’… ∣ ‘(’ ‘result’ [valtype](#text-valtype)[I](#text-context)∗​ ‘)’​≡≡≡​(‘(’ ‘field’ [fieldtype](#text-fieldtype)[I](#text-context)​ ‘)’)∗(‘(’ ‘param’ [valtype](#text-valtype)[I](#text-context)​ ‘)’)∗(‘(’ ‘param’ [valtype](#text-valtype)[I](#text-context)​ ‘)’)∗​​

#### 6.4.7. Recursive Types[](#recursive-types⑦)

Recursive types are parsed into their respective abstract representation, paired with the [identifier context](#text-context) generated by their bound identifiers:

​[final](#text-final)​::=​‘final’​⇒​[final](#syntax-subtype)0.8ex\]​[subtype](#text-subtype)[I](#text-context)​​::=​‘(’ ‘sub’ fin?:[final](#text-final)? x∗:[list](#text-list)([typeidx](#text-typeidx)[I](#text-context)​) (ct,[I](#text-context)′):[comptype](#text-comptype)[I](#text-context)​ ‘)’​⇒​([sub](#syntax-subtype) fin? x∗ ct,[I](#text-context)′)0.8ex\]​[typedef](#text-typedef)[I](#text-context)​​::=​‘(’ ‘type’ id?:[id](#text-id)? (st,[I](#text-context)′):[subtype](#text-subtype)[I](#text-context)​ ‘)’​⇒​(st,[I](#text-context)′⊕{[types](#text-context) (id?)})0.8ex\]​[rectype](#text-rectype)[I](#text-context)​​::=​‘(’ ‘rec’ (st,[I](#text-context)′)∗:[list](#text-list)([typedef](#text-typedef)[I](#text-context)​) ‘)’​⇒​([rec](#syntax-rectype) st∗,[⨁](#notation-concat)[I](#text-context)′∗)​​

##### 6.4.7.1. Abbreviations[](#abbreviations⑤)

Final sub types with no super-types can omit the ‘sub’ keyword and its arguments:

​[subtype](#text-subtype)[I](#text-context)​​::=​… ∣ [comptype](#text-comptype)[I](#text-context)​​≡​‘(’ ‘sub’ ‘final’ [comptype](#text-comptype)[I](#text-context)​ ‘)’​​

Similarly, singular recursive types can omit the ‘rec’ keyword:

​[rectype](#text-rectype)[I](#text-context)​​::=​… ∣ [typedef](#text-typedef)[I](#text-context)​​≡​‘(’ ‘rec’ [typedef](#text-typedef)[I](#text-context)​ ‘)’​​

#### 6.4.8. Address Types[](#address-types③)

​[addrtype](#text-addrtype)​::=∣​‘i32’‘i64’​⇒⇒​[i32](#syntax-numtype)[i64](#syntax-numtype)​​

##### 6.4.8.1. Abbreviations[](#abbreviations⑥)

The address type can be omitted, in which case it defaults [i32](#syntax-numtype):

​[addrtype](#text-addrtype)​::=​… ∣ ϵ​≡​‘i32’​​

#### 6.4.9. Limits[](#limits⑨)

​[limits](#text-limits)​::=∣​n:[u64](#text-int)n:[u64](#text-int) m:[u64](#text-int)​⇒⇒​\[n[..](#syntax-limits)ϵ\]\[n[..](#syntax-limits)m\]​​

#### 6.4.10. Tag Types[](#tag-types⑨)

​[tagtype](#text-tagtype)[I](#text-context)​​::=​(x,[I](#text-context)′):[typeuse](#text-typeuse)[I](#text-context)​​⇒​x​​

#### 6.4.11. Global Types[](#global-types⑨)

​[globaltype](#text-globaltype)[I](#text-context)​​::=∣​t:[valtype](#text-valtype)[I](#text-context)​‘(’ ‘mut’ t:[valtype](#text-valtype)[I](#text-context)​ ‘)’​⇒⇒​t[mut](#syntax-mut) t​​

#### 6.4.12. Memory Types[](#memory-types⑨)

​[memtype](#text-memtype)[I](#text-context)​​::=​at:[addrtype](#text-addrtype) lim:[limits](#text-limits)​⇒​at lim [page](#syntax-memtype)​​

#### 6.4.13. Table Types[](#table-types⑨)

​[tabletype](#text-tabletype)[I](#text-context)​​::=​at:[addrtype](#text-addrtype) lim:[limits](#text-limits) rt:[reftype](#text-reftype)[I](#text-context)​​⇒​at lim rt​​

#### 6.4.14. External Types[](#external-types⑨)

​[externtype](#text-externtype)[I](#text-context)​​::=∣∣∣∣​‘(’ ‘tag’ id?:[id](#text-id)? jt:[tagtype](#text-tagtype)[I](#text-context)​ ‘)’‘(’ ‘global’ id?:[id](#text-id)? gt:[globaltype](#text-globaltype)[I](#text-context)​ ‘)’‘(’ ‘memory’ id?:[id](#text-id)? mt:[memtype](#text-memtype)[I](#text-context)​ ‘)’‘(’ ‘table’ id?:[id](#text-id)? tt:[tabletype](#text-tabletype)[I](#text-context)​ ‘)’‘(’ ‘func’ id?:[id](#text-id)? (x,[I](#text-context)′):[typeuse](#text-typeuse)[I](#text-context)​ ‘)’​⇒⇒⇒⇒⇒​([tag](#syntax-externtype) jt,{[tags](#text-context) (id?)})([global](#syntax-externtype) gt,{[globals](#text-context) (id?)})([mem](#syntax-externtype) mt,{[mems](#text-context) (id?)})([table](#syntax-externtype) tt,{[tables](#text-context) (id?)})([func](#syntax-externtype) x,{[funcs](#text-context) (id?)})​​

#### 6.4.15. Type Uses[](#type-uses⑤)

A _type use_ is a reference to a [type definition](#text-type). Where it is required to reference a [function type](#text-functype), it may optionally be augmented by explicit inlined [parameter](#text-param) and [result](#text-result) declarations. That allows binding symbolic [identifiers](#text-id) to name the [local indices](#text-localidx) of parameters. If inline declarations are given, then their types must match the referenced [function type](#text-type).

​[typeuse](#text-typeuse)[I](#text-context)​​::=∣​‘(’ ‘type’ x:[typeidx](#text-typeidx)[I](#text-context)​ ‘)’if [I](#text-context).[typedefs](#text-context)\[x\]\=([rec](#syntax-rectype) st∗).i∧ st∗\[i\]\=[sub](#syntax-subtype) [final](#syntax-subtype) ([func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​)∧ [I](#text-context)′\={[locals](#text-context) (ϵ)∣t1∗​∣}​‘(’ ‘type’ x:[typeidx](#text-typeidx)[I](#text-context)​ ‘)’ (t1​,id?)∗:[param](#text-comptype)[I](#text-context)∗​ t2∗​:[result](#text-comptype)[I](#text-context)∗​if [I](#text-context).[typedefs](#text-context)\[x\]\=([rec](#syntax-rectype) st∗).i∧ st∗\[i\]\=[sub](#syntax-subtype) [final](#syntax-subtype) ([func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​)∧ [I](#text-context)′\={[locals](#text-context) (id?)∗}∧ ⊢[I](#text-context)′:ok​​⇒⇒​(x,[I](#text-context)′)(x,[I](#text-context)′)​​​

Note

If inline declarations are given, their types must be _syntactically_ equal to the types from the indexed definition; possible type [substitutions](#notation-subst) from other definitions that might make them equal are not taken into account. This is to simplify syntactic pre-processing.

The synthesized attribute of a typeuse is a pair consisting of both the used [type index](#syntax-typeidx) and the local [identifier context](#text-context) containing possible parameter identifiers.

Note

Both productions overlap for the case that the function type is [func](#syntax-comptype) ϵ[→](#syntax-comptype)ϵ. However, in that case, they also produce the same results, so that the choice is immaterial.

The [well-formedness](#text-context-wf) condition on [I](#text-context)′ ensures that the parameters do not contain duplicate identifiers.

##### 6.4.15.1. Abbreviations[](#abbreviations⑦)

A type use may also be replaced entirely by inline [parameter](#text-param) and [result](#text-result) declarations. In that case, a [type index](#syntax-typeidx) is automatically inserted:

​[typeuse](#text-typeuse)[I](#text-context)​​::=​… ∣ (t1​,id?)∗:[param](#text-comptype)[I](#text-context)∗​ t2∗​:[result](#text-comptype)[I](#text-context)∗​if [I](#text-context).[typedefs](#text-context)\[x\]\=([rec](#syntax-rectype) ([sub](#syntax-subtype) [final](#syntax-subtype) ([func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​))).0∧ ([I](#text-context).[typedefs](#text-context)\[i\]\=([rec](#syntax-rectype) ([sub](#syntax-subtype) [final](#syntax-subtype) ([func](#syntax-comptype) t1∗​[→](#syntax-comptype)t2∗​))).0)i<x​​≡‘(’ ‘type’ x:[typeidx](#text-typeidx)[I](#text-context)​ ‘)’ [param](#text-comptype)[I](#text-context)∗​ [result](#text-comptype)[I](#text-context)∗​​

where x is the smallest existing [type index](#syntax-typeidx) whose [recursive type](#syntax-rectype) definition parses into a singular, final [function type](#syntax-functype) with the same parameters and results. If no such index exists, then a new [recursive type](#text-rectype) of the same form is inserted at the end of the module.

Abbreviations are expanded in the order they appear, such that previously inserted type definitions are reused by consecutive expansions.

### 6.5. Instructions[](#instructions⑨)

Instructions are syntactically distinguished into _plain_ and _structured_ instructions.

​[instr](#text-instr)[I](#text-context)​[instrs](#text-instrs)[I](#text-context)​​::=∣::=​in:[plaininstr](#text-plaininstr)[I](#text-context)​in:[blockinstr](#text-blockinstr)[I](#text-context)​in∗:[instr](#text-instr)[I](#text-context)∗​​⇒⇒⇒​ininin∗​​

In addition, as a syntactic abbreviation, instructions can be written as S-expressions in [folded](#text-foldedinstr) form, to group them visually.

#### 6.5.1. Labels[](#labels③)

[Structured control instructions](#text-instr-control) can be annotated with a symbolic [label identifier](#text-id). They are the only [symbolic identifiers](#text-index) that can be bound locally in an instruction sequence. The following grammar handles the corresponding update to the [identifier context](#text-context) by [composing](#notation-compose) the context with an additional label entry.

​[label](#text-label)[I](#text-context)​​::=∣∣​ϵid:[id](#text-id)id:[id](#text-id)​⇒⇒⇒​(ϵ,{[labels](#text-context) ϵ}⊕[I](#text-context))(id,{[labels](#text-context) id}⊕[I](#text-context))(id,{[labels](#text-context) id}⊕[I](#text-context)\[.[labels](#text-context)\[x\]\=ϵ\])​if id∈/[I](#text-context).[labels](#text-context)if id\=[I](#text-context).[labels](#text-context)\[x\]​​

Note

The new label entry is inserted at the _beginning_ of the label list in the identifier context. This effectively shifts all existing labels up by one, mirroring the fact that control instructions are indexed relatively not absolutely.

If a label with the same name already exists, then it is shadowed and the earlier label becomes inaccessible.

#### 6.5.2. Parametric Instructions[](#parametric-instructions⑨)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣​‘unreachable’‘nop’‘drop’‘select’ (t∗:[result](#text-comptype)[I](#text-context)∗​)?​⇒⇒⇒⇒​[unreachable](#syntax-instr-control)[nop](#syntax-instr-control)[drop](#syntax-instr-parametric)[select](#syntax-instr-parametric) (t∗)?​​

#### 6.5.3. Control Instructions[](#control-instructions⑨)

[Structured control instructions](#syntax-instr-control) can bind an optional symbolic [label identifier](#text-label). The same label identifier may optionally be repeated after the corresponding ‘end’ or ‘else’ keywords, to indicate the matching delimiters.

Their [block type](#syntax-blocktype) is given as a [type use](#text-typeuse), analogous to the type of [functions](#text-func). However, the special case of a type use that is syntactically empty or consists of only a single [result](#text-result) is not regarded as an [abbreviation](#text-typeuse-abbrev) for an inline [function type](#syntax-functype), but is parsed directly into an optional [value type](#syntax-valtype).

​[blocktype](#text-blocktype)[I](#text-context)​​::=∣∣∣∣∣∣∣​t?:[result](#text-comptype)[I](#text-context)?​(x,[I](#text-context)′):[typeuse](#text-typeuse)[I](#text-context)​if [I](#text-context)′\={[locals](#text-context) (ϵ)∗}0.8ex\]if id′?\=ϵ∨id′?\=id?‘loop’ (id?,[I](#text-context)′):[label](#text-label)[I](#text-context)​ bt:[blocktype](#text-blocktype)[I](#text-context)​in∗:[instrs](#text-instrs)[I](#text-context)′​‘end’ id′?:[id](#text-id)?​if id′?\=ϵ∨id′?\=id?‘if’ (id?,[I](#text-context)′):[label](#text-label)[I](#text-context)​ bt:[blocktype](#text-blocktype)[I](#text-context)​in1∗​:[instrs](#text-instrs)[I](#text-context)′​‘else’ id1?​:[id](#text-id)?in2∗​:[instrs](#text-instrs)[I](#text-context)′​‘end’ id2?​:[id](#text-id)?​if (id1?​\=ϵ∨id1?​\=id?)∧(id2?​\=ϵ∨id2?​\=id?)‘try\_table’ (id?,[I](#text-context)′):[label](#text-label)[I](#text-context)​ bt:[blocktype](#text-blocktype)[I](#text-context)​c∗:[catch](#text-catch)[I](#text-context)∗​in∗:[instrs](#text-instrs)[I](#text-context)′​‘end’ id′?:[id](#text-id)?​if id′?\=ϵ∨id′?\=id?0.8ex\]‘(’ ‘catch\_ref’ x:[tagidx](#text-tagidx)[I](#text-context)​ l:[labelidx](#text-labelidx)[I](#text-context)​ ‘)’‘(’ ‘catch\_all’ l:[labelidx](#text-labelidx)[I](#text-context)​ ‘)’‘(’ ‘catch\_all\_ref’ l:[labelidx](#text-labelidx)[I](#text-context)​ ‘)’​⇒⇒[blockinstr](#text-blockinstr)[I](#text-context)​⇒⇒⇒[catch](#text-catch)[I](#text-context)​⇒⇒⇒​t?x::=[loop](#syntax-instr-control) bt in∗[if](#syntax-instr-control) bt in1∗​ [else](#syntax-instr-control) in2∗​[try\_table](#syntax-instr-control) bt c∗ in∗::=[catch\_ref](#syntax-instr-control) x l[catch\_all](#syntax-instr-control) l[catch\_all\_ref](#syntax-instr-control) l​‘block’ (id?,[I](#text-context)′):[label](#text-label)[I](#text-context)​ bt:[blocktype](#text-blocktype)[I](#text-context)​in∗:[instrs](#text-instrs)[I](#text-context)′​‘end’ id′?:[id](#text-id)?​‘(’ ‘catch’ x:[tagidx](#text-tagidx)[I](#text-context)​ l:[labelidx](#text-labelidx)[I](#text-context)​ ‘)’​⇒⇒​[block](#syntax-instr-control) bt in∗[catch](#syntax-instr-control) x l​​

Note

The side condition stating that the [identifier context](#text-context) [I](#text-context)′ must only contain unnamed entries in the rule for typeuse block types enforces that no identifier can be bound in any param declaration for a block type.

All other control instruction are represented verbatim.

Note

The side condition stating that the [identifier context](#text-context) [I](#text-context)′ must only contain unnamed entries in the rule for [call\_indirect](#syntax-instr-control) enforces that no identifier can be bound in any [param](#text-comptype) declaration appearing in the type annotation.

##### 6.5.3.1. Abbreviations[](#abbreviations⑨)

The ‘else’ keyword of an ‘if’ instruction can be omitted if the following instruction sequence is empty.

​[blockinstr](#text-blockinstr)[I](#text-context)​​::=∣​…‘if’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)​ ‘end’ [id](#text-id)?‘if’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)​ ‘else’ ‘end’ [id](#text-id)?​​≡​​​​

Also, for backwards compatibility, the table index to ‘call\_indirect’ and ‘return\_call\_indirect’ can be omitted, defaulting to 0.

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣​…‘call\_indirect’ [typeuse](#text-typeuse)[I](#text-context)​‘return\_call\_indirect’ [typeuse](#text-typeuse)[I](#text-context)​​≡≡​‘call\_indirect’ ‘0’ [typeuse](#text-typeuse)[I](#text-context)​‘return\_call\_indirect’ ‘0’ [typeuse](#text-typeuse)[I](#text-context)​​​

#### 6.5.4. Variable Instructions[](#variable-instructions⑨)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣​…‘local.get’ x:[localidx](#text-localidx)[I](#text-context)​‘local.set’ x:[localidx](#text-localidx)[I](#text-context)​‘local.tee’ x:[localidx](#text-localidx)[I](#text-context)​‘global.get’ x:[globalidx](#text-globalidx)[I](#text-context)​‘global.set’ x:[globalidx](#text-globalidx)[I](#text-context)​​⇒⇒⇒⇒⇒​[local.get](#syntax-instr-variable) x[local.set](#syntax-instr-variable) x[local.tee](#syntax-instr-variable) x[global.get](#syntax-instr-variable) x[global.set](#syntax-instr-variable) x​​

#### 6.5.5. Table Instructions[](#table-instructions⑨)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣​…‘table.get’ x:[tableidx](#text-tableidx)[I](#text-context)​‘table.set’ x:[tableidx](#text-tableidx)[I](#text-context)​‘table.size’ x:[tableidx](#text-tableidx)[I](#text-context)​‘table.grow’ x:[tableidx](#text-tableidx)[I](#text-context)​‘table.fill’ x:[tableidx](#text-tableidx)[I](#text-context)​‘table.copy’ x1​:[tableidx](#text-tableidx)[I](#text-context)​ x2​:[tableidx](#text-tableidx)[I](#text-context)​‘table.init’ x:[tableidx](#text-tableidx)[I](#text-context)​ y:[elemidx](#text-elemidx)[I](#text-context)​‘elem.drop’ x:[elemidx](#text-elemidx)[I](#text-context)​​⇒⇒⇒⇒⇒⇒⇒⇒​[table.get](#syntax-instr-table) x[table.set](#syntax-instr-table) x[table.size](#syntax-instr-table) x[table.grow](#syntax-instr-table) x[table.fill](#syntax-instr-table) x[table.copy](#syntax-instr-table) x1​ x2​[table.init](#syntax-instr-table) x y[elem.drop](#syntax-instr-table) x​​

##### 6.5.5.1. Abbreviations[](#abbreviations①⓪)

For backwards compatibility, all [table indices](#syntax-tableidx) may be omitted from table instructions, defaulting to 0.

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣​…‘table.get’‘table.set’‘table.size’‘table.grow’‘table.fill’‘table.copy’‘table.init’ [elemidx](#text-elemidx)[I](#text-context)​​≡≡≡≡≡≡≡​‘table.get’ ‘0’‘table.set’ ‘0’‘table.size’ ‘0’‘table.grow’ ‘0’‘table.fill’ ‘0’‘table.copy’ ‘0’ ‘0’‘table.init’ ‘0’ [elemidx](#text-elemidx)[I](#text-context)​​​

#### 6.5.6. Memory Instructions[](#memory-instructions⑨)

The offset and alignment immediates to memory instructions are optional. The offset defaults to 0, the alignment to the storage size of the respective memory access, which is its _natural alignment_. Lexically, an [offset](#text-memarg) or [align](#text-memarg) phrase is considered a single [keyword token](#text-keyword), so no [white space](#text-space) is allowed around the ‘\=’.

​[memarg](#text-memarg)N​[offset](#text-memarg)[align](#text-memarg)N​[laneidx](#text-laneidx)[plaininstr](#text-plaininstr)[I](#text-context)​​::=::=∣::=∣::=::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​n:[offset](#text-memarg) m:[align](#text-memarg)N​‘offset\=’ n:[u64](#text-int)ϵ‘align\=’ m:[u64](#text-int)ϵi:[u8](#text-int)…‘i32.load’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘i64.load’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘f32.load’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘f64.load’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘i32.load8\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i32.load8\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i32.load16\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i32.load16\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i64.load8\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i64.load8\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i64.load16\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i64.load16\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i64.load32\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘i64.load32\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘v128.load’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)16​‘v128.load8x8\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load8x8\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load16x4\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load16x4\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load32x2\_s’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load32x2\_u’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load8\_splat’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘v128.load16\_splat’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘v128.load32\_splat’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘v128.load64\_splat’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load32\_zero’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘v128.load64\_zero’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘v128.load8\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​ i:[laneidx](#text-laneidx)‘v128.load16\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​ i:[laneidx](#text-laneidx)‘v128.load32\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​ i:[laneidx](#text-laneidx)‘v128.load64\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​ i:[laneidx](#text-laneidx)‘i32.store’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘i64.store’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘f32.store’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘f64.store’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​‘i32.store8’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i32.store16’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i64.store8’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​‘i64.store16’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​‘i64.store32’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​‘v128.store’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)16​‘v128.store8\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)1​ i:[laneidx](#text-laneidx)‘v128.store16\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)2​ i:[laneidx](#text-laneidx)‘v128.store32\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)4​ i:[laneidx](#text-laneidx)‘v128.store64\_lane’ x:[memidx](#text-memidx)[I](#text-context)​ ao:[memarg](#text-memarg)8​ i:[laneidx](#text-laneidx)‘memory.size’ x:[memidx](#text-memidx)[I](#text-context)​‘memory.grow’ x:[memidx](#text-memidx)[I](#text-context)​‘memory.fill’ x:[memidx](#text-memidx)[I](#text-context)​‘memory.copy’ x1​:[memidx](#text-memidx)[I](#text-context)​ x2​:[memidx](#text-memidx)[I](#text-context)​‘memory.init’ x:[memidx](#text-memidx)[I](#text-context)​ y:[dataidx](#text-dataidx)[I](#text-context)​‘data.drop’ x:[dataidx](#text-dataidx)[I](#text-context)​​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​{[align](#syntax-instr-memory) n,[offset](#syntax-instr-memory) m}n0mNi[i32](#syntax-numtype).[load](#syntax-instr-memory) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory) x ao[f32](#syntax-numtype).[load](#syntax-instr-memory) x ao[f64](#syntax-numtype).[load](#syntax-instr-memory) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[s](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)16\_[s](#syntax-sx) x ao[i32](#syntax-numtype).[load](#syntax-instr-memory)16\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)8\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)8\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)16\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)16\_[u](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)32\_[s](#syntax-sx) x ao[i64](#syntax-numtype).[load](#syntax-instr-memory)32\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8[x](#syntax-shape)8\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8[x](#syntax-shape)8\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16[x](#syntax-shape)4\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16[x](#syntax-shape)4\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32[x](#syntax-shape)2\_[s](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32[x](#syntax-shape)2\_[u](#syntax-sx) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)16\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[splat](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[zero](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[zero](#syntax-instr-memory) x ao[v128](#syntax-vectype).[load](#syntax-instr-memory)8\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)16\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)32\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[load](#syntax-instr-memory)64\_[lane](#syntax-instr-memory) x ao i[i32](#syntax-numtype).[store](#syntax-instr-memory) x ao[i64](#syntax-numtype).[store](#syntax-instr-memory) x ao[f32](#syntax-numtype).[store](#syntax-instr-memory) x ao[f64](#syntax-numtype).[store](#syntax-instr-memory) x ao[i32](#syntax-numtype).[store](#syntax-instr-memory)8 x ao[i32](#syntax-numtype).[store](#syntax-instr-memory)16 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)8 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)16 x ao[i64](#syntax-numtype).[store](#syntax-instr-memory)32 x ao[v128](#syntax-vectype).[store](#syntax-instr-memory) x ao[v128](#syntax-vectype).[store](#syntax-instr-memory)8\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)16\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)32\_[lane](#syntax-instr-memory) x ao i[v128](#syntax-vectype).[store](#syntax-instr-memory)64\_[lane](#syntax-instr-memory) x ao i[memory.size](#syntax-instr-memory) x[memory.grow](#syntax-instr-memory) x[memory.fill](#syntax-instr-memory) x[memory.copy](#syntax-instr-memory) x1​ x2​[memory.init](#syntax-instr-memory) x y[data.drop](#syntax-instr-memory) x​if m\=2n​

##### 6.5.6.1. Abbreviations[](#abbreviations①①)

As an abbreviation, the memory index can be omitted in all memory instructions, defaulting to 0.

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i32.load’ [memarg](#text-memarg)4​‘i64.load’ [memarg](#text-memarg)8​‘f32.load’ [memarg](#text-memarg)4​‘f64.load’ [memarg](#text-memarg)8​‘i32.load8\_s’ [memarg](#text-memarg)1​‘i32.load8\_u’ [memarg](#text-memarg)1​‘i32.load16\_s’ [memarg](#text-memarg)2​‘i32.load16\_u’ [memarg](#text-memarg)2​‘i64.load8\_s’ [memarg](#text-memarg)1​‘i64.load8\_u’ [memarg](#text-memarg)1​‘i64.load16\_s’ [memarg](#text-memarg)2​‘i64.load16\_u’ [memarg](#text-memarg)2​‘i64.load32\_s’ [memarg](#text-memarg)4​‘i64.load32\_u’ [memarg](#text-memarg)4​‘v128.load’ [memarg](#text-memarg)16​‘v128.load8x8\_s’ [memarg](#text-memarg)8​‘v128.load8x8\_u’ [memarg](#text-memarg)8​‘v128.load16x4\_s’ [memarg](#text-memarg)8​‘v128.load16x4\_u’ [memarg](#text-memarg)8​‘v128.load32x2\_s’ [memarg](#text-memarg)8​‘v128.load32x2\_u’ [memarg](#text-memarg)8​‘v128.load8\_splat’ [memarg](#text-memarg)1​‘v128.load16\_splat’ [memarg](#text-memarg)2​‘v128.load32\_splat’ [memarg](#text-memarg)4​‘v128.load64\_splat’ [memarg](#text-memarg)8​‘v128.load32\_zero’ [memarg](#text-memarg)4​‘v128.load64\_zero’ [memarg](#text-memarg)8​‘v128.load8\_lane’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.load16\_lane’ [memarg](#text-memarg)2​ [laneidx](#text-laneidx)‘v128.load32\_lane’ [memarg](#text-memarg)4​ [laneidx](#text-laneidx)‘v128.load64\_lane’ [memarg](#text-memarg)8​ [laneidx](#text-laneidx)‘i32.store’ [memarg](#text-memarg)4​‘i64.store’ [memarg](#text-memarg)8​‘f32.store’ [memarg](#text-memarg)4​‘f64.store’ [memarg](#text-memarg)8​‘i32.store8’ [memarg](#text-memarg)1​‘i32.store16’ [memarg](#text-memarg)2​‘i64.store8’ [memarg](#text-memarg)1​‘i64.store16’ [memarg](#text-memarg)2​‘i64.store32’ [memarg](#text-memarg)4​‘v128.store’ [memarg](#text-memarg)16​‘v128.store8\_lane’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.store16\_lane’ [memarg](#text-memarg)2​ [laneidx](#text-laneidx)‘v128.store32\_lane’ [memarg](#text-memarg)4​ [laneidx](#text-laneidx)‘v128.store64\_lane’ [memarg](#text-memarg)8​ [laneidx](#text-laneidx)‘memory.size’‘memory.grow’‘memory.fill’‘memory.copy’‘memory.init’ [dataidx](#text-dataidx)[I](#text-context)​​≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡​‘i32.load’ ‘0’ [memarg](#text-memarg)4​‘i64.load’ ‘0’ [memarg](#text-memarg)8​‘f32.load’ ‘0’ [memarg](#text-memarg)4​‘f64.load’ ‘0’ [memarg](#text-memarg)8​‘i32.load8\_s’ ‘0’ [memarg](#text-memarg)1​‘i32.load8\_u’ ‘0’ [memarg](#text-memarg)1​‘i32.load16\_s’ ‘0’ [memarg](#text-memarg)2​‘i32.load16\_u’ ‘0’ [memarg](#text-memarg)2​‘i64.load8\_s’ ‘0’ [memarg](#text-memarg)1​‘i64.load8\_u’ ‘0’ [memarg](#text-memarg)1​‘i64.load16\_s’ ‘0’ [memarg](#text-memarg)2​‘i64.load16\_u’ ‘0’ [memarg](#text-memarg)2​‘i64.load32\_s’ ‘0’ [memarg](#text-memarg)4​‘i64.load32\_u’ ‘0’ [memarg](#text-memarg)4​‘v128.load’ ‘0’ [memarg](#text-memarg)16​‘v128.load8x8\_s’ ‘0’ [memarg](#text-memarg)8​‘v128.load8x8\_u’ ‘0’ [memarg](#text-memarg)8​‘v128.load16x4\_s’ ‘0’ [memarg](#text-memarg)8​‘v128.load16x4\_u’ ‘0’ [memarg](#text-memarg)8​‘v128.load32x2\_s’ ‘0’ [memarg](#text-memarg)8​‘v128.load32x2\_u’ ‘0’ [memarg](#text-memarg)8​‘v128.load8\_splat’ ‘0’ [memarg](#text-memarg)1​‘v128.load16\_splat’ ‘0’ [memarg](#text-memarg)2​‘v128.load32\_splat’ ‘0’ [memarg](#text-memarg)4​‘v128.load64\_splat’ ‘0’ [memarg](#text-memarg)8​‘v128.load32\_zero’ ‘0’ [memarg](#text-memarg)4​‘v128.load64\_zero’ ‘0’ [memarg](#text-memarg)8​‘v128.load8\_lane’ ‘0’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.load16\_lane’ ‘0’ [memarg](#text-memarg)2​ [laneidx](#text-laneidx)‘v128.load32\_lane’ ‘0’ [memarg](#text-memarg)4​ [laneidx](#text-laneidx)‘v128.load64\_lane’ ‘0’ [memarg](#text-memarg)8​ [laneidx](#text-laneidx)‘i32.store’ ‘0’ [memarg](#text-memarg)4​‘i64.store’ ‘0’ [memarg](#text-memarg)8​‘f32.store’ ‘0’ [memarg](#text-memarg)4​‘f64.store’ ‘0’ [memarg](#text-memarg)8​‘i32.store8’ ‘0’ [memarg](#text-memarg)1​‘i32.store16’ ‘0’ [memarg](#text-memarg)2​‘i64.store8’ ‘0’ [memarg](#text-memarg)1​‘i64.store16’ ‘0’ [memarg](#text-memarg)2​‘i64.store32’ ‘0’ [memarg](#text-memarg)4​‘v128.store’ ‘0’ [memarg](#text-memarg)16​‘v128.store8\_lane’ ‘0’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.store16\_lane’ ‘0’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.store32\_lane’ ‘0’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘v128.store64\_lane’ ‘0’ [memarg](#text-memarg)1​ [laneidx](#text-laneidx)‘memory.size’ ‘0’‘memory.grow’ ‘0’‘memory.fill’ ‘0’‘memory.copy’ ‘0’ ‘0’‘memory.init’ ‘0’ [dataidx](#text-dataidx)[I](#text-context)​​​

#### 6.5.7. Reference Instructions[](#reference-instructions⑨)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣​…‘ref.null’ ht:[heaptype](#text-heaptype)[I](#text-context)​‘ref.func’ x:[funcidx](#text-funcidx)[I](#text-context)​‘ref.is\_null’‘ref.as\_non\_null’‘ref.eq’‘ref.test’ rt:[reftype](#text-reftype)[I](#text-context)​‘ref.cast’ rt:[reftype](#text-reftype)[I](#text-context)​​⇒⇒⇒⇒⇒⇒⇒​[ref.null](#syntax-instr-ref) ht[ref.func](#syntax-instr-ref) x[ref.is\_null](#syntax-instr-ref)[ref.as\_non\_null](#syntax-instr-ref)[ref.eq](#syntax-instr-ref)[ref.test](#syntax-instr-ref) rt[ref.cast](#syntax-instr-ref) rt​​

#### 6.5.8. Aggregate Instructions[](#aggregate-instructions⑤)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘ref.i31’‘i31.get\_s’‘i31.get\_u’‘struct.new’ x:[typeidx](#text-typeidx)[I](#text-context)​‘struct.new\_default’ x:[typeidx](#text-typeidx)[I](#text-context)​‘struct.get’ x:[typeidx](#text-typeidx)[I](#text-context)​ i:[fieldidx](#text-fieldidx)[I](#text-context),x​‘struct.get\_s’ x:[typeidx](#text-typeidx)[I](#text-context)​ i:[fieldidx](#text-fieldidx)[I](#text-context),x​‘struct.get\_u’ x:[typeidx](#text-typeidx)[I](#text-context)​ i:[fieldidx](#text-fieldidx)[I](#text-context),x​‘struct.set’ x:[typeidx](#text-typeidx)[I](#text-context)​ i:[fieldidx](#text-fieldidx)[I](#text-context),x​‘array.new’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.new\_default’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.new\_fixed’ x:[typeidx](#text-typeidx)[I](#text-context)​ n:[u32](#text-int)‘array.new\_data’ x:[typeidx](#text-typeidx)[I](#text-context)​ y:[dataidx](#text-dataidx)[I](#text-context)​‘array.new\_elem’ x:[typeidx](#text-typeidx)[I](#text-context)​ y:[elemidx](#text-elemidx)[I](#text-context)​‘array.get’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.get\_s’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.get\_u’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.set’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.len’‘array.fill’ x:[typeidx](#text-typeidx)[I](#text-context)​‘array.copy’ x1​:[typeidx](#text-typeidx)[I](#text-context)​ x2​:[typeidx](#text-typeidx)[I](#text-context)​‘array.init\_data’ x:[typeidx](#text-typeidx)[I](#text-context)​ y:[dataidx](#text-dataidx)[I](#text-context)​‘array.init\_elem’ x:[typeidx](#text-typeidx)[I](#text-context)​ y:[elemidx](#text-elemidx)[I](#text-context)​‘any.convert\_extern’‘extern.convert\_any’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[ref.i31](#syntax-instr-i31)[i31.get](#syntax-instr-i31)\_[s](#syntax-sx)[i31.get](#syntax-instr-i31)\_[u](#syntax-sx)[struct.new](#syntax-instr-struct) x[struct.new\_default](#syntax-instr-struct) x[struct.get](#syntax-instr-struct) x i[struct.get](#syntax-instr-struct)\_[s](#syntax-sx) x i[struct.get](#syntax-instr-struct)\_[u](#syntax-sx) x i[struct.set](#syntax-instr-struct) x i[array.new](#syntax-instr-array) x[array.new\_default](#syntax-instr-array) x[array.new\_fixed](#syntax-instr-array) x n[array.new\_data](#syntax-instr-array) x y[array.new\_elem](#syntax-instr-array) x y[array.get](#syntax-instr-array) x[array.get](#syntax-instr-array)\_[s](#syntax-sx) x[array.get](#syntax-instr-array)\_[u](#syntax-sx) x[array.set](#syntax-instr-array) x[array.len](#syntax-instr-array)[array.fill](#syntax-instr-array) x[array.copy](#syntax-instr-array) x1​ x2​[array.init\_data](#syntax-instr-array) x y[array.init\_elem](#syntax-instr-array) x y[any.convert\_extern](#syntax-instr-extern)[extern.convert\_any](#syntax-instr-extern)​​

#### 6.5.9. Numeric Instructions[](#numeric-instructions⑨)

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣​…‘i32.const’ c:[i32](#text-int)‘i64.const’ c:[i64](#text-int)‘f32.const’ c:[f32](#text-float)‘f64.const’ c:[f64](#text-float)​⇒⇒⇒⇒​[i32](#syntax-numtype).[const](#syntax-instr-numeric) c[i64](#syntax-numtype).[const](#syntax-instr-numeric) c[f32](#syntax-numtype).[const](#syntax-instr-numeric) c[f64](#syntax-numtype).[const](#syntax-instr-numeric) c​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i32.eqz’‘i32.eq’‘i32.ne’‘i32.lt\_s’‘i32.lt\_u’‘i32.gt\_s’‘i32.gt\_u’‘i32.le\_s’‘i32.le\_u’‘i32.ge\_s’‘i32.ge\_u’‘i32.clz’‘i32.ctz’‘i32.popcnt’‘i32.extend8\_s’‘i32.extend16\_s’‘i32.add’‘i32.sub’‘i32.mul’‘i32.div\_s’‘i32.div\_u’‘i32.rem\_s’‘i32.rem\_u’‘i32.and’‘i32.or’‘i32.xor’‘i32.shl’‘i32.shr\_s’‘i32.shr\_u’‘i32.rotl’‘i32.rotr’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[eqz](#syntax-instr-numeric)[i32](#syntax-numtype).[eq](#syntax-instr-numeric)[i32](#syntax-numtype).[ne](#syntax-instr-numeric)[i32](#syntax-numtype).[lt](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[lt](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[gt](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[gt](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[le](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[le](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[ge](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[ge](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[clz](#syntax-instr-numeric)[i32](#syntax-numtype).[ctz](#syntax-instr-numeric)[i32](#syntax-numtype).[popcnt](#syntax-instr-numeric)[i32](#syntax-numtype).[extend](#syntax-instr-numeric)8\_[s](#syntax-sx)[i32](#syntax-numtype).[extend](#syntax-instr-numeric)16\_[s](#syntax-sx)[i32](#syntax-numtype).[add](#syntax-instr-numeric)[i32](#syntax-numtype).[sub](#syntax-instr-numeric)[i32](#syntax-numtype).[mul](#syntax-instr-numeric)[i32](#syntax-numtype).[div](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[div](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[rem](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[rem](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[and](#syntax-instr-numeric)[i32](#syntax-numtype).[or](#syntax-instr-numeric)[i32](#syntax-numtype).[xor](#syntax-instr-numeric)[i32](#syntax-numtype).[shl](#syntax-instr-numeric)[i32](#syntax-numtype).[shr](#syntax-instr-numeric)\_[s](#syntax-sx)[i32](#syntax-numtype).[shr](#syntax-instr-numeric)\_[u](#syntax-sx)[i32](#syntax-numtype).[rotl](#syntax-instr-numeric)[i32](#syntax-numtype).[rotr](#syntax-instr-numeric)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i64.eqz’‘i64.eq’‘i64.ne’‘i64.lt\_s’‘i64.lt\_u’‘i64.gt\_s’‘i64.gt\_u’‘i64.le\_s’‘i64.le\_u’‘i64.ge\_s’‘i64.ge\_u’‘i64.clz’‘i64.ctz’‘i64.popcnt’‘i64.extend8\_s’‘i64.extend16\_s’‘i64.extend32\_s’‘i64.add’‘i64.sub’‘i64.mul’‘i64.div\_s’‘i64.div\_u’‘i64.rem\_s’‘i64.rem\_u’‘i64.and’‘i64.or’‘i64.xor’‘i64.shl’‘i64.shr\_s’‘i64.shr\_u’‘i64.rotl’‘i64.rotr’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i64](#syntax-numtype).[eqz](#syntax-instr-numeric)[i64](#syntax-numtype).[eq](#syntax-instr-numeric)[i64](#syntax-numtype).[ne](#syntax-instr-numeric)[i64](#syntax-numtype).[lt](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[lt](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[gt](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[gt](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[le](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[le](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[ge](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[ge](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[clz](#syntax-instr-numeric)[i64](#syntax-numtype).[ctz](#syntax-instr-numeric)[i64](#syntax-numtype).[popcnt](#syntax-instr-numeric)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)8\_[s](#syntax-sx)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)16\_[s](#syntax-sx)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)32\_[s](#syntax-sx)[i64](#syntax-numtype).[add](#syntax-instr-numeric)[i64](#syntax-numtype).[sub](#syntax-instr-numeric)[i64](#syntax-numtype).[mul](#syntax-instr-numeric)[i64](#syntax-numtype).[div](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[div](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[rem](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[rem](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[and](#syntax-instr-numeric)[i64](#syntax-numtype).[or](#syntax-instr-numeric)[i64](#syntax-numtype).[xor](#syntax-instr-numeric)[i64](#syntax-numtype).[shl](#syntax-instr-numeric)[i64](#syntax-numtype).[shr](#syntax-instr-numeric)\_[s](#syntax-sx)[i64](#syntax-numtype).[shr](#syntax-instr-numeric)\_[u](#syntax-sx)[i64](#syntax-numtype).[rotl](#syntax-instr-numeric)[i64](#syntax-numtype).[rotr](#syntax-instr-numeric)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘f32.eq’‘f32.ne’‘f32.lt’‘f32.gt’‘f32.le’‘f32.ge’‘f32.abs’‘f32.neg’‘f32.sqrt’‘f32.ceil’‘f32.floor’‘f32.trunc’‘f32.nearest’‘f32.add’‘f32.sub’‘f32.mul’‘f32.div’‘f32.min’‘f32.max’‘f32.copysign’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype).[eq](#syntax-instr-numeric)[f32](#syntax-numtype).[ne](#syntax-instr-numeric)[f32](#syntax-numtype).[lt](#syntax-instr-numeric)[f32](#syntax-numtype).[gt](#syntax-instr-numeric)[f32](#syntax-numtype).[le](#syntax-instr-numeric)[f32](#syntax-numtype).[ge](#syntax-instr-numeric)[f32](#syntax-numtype).[abs](#syntax-instr-numeric)[f32](#syntax-numtype).[neg](#syntax-instr-numeric)[f32](#syntax-numtype).[sqrt](#syntax-instr-numeric)[f32](#syntax-numtype).[ceil](#syntax-instr-numeric)[f32](#syntax-numtype).[floor](#syntax-instr-numeric)[f32](#syntax-numtype).[trunc](#syntax-instr-numeric)[f32](#syntax-numtype).[nearest](#syntax-instr-numeric)[f32](#syntax-numtype).[add](#syntax-instr-numeric)[f32](#syntax-numtype).[sub](#syntax-instr-numeric)[f32](#syntax-numtype).[mul](#syntax-instr-numeric)[f32](#syntax-numtype).[div](#syntax-instr-numeric)[f32](#syntax-numtype).[min](#syntax-instr-numeric)[f32](#syntax-numtype).[max](#syntax-instr-numeric)[f32](#syntax-numtype).[copysign](#syntax-instr-numeric)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘f64.eq’‘f64.ne’‘f64.lt’‘f64.gt’‘f64.le’‘f64.ge’‘f64.abs’‘f64.neg’‘f64.sqrt’‘f64.ceil’‘f64.floor’‘f64.trunc’‘f64.nearest’‘f64.add’‘f64.sub’‘f64.mul’‘f64.div’‘f64.min’‘f64.max’‘f64.copysign’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f64](#syntax-numtype).[eq](#syntax-instr-numeric)[f64](#syntax-numtype).[ne](#syntax-instr-numeric)[f64](#syntax-numtype).[lt](#syntax-instr-numeric)[f64](#syntax-numtype).[gt](#syntax-instr-numeric)[f64](#syntax-numtype).[le](#syntax-instr-numeric)[f64](#syntax-numtype).[ge](#syntax-instr-numeric)[f64](#syntax-numtype).[abs](#syntax-instr-numeric)[f64](#syntax-numtype).[neg](#syntax-instr-numeric)[f64](#syntax-numtype).[sqrt](#syntax-instr-numeric)[f64](#syntax-numtype).[ceil](#syntax-instr-numeric)[f64](#syntax-numtype).[floor](#syntax-instr-numeric)[f64](#syntax-numtype).[trunc](#syntax-instr-numeric)[f64](#syntax-numtype).[nearest](#syntax-instr-numeric)[f64](#syntax-numtype).[add](#syntax-instr-numeric)[f64](#syntax-numtype).[sub](#syntax-instr-numeric)[f64](#syntax-numtype).[mul](#syntax-instr-numeric)[f64](#syntax-numtype).[div](#syntax-instr-numeric)[f64](#syntax-numtype).[min](#syntax-instr-numeric)[f64](#syntax-numtype).[max](#syntax-instr-numeric)[f64](#syntax-numtype).[copysign](#syntax-instr-numeric)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i32.wrap\_i64’‘i32.trunc\_f32\_s’‘i32.trunc\_f32\_u’‘i32.trunc\_f64\_s’‘i32.trunc\_f64\_u’‘i32.trunc\_sat\_f32\_s’‘i32.trunc\_sat\_f32\_u’‘i32.trunc\_sat\_f64\_s’‘i32.trunc\_sat\_f64\_u’‘i64.extend\_i64\_s’‘i64.extend\_i64\_u’‘i64.trunc\_f32\_s’‘i64.trunc\_f32\_u’‘i64.trunc\_f64\_s’‘i64.trunc\_f64\_u’‘i64.trunc\_sat\_f32\_s’‘i64.trunc\_sat\_f32\_u’‘i64.trunc\_sat\_f64\_s’‘i64.trunc\_sat\_f64\_u’‘f32.demote\_f64’‘f32.convert\_i32\_s’‘f32.convert\_i32\_u’‘f32.convert\_i64\_s’‘f32.convert\_i64\_u’‘f64.promote\_f32’‘f64.convert\_i32\_s’‘f64.convert\_i32\_u’‘f64.convert\_i64\_s’‘f64.convert\_i64\_u’‘i32.reinterpret\_f32’‘i64.reinterpret\_f64’‘f32.reinterpret\_i32’‘f64.reinterpret\_i64’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype).[wrap](#syntax-instr-numeric)\_[i64](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i32](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i32](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i64](#syntax-numtype)[i64](#syntax-numtype).[extend](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i64](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[s](#syntax-sx)\_[f64](#syntax-numtype)[i64](#syntax-numtype).[trunc\_sat](#syntax-instr-numeric)\_[u](#syntax-sx)\_[f64](#syntax-numtype)[f32](#syntax-numtype).[demote](#syntax-instr-numeric)\_[f64](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i64](#syntax-numtype)[f32](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i64](#syntax-numtype)[f64](#syntax-numtype).[promote](#syntax-instr-numeric)\_[f32](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[s](#syntax-sx)\_[i64](#syntax-numtype)[f64](#syntax-numtype).[convert](#syntax-instr-numeric)\_[u](#syntax-sx)\_[i64](#syntax-numtype)[i32](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[f32](#syntax-numtype)[i64](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[f64](#syntax-numtype)[f32](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[i32](#syntax-numtype)[f64](#syntax-numtype).[reinterpret](#syntax-instr-numeric)\_[i64](#syntax-numtype)​​

#### 6.5.10. Vector Instructions[](#vector-instructions⑨)

Vector constant instructions have a mandatory [shape](#syntax-shape) descriptor, which determines how the following values are parsed.

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣​…‘v128.const’ ‘i8x16’ c∗:[i8](#text-int)16‘v128.const’ ‘i16x8’ c∗:[i16](#text-int)8‘v128.const’ ‘i32x4’ c∗:[i32](#text-int)4‘v128.const’ ‘i64x2’ c∗:[i64](#text-int)2‘v128.const’ ‘f32x4’ c∗:[f32](#text-float)4‘v128.const’ ‘f64x2’ c∗:[f64](#text-float)2​⇒⇒⇒⇒⇒⇒​[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[i](#syntax-numtype)8​(c)∗)[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[i](#syntax-numtype)16​(c)∗)[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[i](#syntax-numtype)32​(c)∗)[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[i](#syntax-numtype)64​(c)∗)[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[f](#syntax-numtype)32​(c)∗)[v128](#syntax-vectype).[const](#syntax-instr-numeric) [bytes](#aux-bytes)[i](#syntax-numtype)128−1​([⨁](#notation-concat)[bytes](#aux-bytes)[f](#syntax-numtype)64​(c)∗)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i8x16.shuffle’ i∗:[laneidx](#text-laneidx)16‘i8x16.swizzle’‘i8x16.relaxed\_swizzle’‘i8x16.splat’‘i16x8.splat’‘i32x4.splat’‘i64x2.splat’‘f32x4.splat’‘f64x2.splat’‘i8x16.extract\_lane\_s’ i:[laneidx](#text-laneidx)‘i8x16.extract\_lane\_u’ i:[laneidx](#text-laneidx)‘i16x8.extract\_lane\_s’ i:[laneidx](#text-laneidx)‘i16x8.extract\_lane\_u’ i:[laneidx](#text-laneidx)‘i32x4.extract\_lane’ i:[laneidx](#text-laneidx)‘i64x2.extract\_lane’ i:[laneidx](#text-laneidx)‘f32x4.extract\_lane’ i:[laneidx](#text-laneidx)‘f64x2.extract\_lane’ i:[laneidx](#text-laneidx)‘i8x16.replace\_lane’ i:[laneidx](#text-laneidx)‘i16x8.replace\_lane’ i:[laneidx](#text-laneidx)‘i32x4.replace\_lane’ i:[laneidx](#text-laneidx)‘i64x2.replace\_lane’ i:[laneidx](#text-laneidx)‘f32x4.replace\_lane’ i:[laneidx](#text-laneidx)‘f64x2.replace\_lane’ i:[laneidx](#text-laneidx)​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[shuffle](#syntax-instr-vec) i∗[i8](#syntax-storagetype)[x](#syntax-shape)16.[swizzle](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[relaxed\_swizzle](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[splat](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[splat](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[splat](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[splat](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[splat](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[splat](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[extract\_lane](#syntax-instr-vec)\_[s](#syntax-sx) i[i8](#syntax-storagetype)[x](#syntax-shape)16.[extract\_lane](#syntax-instr-vec)\_[u](#syntax-sx) i[i16](#syntax-storagetype)[x](#syntax-shape)8.[extract\_lane](#syntax-instr-vec)\_[s](#syntax-sx) i[i16](#syntax-storagetype)[x](#syntax-shape)8.[extract\_lane](#syntax-instr-vec)\_[u](#syntax-sx) i[i32](#syntax-numtype)[x](#syntax-shape)4.[extract\_lane](#syntax-instr-vec) i[i64](#syntax-numtype)[x](#syntax-shape)2.[extract\_lane](#syntax-instr-vec) i[f32](#syntax-numtype)[x](#syntax-shape)4.[extract\_lane](#syntax-instr-vec) i[f64](#syntax-numtype)[x](#syntax-shape)2.[extract\_lane](#syntax-instr-vec) i[i8](#syntax-storagetype)[x](#syntax-shape)16.[replace\_lane](#syntax-instr-vec) i[i16](#syntax-storagetype)[x](#syntax-shape)8.[replace\_lane](#syntax-instr-vec) i[i32](#syntax-numtype)[x](#syntax-shape)4.[replace\_lane](#syntax-instr-vec) i[i64](#syntax-numtype)[x](#syntax-shape)2.[replace\_lane](#syntax-instr-vec) i[f32](#syntax-numtype)[x](#syntax-shape)4.[replace\_lane](#syntax-instr-vec) i[f64](#syntax-numtype)[x](#syntax-shape)2.[replace\_lane](#syntax-instr-vec) i​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣​…‘v128.any\_true’‘v128.not’‘v128.and’‘v128.andnot’‘v128.or’‘v128.xor’‘v128.bitselect’​⇒⇒⇒⇒⇒⇒⇒​[v128](#syntax-vectype).[any\_true](#syntax-instr-vec)[v128](#syntax-vectype).[not](#syntax-instr-vec)[v128](#syntax-vectype).[and](#syntax-instr-vec)[v128](#syntax-vectype).[andnot](#syntax-instr-vec)[v128](#syntax-vectype).[or](#syntax-instr-vec)[v128](#syntax-vectype).[xor](#syntax-instr-vec)[v128](#syntax-vectype).[bitselect](#syntax-instr-vec)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i8x16.all\_true’‘i8x16.eq’‘i8x16.ne’‘i8x16.lt\_s’‘i8x16.lt\_u’‘i8x16.gt\_s’‘i8x16.gt\_u’‘i8x16.le\_s’‘i8x16.le\_u’‘i8x16.ge\_s’‘i8x16.ge\_u’‘i8x16.abs’‘i8x16.neg’‘i8x16.popcnt’‘i8x16.add’‘i8x16.add\_sat\_s’‘i8x16.add\_sat\_u’‘i8x16.sub’‘i8x16.sub\_sat\_s’‘i8x16.sub\_sat\_u’‘i8x16.min\_s’‘i8x16.min\_u’‘i8x16.max\_s’‘i8x16.max\_u’‘i8x16.avgr\_u’‘i8x16.relaxed\_laneselect’‘i8x16.shl’‘i8x16.shr\_s’‘i8x16.shr\_u’‘i8x16.bitmask’‘i8x16.narrow\_i16x8\_s’‘i8x16.narrow\_i16x8\_u’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i8](#syntax-storagetype)[x](#syntax-shape)16.[all\_true](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[eq](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ne](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[abs](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[neg](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[popcnt](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[add\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[sub\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[avgr](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[relaxed\_laneselect](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shl](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[bitmask](#syntax-instr-vec)[i8](#syntax-storagetype)[x](#syntax-shape)16.[narrow](#syntax-instr-vec)\_[i16](#syntax-storagetype)[x](#syntax-shape)8\_[s](#syntax-sx)[i8](#syntax-storagetype)[x](#syntax-shape)16.[narrow](#syntax-instr-vec)\_[i16](#syntax-storagetype)[x](#syntax-shape)8\_[u](#syntax-sx)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i16x8.all\_true’‘i16x8.eq’‘i16x8.ne’‘i16x8.lt\_s’‘i16x8.lt\_u’‘i16x8.gt\_s’‘i16x8.gt\_u’‘i16x8.le\_s’‘i16x8.le\_u’‘i16x8.ge\_s’‘i16x8.ge\_u’‘i16x8.abs’‘i16x8.neg’‘i16x8.add’‘i16x8.add\_sat\_s’‘i16x8.add\_sat\_u’‘i16x8.sub’‘i16x8.sub\_sat\_s’‘i16x8.sub\_sat\_u’‘i16x8.mul’‘i16x8.min\_s’‘i16x8.min\_u’‘i16x8.max\_s’‘i16x8.max\_u’‘i16x8.avgr\_u’‘i16x8.q15mulr\_sat\_s’‘i16x8.relaxed\_q15mulr\_s’‘i16x8.relaxed\_laneselect’‘i16x8.shl’‘i16x8.shr\_s’‘i16x8.shr\_u’‘i16x8.bitmask’‘i16x8.narrow\_i32x4\_s’‘i16x8.narrow\_i32x4\_u’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i16](#syntax-storagetype)[x](#syntax-shape)8.[all\_true](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[eq](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ne](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[abs](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[neg](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[add\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[sub\_sat](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[mul](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[avgr](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[q15mulr\_sat](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[relaxed\_q15mulr](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[relaxed\_laneselect](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[shl](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[bitmask](#syntax-instr-vec)[i16](#syntax-storagetype)[x](#syntax-shape)8.[narrow](#syntax-instr-vec)\_[i32](#syntax-numtype)[x](#syntax-shape)4\_[s](#syntax-sx)[i16](#syntax-storagetype)[x](#syntax-shape)8.[narrow](#syntax-instr-vec)\_[i32](#syntax-numtype)[x](#syntax-shape)4\_[u](#syntax-sx)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i32x4.all\_true’‘i32x4.eq’‘i32x4.ne’‘i32x4.lt\_s’‘i32x4.lt\_u’‘i32x4.gt\_s’‘i32x4.gt\_u’‘i32x4.le\_s’‘i32x4.le\_u’‘i32x4.ge\_s’‘i32x4.ge\_u’‘i32x4.abs’‘i32x4.neg’‘i32x4.add’‘i32x4.sub’‘i32x4.mul’‘i32x4.min\_s’‘i32x4.min\_u’‘i32x4.max\_s’‘i32x4.max\_u’‘i32x4.relaxed\_laneselect’‘i32x4.shl’‘i32x4.shr\_s’‘i32x4.shr\_u’‘i32x4.bitmask’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i32](#syntax-numtype)[x](#syntax-shape)4.[all\_true](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[eq](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[ne](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[abs](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[neg](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[add](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[sub](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[mul](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_laneselect](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[shl](#syntax-instr-vec)[i32](#syntax-numtype)[x](#syntax-shape)4.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i32](#syntax-numtype)[x](#syntax-shape)4.[bitmask](#syntax-instr-vec)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i64x2.all\_true’‘i64x2.eq’‘i64x2.ne’‘i64x2.lt\_s’‘i64x2.gt\_s’‘i64x2.le\_s’‘i64x2.ge\_s’‘i64x2.abs’‘i64x2.neg’‘i64x2.add’‘i64x2.sub’‘i64x2.mul’‘i64x2.relaxed\_laneselect’‘i64x2.shl’‘i64x2.shr\_s’‘i64x2.shr\_u’‘i64x2.bitmask’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i64](#syntax-numtype)[x](#syntax-shape)2.[all\_true](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[eq](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[ne](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[lt](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[gt](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[le](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[ge](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[abs](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[neg](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[add](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[sub](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[mul](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_laneselect](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[shl](#syntax-instr-vec)[i64](#syntax-numtype)[x](#syntax-shape)2.[shr](#syntax-instr-vec)\_[s](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[shr](#syntax-instr-vec)\_[u](#syntax-sx)[i64](#syntax-numtype)[x](#syntax-shape)2.[bitmask](#syntax-instr-vec)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘f32x4.eq’‘f32x4.ne’‘f32x4.lt’‘f32x4.gt’‘f32x4.le’‘f32x4.ge’‘f32x4.abs’‘f32x4.neg’‘f32x4.sqrt’‘f32x4.ceil’‘f32x4.floor’‘f32x4.trunc’‘f32x4.nearest’‘f32x4.add’‘f32x4.sub’‘f32x4.mul’‘f32x4.div’‘f32x4.min’‘f32x4.max’‘f32x4.pmin’‘f32x4.pmax’‘f32x4.relaxed\_min’‘f32x4.relaxed\_max’‘f32x4.relaxed\_madd’‘f32x4.relaxed\_nmadd’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f32](#syntax-numtype)[x](#syntax-shape)4.[eq](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[ne](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[lt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[gt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[le](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[ge](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[abs](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[neg](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[sqrt](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[ceil](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[floor](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[trunc](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[nearest](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[add](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[sub](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[mul](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[div](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[min](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[max](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[pmin](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[pmax](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_min](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_max](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_madd](#syntax-instr-vec)[f32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_nmadd](#syntax-instr-vec)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘f64x2.eq’‘f64x2.ne’‘f64x2.lt’‘f64x2.gt’‘f64x2.le’‘f64x2.ge’‘f64x2.abs’‘f64x2.neg’‘f64x2.sqrt’‘f64x2.ceil’‘f64x2.floor’‘f64x2.trunc’‘f64x2.nearest’‘f64x2.add’‘f64x2.sub’‘f64x2.mul’‘f64x2.div’‘f64x2.min’‘f64x2.max’‘f64x2.pmin’‘f64x2.pmax’‘f64x2.relaxed\_min’‘f64x2.relaxed\_max’‘f64x2.relaxed\_madd’‘f64x2.relaxed\_nmadd’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[f64](#syntax-numtype)[x](#syntax-shape)2.[eq](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[ne](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[lt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[gt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[le](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[ge](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[abs](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[neg](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[sqrt](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[ceil](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[floor](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[trunc](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[nearest](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[add](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[sub](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[mul](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[div](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[min](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[max](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[pmin](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[pmax](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_min](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_max](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_madd](#syntax-instr-vec)[f64](#syntax-numtype)[x](#syntax-shape)2.[relaxed\_nmadd](#syntax-instr-vec)​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i16x8.extend\_low\_i8x16\_s’‘i16x8.extend\_low\_i8x16\_u’‘i16x8.extend\_high\_i8x16\_s’‘i16x8.extend\_high\_i8x16\_u’‘i32x4.extend\_low\_i16x8\_s’‘i32x4.extend\_low\_i16x8\_u’‘i32x4.extend\_high\_i16x8\_s’‘i32x4.extend\_high\_i16x8\_u’‘i32x4.trunc\_sat\_f32x4\_s’‘i32x4.trunc\_sat\_f32x4\_u’‘i32x4.trunc\_sat\_f64x2\_s\_zero’‘i32x4.trunc\_sat\_f64x2\_u\_zero’‘i32x4.relaxed\_trunc\_f32x4\_s’‘i32x4.relaxed\_trunc\_f32x4\_u’‘i32x4.relaxed\_trunc\_f64x2\_s\_zero’‘i32x4.relaxed\_trunc\_f64x2\_u\_zero’‘i64x2.extend\_low\_i32x4\_s’‘i64x2.extend\_low\_i32x4\_u’‘i64x2.extend\_high\_i32x4\_s’‘i64x2.extend\_high\_i32x4\_u’‘f32x4.demote\_f64x2\_zero’‘f32x4.convert\_i32x4\_s’‘f32x4.convert\_i32x4\_u’‘f64x2.promote\_low\_f32x4’‘f64x2.convert\_low\_i32x4\_s’‘f64x2.convert\_low\_i32x4\_u’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[s](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i32](#syntax-numtype)[x](#syntax-shape)4.[trunc\_sat](#syntax-instr-vec)\_[u](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[s](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[u](#syntax-sx)\_[f32](#syntax-numtype)[x](#syntax-shape)4[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[s](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i32](#syntax-numtype)[x](#syntax-shape)4.[relaxed\_trunc](#syntax-instr-vec)\_[u](#syntax-sx)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extend](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f32](#syntax-numtype)[x](#syntax-shape)4.[demote](#syntax-instr-vec)\_[zero](#syntax-instr-vec)\_[f64](#syntax-numtype)[x](#syntax-shape)2[f32](#syntax-numtype)[x](#syntax-shape)4.[convert](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f32](#syntax-numtype)[x](#syntax-shape)4.[convert](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f64](#syntax-numtype)[x](#syntax-shape)2.[promote](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[f32](#syntax-numtype)[x](#syntax-shape)4[f64](#syntax-numtype)[x](#syntax-shape)2.[convert](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[f64](#syntax-numtype)[x](#syntax-shape)2.[convert](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4​​

​[plaininstr](#text-plaininstr)[I](#text-context)​​::=∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣∣​…‘i16x8.extadd\_pairwise\_i8x16\_s’‘i16x8.extadd\_pairwise\_i8x16\_u’‘i16x8.extmul\_low\_i8x16\_s’‘i16x8.extmul\_low\_i8x16\_u’‘i16x8.extmul\_high\_i8x16\_s’‘i16x8.extmul\_high\_i8x16\_u’‘i32x4.extadd\_pairwise\_i16x8\_s’‘i32x4.extadd\_pairwise\_i16x8\_u’‘i32x4.extmul\_low\_i16x8\_s’‘i32x4.extmul\_low\_i16x8\_u’‘i32x4.extmul\_high\_i16x8\_s’‘i32x4.extmul\_high\_i16x8\_u’‘i32x4.dot\_i16x8\_s’‘i64x2.extmul\_low\_i32x4\_s’‘i64x2.extmul\_low\_i32x4\_u’‘i64x2.extmul\_high\_i32x4\_s’‘i64x2.extmul\_high\_i32x4\_u’​⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒⇒​[i16](#syntax-storagetype)[x](#syntax-shape)8.[extadd\_pairwise](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extadd\_pairwise](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i16](#syntax-storagetype)[x](#syntax-shape)8.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i8](#syntax-storagetype)[x](#syntax-shape)16[i32](#syntax-numtype)[x](#syntax-shape)4.[extadd\_pairwise](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extadd\_pairwise](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i32](#syntax-numtype)[x](#syntax-shape)4.[dot](#syntax-instr-vec)\_[s](#syntax-sx)\_[i16](#syntax-storagetype)[x](#syntax-shape)8[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[low](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[s](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4[i64](#syntax-numtype)[x](#syntax-shape)2.[extmul](#syntax-instr-vec)\_[high](#syntax-instr-vec)\_[u](#syntax-sx)\_[i32](#syntax-numtype)[x](#syntax-shape)4​​

#### 6.5.11. Folded Instructions[](#folded-instructions①)

Instructions can be written as S-expressions by grouping them into _folded_ form. In that notation, an instruction is wrapped in parentheses and optionally includes nested folded instructions to indicate its operands.

In the case of [block instructions](#text-instr-block), the folded form omits the ‘end’ delimiter. For if instructions, both branches have to be wrapped into nested S-expressions, headed by the keywords ‘then’ and ‘else’.

The set of all phrases defined by the following abbreviations recursively forms the auxiliary syntactic class foldedinstr. Such a folded instruction can appear anywhere a regular instruction can.

​[foldedinstr](#text-foldedinstr)[I](#text-context)​​::=∣∣∣∣​‘(’ [plaininstr](#text-plaininstr)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)​ ‘)’[instrs](#text-instrs)[I](#text-context)​ [plaininstr](#text-plaininstr)[I](#text-context)​​‘(’ ‘block’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)′​ ‘)’‘block’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)′​ ‘end’​‘(’ ‘loop’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)′​ ‘)’‘loop’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [instrs](#text-instrs)[I](#text-context)′​ ‘end’​‘(’ ‘if’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [foldedinstr](#text-foldedinstr)[I](#text-context)∗​‘(’ ‘then’ in1∗​:[instrs](#text-instrs)[I](#text-context)′​ ‘)’ (‘(’ ‘else’ in2∗​:[instrs](#text-instrs)[I](#text-context)′​ ‘)’)? ‘)’​[foldedinstr](#text-foldedinstr)[I](#text-context)∗​ ‘if’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ in1∗​:[instrs](#text-instrs)[I](#text-context)′​ (‘else’ in2∗​:[instrs](#text-instrs)[I](#text-context)′​)? ‘end’​‘(’ ‘try\_table’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [catch](#text-catch)[I](#text-context)∗​ [instrs](#text-instrs)[I](#text-context)′​ ‘)’‘try\_table’ [label](#text-label)[I](#text-context)​ [blocktype](#text-blocktype)[I](#text-context)​ [catch](#text-catch)[I](#text-context)∗​ [instrs](#text-instrs)[I](#text-context)′​ ‘end’​​≡≡≡≡≡​​​​

Note

For example, the instruction sequence

(local.get $x) (i32.const 2) i32.add (i32.const 3) i32.mul

can be folded into

(i32.mul (i32.add (local.get $x) (i32.const 2)) (i32.const 3))

Folded instructions are solely syntactic sugar, no additional syntactic or type-based checking is implied.

#### 6.5.12. Expressions[](#expressions⑨)

Expressions are written as instruction sequences.

​[expr](#text-expr)[I](#text-context)​​::=​in∗:[instrs](#text-instrs)[I](#text-context)​​⇒​in∗​​

### 6.6. Modules[](#modules①②)

Modules consist of a sequence of [declarations](#text-decl). The grammar rules for each declaration construct produce a pair, consisting of not just the abstract syntax representing the respective declaration, but also an [identifier context](#text-context) recording the new symbolic [identifiers](#text-id) bound by the construct, for use in the remainder of the module.

#### 6.6.1. Indices[](#indices⑤)

[Indices](#syntax-index) can be given either in raw numeric form or as symbolic [identifiers](#text-id) when bound by a respective construct. Such identifiers are looked up in the suitable space of the [identifier context](#text-context) [I](#text-context).

​[idx](#text-idx)ids​[tagidx](#text-tagidx)[I](#text-context)​[globalidx](#text-globalidx)[I](#text-context)​[memidx](#text-memidx)[I](#text-context)​[tableidx](#text-tableidx)[I](#text-context)​[funcidx](#text-funcidx)[I](#text-context)​[dataidx](#text-dataidx)[I](#text-context)​[elemidx](#text-elemidx)[I](#text-context)​[localidx](#text-localidx)[I](#text-context)​[labelidx](#text-labelidx)[I](#text-context)​[fieldidx](#text-fieldidx)[I](#text-context),x​​::=∣::=::=::=::=::=::=::=::=::=::=​x:[u32](#text-int)id:[id](#text-id)[idx](#text-idx)[I](#text-context).[tags](#text-context)​[idx](#text-idx)[I](#text-context).[globals](#text-context)​[idx](#text-idx)[I](#text-context).[mems](#text-context)​[idx](#text-idx)[I](#text-context).[tables](#text-context)​[idx](#text-idx)[I](#text-context).[funcs](#text-context)​[idx](#text-idx)[I](#text-context).[datas](#text-context)​[idx](#text-idx)[I](#text-context).[elems](#text-context)​[idx](#text-idx)[I](#text-context).[locals](#text-context)​[idx](#text-idx)[I](#text-context).[labels](#text-context)​[idx](#text-idx)[I](#text-context).[fields](#text-context)\[x\]​​⇒⇒xxif ids\[x\]\=id0.8ex\][typeidx](#text-typeidx)[I](#text-context)​::=[idx](#text-idx)[I](#text-context).[types](#text-context)​​

#### 6.6.2. Types[](#types①⑦)

A type definition consists of a [recursive type](#text-rectype). The [identifier context](#text-context) produced for the local bindings is further extended with the respective sequence of [defined types](#syntax-deftype) that the recursive type generates.

​[type](#text-type)[I](#text-context)​​::=​(qt,[I](#text-context)′):[rectype](#text-rectype)[I](#text-context)​​⇒​([type](#syntax-type) qt,[I](#text-context)′⊕[I](#text-context)′′)​if qt\=[rec](#syntax-rectype) stn∧ [I](#text-context)′′\={[typedefs](#text-context) (qt.i)i<n}​​​

#### 6.6.3. Tags[](#tags⑨)

A tag definition can bind a symbolic [tag identifier](#text-id).

​[tag](#text-tag)[I](#text-context)​​::=​‘(’ ‘tag’ id?:[id](#text-id)? jt:[tagtype](#text-tagtype)[I](#text-context)​ ‘)’​⇒​([tag](#syntax-tag) jt,{[tags](#text-context) (id?)})​​

##### 6.6.3.1. Abbreviations[](#abbreviations①③)

Tags can be defined as [imports](#text-import) or [exports](#text-export) inline:

​[import](#text-import)[I](#text-context)​​::=∣​…‘(’ ‘tag’ [id](#text-id)? ‘(’ ‘import’ [name](#text-name)2 ‘)’ [tagtype](#text-tagtype)[I](#text-context)​ ‘)’‘(’ ‘import’ [name](#text-name)2 ‘(’ ‘tag’ [id](#text-id)? [tagtype](#text-tagtype)[I](#text-context)​ ‘)’ ‘)’​0.8ex\]‘(’ ‘tag’ id′:[id](#text-id) … ‘)’‘(’ ‘export’ [name](#text-name) ‘(’ ‘tag’ [id](#text-id) ‘)’ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[tags](#text-context)​​​​​≡[export](#text-export)[I](#text-context)​::=‘(’ ‘tag’ id?:[id](#text-id)? ‘(’ ‘export’ [name](#text-name) ‘)’ … ‘)’≡​

Note

The latter abbreviation can be applied repeatedly, if “…” contains additional export clauses. Consequently, a memory declaration can contain any number of exports, possibly followed by an import.

#### 6.6.4. Globals[](#globals⑨)

Global definitions can bind a symbolic [global identifier](#text-id).

​[global](#text-global)[I](#text-context)​​::=​‘(’ ‘global’ id?:[id](#text-id)? gt:[globaltype](#text-globaltype)[I](#text-context)​ e:[expr](#text-expr)[I](#text-context)​ ‘)’​⇒​([global](#syntax-global) gt e,{[globals](#text-context) (id?)})​​

##### 6.6.4.1. Abbreviations[](#abbreviations①④)

Globals can be defined as [imports](#text-import) or [exports](#text-export) inline:

​[import](#text-import)[I](#text-context)​​::=∣​…‘(’ ‘global’ [id](#text-id)? ‘(’ ‘import’ [name](#text-name)2 ‘)’ [globaltype](#text-globaltype)[I](#text-context)​ ‘)’‘(’ ‘import’ [name](#text-name)2 ‘(’ ‘global’ [id](#text-id)? [globaltype](#text-globaltype)[I](#text-context)​ ‘)’ ‘)’​0.8ex\]‘(’ ‘global’ id′:[id](#text-id) … ‘)’‘(’ ‘export’ [name](#text-name) ‘(’ ‘global’ [id](#text-id) ‘)’ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[globals](#text-context)​​​​​≡[export](#text-export)[I](#text-context)​::=‘(’ ‘global’ id?:[id](#text-id)? ‘(’ ‘export’ [name](#text-name) ‘)’ … ‘)’≡​

Note

The latter abbreviation can be applied repeatedly, if “…” contains additional export clauses. Consequently, a global declaration can contain any number of exports, possibly followed by an import.

#### 6.6.5. Memories[](#memories⑨)

Memory definitions can bind a symbolic [memory identifier](#text-id).

​[mem](#text-mem)[I](#text-context)​​::=​‘(’ ‘memory’ id?:[id](#text-id)? mt:[memtype](#text-memtype)[I](#text-context)​ ‘)’​⇒​([memory](#syntax-mem) mt,{[mems](#text-context) (id?)})​​

##### 6.6.5.1. Abbreviations[](#abbreviations①⑤)

A [data segment](#text-data) can be given inline with a memory definition, in which case its offset is 0 and the [limits](#text-limits) of the [memory type](#text-memtype) are inferred from the length of the data, rounded up to [page size](#page-size):

​[mem](#text-mem)[I](#text-context)​​::=​‘(’ ‘memory’ id?:[id](#text-id)? at?:[addrtype](#text-addrtype)? ‘(’ ‘data’ b∗:[datastring](#text-datastring) ‘)’ ‘)’‘(’ ‘memory’ id′:[id](#text-id) at?:[addrtype](#text-addrtype)? n:[u64](#text-int) n:[u64](#text-int) ‘)’‘(’ ‘data’ ‘(’ ‘memory’ id′:[id](#text-id) ‘)’ ‘(’ at′:[addrtype](#text-addrtype) ‘.const’ ‘0’ ‘)’ [datastring](#text-datastring) ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[mems](#text-context)∧ at?\=at′∨at?\=ϵ∧at′\=[i32](#syntax-numtype)∧ n\=ceil(∣b∗∣/64⋅Ki)​​​​≡​

Memories can be defined as [imports](#text-import) or [exports](#text-export) inline:

​[import](#text-import)[I](#text-context)​​::=∣​…‘(’ ‘memory’ [id](#text-id)? ‘(’ ‘import’ [name](#text-name)2 ‘)’ [memtype](#text-memtype)[I](#text-context)​ ‘)’‘(’ ‘import’ [name](#text-name)2 ‘(’ ‘memory’ [id](#text-id)? [memtype](#text-memtype)[I](#text-context)​ ‘)’ ‘)’​0.8ex\]‘(’ ‘memory’ id′:[id](#text-id) … ‘)’‘(’ ‘export’ [name](#text-name) ‘(’ ‘memory’ [id](#text-id) ‘)’ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[mems](#text-context)​​​​​≡[export](#text-export)[I](#text-context)​::=‘(’ ‘memory’ id?:[id](#text-id)? ‘(’ ‘export’ [name](#text-name) ‘)’ … ‘)’≡​

Note

The latter abbreviation can be applied repeatedly, if “…” contains additional export clauses. Consequently, a memory declaration can contain any number of exports, possibly followed by an import.

#### 6.6.6. Tables[](#tables⑨)

Table definitions can bind a symbolic [table identifier](#text-id).

​[table](#text-table)[I](#text-context)​​::=​‘(’ ‘table’ id?:[id](#text-id)? tt:[tabletype](#text-tabletype)[I](#text-context)​ e:[expr](#text-expr)[I](#text-context)​ ‘)’​⇒​([table](#syntax-table) tt e,{[tables](#text-context) (id?)})​​

##### 6.6.6.1. Abbreviations[](#abbreviations①⑥)

A table’s initialization [expression](#text-expr) can be omitted, in which case it defaults to ref.null:

​[table](#text-table)[I](#text-context)​​::=∣​…‘(’ ‘table’ [id](#text-id)? tt:[tabletype](#text-tabletype)[I](#text-context)​ ‘)’‘(’ ‘table’ [id](#text-id)? tt:[tabletype](#text-tabletype)[I](#text-context)​ ‘(’ ‘ref.null’ ht:[heaptype](#text-heaptype)[I](#text-context)​ ‘)’ ‘)’if tt\=at lim ([ref](#syntax-reftype) [null](#syntax-reftype)? ht)​​​≡​

An [element segment](#text-elem) can be given inline with a table definition, in which case its offset is 0 and the [limits](#text-limits) of the [table type](#text-tabletype) are inferred from the length of the given segment:

​[table](#text-table)[I](#text-context)​​::=​‘(’ ‘table’ id?:[id](#text-id)? at?:[addrtype](#text-addrtype)? [reftype](#text-reftype)[I](#text-context)​ ‘(’ ‘elem’ (rt,e∗):[elemlist](#text-elemlist)[I](#text-context)​ ‘)’ ‘)’‘(’ ‘table’ id′:[id](#text-id) at?:[addrtype](#text-addrtype)? n:[u64](#text-int) n:[u64](#text-int) [reftype](#text-reftype)[I](#text-context)​ ‘)’‘(’ ‘elem’ ‘(’ ‘table’ id′:[id](#text-id) ‘)’ ‘(’ at′:[addrtype](#text-addrtype) ‘.const’ ‘0’ ‘)’ [elemlist](#text-elemlist)[I](#text-context)​ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[tables](#text-context)∧ at?\=at′∨at?\=ϵ∧at′\=[i32](#syntax-numtype)∧ n\=∣e∗∣​​​​≡​

Tables can be defined as [imports](#text-import) or [exports](#text-export) inline:

​[import](#text-import)[I](#text-context)​​::=∣​…‘(’ ‘table’ [id](#text-id)? ‘(’ ‘import’ [name](#text-name)2 ‘)’ [tabletype](#text-tabletype)[I](#text-context)​ ‘)’‘(’ ‘import’ [name](#text-name)2 ‘(’ ‘table’ [id](#text-id)? [tabletype](#text-tabletype)[I](#text-context)​ ‘)’ ‘)’​0.8ex\]‘(’ ‘table’ id′:[id](#text-id) … ‘)’‘(’ ‘export’ [name](#text-name) ‘(’ ‘table’ [id](#text-id) ‘)’ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[tables](#text-context)​​​​​≡[export](#text-export)[I](#text-context)​::=‘(’ ‘table’ id?:[id](#text-id)? ‘(’ ‘export’ [name](#text-name) ‘)’ … ‘)’≡​

Note

The latter abbreviation can be applied repeatedly, if “…” contains additional export clauses. Consequently, a table declaration can contain any number of exports, possibly followed by an import.

#### 6.6.7. Functions[](#functions⑨)

Function definitions can bind a symbolic [function identifier](#text-id), and [local identifiers](#text-id) for its [parameters](#text-typeuse) and locals.

​[func](#text-func)[I](#text-context)​​::=​‘(’ ‘func’ id?:[id](#text-id)? (x,[I](#text-context)1​):[typeuse](#text-typeuse)[I](#text-context)​ ((loc∗,[I](#text-context)2​):[local](#text-local)[I](#text-context)​)∗ e:[expr](#text-expr)[I](#text-context)′​ ‘)’([func](#syntax-func) x ([⨁](#notation-concat)loc∗∗) e,{[funcs](#text-context) (id?)})if [I](#text-context)′\=[I](#text-context)⊕[I](#text-context)1​⊕[⨁](#notation-concat)[I](#text-context)2∗​∧ ⊢[I](#text-context)′:ok​​​​⇒​

​[local](#text-local)[I](#text-context)​​::=​‘(’ ‘local’ id?:[id](#text-id)? t:[valtype](#text-valtype)[I](#text-context)​ ‘)’([local](#syntax-local) t,{[locals](#text-context) (id?)})​​⇒​

Note

The [well-formedness](#text-context-wf) condition on [I](#text-context)′ ensures that parameters and locals do not contain duplicate identifiers.

##### 6.6.7.1. Abbreviations[](#abbreviations①⑦)

Multiple anonymous locals may be combined into a single declaration:

​[local](#text-local)[I](#text-context)​​::=​… ∣ ‘(’ ‘local’ t:[valtype](#text-valtype)[I](#text-context)∗​ ‘)’​≡​(‘(’ ‘local’ t:[valtype](#text-valtype)[I](#text-context)​ ‘)’)∗​​

Functions can be defined as [imports](#text-import) or [exports](#text-export) inline:

​[import](#text-import)[I](#text-context)​​::=∣​…‘(’ ‘func’ [id](#text-id)? ‘(’ ‘import’ [name](#text-name)2 ‘)’ [typeuse](#text-typeuse)[I](#text-context)​ ‘)’‘(’ ‘import’ [name](#text-name)2 ‘(’ ‘func’ [id](#text-id)? [typeuse](#text-typeuse)[I](#text-context)​ ‘)’ ‘)’​0.8ex\]‘(’ ‘func’ id′:[id](#text-id) … ‘)’‘(’ ‘export’ [name](#text-name) ‘(’ ‘func’ [id](#text-id) ‘)’ ‘)’​if id?\=id′∨id?\=ϵ∧id′∈/[I](#text-context).[funcs](#text-context)​​​​​≡[export](#text-export)[I](#text-context)​::=‘(’ ‘func’ id?:[id](#text-id)? ‘(’ ‘export’ [name](#text-name) ‘)’ … ‘)’≡​

Note

The latter abbreviation can be applied repeatedly, if “…” contains additional export clauses. Consequently, a function declaration can contain any number of exports, possibly followed by an import.

#### 6.6.8. Data Segments[](#data-segments⑦)

Data segments allow for an optional [memory index](#text-memidx) to identify the memory to initialize. The data is written as a [string](#text-string), which may be split up into a possibly empty sequence of individual string literals.

​[data](#text-data)[I](#text-context)​[offset](#text-memarg)[I](#text-context)​​::=∣::=​‘(’ ‘data’ id?:[id](#text-id)? b∗:[datastring](#text-datastring) ‘)’([data](#syntax-data) b∗ [passive](#syntax-datamode),{[datas](#text-context) (id?)})​‘(’ ‘data’ id?:[id](#text-id)? x:[memuse](#text-memuse)[I](#text-context)​ e:[offset](#text-memarg)[I](#text-context)​ b∗:[datastring](#text-datastring) ‘)’([data](#syntax-data) b∗ ([active](#syntax-datamode) x e),{[datas](#text-context) (id?)})​0.8ex\]‘(’ ‘offset’ e:[expr](#text-expr)[I](#text-context)​ ‘)’​⇒⇒[datastring](#text-datastring)⇒​::=e​b∗∗:[string](#text-string)∗​⇒​[⨁](#notation-concat)b∗∗0.8ex\]​[memuse](#text-memuse)[I](#text-context)​​::=​‘(’ ‘memory’ x:[memidx](#text-memidx)[I](#text-context)​ ‘)’​⇒​x​​

Note

In the current version of WebAssembly, the only valid memory index is 0 or a symbolic [memory identifier](#text-id) resolving to the same value.

##### 6.6.8.1. Abbreviations[](#abbreviations①⑧)

As an abbreviation, a single [folded instruction](#text-foldedinstr) may occur in place of the offset of an active segment:

​[offset](#text-memarg)[I](#text-context)​​::=​… ∣ [foldedinstr](#text-foldedinstr)[I](#text-context)​​≡​‘(’ ‘offset’ [foldedinstr](#text-foldedinstr)[I](#text-context)​ ‘)’​​

Also, a memory use can be omitted, defaulting to 0.

​[memuse](#text-memuse)[I](#text-context)​​::=​… ∣ ϵ​≡​‘(’ ‘memory’ ‘0’ ‘)’​​

As another abbreviation, data segments may also be specified inline with [memory](#text-mem) definitions; see the respective section.

#### 6.6.9. Element Segments[](#element-segments⑦)

Element segments allow for an optional [table index](#text-tableidx) to identify the table to initialize.

​[elem](#text-elem)[I](#text-context)​[elemexpr](#text-elemexpr)[I](#text-context)​​::=∣∣::=​‘(’ ‘elem’ id?:[id](#text-id)? (rt,e∗):[elemlist](#text-elemlist)[I](#text-context)​ ‘)’([elem](#syntax-elem) rt e∗ [passive](#syntax-elemmode),{[elems](#text-context) (id?)})​‘(’ ‘elem’ id?:[id](#text-id)? x:[tableuse](#text-tableuse)[I](#text-context)​ e′:[offset](#text-memarg)[I](#text-context)​ (rt,e∗):[elemlist](#text-elemlist)[I](#text-context)​ ‘)’([elem](#syntax-elem) rt e∗ ([active](#syntax-elemmode) x e′),{[elems](#text-context) (id?)})​‘(’ ‘elem’ id?:[id](#text-id)? ‘declare’ (rt,e∗):[elemlist](#text-elemlist)[I](#text-context)​ ‘)’([elem](#syntax-elem) rt e∗ [declare](#syntax-elemmode),{[elems](#text-context) (id?)})​0.8ex\]‘(’ ‘item’ e:[expr](#text-expr)[I](#text-context)​ ‘)’​⇒⇒⇒[elemlist](#text-elemlist)[I](#text-context)​⇒​::=e0.8ex\]​rt:[reftype](#text-reftype)[I](#text-context)​ e∗:[list](#text-list)([expr](#text-expr)[I](#text-context)​)[tableuse](#text-tableuse)[I](#text-context)​​⇒::=​(rt,e∗)‘(’ ‘table’ x:[tableidx](#text-tableidx)[I](#text-context)​ ‘)’​⇒​x​​

##### 6.6.9.1. Abbreviations[](#abbreviations①⑨)

As an abbreviation, a single [folded instruction](#text-foldedinstr) may occur in place of the offset of an active element segment or as an element expression:

​[elemexpr](#text-elemexpr)[I](#text-context)​​::=​… ∣ [foldedinstr](#text-foldedinstr)[I](#text-context)​​≡​‘(’ ‘item’ [foldedinstr](#text-foldedinstr)[I](#text-context)​ ‘)’​​

Also, the element list may be written as just a sequence of [function indices](#text-funcidx):

​[elemlist](#text-elemlist)[I](#text-context)​​::=​… ∣ ‘func’ x∗:[funcidx](#text-funcidx)[I](#text-context)∗​​≡​‘(’ ‘ref’ ‘func’ ‘)’ (‘(’ ‘ref.func’ [funcidx](#text-funcidx)[I](#text-context)​ ‘)’)∗​​

A table use can be omitted, defaulting to 0.

​[tableuse](#text-tableuse)[I](#text-context)​​::=​… ∣ ϵ​≡​‘(’ ‘table’ ‘0’ ‘)’​​

Furthermore, for backwards compatibility with earlier versions of WebAssembly, if the table use is omitted, the ‘func’ keyword can be omitted as well.

​[elem](#text-elem)[I](#text-context)​​::=∣​…‘(’ ‘elem’ e′:[offset](#text-memarg)[I](#text-context)​ [list](#text-list)([funcidx](#text-funcidx)[I](#text-context)​) ‘)’‘(’ ‘elem’ e′:[offset](#text-memarg)[I](#text-context)​ ‘func’ [list](#text-list)([funcidx](#text-funcidx)[I](#text-context)​) ‘)’​​≡​​​​

As yet another abbreviation, element segments may also be specified inline with [table](#text-table) definitions; see the respective section.

#### 6.6.10. Start Function[](#start-function⑤)

A [start function](#syntax-start) is defined in terms of its index.

​[start](#text-start)[I](#text-context)​​::=​‘(’ ‘start’ x:[funcidx](#text-funcidx)[I](#text-context)​ ‘)’​⇒​([start](#syntax-start) x,{})​​

Note

At most one start function may occur in a module, which is ensured by a suitable side condition on the [module](#text-module) grammar.

#### 6.6.11. Imports[](#imports⑤)

The [external type](#syntax-externtype) in imports can bind a symbolic tag, global, memory, or function [identifier](#text-id).

​[import](#text-import)[I](#text-context)​​::=​‘(’ ‘import’ nm1​:[name](#text-name) nm2​:[name](#text-name) (xt,[I](#text-context)′):[externtype](#text-externtype)[I](#text-context)​ ‘)’​⇒​([import](#syntax-import) nm1​ nm2​ xt,[I](#text-context)′)​​

##### 6.6.11.1. Abbreviations[](#abbreviations②⓪)

As an abbreviation, imports may also be specified inline with [tag](#text-tag), [global](#text-global), [memory](#text-mem), [table](#text-table), or [function](#text-func) definitions; see the respective sections.

#### 6.6.12. Exports[](#exports⑤)

The syntax for exports mirrors their [abstract syntax](#syntax-export) directly.

​[export](#text-export)[I](#text-context)​​::=∣∣∣∣​‘(’ ‘export’ nm:[name](#text-name) xx:[externidx](#text-externidx)[I](#text-context)​ ‘)’‘(’ ‘global’ x:[globalidx](#text-globalidx)[I](#text-context)​ ‘)’‘(’ ‘memory’ x:[memidx](#text-memidx)[I](#text-context)​ ‘)’‘(’ ‘table’ x:[tableidx](#text-tableidx)[I](#text-context)​ ‘)’‘(’ ‘func’ x:[funcidx](#text-funcidx)[I](#text-context)​ ‘)’​⇒⇒⇒⇒⇒​([export](#syntax-export) nm xx,{})0.8ex\][global](#syntax-externidx) x[memory](#syntax-externidx) x[table](#syntax-externidx) x[func](#syntax-externidx) x​[externidx](#text-externidx)[I](#text-context)​::=‘(’ ‘tag’ x:[tagidx](#text-tagidx)[I](#text-context)​ ‘)’⇒[tag](#syntax-externidx) x​

##### 6.6.12.1. Abbreviations[](#abbreviations②①)

As an abbreviation, exports may also be specified inline with [tag](#text-tag), [global](#text-global), [memory](#text-mem), [table](#text-table), or [function](#text-func) definitions; see the respective sections.

#### 6.6.13. Modules[](#modules①③)

A module consists of a sequence of _declarations_ that can occur in any order.

​[decl](#syntax-decl)​::=​[type](#syntax-rectype) ∣ [import](#syntax-import) ∣ [tag](#syntax-tag) ∣ [global](#syntax-global) ∣ [mem](#syntax-mem) ∣ [table](#syntax-table) ∣ [func](#syntax-func) ∣ [data](#syntax-data) ∣ [elem](#syntax-elem) ∣ [start](#syntax-start) ∣ [export](#syntax-export)​​

All declarations and their respective bound [identifiers](#text-id) scope over the entire module, including the text preceding them. A module itself may optionally bind an [identifier](#text-id) that names the module. The name serves a documentary role only.

Note

Tools may include the module name in the [name section](#binary-namesec) of the [binary format](#binary).

​[decl](#text-decl)[I](#text-context)​​::=∣​[type](#text-type)[I](#text-context)​ ∣ [import](#text-import)[I](#text-context)​ ∣ [tag](#text-tag)[I](#text-context)​ ∣ [global](#text-global)[I](#text-context)​ ∣ [mem](#text-mem)[I](#text-context)​ ∣ [table](#text-table)[I](#text-context)​[func](#text-func)[I](#text-context)​ ∣ [data](#text-data)[I](#text-context)​ ∣ [elem](#text-elem)[I](#text-context)​ ∣ [start](#text-start)[I](#text-context)​ ∣ [export](#text-export)[I](#text-context)​​​

​[module](#text-module)​::=​‘(’ ‘module’ [id](#text-id)? ([decl](#syntax-decl),[I](#text-context))∗:[decl](#text-decl)[I](#text-context)′∗​ ‘)’[module](#syntax-module) [type](#syntax-rectype)∗ [import](#syntax-import)∗ [tag](#syntax-tag)∗ [global](#syntax-global)∗ [mem](#syntax-mem)∗ [table](#syntax-table)∗ [func](#syntax-func)∗ [data](#syntax-data)∗ [elem](#syntax-elem)∗ [start](#syntax-start)? [export](#syntax-export)∗if [I](#text-context)′\=[⨁](#notation-concat)[I](#text-context)∗∧ ⊢[I](#text-context)′:ok∧ [type](#syntax-rectype)∗\=[types](#syntax-decl)([decl](#syntax-decl)∗)∧ [import](#syntax-import)∗\=[imports](#syntax-decl)([decl](#syntax-decl)∗)∧ [tag](#syntax-tag)∗\=[tags](#syntax-decl)([decl](#syntax-decl)∗)∧ [global](#syntax-global)∗\=[globals](#syntax-decl)([decl](#syntax-decl)∗)∧ [mem](#syntax-mem)∗\=[mems](#syntax-decl)([decl](#syntax-decl)∗)∧ [table](#syntax-table)∗\=[tables](#syntax-decl)([decl](#syntax-decl)∗)∧ [func](#syntax-func)∗\=[funcs](#syntax-decl)([decl](#syntax-decl)∗)∧ [data](#syntax-data)∗\=[datas](#syntax-decl)([decl](#syntax-decl)∗)∧ [elem](#syntax-elem)∗\=[elems](#syntax-decl)([decl](#syntax-decl)∗)∧ [start](#syntax-start)?\=[starts](#syntax-decl)([decl](#syntax-decl)∗)∧ [export](#syntax-export)∗\=[exports](#syntax-decl)([decl](#syntax-decl)∗)∧ [ordered](#aux-ordered)([decl](#syntax-decl)∗)​​​​⇒​

where types([decl](#syntax-decl)∗), imports([decl](#syntax-decl)∗), tags([decl](#syntax-decl)∗), etc., extract the sequence of [types](#syntax-type), [imports](#syntax-import), [tags](#syntax-tag), etc., contained in [decl](#syntax-decl)∗, respectively. The auxiliary predicate [ordered](#aux-ordered) checks that no imports occur after the first definition of a [tag](#syntax-tag), [global](#syntax-global), [memory](#syntax-mem), [table](#syntax-table), or [function](#syntax-func) in a sequence of declarations:

[ordered](#aux-ordered)([decl](#syntax-decl)′∗)[ordered](#aux-ordered)([decl](#syntax-decl)1∗​ [import](#syntax-import) [decl](#syntax-decl)2∗​)[imports](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ∧[tags](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ∧[globals](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ∧[mems](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ∧[tables](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ∧[funcs](#syntax-decl)([decl](#syntax-decl)1∗​)\=ϵ​​\=\=​true​if [imports](#syntax-decl)([decl](#syntax-decl)′∗)\=ϵ​​

##### 6.6.13.1. Abbreviations[](#abbreviations②②)

In a source file, the toplevel ‘(’ ‘module’ decldots ‘)’ surrounding the module body may be omitted.

​[module](#text-module)​::=​… ∣ [decl](#text-decl)[I](#text-context)∗​​≡​‘(’ ‘module’ [decl](#text-decl)[I](#text-context)∗​ ‘)’​​

A Appendix[](#a-appendix)
-------------------------

### A.1 Embedding[](#a1-embedding)

A WebAssembly implementation will typically be _embedded_ into a _host_ environment. An _embedder_ implements the connection between such a host environment and the WebAssembly semantics as defined in the main body of this specification. An embedder is expected to interact with the semantics in well-defined ways.

This section defines a suitable interface to the WebAssembly semantics in the form of entry points through which an embedder can access it. The interface is intended to be complete, in the sense that an embedder does not need to reference other functional parts of the WebAssembly specification directly.

Note

On the other hand, an embedder does not need to provide the host environment with access to all functionality defined in this interface. For example, an implementation may not support [parsing](#embed-module-parse) of the [text format](#text).

#### Types[](#types①⑨)

In the description of the embedder interface, syntactic classes from the [abstract syntax](#syntax) and the [runtime’s abstract machine](#syntax-runtime) are used as names for variables that range over the possible objects from that class. Hence, these syntactic classes can also be interpreted as types.

For numeric parameters, notation like i:[u64](#syntax-int) is used to specify a symbolic name in addition to the respective value range.

#### Booleans[](#booleans①)

Interface operation that are predicates return Boolean values:

​[bool](#embed-bool)​::=​[false](#embed-bool) ∣ [true](#embed-bool)​​

#### Exceptions and Errors[](#exceptions-and-errors①)

Invoking an exported function may throw or propagate exceptions, expressed by an auxiliary syntactic class:

​[exception](#embed-error)​::=​[exception](#embed-error) [exnaddr](#syntax-exnaddr)​​

The exception address exnaddr identifies the exception thrown.

Failure of an interface operation is also indicated by an auxiliary syntactic class:

​[error](#embed-error)​::=​[error](#embed-error)​​

In addition to the error conditions specified explicitly in this section, such as invalid arguments or [exceptions](#exception) and [traps](#trap) resulting from [execution](#exec), implementations may also return errors when specific [implementation limitations](#impl) are reached.

Note

Errors are abstract and unspecific with this definition. Implementations can refine it to carry suitable classifications and diagnostic messages.

#### Pre- and Post-Conditions[](#pre--and-post-conditions)

Some operations state _pre-conditions_ about their arguments or _post-conditions_ about their results. It is the embedder’s responsibility to meet the pre-conditions. If it does, the post conditions are guaranteed by the semantics.

In addition to pre- and post-conditions explicitly stated with each operation, the specification adopts the following conventions for [runtime objects](#syntax-runtime) ([store](#syntax-store), [moduleinst](#syntax-moduleinst), [addresses](#syntax-addr)):

*   Every runtime object passed as a parameter must be [valid](#valid-store) per an implicit pre-condition.
    
*   Every runtime object returned as a result is [valid](#valid-store) per an implicit post-condition.
    

Note

As long as an embedder treats runtime objects as abstract and only creates and manipulates them through the interface defined here, all implicit pre-conditions are automatically met.

#### Store[](#store③)

##### store\_init():[store](#syntax-store)[](#-mathrmstore_init--hrefsyntax-storemathitstore)

1.  Return the empty [store](#syntax-store).
    

store\_init()​\=​{}​​

#### Modules[](#modules①⑤)

##### module\_decode([byte](#syntax-byte)∗):[module](#syntax-module) ∣ [error](#embed-error)[](#-mathrmmodule_decode-hrefsyntax-bytemathitbyteast--hrefsyntax-modulemathitmodule--hrefembed-errormathiterror)

1.  If there exists a derivation for the [byte](#syntax-byte) sequence [byte](#syntax-byte)∗ as a [module](#binary-module) according to the [binary grammar for modules](#binary-module), yielding a [module](#syntax-module) m, then return m.
    
2.  Else, return [error](#embed-error).
    

module\_decode(b∗)module\_decode(b∗)​\=\=​m[error](#embed-error)​​(if[module](#binary-module)⟹∗​m:b∗)(otherwise)​​

##### module\_parse([char](#syntax-name)∗):[module](#syntax-module) ∣ [error](#embed-error)[](#-mathrmmodule_parse-hrefsyntax-namemathitcharast--hrefsyntax-modulemathitmodule--hrefembed-errormathiterror)

1.  If there exists a derivation for the [source](#text-source) [char](#syntax-name)∗ as a [module](#text-module) according to the [text grammar for modules](#text-module), yielding a [module](#syntax-module) m, then return m.
    
2.  Else, return [error](#embed-error).
    

module\_parse(c∗)module\_parse(c∗)​\=\=​m[error](#embed-error)​​(if[module](#text-module)⟹∗​m:c∗)(otherwise)​​

##### module\_validate([module](#syntax-module)):[error](#embed-error)?[](#-mathrmmodule_validate-hrefsyntax-modulemathitmodule--hrefembed-errormathiterror)

1.  If [module](#syntax-module) is [valid](#valid-module), then return nothing.
    
2.  Else, return [error](#embed-error).
    

module\_validate(m)module\_validate(m)​\=\=​ϵ[error](#embed-error)​​(if[⊢](#valid-module)m:[externtype](#syntax-externtype)∗→[externtype](#syntax-externtype)′∗)(otherwise)​​

##### module\_instantiate([store](#syntax-store),[module](#syntax-module),[externaddr](#syntax-externaddr)∗):([store](#syntax-store),[moduleinst](#syntax-moduleinst) ∣ [exception](#embed-error) ∣ [error](#embed-error))[](#-mathrmmodule_instantiate-hrefsyntax-storemathitstore-hrefsyntax-modulemathitmodule-hrefsyntax-externaddrmathitexternaddrast--hrefsyntax-storemathitstore-hrefsyntax-moduleinstmathitmoduleinst--hrefembed-errormathitexception--hrefembed-errormathiterror)

1.  Try [instantiating](#exec-instantiation) [module](#syntax-module) in [store](#syntax-store) with [external addresses](#syntax-externaddr) [externaddr](#syntax-externaddr)∗ as imports:
    

> 1.  If it succeeds with a [module instance](#syntax-moduleinst) [moduleinst](#syntax-moduleinst), then let result be [moduleinst](#syntax-moduleinst).
>     
> 2.  Else, let result be [error](#embed-error).
>     

2.  Return the new store paired with result.
    

module\_instantiate(S,m,ev∗)module\_instantiate(S,m,ev∗)​\=\=​(S′,F.[module](#syntax-frame))(S′,[error](#embed-error))​​(if[instantiate](#exec-instantiation)(S,m,ev∗)[↪](#exec-notation)∗S′;F;ϵ)(otherwise,if[instantiate](#exec-instantiation)(S,m,ev∗)[↪](#exec-notation)∗S′;F;[result](#syntax-result))​​

Note

The store may be modified even in case of an error.

##### module\_imports([module](#syntax-module)):([name](#syntax-name),[name](#syntax-name),[externtype](#syntax-externtype))∗[](#-mathrmmodule_imports-hrefsyntax-modulemathitmodule--hrefsyntax-namemathitname-hrefsyntax-namemathitname-hrefsyntax-externtypemathitexterntypeast)

1.  Pre-condition: [module](#syntax-module) is [valid](#valid-module) with the external import types [externtype](#syntax-externtype)∗ and external export types [externtype](#syntax-externtype)′∗.
    
2.  Let [import](#syntax-import)∗ be the [imports](#syntax-import) of [module](#syntax-module).
    
3.  Assert: the length of [import](#syntax-import)∗ equals the length of [externtype](#syntax-externtype)∗.
    
4.  For each [import](#syntax-import)i​ in [import](#syntax-import)∗ and corresponding [externtype](#syntax-externtype)i​ in [externtype](#syntax-externtype)∗, do:
    

> 1.  Let [import](#syntax-import) nmi1​ nmi2​ xti​ be the deconstruction of [import](#syntax-import)i​.
>     
> 2.  Let resulti​ be the triple (nmi1​,nmi2​,[externtype](#syntax-externtype)i​).
>     

5.  Return the concatenation of all resulti​, in index order.
    
6.  Post-condition: each [externtype](#syntax-externtype)i​ is [valid](#valid-externtype) under the empty [context](#context).
    

module\_imports(m)​\=​(nm1​,nm2​,[externtype](#syntax-externtype))∗(if([import](#syntax-import) nm1​ nm2​ xt∗)∗∈m∧[⊢](#valid-module)m:[externtype](#syntax-externtype)∗→[externtype](#syntax-externtype)′∗)​​

##### module\_exports([module](#syntax-module)):([name](#syntax-name),[externtype](#syntax-externtype))∗[](#-mathrmmodule_exports-hrefsyntax-modulemathitmodule--hrefsyntax-namemathitname-hrefsyntax-externtypemathitexterntypeast)

1.  Pre-condition: [module](#syntax-module) is [valid](#valid-module) with the external import types [externtype](#syntax-externtype)∗ and external export types [externtype](#syntax-externtype)′∗.
    
2.  Let [export](#syntax-export)∗ be the [exports](#syntax-export) of [module](#syntax-module).
    
3.  Assert: the length of [export](#syntax-export)∗ equals the length of [externtype](#syntax-externtype)′∗.
    
4.  For each [export](#syntax-export)i​ in [export](#syntax-export)∗ and corresponding [externtype](#syntax-externtype)i′​ in [externtype](#syntax-externtype)′∗, do:
    

> 1.  Let [export](#syntax-export) nmi​ [externidx](#syntax-externidx)i​ be the deconstruction of [export](#syntax-export)i​.
>     
> 2.  Let resulti​ be the pair (nmi​,[externtype](#syntax-externtype)i′​).
>     

5.  Return the concatenation of all resulti​, in index order.
    
6.  Post-condition: each [externtype](#syntax-externtype)i′​ is [valid](#valid-externtype) under the empty [context](#context).
    

module\_exports(m)mathitnm,[externtype](#syntax-externtype)′)∗​\=​((if([export](#syntax-export) nm xt∗)∗∈m∧[⊢](#valid-module)m:[externtype](#syntax-externtype)∗→[externtype](#syntax-externtype)′∗)​​

#### Module Instances[](#module-instances③)

##### instance\_export([moduleinst](#syntax-moduleinst),[name](#syntax-name)):[externaddr](#syntax-externaddr) ∣ [error](#embed-error)[](#-mathrminstance_export-hrefsyntax-moduleinstmathitmoduleinst-hrefsyntax-namemathitname--hrefsyntax-externaddrmathitexternaddr--hrefembed-errormathiterror)

1.  Assert: due to [validity](#valid-moduleinst) of the [module instance](#syntax-moduleinst) [moduleinst](#syntax-moduleinst), all its [export names](#syntax-exportinst) are different.
    
2.  If there exists an [exportinst](#syntax-exportinst)i​ in [moduleinst](#syntax-moduleinst).[exports](#syntax-moduleinst) such that [name](#syntax-name) [exportinst](#syntax-exportinst)i​.[name](#syntax-exportinst) equals [name](#syntax-name), then:
    
    1.  Return the [external address](#syntax-externaddr) [exportinst](#syntax-exportinst)i​.[addr](#syntax-exportinst).
        
3.  Else, return [error](#embed-error).
    

instance\_export(m,[name](#syntax-name))instance\_export(m,[name](#syntax-name))​\=\=​m.[exports](#syntax-moduleinst)\[i\].[addr](#syntax-exportinst)[error](#embed-error)​​(ifm.[exports](#syntax-moduleinst)\[i\].[name](#syntax-exportinst)\=[name](#syntax-name))(otherwise)​​

#### Functions[](#functions①①)

##### func\_alloc([store](#syntax-store),[deftype](#syntax-deftype),[hostfunc](#syntax-hostfunc)):([store](#syntax-store),[funcaddr](#syntax-funcaddr))[](#-mathrmfunc_alloc-hrefsyntax-storemathitstore-hrefsyntax-deftypemathitdeftype-hrefsyntax-hostfuncmathithostfunc--hrefsyntax-storemathitstore-hrefsyntax-funcaddrmathitfuncaddr)

1.  Pre-condition: the [defined type](#syntax-deftype) [deftype](#syntax-deftype) is [valid](#valid-deftype) under the empty [context](#context) and [expands](#aux-expand-deftype) to a [function type](#syntax-functype).
    
2.  Let [funcaddr](#syntax-funcaddr) be the result of [allocating a host function](#alloc-func) in [store](#syntax-store) with [defined type](#syntax-deftype) [deftype](#syntax-deftype), host function code [hostfunc](#syntax-hostfunc) and an empty [module instance](#syntax-moduleinst).
    
3.  Return the new store paired with [funcaddr](#syntax-funcaddr).
    

func\_alloc(S,dt,code)​\=​(S′,a)​​(if[allocfunc](#alloc-func)(S,dt,code,{})\=S′,a)​​​

Note

This operation assumes that [hostfunc](#syntax-hostfunc) satisfies the [pre- and post-conditions](#exec-invoke-host) required for a function instance with type [deftype](#syntax-deftype).

Regular (non-host) function instances can only be created indirectly through [module instantiation](#embed-module-instantiate).

##### func\_type([store](#syntax-store),[funcaddr](#syntax-funcaddr)):[deftype](#syntax-deftype)[](#-mathrmfunc_type-hrefsyntax-storemathitstore-hrefsyntax-funcaddrmathitfuncaddr--hrefsyntax-deftypemathitdeftype)

1.  Let [deftype](#syntax-deftype) be the [definedn type](#syntax-deftype) S.[funcs](#syntax-store)\[a\].[type](#syntax-funcinst).
    
2.  Return [deftype](#syntax-deftype).
    
3.  Post-condition: the returned [defined type](#syntax-deftype) is [valid](#valid-deftype) and [expands](#aux-expand-deftype) to a [function type](#syntax-functype).
    

func\_type(S,a)​\=​S.[funcs](#syntax-store)\[a\].[type](#syntax-funcinst)​​

##### func\_invoke([store](#syntax-store),[funcaddr](#syntax-funcaddr),[val](#syntax-val)∗):([store](#syntax-store),[val](#syntax-val)∗ ∣ [exception](#embed-error) ∣ [error](#embed-error))[](#-mathrmfunc_invoke-hrefsyntax-storemathitstore-hrefsyntax-funcaddrmathitfuncaddr-hrefsyntax-valmathitvalast--hrefsyntax-storemathitstore-hrefsyntax-valmathitvalast--hrefembed-errormathitexception--hrefembed-errormathiterror)

1.  Try [invoking](#exec-invocation) the function [funcaddr](#syntax-funcaddr) in [store](#syntax-store) with [values](#syntax-val) [val](#syntax-val)∗ as arguments:
    

> 1.  If it succeeds with [values](#syntax-val) [val](#syntax-val)′∗ as results, then let result be [val](#syntax-val)′∗.
>     
> 2.  Else if the outcome is an exception with a thrown [exception](#exec-throw-ref) [ref.exn](#syntax-ref) [exnaddr](#syntax-exnaddr) as the result, then let result be [exception](#embed-error) [exnaddr](#syntax-exnaddr)
>     
> 3.  Else it has trapped, hence let result be [error](#embed-error).
>     

2.  Return the new store paired with result.
    

func\_invoke(S,a,v∗)func\_invoke(S,a,v∗)func\_invoke(S,a,v∗)​\=\=\=​(S′,v′∗)(S′,[exception](#embed-error) a′)(S′,[error](#embed-error))​​(if[invoke](#exec-invocation)(S,a,v∗)[↪](#exec-notation)∗S′;F;v′∗)(if[invoke](#exec-invocation)(S,a,v∗)[↪](#exec-notation)∗S′;F;([ref.exn](#syntax-ref) a′) [throw\_ref](#syntax-instr-control)(if[invoke](#exec-invocation)(S,a,v∗)[↪](#exec-notation)∗S′;F;[trap](#syntax-trap))​​

Note

The store may be modified even in case of an error.

#### Tables[](#tables①①)

##### table\_alloc([store](#syntax-store),[tabletype](#syntax-tabletype),[ref](#syntax-ref)):([store](#syntax-store),[tableaddr](#syntax-tableaddr))[](#-mathrmtable_alloc-hrefsyntax-storemathitstore-hrefsyntax-tabletypemathittabletype-hrefsyntax-refmathitref--hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr)

1.  Pre-condition: the [tabletype](#syntax-tabletype) is [valid](#valid-tabletype) under the empty [context](#context).
    
2.  Let [tableaddr](#syntax-tableaddr) be the result of [allocating a table](#alloc-table) in [store](#syntax-store) with [table type](#syntax-tabletype) [tabletype](#syntax-tabletype) and initialization value [ref](#syntax-ref).
    
3.  Return the new store paired with [tableaddr](#syntax-tableaddr).
    

table\_alloc(S,tt,r)​\=​(S′,a)​​(if[alloctable](#alloc-table)(S,tt,r)\=S′,a)​​

##### table\_type([store](#syntax-store),[tableaddr](#syntax-tableaddr)):[tabletype](#syntax-tabletype)[](#-mathrmtable_type-hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr--hrefsyntax-tabletypemathittabletype)

1.  Return S.[tables](#syntax-store)\[a\].[type](#syntax-tableinst).
    
2.  Post-condition: the returned [table type](#syntax-tabletype) is [valid](#valid-tabletype) under the empty [context](#context).
    

table\_type(S,a)​\=​S.[tables](#syntax-store)\[a\].[type](#syntax-tableinst)​​

##### table\_read([store](#syntax-store),[tableaddr](#syntax-tableaddr),i:[u64](#syntax-int)):[ref](#syntax-ref) ∣ [error](#embed-error)[](#-mathrmtable_read-hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr-ihrefsyntax-intmathituscriptstylekern-01em64--hrefsyntax-refmathitref--hrefembed-errormathiterror)

1.  Let ti be the [table instance](#syntax-tableinst) [store](#syntax-store).[tables](#syntax-store)\[[tableaddr](#syntax-tableaddr)\].
    
2.  If i is larger than or equal to the length of ti.[refs](#syntax-tableinst), then return [error](#embed-error).
    
3.  Else, return the [reference value](#syntax-ref) ti.[refs](#syntax-tableinst)\[i\].
    

table\_read(S,a,i)table\_read(S,a,i)​\=\=​r[error](#embed-error)​​(ifS.[tables](#syntax-store)\[a\].[refs](#syntax-tableinst)\[i\]\=r)(otherwise)​​

##### table\_write([store](#syntax-store),[tableaddr](#syntax-tableaddr),i:[u64](#syntax-int),[ref](#syntax-ref)):[store](#syntax-store) ∣ [error](#embed-error)[](#-mathrmtable_write-hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr-ihrefsyntax-intmathituscriptstylekern-01em64-hrefsyntax-refmathitref--hrefsyntax-storemathitstore--hrefembed-errormathiterror)

1.  Let ti be the [table instance](#syntax-tableinst) [store](#syntax-store).[tables](#syntax-store)\[[tableaddr](#syntax-tableaddr)\].
    
2.  If i is larger than or equal to the length of ti.[refs](#syntax-tableinst), then return [error](#embed-error).
    
3.  Replace ti.[refs](#syntax-tableinst)\[i\] with the [reference value](#syntax-ref) [ref](#syntax-ref).
    
4.  Return the updated store.
    

table\_write(S,a,i,r)table\_write(S,a,i,r)​\=\=​S′[error](#embed-error)​​(ifS′\=S[with](#notation-replace)[tables](#syntax-store)\[a\].[refs](#syntax-tableinst)\[i\]\=r)(otherwise)​​

##### table\_size([store](#syntax-store),[tableaddr](#syntax-tableaddr)):[u64](#syntax-int)[](#-mathrmtable_size-hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr--hrefsyntax-intmathituscriptstylekern-01em64)

1.  Return the length of [store](#syntax-store).[tables](#syntax-store)\[[tableaddr](#syntax-tableaddr)\].[refs](#syntax-tableinst).
    

table\_size(S,a)​\=​n​​(if∣S.[tables](#syntax-store)\[a\].[refs](#syntax-tableinst)∣\=n)​​

##### table\_grow([store](#syntax-store),[tableaddr](#syntax-tableaddr),n:[u64](#syntax-int),[ref](#syntax-ref)):[store](#syntax-store) ∣ [error](#embed-error)[](#-mathrmtable_grow-hrefsyntax-storemathitstore-hrefsyntax-tableaddrmathittableaddr-nhrefsyntax-intmathituscriptstylekern-01em64-hrefsyntax-refmathitref--hrefsyntax-storemathitstore--hrefembed-errormathiterror)

1.  Try [growing](#grow-table) the [table instance](#syntax-tableinst) [store](#syntax-store).[tables](#syntax-store)\[[tableaddr](#syntax-tableaddr)\] by n elements with initialization value [ref](#syntax-ref):
    
    1.  If it succeeds, return the updated store.
        
    2.  Else, return [error](#embed-error).
        

table\_grow(S,a,n,r)table\_grow(S,a,n,r)​\=\=​S′[error](#embed-error)​​(ifS′\=S[with](#notation-replace)[tables](#syntax-store)\[a\]\=[growtable](#grow-table)(S.[tables](#syntax-store)\[a\],n,r))(otherwise)​​

#### Memories[](#memories①①)

##### mem\_alloc([store](#syntax-store),[memtype](#syntax-memtype)):([store](#syntax-store),[memaddr](#syntax-memaddr))[](#-mathrmmem_alloc-hrefsyntax-storemathitstore-hrefsyntax-memtypemathitmemtype--hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr)

1.  Pre-condition: the [memtype](#syntax-memtype) is [valid](#valid-memtype) under the empty [context](#context).
    
2.  Let [memaddr](#syntax-memaddr) be the result of [allocating a memory](#alloc-mem) in [store](#syntax-store) with [memory type](#syntax-memtype) [memtype](#syntax-memtype).
    
3.  Return the new store paired with [memaddr](#syntax-memaddr).
    

mem\_alloc(S,mt)​\=​(S′,a)​​(if[allocmem](#alloc-mem)(S,mt)\=S′,a)​​

##### mem\_type([store](#syntax-store),[memaddr](#syntax-memaddr)):[memtype](#syntax-memtype)[](#-mathrmmem_type-hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr--hrefsyntax-memtypemathitmemtype)

1.  Return S.[mems](#syntax-store)\[a\].[type](#syntax-meminst).
    
2.  Post-condition: the returned [memory type](#syntax-memtype) is [valid](#valid-memtype) under the empty [context](#context).
    

mem\_type(S,a)​\=​S.[mems](#syntax-store)\[a\].[type](#syntax-meminst)​​

##### mem\_read([store](#syntax-store),[memaddr](#syntax-memaddr),i:[u64](#syntax-int)):[byte](#syntax-byte) ∣ [error](#embed-error)[](#-mathrmmem_read-hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr-ihrefsyntax-intmathituscriptstylekern-01em64--hrefsyntax-bytemathitbyte--hrefembed-errormathiterror)

1.  Let mi be the [memory instance](#syntax-meminst) [store](#syntax-store).[mems](#syntax-store)\[[memaddr](#syntax-memaddr)\].
    
2.  If i is larger than or equal to the length of mi.[bytes](#syntax-meminst), then return [error](#embed-error).
    
3.  Else, return the [byte](#syntax-byte) mi.[bytes](#syntax-meminst)\[i\].
    

mem\_read(S,a,i)mem\_read(S,a,i)​\=\=​b[error](#embed-error)​​(ifS.[mems](#syntax-store)\[a\].[bytes](#syntax-meminst)\[i\]\=b)(otherwise)​​

##### mem\_write([store](#syntax-store),[memaddr](#syntax-memaddr),i:[u64](#syntax-int),[byte](#syntax-byte)):[store](#syntax-store) ∣ [error](#embed-error)[](#-mathrmmem_write-hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr-ihrefsyntax-intmathituscriptstylekern-01em64-hrefsyntax-bytemathitbyte--hrefsyntax-storemathitstore--hrefembed-errormathiterror)

1.  Let mi be the [memory instance](#syntax-meminst) [store](#syntax-store).[mems](#syntax-store)\[[memaddr](#syntax-memaddr)\].
    
2.  If i is larger than or equal to the length of mi.[bytes](#syntax-meminst), then return [error](#embed-error).
    
3.  Replace mi.[bytes](#syntax-meminst)\[i\] with [byte](#syntax-byte).
    
4.  Return the updated store.
    

mem\_write(S,a,i,b)mem\_write(S,a,i,b)​\=\=​S′[error](#embed-error)​​(ifS′\=S[with](#notation-replace)[mems](#syntax-store)\[a\].[bytes](#syntax-meminst)\[i\]\=b)(otherwise)​​

##### mem\_size([store](#syntax-store),[memaddr](#syntax-memaddr)):[u64](#syntax-int)[](#-mathrmmem_size-hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr--hrefsyntax-intmathituscriptstylekern-01em64)

1.  Return the length of [store](#syntax-store).[mems](#syntax-store)\[[memaddr](#syntax-memaddr)\].[bytes](#syntax-meminst) divided by the [page size](#page-size).
    

mem\_size(S,a)​\=​n​​(if∣S.[mems](#syntax-store)\[a\].[bytes](#syntax-meminst)∣\=n⋅64Ki)​​

##### mem\_grow([store](#syntax-store),[memaddr](#syntax-memaddr),n:[u64](#syntax-int)):[store](#syntax-store) ∣ [error](#embed-error)[](#-mathrmmem_grow-hrefsyntax-storemathitstore-hrefsyntax-memaddrmathitmemaddr-nhrefsyntax-intmathituscriptstylekern-01em64--hrefsyntax-storemathitstore--hrefembed-errormathiterror)

1.  Try [growing](#grow-mem) the [memory instance](#syntax-meminst) [store](#syntax-store).[mems](#syntax-store)\[[memaddr](#syntax-memaddr)\] by n [pages](#page-size):
    
    1.  If it succeeds, return the updated store.
        
    2.  Else, return [error](#embed-error).
        

mem\_grow(S,a,n)mem\_grow(S,a,n)​\=\=​S′[error](#embed-error)​​(ifS′\=S[with](#notation-replace)[mems](#syntax-store)\[a\]\=[growmem](#grow-mem)(S.[mems](#syntax-store)\[a\],n))(otherwise)​​

#### Tags[](#tags①①)

##### tag\_alloc([store](#syntax-store),[tagtype](#syntax-tagtype)):([store](#syntax-store),[tagaddr](#syntax-tagaddr))[](#-mathrmtag_alloc-hrefsyntax-storemathitstore-hrefsyntax-tagtypemathittagtype--hrefsyntax-storemathitstore-hrefsyntax-tagaddrmathittagaddr)

1.  Pre-condition: tagtype is [valid](#valid-tagtype).
    
2.  Let [tagaddr](#syntax-tagaddr) be the result of [allocating a tag](#alloc-tag) in [store](#syntax-store) with [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype).
    
3.  Return the new store paired with [tagaddr](#syntax-tagaddr).
    

tag\_alloc(S,tt)​\=​(S′,a)​​(if[alloctag](#alloc-tag)(S,tt)\=S′,a)​​

##### tag\_type([store](#syntax-store),[tagaddr](#syntax-tagaddr)):[tagtype](#syntax-tagtype)[](#-mathrmtag_type-hrefsyntax-storemathitstore-hrefsyntax-tagaddrmathittagaddr--hrefsyntax-tagtypemathittagtype)

1.  Return S.[tags](#syntax-store)\[a\].[type](#syntax-taginst).
    
2.  Post-condition: the returned [tag type](#syntax-tagtype) is [valid](#valid-tagtype).
    

tag\_type(S,a)​\=​S.[tags](#syntax-store)\[a\].[type](#syntax-taginst)​​

#### Exceptions[](#exceptions①)

##### exn\_alloc([store](#syntax-store),[tagaddr](#syntax-tagaddr),[val](#syntax-val)∗):([store](#syntax-store),[exnaddr](#syntax-exnaddr))[](#-mathrmexn_alloc-hrefsyntax-storemathitstore-hrefsyntax-tagaddrmathittagaddr-hrefsyntax-valmathitvalast--hrefsyntax-storemathitstore-hrefsyntax-exnaddrmathitexnaddr)

1.  Pre-condition: [tagaddr](#syntax-tagaddr) is an allocated [tag address](#syntax-tagaddr).
    
2.  Let [exnaddr](#syntax-exnaddr) be the result of [allocating an exception instance](#syntax-exninst) in [store](#syntax-store) with [tag address](#syntax-tagaddr) [tagaddr](#syntax-tagaddr) and initialization values [val](#syntax-val)∗.
    
3.  Return the new store paired with [exnaddr](#syntax-exnaddr).
    

exn\_alloc(S,[tagaddr](#syntax-tagaddr),[val](#syntax-val)∗)​\=​(S[⊕](#notation-compose){[exns](#syntax-store) [exninst](#syntax-exninst)},∣S.[exns](#syntax-store)∣)​(if[exninst](#syntax-exninst)\={[tag](#syntax-exninst) [tagaddr](#syntax-tagaddr),[fields](#syntax-exninst) [val](#syntax-val)∗}​​

##### exn\_tag([store](#syntax-store),[exnaddr](#syntax-exnaddr)):[tagaddr](#syntax-tagaddr)[](#-mathrmexn_tag-hrefsyntax-storemathitstore-hrefsyntax-exnaddrmathitexnaddr--hrefsyntax-tagaddrmathittagaddr)

1.  Let [exninst](#syntax-exninst) be the [exception instance](#syntax-exninst) [store](#syntax-store).[exns](#syntax-store)\[[exnaddr](#syntax-exnaddr)\].
    
2.  Return the [tag address](#syntax-tagaddr) [exninst](#syntax-exninst).[tag](#syntax-exninst).
    

exn\_tag(S,a)​\=​[exninst](#syntax-exninst).[tag](#syntax-exninst)​(if[exninst](#syntax-exninst)\=S.[exns](#syntax-store)\[a\])​​

##### exn\_read([store](#syntax-store),[exnaddr](#syntax-exnaddr)):[val](#syntax-val)∗[](#-mathrmexn_read-hrefsyntax-storemathitstore-hrefsyntax-exnaddrmathitexnaddr--hrefsyntax-valmathitvalast)

1.  Let [exninst](#syntax-exninst) be the [exception instance](#syntax-exninst) [store](#syntax-store).[exns](#syntax-store)\[[exnaddr](#syntax-exnaddr)\].
    
2.  Return the [values](#syntax-val) [exninst](#syntax-exninst).[fields](#syntax-exninst).
    

exn\_read(S,a)​\=​[exninst](#syntax-exninst).[fields](#syntax-exninst)​(if[exninst](#syntax-exninst)\=S.[exns](#syntax-store)\[a\])​​

#### Globals[](#globals①①)

##### global\_alloc([store](#syntax-store),[globaltype](#syntax-globaltype),[val](#syntax-val)):([store](#syntax-store),[globaladdr](#syntax-globaladdr))[](#-mathrmglobal_alloc-hrefsyntax-storemathitstore-hrefsyntax-globaltypemathitglobaltype-hrefsyntax-valmathitval--hrefsyntax-storemathitstore-hrefsyntax-globaladdrmathitglobaladdr)

1.  Pre-condition: the [globaltype](#syntax-globaltype) is [valid](#valid-globaltype) under the empty [context](#context).
    
2.  Let [globaladdr](#syntax-globaladdr) be the result of [allocating a global](#alloc-global) in [store](#syntax-store) with [global type](#syntax-globaltype) [globaltype](#syntax-globaltype) and initialization value [val](#syntax-val).
    
3.  Return the new store paired with [globaladdr](#syntax-globaladdr).
    

global\_alloc(S,gt,v)​\=​(S′,a)​​(if[allocglobal](#alloc-global)(S,gt,v)\=S′,a)​​

##### global\_type([store](#syntax-store),[globaladdr](#syntax-globaladdr)):[globaltype](#syntax-globaltype)[](#-mathrmglobal_type-hrefsyntax-storemathitstore-hrefsyntax-globaladdrmathitglobaladdr--hrefsyntax-globaltypemathitglobaltype)

1.  Return S.[globals](#syntax-store)\[a\].[type](#syntax-globalinst).
    
2.  Post-condition: the returned [global type](#syntax-globaltype) is [valid](#valid-globaltype) under the empty [context](#context).
    

global\_type(S,a)​\=​S.[globals](#syntax-store)\[a\].[type](#syntax-globalinst)​​

##### global\_read([store](#syntax-store),[globaladdr](#syntax-globaladdr)):[val](#syntax-val)[](#-mathrmglobal_read-hrefsyntax-storemathitstore-hrefsyntax-globaladdrmathitglobaladdr--hrefsyntax-valmathitval)

1.  Let gi be the [global instance](#syntax-globalinst) [store](#syntax-store).[globals](#syntax-store)\[[globaladdr](#syntax-globaladdr)\].
    
2.  Return the [value](#syntax-val) gi.[value](#syntax-globalinst).
    

global\_read(S,a)​\=​v​​(ifS.[globals](#syntax-store)\[a\].[value](#syntax-globalinst)\=v)​​

##### global\_write([store](#syntax-store),[globaladdr](#syntax-globaladdr),[val](#syntax-val)):[store](#syntax-store) ∣ [error](#embed-error)[](#-mathrmglobal_write-hrefsyntax-storemathitstore-hrefsyntax-globaladdrmathitglobaladdr-hrefsyntax-valmathitval--hrefsyntax-storemathitstore--hrefembed-errormathiterror)

1.  Let gi be the [global instance](#syntax-globalinst) [store](#syntax-store).[globals](#syntax-store)\[[globaladdr](#syntax-globaladdr)\].
    
2.  Let [mut](#syntax-mut) t be the structure of the [global type](#syntax-globaltype) gi.[type](#syntax-globalinst).
    
3.  If [mut](#syntax-mut) is empty, then return [error](#embed-error).
    
4.  Replace gi.[value](#syntax-globalinst) with the [value](#syntax-val) [val](#syntax-val).
    
5.  Return the updated store.
    

global\_write(S,a,v)global\_write(S,a,v)​\=\=​S′[error](#embed-error)​​(ifS.[globals](#syntax-store)\[a\].[type](#syntax-globalinst)\=[mut](#syntax-mut) t∧S′\=S[with](#notation-replace)[globals](#syntax-store)\[a\].[value](#syntax-globalinst)\=v)(otherwise)​​

#### Values[](#values①②)

##### ref\_type([store](#syntax-store),[ref](#syntax-ref)):[reftype](#syntax-reftype)[](#-mathrmref_type-hrefsyntax-storemathitstore-hrefsyntax-refmathitref--hrefsyntax-reftypemathitreftype)

1.  Pre-condition: the [reference](#syntax-ref) [ref](#syntax-ref) is [valid](#valid-val) under store S.
    
2.  Return the [reference type](#syntax-reftype) t with which [ref](#syntax-ref) is valid.
    
3.  Post-condition: the returned [reference type](#syntax-reftype) is [valid](#valid-reftype) under the empty [context](#context).
    

ref\_type(S,r)​\=​t​​(ifS[⊢](#valid-val)r:t)​​

Note

In future versions of WebAssembly, not all references may carry precise type information at run time. In such cases, this function may return a less precise supertype.

##### val\_default([valtype](#syntax-valtype)):[val](#syntax-val)[](#-mathrmval_default-hrefsyntax-valtypemathitvaltype--hrefsyntax-valmathitval)

1.  If [default](#aux-default)valtype​ is not defined, then return [error](#embed-error).
    

1.  Else, return the [value](#syntax-val) [default](#aux-default)valtype​.
    

val\_default(t)val\_default(t)​\=\=​v[error](#embed-error)​​(if[default](#aux-default)t​\=v)(if[default](#aux-default)t​\=ϵ)​​

#### Matching[](#matching③)

##### match\_valtype([valtype](#syntax-valtype)1​,[valtype](#syntax-valtype)2​):[bool](#embed-bool)[](#-mathrmmatch_valtype-hrefsyntax-valtypemathitvaltype_1-hrefsyntax-valtypemathitvaltype_2--hrefembed-boolmathitbool)

1.  Pre-condition: the [value types](#syntax-valtype) [valtype](#syntax-valtype)1​ and [valtype](#syntax-valtype)2​ are [valid](#valid-valtype) under the empty [context](#context).
    
2.  If [valtype](#syntax-valtype)1​ [matches](#match-valtype) [valtype](#syntax-valtype)2​, then return [true](#embed-bool).
    
3.  Else, return [false](#embed-bool).
    

match\_reftype(t1​,t2​)match\_reftype(t1​,t2​)​\=\=​[true](#embed-bool)[false](#embed-bool)​​(if[⊢](#match-valtype)t1​[≤](#match-valtype)t2​)(otherwise)​​

##### match\_externtype([externtype](#syntax-externtype)1​,[externtype](#syntax-externtype)2​):[bool](#embed-bool)[](#-mathrmmatch_externtype-hrefsyntax-externtypemathitexterntype_1-hrefsyntax-externtypemathitexterntype_2--hrefembed-boolmathitbool)

1.  Pre-condition: the [extern types](#syntax-externtype) [externtype](#syntax-externtype)1​ and [externtype](#syntax-externtype)2​ are [valid](#valid-externtype) under the empty [context](#context).
    
2.  If [externtype](#syntax-externtype)1​ [matches](#match-externtype) [externtype](#syntax-externtype)2​, then return [true](#embed-bool).
    
3.  Else, return [false](#embed-bool).
    

match\_externtype(et1​,et2​)match\_externtype(et1​,et2​)​\=\=​[true](#embed-bool)[false](#embed-bool)​​(if[⊢](#match-externtype)et1​[≤](#match-externtype)et2​)(otherwise)​​

### A.2 Profiles[](#a2-profiles)

To enable the use of WebAssembly in as many environments as possible, _profiles_ specify coherent language subsets that fit constraints imposed by common classes of host environments. A host platform can thereby decide to support the language only under a restricted profile, or even the intersection of multiple profiles.

#### Conventions[](#conventions③⑧)

A profile modification is specified by decorating selected rules in the main body of this specification with a _profile annotation_ that defines them as conditional on the choice of profile.

For that purpose, every profile defines a _profile marker_, an alphanumeric short-hand like ABC. A profile annotation of the form \[!ABC XYZ\] on a rule indicates that this rule is _excluded_ for either of the profiles whose marker is ABC or XYZ.

There are two ways of subsetting the language in a profile:

*   _Syntactic_, by _omitting_ a feature, in which case certain constructs are removed from the syntax altogether.
    
*   _Semantic_, by _restricting_ a feature, in which case certain constructs are still present but some behaviours are ruled out.
    

##### Syntax Annotations[](#syntax-annotations①)

To omit a construct from a profile syntactically, respective productions in the grammar of the [abstract syntax](#syntax) are annotated with an associated profile marker. This is defined to have the following implications:

1.  Any production in the [binary](#binary) or [textual](#text) syntax that produces abstract syntax with a marked construct is omitted by extension.
    
2.  Any [validation](#valid) or [execution](#exec) rule that handles a marked construct is omitted by extension.
    

The overall effect is that the respective construct is no longer part of the language under a respective profile.

Note

For example, a “busy” profile marked BUSY could rule out the [nop](#syntax-instr-control) instruction by marking the production for it in the abstract syntax as follows:

​[instr](#syntax-instr)\[!BUSY\]​::=∣∣​…[nop](#syntax-instr-control)[unreachable](#syntax-instr-control)​​

A rule may be annotated by multiple markers, which could be the case if a construct is in the intersection of multiple features.

##### Semantics Annotations[](#semantics-annotations①)

To restrict certain behaviours in a profile, individual [validation](#valid) or [reduction](#exec) rules or auxiliary definitions are annotated with an associated marker.

This has the consequence that the respective rule is no longer applicable under the given profile.

Note

For example, an “infinite” profile marked INF could define that growing memory never fails:

​S;F;([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) [memory.grow](#syntax-instr-memory) x​[↪](#exec-notation)​S′;F;([i32](#syntax-numtype).[const](#syntax-instr-numeric) sz)(if∧∧​F.[module](#syntax-frame).[mems](#syntax-moduleinst)\[x\]\=asz\=∣S.[mems](#syntax-store)\[a\].[datas](#syntax-moduleinst)∣/64KiS′\=S[with](#notation-replace)[mems](#syntax-store)\[a\]\=[growmem](#grow-mem)(S.[mems](#syntax-store)\[a\],n))​1ex\]\[!INF\]​S;F;([i32](#syntax-numtype).[const](#syntax-instr-numeric) n) [memory.grow](#syntax-instr-memory) x​[↪](#exec-notation)​S;F;([i32](#syntax-numtype).[const](#syntax-instr-numeric) [signed](#aux-signed)32−1​(−1))​​

##### Properties[](#properties①)

All profiles are defined such that the following properties are preserved:

*   All profiles represent syntactic and semantic subsets of the [full profile](#profile-full), i.e., they do not _add_ syntax or _alter_ behaviour.
    
*   All profiles are mutually compatible, i.e., no two profiles subset semantic behaviour in inconsistent or ambiguous ways, and any intersection of profiles preserves the properties described here.
    
*   Profiles do not violate [soundness](#soundness), i.e., all [configurations](#syntax-config) valid under that profile still have well-defined execution behaviour.
    

Note

Tools are generally expected to handle and produce code for the full profile by default. In particular, producers should not generate code that _depends_ on specific profiles. Instead, all code should preserve correctness when executed under the full profile.

Moreover, profiles should be considered static and fixed for a given platform or ecosystem. Runtime conditioning on the “current” profile is not intended and should be avoided.

#### Defined Profiles[](#defined-profiles①)

Note

The number of defined profiles is expected to remain small in the future. Profiles are intended for broad and permanent use cases only. In particular, profiles are not intended for language versioning.

##### Full Profile (FUL)[](#full-profile--smallmathrmful)

The _full_ profile contains the complete language and all possible behaviours. It imposes no restrictions, i.e., all rules and definitions are active. All other profiles define sub-languages of this profile.

##### Deterministic Profile (DET)[](#deterministic-profile--smallmathrmdet)

The _deterministic_ profile excludes all rules marked \[![DET](#profile-deterministic)\]. It defines a sub-language that does not exhibit any incidental non-deterministic behaviour:

*   All [NaN](#syntax-nan) values [generated](#aux-nans) by [floating-point instructions](#syntax-instr-numeric) are canonical and positive.
    
*   All [relaxed vector instructions](#syntax-instr-vec-relaxed) have a fixed behaviour that does not depend on the implementation.
    

Even under this profile, the [memory.grow](#syntax-instr-memory) and [table.grow](#syntax-instr-table) instructions technically remain [non-deterministic](#exec-memory-grow), in order to be able to indicate resource exhaustion.

Note

In future versions of WebAssembly, new non-deterministic behaviour may be added to the language, such that the deterministic profile will induce additional restrictions.

### A.3 Implementation Limitations[](#a3-implementation-limitations)

Implementations typically impose additional restrictions on a number of aspects of a WebAssembly module or execution. These may stem from:

*   physical resource limits,
    
*   constraints imposed by the embedder or its environment,
    
*   limitations of selected implementation strategies.
    

This section lists allowed limitations. Where restrictions take the form of numeric limits, no minimum requirements are given, nor are the limits assumed to be concrete, fixed numbers. However, it is expected that all implementations have “reasonably” large limits to enable common applications.

Note

A conforming implementation is not allowed to leave out individual _features_. However, designated subsets of WebAssembly may be specified in the future.

#### Syntactic Limits[](#syntactic-limits①)

##### Structure[](#structure③)

An implementation may impose restrictions on the following dimensions of a module:

*   the number of [types](#syntax-type) in a [module](#syntax-module)
    
*   the number of [functions](#syntax-func) in a [module](#syntax-module), including imports
    
*   the number of [tables](#syntax-table) in a [module](#syntax-module), including imports
    
*   the number of [memories](#syntax-mem) in a [module](#syntax-module), including imports
    
*   the number of [globals](#syntax-global) in a [module](#syntax-module), including imports
    
*   the number of [tags](#syntax-tag) in a [module](#syntax-module), including imports
    
*   the number of [element segments](#syntax-elem) in a [module](#syntax-module)
    
*   the number of [data segments](#syntax-data) in a [module](#syntax-module)
    
*   the number of [imports](#syntax-import) to a [module](#syntax-module)
    
*   the number of [exports](#syntax-export) from a [module](#syntax-module)
    
*   the number of [sub types](#syntax-subtype) in a [recursive type](#syntax-rectype)
    
*   the subtyping depth of a [sub type](#syntax-subtype)
    
*   the number of fields in a [structure type](#syntax-structtype)
    
*   the number of parameters in a [function type](#syntax-functype)
    
*   the number of results in a [function type](#syntax-functype)
    
*   the number of parameters in a [block type](#syntax-blocktype)
    
*   the number of results in a [block type](#syntax-blocktype)
    
*   the number of [locals](#syntax-local) in a [function](#syntax-func)
    
*   the number of [instructions](#syntax-instr) in a [function](#syntax-func) body
    
*   the number of [instructions](#syntax-instr) in a [structured control instruction](#syntax-instr-control)
    
*   the number of [structured control instructions](#syntax-instr-control) in a [function](#syntax-func)
    
*   the nesting depth of [structured control instructions](#syntax-instr-control)
    
*   the number of [label indices](#syntax-labelidx) in a [br\_table](#syntax-instr-control) instruction
    
*   the number of instructions in a [constant](#valid-constant) [expression](#syntax-expr)
    
*   the length of the array in a [array.new\_fixed](#syntax-instr-array) instruction
    
*   the length of an [element segment](#syntax-elem)
    
*   the length of a [data segment](#syntax-data)
    
*   the length of a [name](#syntax-name)
    
*   the range of [characters](#syntax-char) in a [name](#syntax-name)
    

If the limits of an implementation are exceeded for a given module, then the implementation may reject the [validation](#valid), compilation, or [instantiation](#exec-instantiation) of that module with an embedder-specific error.

Note

The last item allows [embedders](#embedder) that operate in limited environments without support for [\[UNICODE\]](#biblio-unicode "The Unicode Standard") to limit the names of [imports](#syntax-import) and [exports](#syntax-export) to common subsets like [ASCII](https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d).

##### Binary Format[](#binary-format③)

For a module given in [binary format](#binary), additional limitations may be imposed on the following dimensions:

*   the size of a [module](#binary-module)
    
*   the size of any [section](#binary-section)
    
*   the size of an individual [function](#syntax-func)’s [code](#binary-code)
    
*   the size of a [structured control instruction](#syntax-instr-control)
    
*   the size of an individual [constant](#valid-constant) [expression](#syntax-expr)’s instruction sequence
    
*   the number of [sections](#binary-section)
    

##### Text Format[](#text-format④)

For a module given in [text format](#text), additional limitations may be imposed on the following dimensions:

*   the size of the [source text](#source)
    
*   the size of any syntactic element
    
*   the size of an individual [token](#text-token)
    
*   the nesting depth of [folded instructions](#text-foldedinstr)
    
*   the length of symbolic [identifiers](#text-id)
    
*   the range of literal [characters](#text-char) allowed in the [source text](#source)
    

#### Validation[](#validation④)

An implementation may defer [validation](#valid) of individual [functions](#syntax-func) until they are first [invoked](#exec-invoke).

If a function turns out to be invalid, then the invocation, and every consecutive call to the same function, results in a [trap](#trap).

Note

This is to allow implementations to use interpretation or just-in-time compilation for functions. The function must still be fully validated before execution of its body begins.

#### Execution[](#execution④)

Restrictions on the following dimensions may be imposed during [execution](#exec) of a WebAssembly program:

*   the number of allocated [module instances](#syntax-moduleinst)
    
*   the number of allocated [function instances](#syntax-funcinst)
    
*   the number of allocated [table instances](#syntax-tableinst)
    
*   the number of allocated [memory instances](#syntax-meminst)
    
*   the number of allocated [global instances](#syntax-globalinst)
    
*   the number of allocated [tag instances](#syntax-taginst)
    
*   the number of allocated [structure instances](#syntax-structinst)
    
*   the number of allocated [array instances](#syntax-arrayinst)
    
*   the number of allocated [exception instances](#syntax-exninst)
    
*   the size of a [table instance](#syntax-tableinst)
    
*   the size of a [memory instance](#syntax-meminst)
    
*   the size of an [array instance](#syntax-arrayinst)
    
*   the number of [frames](#syntax-frame) on the [stack](#stack)
    
*   the number of [labels](#syntax-label) on the [stack](#stack)
    
*   the number of [values](#syntax-val) on the [stack](#stack)
    

If the runtime limits of an implementation are exceeded during execution of a computation, then it may terminate that computation and report an embedder-specific error to the invoking code.

Some of the above limits may already be verified during instantiation, in which case an implementation may report exceedance in the same manner as for [syntactic limits](#impl-syntax).

Note

Concrete limits are usually not fixed but may be dependent on specifics, interdependent, vary over time, or depend on other implementation- or embedder-specific situations or events.

### Type Soundness[](#type-soundness①)

The [type system](#type-system) of WebAssembly is _sound_, implying both _type safety_ and _memory safety_ with respect to the WebAssembly semantics. For example:

*   All types declared and derived during validation are respected at run time; e.g., every [local](#syntax-local) or [global](#syntax-global) variable will only contain type-correct values, every [instruction](#syntax-instr) will only be applied to operands of the expected type, and every [function](#syntax-func) [invocation](#exec-invocation) always evaluates to a result of the right type (if it does not diverge, throw an exception, or [trap](#trap)).
    
*   No memory location will be read or written except those explicitly defined by the program, i.e., as a [local](#syntax-local), a [global](#syntax-global), an element in a [table](#syntax-table), or a location within a linear [memory](#syntax-mem).
    
*   There is no undefined behavior, i.e., the [execution rules](#exec) cover all possible cases that can occur in a [valid](#valid) program, and the rules are mutually consistent.
    

Soundness also is instrumental in ensuring additional properties, most notably, _encapsulation_ of function and module scopes: no [locals](#syntax-local) can be accessed outside their own function and no [module](#syntax-module) components can be accessed outside their own module unless they are explicitly [exported](#syntax-export) or [imported](#syntax-import).

The typing rules defining WebAssembly [validation](#valid) only cover the _static_ components of a WebAssembly program. In order to state and prove soundness precisely, the typing rules must be extended to the _dynamic_ components of the abstract [runtime](#syntax-runtime), that is, the [store](#syntax-store), [configurations](#syntax-config), and [administrative instructions](#syntax-instr-admin). [\[1\]](#cite-pldi2017)

#### Contexts[](#contexts⑤)

In order to check [rolled up](#aux-roll-rectype) recursive types, the [context](#context) is locally extended with an additional component that records the [sub type](#syntax-subtype) corresponding to each [recursive type index](#syntax-rectypeidx) within the current [recursive type](#syntax-rectype):

​C​::=​{ …,[recs](#context-ext) [subtype](#syntax-subtype)∗ }​​

#### Types[](#types②①)

Well-formedness for [extended type forms](#type-ext) is defined as follows.

##### [Heap Type](#syntax-heaptype-ext) [bot](#syntax-heaptype-ext)[](#heap-type--hrefsyntax-heaptype-extmathsfbot)

*   The heap type is valid.
    

C[⊢](#valid-heaptype)[bot](#syntax-heaptype-ext):[ok](#valid-heaptype)​

##### [Heap Type](#syntax-heaptype-ext) [rec](#syntax-heaptype) i[](#heap-type--hrefsyntax-heaptypemathsfreci)

*   The recursive type index i must exist in C.[recs](#context-ext).
    
*   Then the heap type is valid.
    

C[⊢](#valid-heaptype)[rec](#syntax-heaptype) i:[ok](#valid-heaptype)C.[recs](#context-ext)\[i\]\=[subtype](#syntax-subtype)​

##### [Value Type](#syntax-valtype-ext) [bot](#syntax-valtype-ext)[](#value-type--hrefsyntax-valtype-extmathsfbot)

*   The value type is valid.
    

C[⊢](#valid-valtype)[bot](#syntax-valtype-ext):[ok](#valid-valtype)​

##### [Recursive Types](#syntax-rectype) [rec](#syntax-rectype) [subtype](#syntax-subtype)∗[](#recursive-types--hrefsyntax-rectypemathsfrechrefsyntax-subtypemathitsubtypeast)

*   Let C′ be the current [context](#context) C, but where [recs](#context-ext) is [subtype](#syntax-subtype)∗.
    
*   There must be a [type index](#syntax-typeidx) x, such that for each [sub type](#syntax-subtype) [subtype](#syntax-subtype)i​ in [subtype](#syntax-subtype)∗:
    
    *   Under the context C′, the [sub type](#syntax-subtype) [subtype](#syntax-subtype)i​ must be [valid](#valid-subtype) for [type index](#syntax-typeidx) x+i and [recursive type index](#syntax-rectypeidx) i.
        
*   Then the recursive type is valid for the [type index](#syntax-typeidx) x.
    

C[⊢](#valid-rectype)[rec](#syntax-rectype) [subtype](#syntax-subtype)∗:[ok](#valid-rectype)(x)C,[recs](#context-ext) [subtype](#syntax-subtype)∗[⊢](#valid-rectype)[rec](#syntax-rectype) [subtype](#syntax-subtype)∗:[ok](#valid-rectype)(x,0)​

C[⊢](#valid-rectype)[rec](#syntax-rectype) ϵ:[ok](#valid-rectype)(x,i)​C[⊢](#valid-rectype)[rec](#syntax-rectype) [subtype](#syntax-subtype) [subtype](#syntax-subtype)′∗:[ok](#valid-rectype)(x,i)C[⊢](#valid-subtype)[subtype](#syntax-subtype):[ok](#valid-subtype)(x,i)C[⊢](#valid-rectype)[rec](#syntax-rectype) [subtype](#syntax-subtype)′∗:[ok](#valid-rectype)(x+1,i+1)​

Note

These rules are a generalisation of the ones [previously given](#valid-rectype).

##### [Sub types](#syntax-subtype) [sub](#syntax-subtype) [final](#syntax-subtype)? ht∗ [comptype](#syntax-comptype)[](#sub-types--hrefsyntax-subtypemathsfsubhrefsyntax-subtypemathsffinalmathithtasthrefsyntax-comptypemathitcomptype)

*   The [composite type](#syntax-comptype) [comptype](#syntax-comptype) must be [valid](#valid-comptype).
    
*   The sequence ht∗ may be no longer than 1.
    
*   For every [heap type](#syntax-heaptype) htk​ in ht∗:
    
    *   The [heap type](#syntax-heaptype) htk​ must be ordered before a [type index](#syntax-typeidx) x and [recursive type index](#syntax-rectypeidx) a i, meaning:
        
        *   Either htk​ is a [defined type](#syntax-deftype).
            
        *   Or htk​ is a [type index](#syntax-typeidx) yk​ that is smaller than x.
            
        *   Or htk​ is a [recursive type index](#syntax-rectypeidx) [rec](#syntax-heaptype) jk​ where jk​ is smaller than i.
            
    *   Let [sub type](#syntax-subtype) [subtype](#syntax-subtype)k​ be the [unrolling](#aux-unroll-heaptype) of the [heap type](#syntax-heaptype) htk​, meaning:
        
        *   Either htk​ is a [defined type](#syntax-deftype) [deftype](#syntax-deftype)k​, then [subtype](#syntax-subtype)k​ must be the [unrolling](#aux-unroll-deftype) of [deftype](#syntax-deftype)k​.
            
        *   Or htk​ is a [type index](#syntax-typeidx) yk​, then [subtype](#syntax-subtype)k​ must be the [unrolling](#aux-unroll-deftype) of the [defined type](#syntax-deftype) C.[types](#context)\[yk​\].
            
        *   Or htk​ is a [recursive type index](#syntax-rectypeidx) [rec](#syntax-heaptype) jk​, then [subtype](#syntax-subtype)k​ must be C.[recs](#context-ext)\[jk​\].
            
    *   The [sub type](#syntax-subtype) [subtype](#syntax-subtype)k​ must not contain [final](#syntax-subtype).
        
    *   Let [comptype](#syntax-comptype)k′​ be the [composite type](#syntax-comptype) in [subtype](#syntax-subtype)k​.
        
    *   The [composite type](#syntax-comptype) [comptype](#syntax-comptype) must [match](#match-comptype) [comptype](#syntax-comptype)k′​.
        
*   Then the sub type is valid for the [type index](#syntax-typeidx) x and [recursive type index](#syntax-rectypeidx) i.
    

C[⊢](#valid-subtype)[sub](#syntax-subtype) [final](#syntax-subtype)? ht∗ [comptype](#syntax-comptype):[ok](#valid-subtype)(x,i)∣ht∗∣≤1(ht≺x,i)∗([unroll](#aux-unroll-heaptype)C​(ht)\=[sub](#syntax-subtype) ht′∗ [comptype](#syntax-comptype)′)∗C[⊢](#valid-comptype)[comptype](#syntax-comptype):[ok](#valid-comptype)(C[⊢](#match-comptype)[comptype](#syntax-comptype)[≤](#match-comptype)[comptype](#syntax-comptype)′)∗​​​

where:

([deftype](#syntax-deftype)≺x,i)(y≺x,i)([rec](#syntax-heaptype) j≺x,i)\[2ex\][unroll](#aux-unroll-heaptype)C​([deftype](#syntax-deftype))[unroll](#aux-unroll-heaptype)C​(y)[unroll](#aux-unroll-heaptype)C​([rec](#syntax-heaptype) j)​\=\=\=\=\=\=​truey<xj<i[unroll](#aux-unroll-deftype)([deftype](#syntax-deftype))[unroll](#aux-unroll-deftype)(C.[types](#context)\[y\])C.[recs](#context-ext)\[j\]​​

Note

This rule is a generalisation of the ones [previously given](#valid-subtype), which only allowed type indices as supertypes.

##### [Defined types](#syntax-deftype) [rectype](#syntax-rectype).i[](#defined-types--hrefsyntax-rectypemathitrectypei)

The [defined type](#syntax-deftype) ([rectype](#syntax-rectype).i) is [valid](#valid-deftype) if:

> *   The [recursive type](#syntax-rectype) [rectype](#syntax-rectype) is [valid](#valid-rectype) for the type index x.
>     
> *   The [recursive type](#syntax-rectype) [rectype](#syntax-rectype) is of the form ([rec](#syntax-rectype) [subtype](#syntax-subtype)n).
>     
> *   i is less than n.
>     

C[⊢](#valid-deftype)[rectype](#syntax-rectype).i:[ok](#valid-deftype)C[⊢](#valid-rectype)[rectype](#syntax-rectype):[ok](#valid-subtype)(x)[rectype](#syntax-rectype)\=[rec](#syntax-rectype) [subtype](#syntax-subtype)ni<n​​

#### Subtyping[](#subtyping②)

In a [rolled-up](#aux-roll-rectype) [recursive type](#syntax-rectype), a [recursive type indices](#syntax-rectypeidx) [rec](#syntax-heaptype) i [matches](#match-heaptype) another [heap type](#syntax-heaptype) ht if:

*   Let [sub](#syntax-subtype) [final](#syntax-subtype)? ht′∗ [comptype](#syntax-comptype) be the [sub type](#syntax-subtype) C.[recs](#context-ext)\[i\].
    
*   The heap type ht is contained in ht′∗.
    

C[⊢](#match-heaptype)[rec](#syntax-heaptype) i[≤](#match-heaptype)htC.[recs](#context-ext)\[i\]\=[sub](#syntax-subtype) [final](#syntax-subtype)? (ht1∗​ ht ht2∗​) [comptype](#syntax-comptype)​

Note

This rule is only invoked when checking [validity](#valid-rectype-ext) of [rolled-up](#aux-roll-rectype) [recursive types](#syntax-rectype).

#### Results[](#results③)

[Results](#syntax-result) can be classified by [result types](#syntax-resulttype) as follows.

##### [Results](#syntax-result) [val](#syntax-val)∗[](#results--hrefsyntax-valmathitvalast)

*   For each [value](#syntax-val) [val](#syntax-val)i​ in [val](#syntax-val)∗:
    
    *   The value [val](#syntax-val)i​ is [valid](#valid-val) with some [value type](#syntax-valtype) ti​.
        
*   Let t∗ be the concatenation of all ti​.
    
*   Then the result is valid with [result type](#syntax-resulttype) \[t∗\].
    

S[⊢](#valid-result)[val](#syntax-val)∗:\[t∗\](S[⊢](#valid-val)[val](#syntax-val):t)∗​

##### [Results](#syntax-result) ([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control)[](#results--hrefsyntax-refmathsfrefexnahrefsyntax-instr-controlmathsfthrow_ref)

*   The value [ref.exn](#syntax-ref) a must be [valid](#valid-val).
    
*   Then the result is valid with [result type](#syntax-resulttype) \[t∗\], for any [valid](#valid-resulttype) [closed](#type-closed) [result types](#syntax-resulttype).
    

S[⊢](#valid-result)([ref.exn](#syntax-ref) a) [throw\_ref](#syntax-instr-control):\[t∗\]S[⊢](#valid-val)[ref.exn](#syntax-ref) a:[ref](#syntax-reftype) [exn](#syntax-heaptype)[⊢](#valid-resulttype)\[t∗\]:[ok](#valid-resulttype)​

##### [Results](#syntax-result) [trap](#syntax-trap)[](#results--hrefsyntax-trapmathsftrap)

*   The result is valid with [result type](#syntax-resulttype) \[t∗\], for any [valid](#valid-resulttype) [closed](#type-closed) [result types](#syntax-resulttype).
    

S[⊢](#valid-result)[trap](#syntax-trap):\[t∗\][⊢](#valid-resulttype)\[t∗\]:[ok](#valid-resulttype)​

#### Store Validity[](#store-validity①)

The following typing rules specify when a runtime [store](#syntax-store) S is _valid_. A valid store must consist of [tag](#syntax-taginst), [global](#syntax-globalinst), [memory](#syntax-meminst), [table](#syntax-tableinst), [function](#syntax-funcinst), [data](#syntax-datainst), [element](#syntax-eleminst), [structure](#syntax-structinst), [array](#syntax-arrayinst), [exception](#syntax-exninst), and [module](#syntax-moduleinst) instances that are themselves valid, relative to S.

To that end, each kind of instance is classified by a respective [tag](#syntax-tagtype), [global](#syntax-globaltype), [memory](#syntax-memtype), [table](#syntax-tabletype), [function](#syntax-functype), or [element](#syntax-eleminst), type, or just ok in the case of [data](#syntax-datainst) [structures](#syntax-structinst), [arrays](#syntax-arrayinst), or [exceptions](#syntax-exninst). Module instances are classified by _module contexts_, which are regular [contexts](#context) repurposed as module types describing the [index spaces](#syntax-index) defined by a module.

##### [Store](#syntax-store) S[](#store--s)

*   Each [tag instance](#syntax-taginst) [taginst](#syntax-taginst)i​ in S.[tags](#syntax-store) must be [valid](#valid-taginst) with some [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype)i​.
    
*   Each [global instance](#syntax-globalinst) [globalinst](#syntax-globalinst)i​ in S.[globals](#syntax-store) must be [valid](#valid-globalinst) with some [global type](#syntax-globaltype) [globaltype](#syntax-globaltype)i​.
    
*   Each [memory instance](#syntax-meminst) [meminst](#syntax-meminst)i​ in S.[mems](#syntax-store) must be [valid](#valid-meminst) with some [memory type](#syntax-memtype) [memtype](#syntax-memtype)i​.
    
*   Each [table instance](#syntax-tableinst) [tableinst](#syntax-tableinst)i​ in S.[tables](#syntax-store) must be [valid](#valid-tableinst) with some [table type](#syntax-tabletype) [tabletype](#syntax-tabletype)i​.
    
*   Each [function instance](#syntax-funcinst) [funcinst](#syntax-funcinst)i​ in S.[funcs](#syntax-store) must be [valid](#valid-funcinst) with some [defined type](#syntax-deftype) [deftype](#syntax-deftype)i​.
    
*   Each [data instance](#syntax-datainst) [datainst](#syntax-datainst)i​ in S.[datas](#syntax-store) must be [valid](#valid-datainst).
    
*   Each [element instance](#syntax-eleminst) [eleminst](#syntax-eleminst)i​ in S.[elems](#syntax-store) must be [valid](#valid-eleminst) with some [reference type](#syntax-reftype) [reftype](#syntax-reftype)i​.
    
*   Each [structure instance](#syntax-structinst) [structinst](#syntax-structinst)i​ in S.[structs](#syntax-store) must be [valid](#valid-structinst).
    
*   Each [array instance](#syntax-arrayinst) [arrayinst](#syntax-arrayinst)i​ in S.[arrays](#syntax-store) must be [valid](#valid-arrayinst).
    
*   Each [exception instance](#syntax-exninst) [exninst](#syntax-exninst)i​ in S.[exns](#syntax-store) must be [valid](#valid-exninst).
    
*   No [reference](#syntax-ref) to a bound [structure address](#syntax-structaddr) must be reachable from itself through a path consisting only of indirections through immutable structure, or array [fields](#syntax-fieldtype) or fields of [exception instances](#syntax-exninst).
    
*   No [reference](#syntax-ref) to a bound [array address](#syntax-arrayaddr) must be reachable from itself through a path consisting only of indirections through immutable structure or array [fields](#syntax-fieldtype) or fields of [exception instances](#syntax-exninst).
    
*   No [reference](#syntax-ref) to a bound [exception address](#syntax-exnaddr) must be reachable from itself through a path consisting only of indirections through immutable structure or array [fields](#syntax-fieldtype) or fields of [exception instances](#syntax-exninst).
    
*   Then the store is valid.
    

−1ex\][⊢](#valid-store)S:[ok](#valid-store)(S[⊢](#valid-taginst)[taginst](#syntax-taginst):[tagtype](#syntax-tagtype))∗(S[⊢](#valid-globalinst)[globalinst](#syntax-globalinst):[globaltype](#syntax-globaltype))∗(S[⊢](#valid-meminst)[meminst](#syntax-meminst):[memtype](#syntax-memtype))∗(S[⊢](#valid-tableinst)[tableinst](#syntax-tableinst):[tabletype](#syntax-tabletype))∗(S[⊢](#valid-funcinst)[funcinst](#syntax-funcinst):[deftype](#syntax-deftype))∗(S[⊢](#valid-datainst)[datainst](#syntax-datainst):[ok](#valid-datainst))∗(S[⊢](#valid-eleminst)[eleminst](#syntax-eleminst):[reftype](#syntax-reftype))∗(S[⊢](#valid-structinst)[structinst](#syntax-structinst):[ok](#valid-structinst))∗(S[⊢](#valid-arrayinst)[arrayinst](#syntax-arrayinst):[ok](#valid-arrayinst))∗(S[⊢](#valid-exninst)[exninst](#syntax-exninst):[ok](#valid-exninst))∗S\={[tags](#syntax-store) [taginst](#syntax-taginst)∗,[globals](#syntax-store) [globalinst](#syntax-globalinst)∗,[mems](#syntax-store) [meminst](#syntax-meminst)∗,[tables](#syntax-store) [tableinst](#syntax-tableinst)∗,[funcs](#syntax-store) [funcinst](#syntax-funcinst)∗,[datas](#syntax-store) [datainst](#syntax-datainst)∗,[elems](#syntax-store) [eleminst](#syntax-eleminst)∗,[structs](#syntax-store) [structinst](#syntax-structinst)∗,[arrays](#syntax-store) [arrayinst](#syntax-arrayinst)∗,[exns](#syntax-store) [exninst](#syntax-exninst)∗}​(S.[structs](#syntax-store)\[as​\]\=[structinst](#syntax-structinst))∗(([ref.struct](#syntax-ref) as​)≫S+​([ref.struct](#syntax-ref) as​))∗(S.[arrays](#syntax-store)\[aa​\]\=[arrayinst](#syntax-arrayinst))∗(([ref.array](#syntax-ref) aa​)≫S+​([ref.array](#syntax-ref) aa​))∗(S.[exns](#syntax-store)\[ae​\]\=[exninst](#syntax-exninst))∗(([ref.exn](#syntax-ref) ae​)≫S+​([ref.exn](#syntax-ref) ae​))∗​​​

where [val](#syntax-val)1​≫S+​[val](#syntax-val)2​ denotes the transitive closure of the following _immutable reachability_ relation on [values](#syntax-val):

([ref.struct](#syntax-ref) a)([ref.array](#syntax-ref) a)([ref.exn](#syntax-ref) a)([ref.extern](#syntax-ref) [ref](#syntax-ref))​≫S​≫S​≫S​≫S​​S.[structs](#syntax-store)\[a\].[fields](#syntax-structinst)\[i\]S.[arrays](#syntax-store)\[a\].[fields](#syntax-arrayinst)\[i\]S.[exns](#syntax-store)\[a\].[fields](#syntax-exninst)\[i\][ref](#syntax-ref)​if[expand](#aux-expand-deftype)(S.[structs](#syntax-store)\[a\].[type](#syntax-structinst))\=[struct](#syntax-comptype) ft1i​ st ft2∗​if[expand](#aux-expand-deftype)(S.[arrays](#syntax-store)\[a\].[type](#syntax-arrayinst))\=[array](#syntax-comptype) st​

Note

The constraint on reachability through immutable fields prevents the presence of cyclic data structures that can not be constructed in the language. Cycles can only be formed using mutation.

##### [Tag Instances](#syntax-taginst) {[type](#syntax-taginst) [tagtype](#syntax-tagtype)}[](#tag-instances---hrefsyntax-taginstmathsftypehrefsyntax-tagtypemathittagtype)

*   The [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype) must be [valid](#valid-tagtype) under the empty [context](#context).
    
*   Then the tag instance is valid with [tag type](#syntax-tagtype) [tagtype](#syntax-tagtype).
    

S[⊢](#valid-taginst){[type](#syntax-taginst) [tagtype](#syntax-tagtype)}:[tagtype](#syntax-tagtype)[⊢](#valid-tagtype)[tagtype](#syntax-tagtype):[ok](#valid-tagtype)​

##### [Global Instances](#syntax-globalinst) {[type](#syntax-globalinst) [mut](#syntax-mut) t,[value](#syntax-globalinst) [val](#syntax-val)}[](#global-instances---hrefsyntax-globalinstmathsftypehrefsyntax-mutmathitmutt-hrefsyntax-globalinstmathsfvaluehrefsyntax-valmathitval)

*   The [global type](#syntax-globaltype) [mut](#syntax-mut) t must be [valid](#valid-globaltype) under the empty [context](#context).
    
*   The [value](#syntax-val) [val](#syntax-val) must be [valid](#valid-val) with some [value type](#syntax-valtype) t′.
    
*   The [value type](#syntax-valtype) t′ must [match](#match-valtype) the [value type](#syntax-valtype) t.
    
*   Then the global instance is valid with [global type](#syntax-globaltype) [mut](#syntax-mut) t.
    

S[⊢](#valid-globalinst){[type](#syntax-globalinst) [mut](#syntax-mut) t,[value](#syntax-globalinst) [val](#syntax-val)}:[mut](#syntax-mut) t[⊢](#valid-globaltype)[mut](#syntax-mut) t:[ok](#valid-globaltype)S[⊢](#valid-val)[val](#syntax-val):t′[⊢](#match-valtype)t′[≤](#match-valtype)t​

##### [Memory Instances](#syntax-meminst) {[type](#syntax-meminst) ([addrtype](#syntax-addrtype) [limits](#syntax-limits)),[bytes](#syntax-meminst) b∗}[](#memory-instances---hrefsyntax-meminstmathsftype-hrefsyntax-addrtypemathitaddrtypehrefsyntax-limitsmathitlimits-hrefsyntax-meminstmathsfbytesbast)

*   The [memory type](#syntax-memtype) [addrtype](#syntax-addrtype) [limits](#syntax-limits) must be [valid](#valid-memtype) under the empty [context](#context).
    
*   Let [limits](#syntax-limits) be \[n..m\].
    
*   The length of b∗ must equal m multiplied by the [page size](#page-size) 64Ki.
    
*   Then the memory instance is valid with [memory type](#syntax-memtype) [addrtype](#syntax-addrtype) [limits](#syntax-limits).
    

S[⊢](#valid-meminst){[type](#syntax-meminst) ([addrtype](#syntax-addrtype) \[n..m\]),[bytes](#syntax-meminst) b∗}:[addrtype](#syntax-addrtype) \[n..m\][⊢](#valid-memtype)[addrtype](#syntax-addrtype) \[n..m\]:[ok](#valid-memtype)∣b∗∣\=n⋅64Ki​

##### [Table Instances](#syntax-tableinst) {[type](#syntax-tableinst) ([addrtype](#syntax-addrtype) [limits](#syntax-limits) t),[refs](#syntax-tableinst) [ref](#syntax-ref)∗}[](#table-instances---hrefsyntax-tableinstmathsftype-hrefsyntax-addrtypemathitaddrtypehrefsyntax-limitsmathitlimitst-hrefsyntax-tableinstmathsfrefshrefsyntax-refmathitrefast)

*   The [table type](#syntax-tabletype) [addrtype](#syntax-addrtype) [limits](#syntax-limits) t must be [valid](#valid-tabletype) under the empty [context](#context).
    
*   Let [limits](#syntax-limits) be \[n..m\].
    
*   The length of [ref](#syntax-ref)∗ must equal n.
    
*   For each [reference](#syntax-ref) [ref](#syntax-ref)i​ in the table’s elements [ref](#syntax-ref)n:
    
    *   The [reference](#syntax-ref) [ref](#syntax-ref)i​ must be [valid](#valid-ref) with some [reference type](#syntax-reftype) ti′​.
        
    *   The [reference type](#syntax-reftype) ti′​ must [match](#match-reftype) the [reference type](#syntax-reftype) t.
        
*   Then the table instance is valid with [table type](#syntax-tabletype) [addrtype](#syntax-addrtype) [limits](#syntax-limits) t.
    

S[⊢](#valid-tableinst){[type](#syntax-tableinst) ([addrtype](#syntax-addrtype) \[n..m\] t),[refs](#syntax-tableinst) [ref](#syntax-ref)∗}:[addrtype](#syntax-addrtype) \[n..m\] t[⊢](#valid-tabletype)[addrtype](#syntax-addrtype) \[n..m\] t:[ok](#valid-tabletype)∣[ref](#syntax-ref)∗∣\=n(S⊢[ref](#syntax-ref):t′)∗([⊢](#match-reftype)t′[≤](#match-valtype)t)∗​

##### [Function Instances](#syntax-funcinst) {[type](#syntax-funcinst) [deftype](#syntax-deftype),[module](#syntax-funcinst) [moduleinst](#syntax-moduleinst),[code](#syntax-funcinst) [func](#syntax-func)}[](#function-instances--hrefsyntax-funcinstmathsftypehrefsyntax-deftypemathitdeftype-hrefsyntax-funcinstmathsfmodulehrefsyntax-moduleinstmathitmoduleinst-hrefsyntax-funcinstmathsfcodehrefsyntax-funcmathitfunc)

*   The [defined type](#syntax-deftype) [deftype](#syntax-deftype) must be [valid](#valid-deftype) under an empty [context](#context).
    
*   The [module instance](#syntax-moduleinst) [moduleinst](#syntax-moduleinst) must be [valid](#valid-moduleinst) with some [context](#context) C.
    
*   Under [context](#context) C:
    
    *   The [function](#syntax-func) [func](#syntax-func) must be [valid](#valid-func) with some [defined type](#syntax-deftype) [deftype](#syntax-deftype)′.
        
    *   The [defined type](#syntax-deftype) [deftype](#syntax-deftype)′ must [match](#match-deftype) [deftype](#syntax-deftype).
        
*   Then the function instance is valid with [defined type](#syntax-deftype) [deftype](#syntax-deftype).
    

S[⊢](#valid-funcinst){[type](#syntax-funcinst) [deftype](#syntax-deftype),[module](#syntax-funcinst) [moduleinst](#syntax-moduleinst),[code](#syntax-funcinst) [func](#syntax-func)}:[deftype](#syntax-deftype)[⊢](#valid-deftype)[deftype](#syntax-deftype):[ok](#valid-deftype)S[⊢](#valid-moduleinst)[moduleinst](#syntax-moduleinst):CC[⊢](#valid-func)[func](#syntax-func):[deftype](#syntax-deftype)′C[⊢](#match-deftype)[deftype](#syntax-deftype)′[≤](#match-deftype)[deftype](#syntax-deftype)​​​

##### [Host Function Instances](#syntax-funcinst) {[type](#syntax-funcinst) [deftype](#syntax-deftype),[hostfunc](#syntax-funcinst) hf}[](#host-function-instances--hrefsyntax-funcinstmathsftypehrefsyntax-deftypemathitdeftype-hrefsyntax-funcinstmathsfhostfuncmathithf)

*   The [defined type](#syntax-deftype) [deftype](#syntax-deftype) must be [valid](#valid-deftype) under an empty [context](#context).
    
*   The [expansion](#aux-expand-deftype) of [defined type](#syntax-deftype) [deftype](#syntax-deftype) must be some [function type](#syntax-functype) [func](#syntax-comptype) \[t1∗​\][→](#syntax-comptype)\[t2∗​\].
    
*   For every [valid](#valid-store) [store](#syntax-store) S1​ [extending](#extend-store) S and every sequence [val](#syntax-val)∗ of [values](#syntax-val) whose [types](#valid-val) coincide with t1∗​:
    
    *   [Executing](#exec-invoke-host) hf in store S1​ with arguments [val](#syntax-val)∗ has a non-empty set of possible outcomes.
        
    *   For every element R of this set:
        
        *   Either R must be ⊥ (i.e., divergence).
            
        *   Or R consists of a [valid](#valid-store) [store](#syntax-store) S2​ [extending](#extend-store) S1​ and a [result](#syntax-result) [result](#syntax-result) whose [type](#valid-result) coincides with \[t2∗​\].
            
*   Then the function instance is valid with [defined type](#syntax-deftype) [deftype](#syntax-deftype).
    

S[⊢](#valid-funcinst){[type](#syntax-funcinst) [deftype](#syntax-deftype),[hostfunc](#syntax-funcinst) hf}:[deftype](#syntax-deftype)[⊢](#valid-deftype)[deftype](#syntax-deftype):[ok](#valid-deftype)[deftype](#syntax-deftype)≈[func](#syntax-comptype) \[t1∗​\][→](#syntax-comptype)\[t2∗​\]​∀S1​,[val](#syntax-val)∗, [⊢](#valid-store)S1​:[ok](#valid-store)∧[⊢](#extend-store)S[⪯](#extend)S1​∧S1​[⊢](#valid-result)[val](#syntax-val)∗:\[t1∗​\]⟹hf(S1​;[val](#syntax-val)∗)⊃∅∧∀R∈hf(S1​;[val](#syntax-val)∗), R\=⊥∨∃S2​,[result](#syntax-result), [⊢](#valid-store)S2​:[ok](#valid-store)∧[⊢](#extend-store)S1​[⪯](#extend)S2​∧S2​[⊢](#valid-result)[result](#syntax-result):\[t2∗​\]∧R\=(S2​;[result](#syntax-result))​​​

Note

This rule states that, if appropriate pre-conditions about store and arguments are satisfied, then executing the host function must satisfy appropriate post-conditions about store and results. The post-conditions match the ones in the [execution rule](#exec-invoke-host) for invoking host functions.

Any store under which the function is invoked is assumed to be an extension of the current store. That way, the function itself is able to make sufficient assumptions about future stores.

##### [Data Instances](#syntax-eleminst) {[bytes](#syntax-datainst) b∗}[](#data-instances---hrefsyntax-datainstmathsfbytesbast)

*   The data instance is valid.
    

S[⊢](#valid-datainst){[bytes](#syntax-datainst) b∗}:[ok](#valid-datainst)​

##### [Element Instances](#syntax-eleminst) {[type](#syntax-eleminst) t,[refs](#syntax-eleminst) [ref](#syntax-ref)∗}[](#element-instances---hrefsyntax-eleminstmathsftypet-hrefsyntax-eleminstmathsfrefshrefsyntax-refmathitrefast)

*   The [reference type](#syntax-reftype) t must be [valid](#valid-reftype) under the empty [context](#context).
    
*   For each [reference](#syntax-ref) [ref](#syntax-ref)i​ in the elements [ref](#syntax-ref)n:
    
    *   The [reference](#syntax-ref) [ref](#syntax-ref)i​ must be [valid](#valid-ref) with some [reference type](#syntax-reftype) ti′​.
        
    *   The [reference type](#syntax-reftype) ti′​ must [match](#match-reftype) the [reference type](#syntax-reftype) t.
        
*   Then the element instance is valid with [reference type](#syntax-reftype) t.
    

S[⊢](#valid-eleminst){[type](#syntax-eleminst) t,[refs](#syntax-eleminst) [ref](#syntax-ref)∗}:t[⊢](#valid-reftype)t:[ok](#valid-reftype)(S[⊢](#valid-val)[ref](#syntax-ref):t′)∗([⊢](#match-reftype)t′[≤](#match-valtype)t)∗​

##### [Structure Instances](#syntax-structinst) {[type](#syntax-structinst) [deftype](#syntax-deftype),[fields](#syntax-structinst) [fieldval](#syntax-fieldval)∗}[](#structure-instances---hrefsyntax-structinstmathsftypehrefsyntax-deftypemathitdeftype-hrefsyntax-structinstmathsffieldshrefsyntax-fieldvalmathitfieldvalast)

*   The [defined type](#syntax-deftype) [deftype](#syntax-deftype) must be [valid](#valid-deftype) under the empty [context](#context).
    
*   The [expansion](#aux-expand-deftype) of [deftype](#syntax-deftype) must be a [structure type](#syntax-structtype) [struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗.
    
*   The length of the sequence of [field values](#syntax-fieldval) [fieldval](#syntax-fieldval)∗ must be the same as the length of the sequence of [field types](#syntax-fieldtype) [fieldtype](#syntax-fieldtype)∗.
    
*   For each [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ in [fieldval](#syntax-fieldval)∗ and corresponding [field type](#syntax-fieldtype) [fieldtype](#syntax-fieldtype)i​ in [fieldtype](#syntax-fieldtype)∗:
    
    *   Let [fieldtype](#syntax-fieldtype)i​ be [mut](#syntax-mut) [storagetype](#syntax-storagetype)i​.
        
    *   The [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ must be [valid](#valid-fieldval) with [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype)i​.
        
*   Then the structure instance is valid.
    

S[⊢](#valid-structinst){[type](#syntax-structinst) dt,[fields](#syntax-structinst) fv∗}:[ok](#valid-structinst)[⊢](#valid-deftype)dt:[ok](#valid-deftype)[expand](#aux-expand-deftype)(dt)\=[struct](#syntax-comptype) ([mut](#syntax-mut) st)∗(S[⊢](#valid-fieldval)fv:st)∗​

##### [Array Instances](#syntax-arrayinst) {[type](#syntax-arrayinst) [deftype](#syntax-deftype),[fields](#syntax-arrayinst) [fieldval](#syntax-fieldval)∗}[](#array-instances---hrefsyntax-arrayinstmathsftypehrefsyntax-deftypemathitdeftype-hrefsyntax-arrayinstmathsffieldshrefsyntax-fieldvalmathitfieldvalast)

*   The [defined type](#syntax-deftype) [deftype](#syntax-deftype) must be [valid](#valid-deftype) under the empty [context](#context).
    
*   The [expansion](#aux-expand-deftype) of [deftype](#syntax-deftype) must be an [array type](#syntax-arraytype) [array](#syntax-comptype) [fieldtype](#syntax-fieldtype).
    
*   Let [fieldtype](#syntax-fieldtype) be [mut](#syntax-mut) [storagetype](#syntax-storagetype).
    
*   For each [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ in [fieldval](#syntax-fieldval)∗:
    
    *   The [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ must be [valid](#valid-fieldval) with [storage type](#syntax-storagetype) [storagetype](#syntax-storagetype).
        
*   Then the array instance is valid.
    

S[⊢](#valid-arrayinst){[type](#syntax-arrayinst) dt,[fields](#syntax-arrayinst) fv∗}:[ok](#valid-arrayinst)[⊢](#valid-deftype)dt:[ok](#valid-deftype)[expand](#aux-expand-deftype)(dt)\=[array](#syntax-comptype) ([mut](#syntax-mut) st)(S[⊢](#valid-fieldval)fv:st)∗​

##### [Field Values](#syntax-fieldval) [fieldval](#syntax-fieldval)[](#field-values--hrefsyntax-fieldvalmathitfieldval)

*   If [fieldval](#syntax-fieldval) is a [value](#syntax-val) [val](#syntax-val), then:
    
    *   The value [val](#syntax-val) must be [valid](#valid-val) with [value type](#syntax-valtype) t.
        
    *   Then the field value is valid with [value type](#syntax-valtype) t.
        
*   Else, [fieldval](#syntax-fieldval) is a [packed value](#syntax-packval) [packval](#syntax-packval):
    
    *   Let [packtype](#syntax-packtype).[pack](#syntax-packval) i be the field value [fieldval](#syntax-fieldval).
        
    *   Then the field value is valid with [packed type](#syntax-packtype) [packtype](#syntax-packtype).
        

S[⊢](#valid-packval)pt.[pack](#syntax-packval) i:pt​

##### [Exception Instances](#syntax-exninst) {[tag](#syntax-exninst) a,[fields](#syntax-exninst) [val](#syntax-val)∗}[](#exception-instances---hrefsyntax-exninstmathsftaga-hrefsyntax-exninstmathsffieldshrefsyntax-valmathitvalast)

*   The store entry S.[tags](#syntax-store)\[a\] must exist.
    
*   The [expansion](#aux-expand-deftype) of the [tag type](#syntax-tagtype) S.[tags](#syntax-store)\[a\].[type](#syntax-taginst) must be some [function type](#syntax-functype) [func](#syntax-comptype) \[t∗\][→](#syntax-comptype)\[t′∗\].
    
*   The [result type](#syntax-resulttype) \[t′∗\] must be empty.
    
*   The sequence [val](#syntax-val)ast of [values](#syntax-val) must have the same length as the sequence t∗ of [value types](#syntax-valtype).
    
*   For each value [val](#syntax-val)i​ in [val](#syntax-val)ast and corresponding value type ti​ in t∗, the value [val](#syntax-val)i​ must be valid with type ti​.
    
*   Then the exception instance is valid.
    

S[⊢](#valid-exninst){[tag](#syntax-exninst) a,[fields](#syntax-exninst) [val](#syntax-val)∗}:[ok](#valid-exninst)S.[tags](#syntax-store)\[a\].[type](#syntax-taginst)≈[func](#syntax-comptype) \[t∗\][→](#syntax-comptype)\[\](S[⊢](#valid-val)[val](#syntax-val):t)∗​

##### [Export Instances](#syntax-exportinst) {[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) [externaddr](#syntax-externaddr)}[](#export-instances---hrefsyntax-exportinstmathsfnamehrefsyntax-namemathitname-hrefsyntax-exportinstmathsfaddrhrefsyntax-externaddrmathitexternaddr)

*   The [external address](#syntax-externaddr) [externaddr](#syntax-externaddr) must be [valid](#valid-externaddr) with some [external type](#syntax-externtype) [externtype](#syntax-externtype).
    
*   Then the export instance is valid.
    

S[⊢](#valid-exportinst){[name](#syntax-exportinst) [name](#syntax-name),[addr](#syntax-exportinst) [externaddr](#syntax-externaddr)}:[ok](#valid-exportinst)S[⊢](#valid-externaddr)[externaddr](#syntax-externaddr):[externtype](#syntax-externtype)​

##### [Module Instances](#syntax-moduleinst) [moduleinst](#syntax-moduleinst)[](#module-instances--hrefsyntax-moduleinstmathitmoduleinst)

*   Each [defined type](#syntax-deftype) [deftype](#syntax-deftype)i​ in [moduleinst](#syntax-moduleinst).[types](#syntax-moduleinst) must be [valid](#valid-deftype) under the empty [context](#context).
    
*   For each [tag address](#syntax-tagaddr) [tagaddr](#syntax-tagaddr)i​ in [moduleinst](#syntax-moduleinst).[tags](#syntax-moduleinst), the [external address](#syntax-externaddr) [tag](#syntax-externaddr) [tagaddr](#syntax-tagaddr)i​ must be [valid](#valid-externaddr-tag) with some [external type](#syntax-externtype) [tag](#syntax-externtype) [tagtype](#syntax-tagtype)i​.
    
*   For each [global address](#syntax-globaladdr) [globaladdr](#syntax-globaladdr)i​ in [moduleinst](#syntax-moduleinst).[globals](#syntax-moduleinst), the [external address](#syntax-externaddr) [global](#syntax-externaddr) [globaladdr](#syntax-globaladdr)i​ must be [valid](#valid-externaddr-global) with some [external type](#syntax-externtype) [global](#syntax-externtype) [globaltype](#syntax-globaltype)i​.
    
*   For each [memory address](#syntax-memaddr) [memaddr](#syntax-memaddr)i​ in [moduleinst](#syntax-moduleinst).[mems](#syntax-moduleinst), the [external address](#syntax-externaddr) [mem](#syntax-externaddr) [memaddr](#syntax-memaddr)i​ must be [valid](#valid-externaddr-mem) with some [external type](#syntax-externtype) [mem](#syntax-externtype) [memtype](#syntax-memtype)i​.
    
*   For each [table address](#syntax-tableaddr) [tableaddr](#syntax-tableaddr)i​ in [moduleinst](#syntax-moduleinst).[tables](#syntax-moduleinst), the [external address](#syntax-externaddr) [table](#syntax-externaddr) [tableaddr](#syntax-tableaddr)i​ must be [valid](#valid-externaddr-table) with some [external type](#syntax-externtype) [table](#syntax-externtype) [tabletype](#syntax-tabletype)i​.
    
*   For each [function address](#syntax-funcaddr) [funcaddr](#syntax-funcaddr)i​ in [moduleinst](#syntax-moduleinst).[funcs](#syntax-moduleinst), the [external address](#syntax-externaddr) [func](#syntax-externaddr) [funcaddr](#syntax-funcaddr)i​ must be [valid](#valid-externaddr-func) with some [external type](#syntax-externtype) [func](#syntax-externtype) [deftype](#syntax-deftype)Fi​.
    
*   For each [data address](#syntax-dataaddr) [dataaddr](#syntax-dataaddr)i​ in [moduleinst](#syntax-moduleinst).[datas](#syntax-moduleinst), the [data instance](#syntax-datainst) S.[datas](#syntax-store)\[[dataaddr](#syntax-dataaddr)i​\] must be [valid](#valid-datainst) with oki​.
    
*   For each [element address](#syntax-elemaddr) [elemaddr](#syntax-elemaddr)i​ in [moduleinst](#syntax-moduleinst).[elems](#syntax-moduleinst), the [element instance](#syntax-eleminst) S.[elems](#syntax-store)\[[elemaddr](#syntax-elemaddr)i​\] must be [valid](#valid-eleminst) with some [reference type](#syntax-reftype) [reftype](#syntax-reftype)i​.
    
*   Each [export instance](#syntax-exportinst) [exportinst](#syntax-exportinst)i​ in [moduleinst](#syntax-moduleinst).[exports](#syntax-moduleinst) must be [valid](#valid-exportinst).
    
*   For each [export instance](#syntax-exportinst) [exportinst](#syntax-exportinst)i​ in [moduleinst](#syntax-moduleinst).[exports](#syntax-moduleinst), the [name](#syntax-name) [exportinst](#syntax-exportinst)i​.[name](#syntax-exportinst) must be different from any other name occurring in [moduleinst](#syntax-moduleinst).[exports](#syntax-moduleinst).
    
*   Let [deftype](#syntax-deftype)∗ be the concatenation of all [deftype](#syntax-deftype)i​ in order.
    
*   Let [tagtype](#syntax-tagtype)∗ be the concatenation of all [tagtype](#syntax-tagtype)i​ in order.
    
*   Let [globaltype](#syntax-globaltype)∗ be the concatenation of all [globaltype](#syntax-globaltype)i​ in order.
    
*   Let [memtype](#syntax-memtype)∗ be the concatenation of all [memtype](#syntax-memtype)i​ in order.
    
*   Let [tabletype](#syntax-tabletype)∗ be the concatenation of all [tabletype](#syntax-tabletype)i​ in order.
    
*   Let [deftype](#syntax-deftype)F∗​ be the concatenation of all [deftype](#syntax-deftype)Fi​ in order.
    
*   Let [reftype](#syntax-reftype)∗ be the concatenation of all [reftype](#syntax-reftype)i​ in order.
    
*   Let ok∗ be the concatenation of all oki​ in order.
    
*   Let m be the length of [moduleinst](#syntax-moduleinst).[funcs](#syntax-moduleinst).
    
*   Let x∗ be the sequence of [function indices](#syntax-funcidx) from 0 to m−1.
    
*   Then the module instance is valid with [context](#context) {[types](#context) [deftype](#syntax-deftype)∗, [tags](#context) [tagtype](#syntax-tagtype)∗, [globals](#context) [globaltype](#syntax-globaltype)∗, [mems](#context) [memtype](#syntax-memtype)∗, [tables](#context) [tabletype](#syntax-tabletype)∗, [funcs](#context) [deftype](#syntax-deftype)F∗​, [datas](#context) ok∗, [elems](#context) [reftype](#syntax-reftype)∗, [refs](#context) x∗}.
    

−1ex\]S[⊢](#valid-moduleinst){[types](#syntax-moduleinst)[tags](#syntax-moduleinst)[globals](#syntax-moduleinst)[mems](#syntax-moduleinst)[tables](#syntax-moduleinst)[funcs](#syntax-moduleinst)[datas](#syntax-moduleinst)[elems](#syntax-moduleinst)[exports](#syntax-moduleinst)​[deftype](#syntax-deftype)∗,[tagaddr](#syntax-tagaddr)∗,[globaladdr](#syntax-globaladdr)∗,[memaddr](#syntax-memaddr)∗,[tableaddr](#syntax-tableaddr)∗,[funcaddr](#syntax-funcaddr)∗,[dataaddr](#syntax-dataaddr)∗,[elemaddr](#syntax-elemaddr)∗,[exportinst](#syntax-exportinst)∗ }:{[types](#context)[tags](#context)[globals](#context)[mems](#context)[tables](#context)[funcs](#context)[datas](#context)[elems](#context)[refs](#context)​[deftype](#syntax-deftype)∗,[tagtype](#syntax-tagtype)∗,[globaltype](#syntax-globaltype)∗,[memtype](#syntax-memtype)∗,[tabletype](#syntax-tabletype)∗,[deftype](#syntax-deftype)F∗​,ok∗,[reftype](#syntax-reftype)∗,0…(∣[funcaddr](#syntax-funcaddr)∗∣−1) }​​([⊢](#valid-deftype)[deftype](#syntax-deftype):[ok](#valid-deftype))∗(S[⊢](#valid-externaddr)[tag](#syntax-externaddr) [tagaddr](#syntax-tagaddr):[tag](#syntax-externtype) [tagtype](#syntax-tagtype))∗(S[⊢](#valid-externaddr)[global](#syntax-externaddr) [globaladdr](#syntax-globaladdr):[global](#syntax-externtype) [globaltype](#syntax-globaltype))∗(S[⊢](#valid-externaddr)[func](#syntax-externaddr) [funcaddr](#syntax-funcaddr):[func](#syntax-externtype) [deftype](#syntax-deftype)F​)∗(S[⊢](#valid-externaddr)[mem](#syntax-externaddr) [memaddr](#syntax-memaddr):[mem](#syntax-externtype) [memtype](#syntax-memtype))∗(S[⊢](#valid-externaddr)[table](#syntax-externaddr) [tableaddr](#syntax-tableaddr):[table](#syntax-externtype) [tabletype](#syntax-tabletype))∗(S[⊢](#valid-datainst)S.[datas](#syntax-store)\[[dataaddr](#syntax-dataaddr)\]:ok)∗(S[⊢](#valid-eleminst)S.[elems](#syntax-store)\[[elemaddr](#syntax-elemaddr)\]:[reftype](#syntax-reftype))∗(S[⊢](#valid-exportinst)[exportinst](#syntax-exportinst):[ok](#valid-exportinst))∗([exportinst](#syntax-exportinst).[name](#syntax-exportinst))∗ disjoint​​​

#### Configuration Validity[](#configuration-validity①)

To relate the WebAssembly [type system](#valid) to its [execution semantics](#exec), the [typing rules for instructions](#valid-instr) must be extended to [configurations](#syntax-config) S;T, which relates the [store](#syntax-store) to execution [threads](#syntax-thread).

Configurations and threads are classified by their [result type](#syntax-resulttype). In addition to the store S, threads are typed under a _return type_ [resulttype](#syntax-resulttype)?, which controls whether and with which type a [return](#syntax-instr-control) instruction is allowed. This type is absent (ϵ) except for instruction sequences inside an administrative [frame](#syntax-frame) instruction.

Finally, [frames](#syntax-frame) are classified with _frame contexts_, which extend the [module contexts](#module-context) of a frame’s associated [module instance](#syntax-moduleinst) with the [locals](#syntax-local) that the frame contains.

##### [Configurations](#syntax-config) S;T[](#configurations--st)

*   The [store](#syntax-store) S must be [valid](#valid-store).
    
*   Under no allowed return type, the [thread](#syntax-thread) T must be [valid](#valid-thread) with some [result type](#syntax-resulttype) \[t∗\].
    
*   Then the configuration is valid with the [result type](#syntax-resulttype) \[t∗\].
    

[⊢](#valid-config)S;T:\[t∗\][⊢](#valid-store)S:[ok](#valid-store)S;ϵ[⊢](#valid-thread)T:\[t∗\]​

##### [Threads](#syntax-thread) F;[instr](#syntax-instr)∗[](#threads--fhrefsyntax-instrmathitinstrast)

*   Let [resulttype](#syntax-resulttype)? be the current allowed return type.
    
*   The [frame](#syntax-frame) F must be [valid](#valid-frame) with a [context](#context) C.
    
*   Let C′ be the same [context](#context) as C, but with [return](#context) set to [resulttype](#syntax-resulttype)?.
    
*   Under context C′, the instruction sequence [instr](#syntax-instr)∗ must be [valid](#valid-instrs) with some type \[\][→](#syntax-instrtype)\[t∗\].
    
*   Then the thread is valid with the [result type](#syntax-resulttype) \[t∗\].
    

S;[resulttype](#syntax-resulttype)?[⊢](#valid-thread)F;[instr](#syntax-instr)∗:\[t∗\]S[⊢](#valid-frame)F:CS;C,[return](#context) [resulttype](#syntax-resulttype)?[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[\][→](#syntax-instrtype)\[t∗\]​

##### [Frames](#syntax-frame) {[locals](#syntax-frame) [val](#syntax-val)∗,[module](#syntax-frame) [moduleinst](#syntax-moduleinst)}[](#frames--hrefsyntax-framemathsflocalshrefsyntax-valmathitvalast-hrefsyntax-framemathsfmodulehrefsyntax-moduleinstmathitmoduleinst)

*   The [module instance](#syntax-moduleinst) [moduleinst](#syntax-moduleinst) must be [valid](#valid-moduleinst) with some [module context](#module-context) C.
    
*   Each [value](#syntax-val) [val](#syntax-val)i​ in [val](#syntax-val)∗ must be [valid](#valid-val) with some [value type](#syntax-valtype) ti​.
    
*   Let t∗ be the concatenation of all ti​ in order.
    
*   Let C′ be the same [context](#context) as C, but with the [value types](#syntax-valtype) t∗ prepended to the [locals](#context) list.
    
*   Then the frame is valid with [frame context](#frame-context) C′.
    

S[⊢](#valid-frame){[locals](#syntax-frame) [val](#syntax-val)∗,[module](#syntax-frame) [moduleinst](#syntax-moduleinst)}:(C,[locals](#context) t∗)S[⊢](#valid-moduleinst)[moduleinst](#syntax-moduleinst):C(S[⊢](#valid-val)[val](#syntax-val):t)∗​

#### Administrative Instructions[](#administrative-instructions③)

Typing rules for [administrative instructions](#syntax-instr-admin) are specified as follows. In addition to the [context](#context) C, typing of these instructions is defined under a given [store](#syntax-store) S.

To that end, all previous typing judgements C⊢prop are generalized to include the store, as in S;C⊢prop, by implicitly adding S to all rules – S is never modified by the pre-existing rules, but it is accessed in the extra rules for [administrative instructions](#valid-instr-admin) given below.

##### [trap](#syntax-trap)[](#-hrefsyntax-trapmathsftrap)

*   The instruction is valid with any [valid](#valid-instrtype) [instruction type](#syntax-instrtype) of the form \[t1∗​\][→](#syntax-instrtype)\[t2∗​\].
    

S;C[⊢](#valid-instr-admin)[trap](#syntax-trap):\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]C[⊢](#valid-instrtype)\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]:[ok](#valid-instrtype)​

##### [val](#syntax-val)[](#-hrefsyntax-valmathitval)

*   The value [val](#syntax-val) must be valid with [value type](#syntax-valtype) t.
    
*   Then it is valid as an instruction with type \[\][→](#syntax-instrtype)\[t\].
    

S;C[⊢](#valid-instr-admin)[val](#syntax-val):\[\][→](#syntax-instrtype)\[t\]S[⊢](#valid-val)[val](#syntax-val):t​

##### [label](#syntax-label)n​{[instr](#syntax-instr)0∗​} [instr](#syntax-instr)∗[](#-hrefsyntax-labelmathsflabel_nhrefsyntax-instrmathitinstr_0asthrefsyntax-instrmathitinstrast)

*   The instruction sequence [instr](#syntax-instr)0∗​ must be [valid](#valid-instrs) with some type \[t1n​\][→](#syntax-instrtype)x∗​\[t2∗​\].
    
*   Let C′ be the same [context](#context) as C, but with the [result type](#syntax-resulttype) \[t1n​\] prepended to the [labels](#context) list.
    
*   Under context C′, the instruction sequence [instr](#syntax-instr)∗ must be [valid](#valid-instrs) with type \[\][→](#syntax-instrtype)x′∗​\[t2∗​\].
    
*   Then the compound instruction is valid with type \[\][→](#syntax-instrtype)\[t2∗​\].
    

S;C[⊢](#valid-instr-admin)[label](#syntax-label)n​{[instr](#syntax-instr)0∗​} [instr](#syntax-instr)∗:\[\][→](#syntax-instrtype)\[t2∗​\]S;C[⊢](#valid-instrs)[instr](#syntax-instr)0∗​:\[t1n​\][→](#syntax-instrtype)x∗​\[t2∗​\]S;C,[labels](#context)\[t1n​\][⊢](#valid-instrs)[instr](#syntax-instr)∗:\[\][→](#syntax-instrtype)x′∗​\[t2∗​\]​

##### [frame](#syntax-frame)n​{F} [instr](#syntax-instr)∗[](#-hrefsyntax-framemathsfframe_nfhrefsyntax-instrmathitinstrast)

*   Under the [valid](#valid-resulttype) return type \[tn\], the [thread](#syntax-frame) F;[instr](#syntax-instr)∗ must be [valid](#valid-frame) with [result type](#syntax-resulttype) \[tn\].
    
*   Then the compound instruction is valid with type \[\][→](#syntax-instrtype)\[tn\].
    

S;C[⊢](#valid-instr-admin)[frame](#syntax-frame)n​{F} [instr](#syntax-instr)∗:\[\][→](#syntax-instrtype)\[tn\]C[⊢](#valid-resulttype)\[tn\]:[ok](#valid-resulttype)S;\[tn\][⊢](#valid-instrs)F;[instr](#syntax-instr)∗:\[tn\]​

##### [handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [instr](#syntax-instr)∗[](#-hrefsyntax-handlermathsfhandler_nhrefsyntax-catchmathitcatchasthrefsyntax-instrmathitinstrast)

*   For every [catch clause](#syntax-catch) [catch](#syntax-catch)i​ in [catch](#syntax-catch)∗, [catch](#syntax-catch)i​ must be [valid](#valid-catch).
    
*   The instruction sequence [instr](#syntax-instr)∗ must be [valid](#valid-instrs) with some type \[t1∗​\][→](#syntax-instrtype)\[t2∗​\].
    
*   Then the compound instruction is valid with type \[t1∗​\][→](#syntax-instrtype)\[t2∗​\].
    

S;C[⊢](#valid-instr-admin)[handler](#syntax-handler)n​{[catch](#syntax-catch)∗} [instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)\[t2∗​\](C[⊢](#valid-catch)[catch](#syntax-catch):[ok](#valid-catch))∗S;C[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]​​​

#### Store Extension[](#store-extension①)

Programs can mutate the [store](#syntax-store) and its contained instances. Any such modification must respect certain invariants, such as not removing allocated instances or changing immutable definitions. While these invariants are inherent to the execution semantics of WebAssembly [instructions](#exec-instr) and [modules](#exec-instantiation), [host functions](#syntax-hostfunc) do not automatically adhere to them. Consequently, the required invariants must be stated as explicit constraints on the [invocation](#exec-invoke-host) of host functions. Soundness only holds when the [embedder](#embedder) ensures these constraints.

The necessary constraints are codified by the notion of store _extension_: a store state S′ extends state S, written S[⪯](#extend)S′, when the following rules hold.

Note

Extension does not imply that the new store is valid, which is defined separately [above](#valid-store).

##### [Store](#syntax-store) S[](#store--s①)

*   The length of S.[tags](#syntax-store) must not shrink.
    
*   The length of S.[globals](#syntax-store) must not shrink.
    
*   The length of S.[mems](#syntax-store) must not shrink.
    
*   The length of S.[tables](#syntax-store) must not shrink.
    
*   The length of S.[funcs](#syntax-store) must not shrink.
    
*   The length of S.[datas](#syntax-store) must not shrink.
    
*   The length of S.[elems](#syntax-store) must not shrink.
    
*   The length of S.[structs](#syntax-store) must not shrink.
    
*   The length of S.[arrays](#syntax-store) must not shrink.
    
*   The length of S.[exns](#syntax-store) must not shrink.
    
*   For each [tag instance](#syntax-taginst) [taginst](#syntax-taginst)i​ in the original S.[tags](#syntax-store), the new tag instance must be an [extension](#extend-taginst) of the old.
    
*   For each [global instance](#syntax-globalinst) [globalinst](#syntax-globalinst)i​ in the original S.[globals](#syntax-store), the new global instance must be an [extension](#extend-globalinst) of the old.
    
*   For each [memory instance](#syntax-meminst) [meminst](#syntax-meminst)i​ in the original S.[mems](#syntax-store), the new memory instance must be an [extension](#extend-meminst) of the old.
    
*   For each [table instance](#syntax-tableinst) [tableinst](#syntax-tableinst)i​ in the original S.[tables](#syntax-store), the new table instance must be an [extension](#extend-tableinst) of the old.
    
*   For each [function instance](#syntax-funcinst) [funcinst](#syntax-funcinst)i​ in the original S.[funcs](#syntax-store), the new function instance must be an [extension](#extend-funcinst) of the old.
    
*   For each [data instance](#syntax-datainst) [datainst](#syntax-datainst)i​ in the original S.[datas](#syntax-store), the new data instance must be an [extension](#extend-datainst) of the old.
    
*   For each [element instance](#syntax-eleminst) [eleminst](#syntax-eleminst)i​ in the original S.[elems](#syntax-store), the new element instance must be an [extension](#extend-eleminst) of the old.
    
*   For each [structure instance](#syntax-structinst) [structinst](#syntax-structinst)i​ in the original S.[structs](#syntax-store), the new structure instance must be an [extension](#extend-structinst) of the old.
    
*   For each [array instance](#syntax-arrayinst) [arrayinst](#syntax-arrayinst)i​ in the original S.[arrays](#syntax-store), the new array instance must be an [extension](#extend-arrayinst) of the old.
    
*   For each [exception instance](#syntax-exninst) [exninst](#syntax-exninst)i​ in the original S.[exns](#syntax-store), the new exception instance must be an [extension](#extend-datainst) of the old.
    

[⊢](#extend-store)S1​[⪯](#extend)S2​S1​.[tags](#syntax-store)\=[taginst](#syntax-taginst)1∗​S1​.[globals](#syntax-store)\=[globalinst](#syntax-globalinst)1∗​S1​.[mems](#syntax-store)\=[meminst](#syntax-meminst)1∗​S1​.[tables](#syntax-store)\=[tableinst](#syntax-tableinst)1∗​S1​.[funcs](#syntax-store)\=[funcinst](#syntax-funcinst)1∗​S1​.[datas](#syntax-store)\=[datainst](#syntax-datainst)1∗​S1​.[elems](#syntax-store)\=[eleminst](#syntax-eleminst)1∗​S1​.[structs](#syntax-store)\=[structinst](#syntax-structinst)1∗​S1​.[arrays](#syntax-store)\=[arrayinst](#syntax-arrayinst)1∗​S1​.[exns](#syntax-store)\=[exninst](#syntax-exninst)1∗​​S2​.[tags](#syntax-store)\=[taginst](#syntax-taginst)1′​∗ [taginst](#syntax-taginst)2∗​S2​.[globals](#syntax-store)\=[globalinst](#syntax-globalinst)1′​∗ [globalinst](#syntax-globalinst)2∗​S2​.[mems](#syntax-store)\=[meminst](#syntax-meminst)1′​∗ [meminst](#syntax-meminst)2∗​S2​.[tables](#syntax-store)\=[tableinst](#syntax-tableinst)1′​∗ [tableinst](#syntax-tableinst)2∗​S2​.[funcs](#syntax-store)\=[funcinst](#syntax-funcinst)1′​∗ [funcinst](#syntax-funcinst)2∗​S2​.[datas](#syntax-store)\=[datainst](#syntax-datainst)1′​∗ [datainst](#syntax-datainst)2∗​S2​.[elems](#syntax-store)\=[eleminst](#syntax-eleminst)1′​∗ [eleminst](#syntax-eleminst)2∗​S2​.[structs](#syntax-store)\=[structinst](#syntax-structinst)1′​∗ [structinst](#syntax-structinst)2∗​S2​.[arrays](#syntax-store)\=[arrayinst](#syntax-arrayinst)1′​∗ [arrayinst](#syntax-arrayinst)2∗​S2​.[exns](#syntax-store)\=[exninst](#syntax-exninst)1′​∗ [exninst](#syntax-exninst)2∗​​([⊢](#extend-taginst)[taginst](#syntax-taginst)1​[⪯](#extend)[taginst](#syntax-taginst)1′​)∗([⊢](#extend-globalinst)[globalinst](#syntax-globalinst)1​[⪯](#extend)[globalinst](#syntax-globalinst)1′​)∗([⊢](#extend-meminst)[meminst](#syntax-meminst)1​[⪯](#extend)[meminst](#syntax-meminst)1′​)∗([⊢](#extend-tableinst)[tableinst](#syntax-tableinst)1​[⪯](#extend)[tableinst](#syntax-tableinst)1′​)∗([⊢](#extend-funcinst)[funcinst](#syntax-funcinst)1​[⪯](#extend)[funcinst](#syntax-funcinst)1′​)∗([⊢](#extend-datainst)[datainst](#syntax-datainst)1​[⪯](#extend)[datainst](#syntax-datainst)1′​)∗([⊢](#extend-eleminst)[eleminst](#syntax-eleminst)1​[⪯](#extend)[eleminst](#syntax-eleminst)1′​)∗([⊢](#extend-structinst)[structinst](#syntax-structinst)1​[⪯](#extend)[structinst](#syntax-structinst)1′​)∗([⊢](#extend-arrayinst)[arrayinst](#syntax-arrayinst)1​[⪯](#extend)[arrayinst](#syntax-arrayinst)1′​)∗([⊢](#extend-exninst)[exninst](#syntax-exninst)1​[⪯](#extend)[exninst](#syntax-exninst)1′​)∗​​​

##### [Tag Instance](#syntax-taginst) [taginst](#syntax-taginst)[](#tag-instance--hrefsyntax-taginstmathittaginst)

*   A tag instance must remain unchanged.
    

[⊢](#extend-taginst)[taginst](#syntax-taginst)[⪯](#extend)[taginst](#syntax-taginst)​

##### [Global Instance](#syntax-globalinst) [globalinst](#syntax-globalinst)[](#global-instance--hrefsyntax-globalinstmathitglobalinst)

*   The [global type](#syntax-globaltype) [globalinst](#syntax-globalinst).[type](#syntax-globalinst) must remain unchanged.
    
*   Let [mut](#syntax-mut) t be the structure of [globalinst](#syntax-globalinst).[type](#syntax-globalinst).
    
*   If [mut](#syntax-mut) is empty, then the [value](#syntax-val) [globalinst](#syntax-globalinst).[value](#syntax-globalinst) must remain unchanged.
    

[⊢](#extend-globalinst){[type](#syntax-globalinst) ([mut](#syntax-mut) t),[value](#syntax-globalinst) [val](#syntax-val)1​}[⪯](#extend){[type](#syntax-globalinst) ([mut](#syntax-mut) t),[value](#syntax-globalinst) [val](#syntax-val)2​}[mut](#syntax-mut)\=[mut](#syntax-mut)∨[val](#syntax-val)1​\=[val](#syntax-val)2​​

##### [Memory Instance](#syntax-meminst) [meminst](#syntax-meminst)[](#memory-instance--hrefsyntax-meminstmathitmeminst)

*   The [memory type](#syntax-memtype) [meminst](#syntax-meminst).[type](#syntax-meminst) must remain unchanged.
    
*   The length of [meminst](#syntax-meminst).[bytes](#syntax-meminst) must not shrink.
    

[⊢](#extend-meminst){[type](#syntax-meminst) mt,[bytes](#syntax-meminst) b1n1​​}[⪯](#extend){[type](#syntax-meminst) mt,[bytes](#syntax-meminst) b2n2​​}n1​≤n2​​

##### [Table Instance](#syntax-tableinst) [tableinst](#syntax-tableinst)[](#table-instance--hrefsyntax-tableinstmathittableinst)

*   The [table type](#syntax-tabletype) [tableinst](#syntax-tableinst).[type](#syntax-tableinst) must remain unchanged.
    
*   The length of [tableinst](#syntax-tableinst).[refs](#syntax-tableinst) must not shrink.
    

[⊢](#extend-tableinst){[type](#syntax-tableinst) tt,[refs](#syntax-tableinst) (fa1?​)n1​}[⪯](#extend){[type](#syntax-tableinst) tt,[refs](#syntax-tableinst) (fa2?​)n2​}n1​≤n2​​

##### [Function Instance](#syntax-funcinst) [funcinst](#syntax-funcinst)[](#function-instance--hrefsyntax-funcinstmathitfuncinst)

*   A function instance must remain unchanged.
    

[⊢](#extend-funcinst)[funcinst](#syntax-funcinst)[⪯](#extend)[funcinst](#syntax-funcinst)​

##### [Data Instance](#syntax-datainst) [datainst](#syntax-datainst)[](#data-instance--hrefsyntax-datainstmathitdatainst)

*   The list [datainst](#syntax-datainst).[bytes](#syntax-datainst) must:
    
    *   either remain unchanged,
        
    *   or shrink to length 0.
        

[⊢](#extend-datainst){[bytes](#syntax-datainst) b∗}[⪯](#extend){[bytes](#syntax-datainst) b∗}​

[⊢](#extend-datainst){[bytes](#syntax-datainst) b∗}[⪯](#extend){[bytes](#syntax-datainst) ϵ}​

##### [Element Instance](#syntax-eleminst) [eleminst](#syntax-eleminst)[](#element-instance--hrefsyntax-eleminstmathiteleminst)

*   The [reference type](#syntax-reftype) [eleminst](#syntax-eleminst).[type](#syntax-eleminst) must remain unchanged.
    
*   The list [eleminst](#syntax-eleminst).[refs](#syntax-eleminst) must:
    
    *   either remain unchanged,
        
    *   or shrink to length 0.
        

[⊢](#extend-eleminst){[type](#syntax-eleminst) t,[refs](#syntax-eleminst) a∗}[⪯](#extend){[type](#syntax-eleminst) t,[refs](#syntax-eleminst) a∗}​

[⊢](#extend-eleminst){[type](#syntax-eleminst) t,[refs](#syntax-eleminst) a∗}[⪯](#extend){[type](#syntax-eleminst) t,[refs](#syntax-eleminst) ϵ}​

##### [Structure Instance](#syntax-structinst) [structinst](#syntax-structinst)[](#structure-instance--hrefsyntax-structinstmathitstructinst)

*   The [defined type](#syntax-deftype) [structinst](#syntax-structinst).[type](#syntax-structinst) must remain unchanged.
    
*   Assert: due to [store well-formedness](#valid-structinst), the [expansion](#aux-expand-deftype) of [structinst](#syntax-structinst).[type](#syntax-structinst) is a [structure type](#syntax-structtype).
    
*   Let [struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗ be the [expansion](#aux-expand-deftype) of [structinst](#syntax-structinst).[type](#syntax-structinst).
    
*   The length of the list [structinst](#syntax-structinst).[fields](#syntax-structinst) must remain unchanged.
    
*   Assert: due to [store well-formedness](#valid-structinst), the length of [structinst](#syntax-structinst).[fields](#syntax-structinst) is the same as the length of [fieldtype](#syntax-fieldtype)∗.
    
*   For each [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ in [structinst](#syntax-structinst).[fields](#syntax-structinst) and corresponding [field type](#syntax-fieldtype) [fieldtype](#syntax-fieldtype)i​ in [fieldtype](#syntax-fieldtype)∗:
    
    *   Let [mut](#syntax-mut)i​ sti​ be the structure of [fieldtype](#syntax-fieldtype)i​.
        
    *   If [mut](#syntax-mut)i​ is empty, then the [field value](#syntax-fieldval) [fieldval](#syntax-fieldval)i​ must remain unchanged.
        

[⊢](#extend-structinst){[type](#syntax-structinst) ([mut](#syntax-mut) st)∗,[fields](#syntax-structinst) [fieldval](#syntax-fieldval)1∗​}[⪯](#extend){[type](#syntax-structinst) ([mut](#syntax-mut) st)∗,[fields](#syntax-structinst) [fieldval](#syntax-fieldval)2∗​}([mut](#syntax-mut)\=[mut](#syntax-mut)∨[fieldval](#syntax-fieldval)1​\=[fieldval](#syntax-fieldval)2​)∗​

##### [Array Instance](#syntax-arrayinst) [arrayinst](#syntax-arrayinst)[](#array-instance--hrefsyntax-arrayinstmathitarrayinst)

*   The [defined type](#syntax-deftype) [arrayinst](#syntax-arrayinst).[type](#syntax-arrayinst) must remain unchanged.
    
*   Assert: due to [store well-formedness](#valid-arrayinst), the [expansion](#aux-expand-deftype) of [arrayinst](#syntax-arrayinst).[type](#syntax-arrayinst) is an [array type](#syntax-arraytype).
    
*   Let [array](#syntax-comptype) [fieldtype](#syntax-fieldtype) be the [expansion](#aux-expand-deftype) of [arrayinst](#syntax-arrayinst).[type](#syntax-arrayinst).
    
*   The length of the list [arrayinst](#syntax-arrayinst).[fields](#syntax-arrayinst) must remain unchanged.
    
*   Let [mut](#syntax-mut) st be the structure of [fieldtype](#syntax-fieldtype).
    
*   If [mut](#syntax-mut) is empty, then the sequence of [field values](#syntax-fieldval) [arrayinst](#syntax-arrayinst).[fields](#syntax-arrayinst) must remain unchanged.
    

[⊢](#extend-arrayinst){[type](#syntax-arrayinst) ([mut](#syntax-mut) st),[fields](#syntax-arrayinst) [fieldval](#syntax-fieldval)1∗​}[⪯](#extend){[type](#syntax-arrayinst) ([mut](#syntax-mut) st),[fields](#syntax-arrayinst) [fieldval](#syntax-fieldval)2∗​}[mut](#syntax-mut)\=[mut](#syntax-mut)∨[fieldval](#syntax-fieldval)1∗​\=[fieldval](#syntax-fieldval)2∗​​

##### [Exception Instance](#syntax-exninst) [exninst](#syntax-exninst)[](#exception-instance--hrefsyntax-exninstmathitexninst)

*   An exception instance must remain unchanged.
    

[⊢](#extend-exninst)[exninst](#syntax-exninst)[⪯](#extend)[exninst](#syntax-exninst)​

#### Theorems[](#theorems①)

Given the definition of [valid configurations](#valid-config), the standard soundness theorems hold. [\[2\]](#cite-cpp2018) [\[3\]](#cite-fm2021)

**Theorem (Preservation).** If a [configuration](#syntax-config) S;T is [valid](#valid-config) with [result type](#syntax-resulttype) \[t∗\] (i.e., [⊢](#valid-config)S;T:\[t∗\]), and steps to S′;T′ (i.e., S;T[↪](#exec-notation)S′;T′), then S′;T′ is a valid configuration with the same result type (i.e., [⊢](#valid-config)S′;T′:\[t∗\]). Furthermore, S′ is an [extension](#extend-store) of S (i.e., [⊢](#extend-store)S[⪯](#extend)S′).

A _terminal_ [thread](#syntax-thread) is one whose sequence of [instructions](#syntax-instr) is a [result](#syntax-result). A terminal configuration is a configuration whose thread is terminal.

**Theorem (Progress).** If a [configuration](#syntax-config) S;T is [valid](#valid-config) (i.e., [⊢](#valid-config)S;T:\[t∗\] for some [result type](#syntax-resulttype) \[t∗\]), then either it is terminal, or it can step to some configuration S′;T′ (i.e., S;T[↪](#exec-notation)S′;T′).

From Preservation and Progress the soundness of the WebAssembly type system follows directly.

**Corollary (Soundness).** If a [configuration](#syntax-config) S;T is [valid](#valid-config) (i.e., [⊢](#valid-config)S;T:\[t∗\] for some [result type](#syntax-resulttype) \[t∗\]), then it either diverges or takes a finite number of steps to reach a terminal configuration S′;T′ (i.e., S;T[↪](#exec-notation)∗S′;T′) that is valid with the same result type (i.e., [⊢](#valid-config)S′;T′:\[t∗\]) and where S′ is an [extension](#extend-store) of S (i.e., [⊢](#extend-store)S[⪯](#extend)S′).

In other words, every thread in a valid configuration either runs forever, traps, throws an exception, or terminates with a result that has the expected type. Consequently, given a [valid store](#valid-store), no computation defined by [instantiation](#exec-instantiation) or [invocation](#exec-invocation) of a valid module can “crash” or otherwise (mis)behave in ways not covered by the [execution](#exec) semantics given in this specification.

\[[1](#id1)\]

The formalization and theorems are derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. [Bringing the Web up to Speed with WebAssembly](https://dl.acm.org/citation.cfm?doid=3062341.3062363). Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.

\[[2](#id3)\]

A machine-verified version of the formalization and soundness proof of the PLDI 2017 paper is described in the following article: Conrad Watt. [Mechanising and Verifying the WebAssembly Specification](https://dl.acm.org/citation.cfm?id=3167082). Proceedings of the 7th ACM SIGPLAN Conference on Certified Programs and Proofs (CPP 2018). ACM 2018.

\[[3](#id4)\]

Machine-verified formalizations and soundness proofs of the semantics from the official specification are described in the following article: Conrad Watt, Xiaojia Rao, Jean Pichon-Pharabod, Martin Bodin, Philippa Gardner. [Two Mechanisations of WebAssembly 1.0](https://link.springer.com/chapter/10.1007/978-3-030-90870-6_4). Proceedings of the 24th International Symposium on Formal Methods (FM 2021). Springer 2021.

### A.7 Type System Properties[](#a7-type-system-properties)

#### Principal Types[](#principal-types①)

The [type system](#type-system) of WebAssembly features both [subtyping](#match) and simple forms of [polymorphism](#polymorphism) for [instruction types](#syntax-instrtype). That has the effect that every instruction or instruction sequence can be classified with multiple different instruction types.

However, the typing rules still allow deriving _principal types_ for instruction sequences. That is, every valid instruction sequence has one particular type scheme, possibly containing some unconstrained place holder _type variables_, that is a subtype of all its valid instruction types, after substituting its type variables with suitable specific types.

Moreover, when deriving an instruction type in a “forward” manner, i.e., the _input_ of the instruction sequence is already fixed to specific types, then it has a principal _output_ type expressible without type variables, up to a possibly [polymorphic stack](#polymorphism) bottom representable with one single variable. In other words, “forward” principal types are effectively _closed_.

Note

For example, in isolation, the instruction [ref.as\_non\_null](#syntax-instr-ref) has the type \[([ref](#syntax-reftype) [null](#syntax-reftype) ht)\][→](#syntax-instrtype)\[([ref](#syntax-reftype) ht)\] for any choice of valid [heap type](#syntax-type) ht. Moreover, if the input type \[([ref](#syntax-reftype) [null](#syntax-reftype) ht)\] is already determined, i.e., a specific ht is given, then the output type \[([ref](#syntax-reftype) ht)\] is fully determined as well.

The implication of the latter property is that a validator for _complete_ instruction sequences (as they occur in valid modules) can be implemented with a simple left-to-right [algorithm](#algo-valid) that does not require the introduction of type variables.

A typing algorithm capable of handling _partial_ instruction sequences (as might be considered for program analysis or program manipulation) needs to introduce type variables and perform substitutions, but it does not need to perform backtracking or record any non-syntactic constraints on these type variables.

Technically, the [syntax](#syntax-type) of [heap](#syntax-heaptype), [value](#syntax-valtype), and [result](#syntax-resulttype) types can be enriched with type variables as follows:

​null[heaptype](#syntax-heaptype)[reftype](#syntax-reftype)[valtype](#syntax-valtype)[resulttype](#syntax-resulttype)​::=::=::=::=::=​[null](#syntax-reftype)? ∣ αnull​… ∣ α[heaptype](#syntax-heaptype)​[ref](#syntax-reftype) null [heaptype](#syntax-heaptype)… ∣ α[valtype](#syntax-valtype)​ ∣ αnumvectype​\[α[valtype](#syntax-valtype)∗?​ [valtype](#syntax-valtype)∗\]​​

where each αxyz​ ranges over a set of type variables for syntactic class xyz, respectively. The special class numvectype is defined as [numtype](#syntax-numtype) ∣ [vectype](#syntax-vectype) ∣ [bot](#syntax-valtype-ext), and is only needed to handle unannotated [select](#syntax-instr-parametric) instructions.

A type is _closed_ when it does not contain any type variables, and _open_ otherwise. A _type substitution_ σ is a finite mapping from type variables to closed types of the respective syntactic class. When applied to an open type, it replaces the type variables α from its domain with the respective σ(α).

**Theorem (Principal Types).** If an instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-config) with some closed [instruction type](#syntax-instrtype) [instrtype](#syntax-instrtype) (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)∗:[instrtype](#syntax-instrtype)), then it is also valid with a possibly open instruction type [instrtype](#syntax-instrtype)min​ (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)∗:[instrtype](#syntax-instrtype)min​), such that for _every_ closed type [instrtype](#syntax-instrtype)′ with which [instr](#syntax-instr)∗ is valid (i.e., for all C[⊢](#valid-instrs)[instr](#syntax-instr)∗:[instrtype](#syntax-instrtype)′), there exists a substitution σ, such that σ([instrtype](#syntax-instrtype)min​) is a subtype of [instrtype](#syntax-instrtype)′ (i.e., C[⊢](#match-instrtype)σ([instrtype](#syntax-instrtype)min​)[≤](#match-instrtype)[instrtype](#syntax-instrtype)′). Furthermore, [instrtype](#syntax-instrtype)min​ is unique up to the choice of type variables.

**Theorem (Closed Principal Forward Types).** If closed input type \[t1∗​\] is given and the instruction sequence [instr](#syntax-instr)∗ is [valid](#valid-config) with [instruction type](#syntax-instrtype) \[t1∗​\][→](#syntax-instrtype)x∗​\[t2∗​\] (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)x∗​\[t2∗​\]), then it is also valid with instruction type \[t1∗​\][→](#syntax-instrtype)x∗​\[α[valtype](#syntax-valtype)∗​ t∗\] (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)x∗​\[α[valtype](#syntax-valtype)∗​ t∗\]), where all t∗ are closed, such that for _every_ closed result type \[t2′​∗\] with which [instr](#syntax-instr)∗ is valid (i.e., for all C[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)x∗​\[t2′​∗\]), there exists a substitution σ, such that \[t2′​∗\]\=\[σ(α[valtype](#syntax-valtype)∗​) t∗\].

#### Type Lattice[](#type-lattice①)

The [Principal Types](#principality) property depends on the existence of a _greatest lower bound_ for any pair of types.

**Theorem (Greatest Lower Bounds for Value Types).** For any two value types t1​ and t2​ that are [valid](#valid-valtype) (i.e., C[⊢](#valid-valtype)t1​:[ok](#valid-valtype) and C[⊢](#valid-valtype)t2​:[ok](#valid-valtype)), there exists a valid value type t that is a subtype of both t1​ and t2​ (i.e., C[⊢](#valid-valtype)t:[ok](#valid-valtype) and C[⊢](#match-valtype)t[≤](#match-valtype)t1​ and C[⊢](#match-valtype)t[≤](#match-valtype)t2​), such that _every_ valid value type t′ that also is a subtype of both t1​ and t2​ (i.e., for all C[⊢](#valid-valtype)t′:[ok](#valid-valtype) and C[⊢](#match-valtype)t′[≤](#match-valtype)t1​ and C[⊢](#match-valtype)t′[≤](#match-valtype)t2​), is a subtype of t (i.e., C[⊢](#match-valtype)t′[≤](#match-valtype)t).

Note

The greatest lower bound of two types may be [bot](#syntax-valtype-ext).

**Theorem (Conditional Least Upper Bounds for Value Types).** Any two value types t1​ and t2​ that are [valid](#valid-valtype) (i.e., C[⊢](#valid-valtype)t1​:[ok](#valid-valtype) and C[⊢](#valid-valtype)t2​:[ok](#valid-valtype)) either have no common supertype, or there exists a valid value type t that is a supertype of both t1​ and t2​ (i.e., C[⊢](#valid-valtype)t:[ok](#valid-valtype) and C[⊢](#match-valtype)t1​[≤](#match-valtype)t and C[⊢](#match-valtype)t2​[≤](#match-valtype)t), such that _every_ valid value type t′ that also is a supertype of both t1​ and t2​ (i.e., for all C[⊢](#valid-valtype)t′:[ok](#valid-valtype) and C[⊢](#match-valtype)t1​[≤](#match-valtype)t′ and C[⊢](#match-valtype)t2​[≤](#match-valtype)t′), is a supertype of t (i.e., C[⊢](#match-valtype)t[≤](#match-valtype)t′).

Note

If a top type was added to the type system, a least upper bound would exist for any two types.

**Corollary (Type Lattice).** Assuming the addition of a provisional top type, [value types](#syntax-valtype) form a lattice with respect to their [subtype](#match-valtype) relation.

Finally, value types can be partitioned into multiple disjoint hierarchies that are not related by subtyping, except through [bot](#syntax-valtype-ext).

**Theorem (Disjoint Subtype Hierarchies).** The greatest lower bound of two [value types](#syntax-valtype) is [bot](#syntax-valtype-ext) or [ref](#syntax-reftype) [bot](#syntax-valtype-ext) if and only if they do not have a least upper bound.

In other words, types that do not have common supertypes, do not have common subtypes either (other than [bot](#syntax-valtype-ext) or [ref](#syntax-reftype) [bot](#syntax-valtype-ext)), and vice versa.

Note

Types from disjoint hierarchies can safely be represented in mutually incompatible ways in an implementation, because their values can never flow to the same place.

#### Compositionality[](#compositionality①)

[Valid](#valid-instrs) [instruction sequences](#syntax-instr) can be freely _composed_, as long as their types match up.

**Theorem (Composition).** If two instruction sequences [instr](#syntax-instr)1∗​ and [instr](#syntax-instr)2∗​ are valid with types \[t1∗​\][→](#syntax-instrtype)x1∗​​\[t∗\] and \[t∗\][→](#syntax-instrtype)x2∗​​\[t2∗​\], respectively (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​:\[t1∗​\][→](#syntax-instrtype)x1∗​​\[t∗\] and C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​:\[t∗\][→](#syntax-instrtype)x2∗​​\[t2∗​\]), then the concatenated instruction sequence ([instr](#syntax-instr)1∗​[instr](#syntax-instr)2∗​) is valid with type \[t1∗​\][→](#syntax-instrtype)x1∗​x2∗​​\[t2∗​\] (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​[instr](#syntax-instr)2∗​:\[t1∗​\][→](#syntax-instrtype)x1∗​x2∗​​\[t2∗​\]).

Note

More generally, instead of a shared type \[t∗\], it suffices if the output type of [instr](#syntax-instr)1∗​ is a [subtype](#match-resulttype) of the input type of [instr](#syntax-instr)1∗​, since the subtype can always be weakened to its supertype by subsumption.

Inversely, valid instruction sequences can also freely be _decomposed_, that is, splitting them anywhere produces two instruction sequences that are both [valid](#valid-instrs).

**Theorem (Decomposition).** If an instruction sequence [instr](#syntax-instr)∗ that is valid with type \[t1∗​\][→](#syntax-instrtype)x∗​\[t2∗​\] (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)∗:\[t1∗​\][→](#syntax-instrtype)x∗​\[t2∗​\]) is split into two instruction sequences [instr](#syntax-instr)1∗​ and [instr](#syntax-instr)2∗​ at any point (i.e., [instr](#syntax-instr)∗\=[instr](#syntax-instr)1∗​[instr](#syntax-instr)2∗​), then these are separately valid with some types \[t1∗​\][→](#syntax-instrtype)x1∗​​\[t∗\] and \[t∗\][→](#syntax-instrtype)x2∗​​\[t2∗​\], respectively (i.e., C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​:\[t1∗​\][→](#syntax-instrtype)x1∗​​\[t∗\] and C[⊢](#valid-instrs)[instr](#syntax-instr)1∗​:\[t∗\][→](#syntax-instrtype)x2∗​​\[t2∗​\]), where x∗\=x1∗​x2∗​.

Note

This property holds because validation is required even for unreachable code. Without that, [instr](#syntax-instr)2∗​ might not be valid in isolation.

### A.4 Validation Algorithm[](#a4-validation-algorithm)

The specification of WebAssembly [validation](#valid) is purely _declarative_. It describes the constraints that must be met by a [module](#valid-module) or [instruction](#valid-instr) sequence to be valid.

This section sketches the skeleton of a sound and complete _algorithm_ for effectively validating code, i.e., sequences of [instructions](#syntax-instr). (Other aspects of validation are straightforward to implement.)

In fact, the algorithm is expressed over the flat sequence of opcodes as occurring in the [binary format](#binary), and performs only a single pass over it. Consequently, it can be integrated directly into a decoder.

The algorithm is expressed in typed pseudo code whose semantics is intended to be self-explanatory.

#### Data Structures[](#data-structures①)

##### Types[](#types②③)

Value types are representable as sets of enumerations:

type num\_type = I32 | I64 | F32 | F64
type vec\_type = V128
type heap\_type =
  Any | Eq | I31 | Struct | Array | None |
  Func | Nofunc | Exn | Noexn | Extern | Noextern | Bot |
  Def(def : def\_type)
type ref\_type = Ref(heap : heap\_type, null : bool)
type val\_type = num\_type | vec\_type | ref\_type | Bot

func is\_num(t : val\_type) : bool =
  return t = I32 || t = I64 || t = F32 || t = F64 || t = Bot

func is\_vec(t : val\_type) : bool =
  return t = V128 || t = Bot

func is\_ref(t : val\_type) : bool =
  return not (is\_num t || is\_vec t) || t = Bot

Similarly, [defined types](#syntax-deftype) `def_type` can be represented:

type pack\_type = I8 | I16
type field\_type = Field(val : val\_type | pack\_type, mut : bool)

type struct\_type = Struct(fields : list(field\_type))
type array\_type = Array(fields : field\_type)
type func\_type = Func(params : list(val\_type), results : list(val\_type))
type comp\_type = struct\_type | array\_type | func\_type

type sub\_type = Sub(super : list(def\_type), body : comp\_type, final : bool)
type rec\_type = Rec(types : list(sub\_type))

type def\_type = Def(rec : rec\_type, proj : int32)

func unpack\_field(t : field\_type) : val\_type =
  if (it = I8 || t = I16) return I32
  return t

func expand\_def(t : def\_type) : comp\_type =
  return t.rec.types\[t.proj\].body

These representations assume that all types have been [closed](#type-closed) by [substituting](#type-subst) all [type indices](#syntax-typeidx) (in [concrete heap types](#syntax-heaptype) and in [sub types](#syntax-subtype)) with their respective [defined types](#syntax-deftype). This includes _recursive_ references to enclosing [defined types](#syntax-deftype), such that type representations form graphs and may be _cyclic_ for [recursive types](#syntax-rectype).

We assume that all types have been _canonicalized_, such that equality on two type representations holds if and only if their [closures](#type-closure) are syntactically equivalent, making it a constant-time check.

Note

For the purpose of type canonicalization, recursive references from a [heap type](#syntax-heaptype) to an enclosing [recursive type](#syntax-reftype) (i.e., forward edges in the graph that form a cycle) need to be distinguished from references to previously defined types. However, this distinction does not otherwise affect validation, so is ignored here. In the graph representation, all recursive types are effectively infinitely [unrolled](#aux-unroll-rectype).

We further assume that [validation](#valid-valtype) and [subtyping](#match-valtype) checks are defined on value types, as well as a few auxiliary functions on composite types:

func validate\_val\_type(t : val\_type)
func validate\_ref\_type(t : ref\_type)

func matches\_val(t1 : val\_type, t2 : val\_type) : bool
func matches\_ref(t1 : val\_type, t2 : val\_type) : bool

func is\_func(t : comp\_type) : bool
func is\_struct(t : comp\_type) : bool
func is\_array(t : comp\_type) : bool

Finally, the following function computes the least precise supertype of a given [heap type](#syntax-heaptype) (its corresponding top type):

func top\_heap\_type(t : heap\_type) : heap\_type =
  switch (t)
    case (Any | Eq | I31 | Struct | Array | None)
      return Any
    case (Func | Nofunc)
      return Func
    case (Extern | Noextern)
      return Extern
    case (Def(dt))
      switch (dt.rec.types\[dt.proj\].body)
        case (Struct(\_) | Array(\_))
          return Any
        case (Func(\_))
          return Func
    case (Bot)
      raise CannotOccurInSource

##### Context[](#context②)

Validation requires a [context](#context) for checking uses of [indices](#syntax-index). For the purpose of presenting the algorithm, it is maintained in a set of global variables:

var return\_type : list(val\_type)
var types : array(def\_type)
var locals : array(val\_type)
var locals\_init : array(bool)
var globals : array(global\_type)
var funcs : array(func\_type)
var tables : array(table\_type)
var mems : array(mem\_type)

This assumes suitable representations for the various [types](#syntax-type) besides `val_type`, which are omitted here.

For locals, there is an additional array recording the initialization status of each local.

##### Stacks[](#stacks①)

The algorithm uses three separate stacks: the _value stack_, the _control stack_, and the _initialization stack_. The value stack tracks the [types](#syntax-valtype) of operand values on the [stack](#stack). The control stack tracks surrounding [structured control instructions](#syntax-instr-control) and their associated [blocks](#syntax-instr-control). The initialization stack records all [locals](#syntax-local) that have been initialized since the beginning of the function.

type val\_stack = stack(val\_type)
type init\_stack = stack(u32)

type ctrl\_stack = stack(ctrl\_frame)
type ctrl\_frame = {
  opcode : opcode
  start\_types : list(val\_type)
  end\_types : list(val\_type)
  val\_height : nat
  init\_height : nat
  unreachable : bool
}

For each entered block, the control stack records a _control frame_ with the originating opcode, the types on the top of the operand stack at the start and end of the block (used to check its result as well as branches), the height of the operand stack at the start of the block (used to check that operands do not underflow the current block), the height of the initialization stack at the start of the block (used to reset initialization status at the end of the block), and a flag recording whether the remainder of the block is unreachable (used to handle [stack-polymorphic](#polymorphism) typing after branches).

For the purpose of presenting the algorithm, these stacks are simply maintained as global variables:

var vals : val\_stack
var inits : init\_stack
var ctrls : ctrl\_stack

However, these variables are not manipulated directly by the main checking function, but through a set of auxiliary functions:

func push\_val(type : val\_type) =
  vals.push(type)

func pop\_val() : val\_type =
  if (vals.size() = ctrls\[0\].val\_height && ctrls\[0\].unreachable) return Bot
  error\_if(vals.size() = ctrls\[0\].val\_height)
  return vals.pop()

func pop\_val(expect : val\_type) : val\_type =
  let actual = pop\_val()
  error\_if(not matches\_val(actual, expect))
  return actual

func pop\_num() : num\_type | Bot =
  let actual = pop\_val()
  error\_if(not is\_num(actual))
  return actual

func pop\_ref() : ref\_type =
  let actual = pop\_val()
  error\_if(not is\_ref(actual))
  if (actual = Bot) return Ref(Bot, false)
  return actual

func push\_vals(types : list(val\_type)) = foreach (t in types) push\_val(t)
func pop\_vals(types : list(val\_type)) : list(val\_type) =
  var popped := \[\]
  foreach (t in reverse(types)) popped.prepend(pop\_val(t))
  return popped

Pushing an operand value simply pushes the respective type to the value stack.

Popping an operand value checks that the value stack does not underflow the current block and then removes one type. But first, a special case is handled where the block contains no known values, but has been marked as unreachable. That can occur after an unconditional branch, when the stack is typed [polymorphically](#polymorphism). In that case, the `Bot` type is returned, because that is a _principal_ choice trivially satisfying all use constraints.

A second function for popping an operand value takes an expected type, which the actual operand type is checked against. The types may differ by subtyping, including the case where the actual type is `Bot`, and thereby matches unconditionally. The function returns the actual type popped from the stack.

Finally, there are accumulative functions for pushing or popping multiple operand types.

Note

The notation `stack[i]` is meant to index the stack from the top, so that, e.g., `ctrls[0]` accesses the element pushed last.

The initialization stack and the initialization status of locals is manipulated through the following functions:

func get\_local(idx : u32) =
  error\_if(not locals\_init\[idx\])

func set\_local(idx : u32) =
  if (not locals\_init\[idx\])
    inits.push(idx)
    locals\_init\[idx\] := true

func reset\_locals(height : nat) =
  while (inits.size() > height)
    locals\_init\[inits.pop()\] := false

Getting a local verifies that it is known to be initialized. When a local is set that was not set already, then its initialization status is updated and the change is recorded in the initialization stack. Thus, the initialization status of all locals can be reset to a previous state by denoting a specific height in the initialization stack.

The size of the initialization stack is bounded by the number of (non-defaultable) locals in a function, so can be preallocated by an algorithm.

The control stack is likewise manipulated through auxiliary functions:

func push\_ctrl(opcode : opcode, in : list(val\_type), out : list(val\_type)) =
  let frame = ctrl\_frame(opcode, in, out, vals.size(), inits.size(), false)
  ctrls.push(frame)
  push\_vals(in)

func pop\_ctrl() : ctrl\_frame =
  error\_if(ctrls.is\_empty())
  let frame = ctrls\[0\]
  pop\_vals(frame.end\_types)
  error\_if(vals.size() =/= frame.val\_height)
  reset\_locals(frame.init\_height)
  ctrls.pop()
  return frame

func label\_types(frame : ctrl\_frame) : list(val\_types) =
  return (if (frame.opcode = loop) frame.start\_types else frame.end\_types)

func unreachable() =
  vals.resize(ctrls\[0\].val\_height)
  ctrls\[0\].unreachable := true

Pushing a control frame takes the types of the label and result values. It allocates a new frame record recording them along with the current height of the operand stack and marks the block as reachable.

Popping a frame first checks that the control stack is not empty. It then verifies that the operand stack contains the right types of values expected at the end of the exited block and pops them off the operand stack. Afterwards, it checks that the stack has shrunk back to its initial height. Finally, it undoes all changes to the initialization status of locals that happened inside the block.

The type of the [label](#syntax-label) associated with a control frame is either that of the stack at the start or the end of the frame, determined by the opcode that it originates from.

Finally, the current frame can be marked as unreachable. In that case, all existing operand types are purged from the value stack, in order to allow for the [stack-polymorphism](#polymorphism) logic in `pop_val` to take effect. Because every function has an implicit outermost label that corresponds to an implicit block frame, it is an invariant of the validation algorithm that there always is at least one frame on the control stack when validating an instruction, and hence, ctrls\[0\] is always defined.

Note

Even with the unreachable flag set, consecutive operands are still pushed to and popped from the operand stack. That is necessary to detect invalid [examples](#polymorphism) like ([unreachable](#syntax-instr-control) ([i32](#syntax-numtype).[const](#syntax-instr-numeric)) [i64](#syntax-numtype).[add](#syntax-instr-numeric)). However, a polymorphic stack cannot underflow, but instead generates `Bot` types as needed.

#### Validation of Opcode Sequences[](#validation-of-opcode-sequences①)

The following function shows the validation of a number of representative instructions that manipulate the stack. Other instructions are checked in a similar manner.

func validate(opcode) =
  switch (opcode)
    case (i32.add)
      pop\_val(I32)
      pop\_val(I32)
      push\_val(I32)

    case (drop)
      pop\_val()

    case (select)
      pop\_val(I32)
      let t1 = pop\_val()
      let t2 = pop\_val()
      error\_if(not (is\_num(t1) && is\_num(t2) || is\_vec(t1) && is\_vec(t2)))
      error\_if(t1 =/= t2 && t1 =/= Bot && t2 =/= Bot)
      push\_val(if (t1 = Bot) t2 else t1)

    case (select t)
      pop\_val(I32)
      pop\_val(t)
      pop\_val(t)
      push\_val(t)

    case (ref.is\_null)
      pop\_ref()
      push\_val(I32)

    case (ref.as\_non\_null)
      let rt = pop\_ref()
      push\_val(Ref(rt.heap, false))

    case (ref.test rt)
      validate\_ref\_type(rt)
      pop\_val(Ref(top\_heap\_type(rt), true))
      push\_val(I32)

    case (local.get x)
      get\_local(x)
      push\_val(locals\[x\])

    case (local.set x)
      pop\_val(locals\[x\])
      set\_local(x)

    case (unreachable)
      unreachable()

    case (block t1\*->t2\*)
      pop\_vals(\[t1\*\])
      push\_ctrl(block, \[t1\*\], \[t2\*\])

    case (loop t1\*->t2\*)
      pop\_vals(\[t1\*\])
      push\_ctrl(loop, \[t1\*\], \[t2\*\])

    case (if t1\*->t2\*)
      pop\_val(I32)
      pop\_vals(\[t1\*\])
      push\_ctrl(if, \[t1\*\], \[t2\*\])

    case (end)
      let frame = pop\_ctrl()
      push\_vals(frame.end\_types)

    case (else)
      let frame = pop\_ctrl()
      error\_if(frame.opcode =/= if)
      push\_ctrl(else, frame.start\_types, frame.end\_types)

    case (br n)
      error\_if(ctrls.size() < n)
      pop\_vals(label\_types(ctrls\[n\]))
      unreachable()

    case (br\_if n)
      error\_if(ctrls.size() < n)
      pop\_val(I32)
      pop\_vals(label\_types(ctrls\[n\]))
      push\_vals(label\_types(ctrls\[n\]))

    case (br\_table n\* m)
      pop\_val(I32)
      error\_if(ctrls.size() < m)
      let arity = label\_types(ctrls\[m\]).size()
      foreach (n in n\*)
        error\_if(ctrls.size() < n)
        error\_if(label\_types(ctrls\[n\]).size() =/= arity)
        push\_vals(pop\_vals(label\_types(ctrls\[n\])))
      pop\_vals(label\_types(ctrls\[m\]))
      unreachable()

    case (br\_on\_null n)
      error\_if(ctrls.size() < n)
      let rt = pop\_ref()
      pop\_vals(label\_types(ctrls\[n\]))
      push\_vals(label\_types(ctrls\[n\]))
      push\_val(Ref(rt.heap, false))

    case (br\_on\_cast n rt1 rt2)
      validate\_ref\_type(rt1)
      validate\_ref\_type(rt2)
      pop\_val(rt1)
      push\_val(rt2)
      pop\_vals(label\_types(ctrls\[n\]))
      push\_vals(label\_types(ctrls\[n\]))
      pop\_val(rt2)
      push\_val(diff\_ref\_type(rt2, rt1))

    case (return)
      pop\_vals(return\_types)
      unreachable()

    case (call\_ref x)
      let t = expand\_def(types\[x\])
      error\_if(not is\_func(t))
      pop\_vals(t.params)
      pop\_val(Ref(Def(types\[x\])))
      push\_vals(t.results)

    case (return\_call\_ref x)
      let t = expand\_def(types\[x\])
      error\_if(not is\_func(t))
      pop\_vals(t.params)
      pop\_val(Ref(Def(types\[x\])))
      error\_if(t.results.len() =/= return\_types.len())
      push\_vals(t.results)
      pop\_vals(return\_types)
      unreachable()

    case (struct.new x)
      let t = expand\_def(types\[x\])
      error\_if(not is\_struct(t))
      for (ti in reverse(t.fields))
        pop\_val(unpack\_field(ti))
      push\_val(Ref(Def(types\[x\])))

    case (struct.set x n)
      let t = expand\_def(types\[x\])
      error\_if(not is\_struct(t) || n >= t.fields.len())
      pop\_val(Ref(Def(types\[x\])))
      pop\_val(unpack\_field(st.fields\[n\]))

    case (throw x)
       pop\_vals(tags\[x\].type.params)
       unreachable()

    case (try\_table t1\*->t2\* handler\*)
      pop\_vals(\[t1\*\])
      foreach (handler in handler\*)
        error\_if(ctrls.size() < handler.label)
        push\_ctrl(catch, \[\], label\_types(ctrls\[handler.label\]))
        switch (handler.clause)
          case (catch x)
            push\_vals(tags\[x\].type.params)
          case (catch\_ref x)
            push\_vals(tags\[x\].type.params)
            push\_val(Exnref)
          case (catch\_all)
            skip
          case (catch\_all\_ref)
            push\_val(Exnref)
        pop\_ctrl()
      push\_ctrl(try\_table, \[t1\*\], \[t2\*\])

Note

It is an invariant under the current WebAssembly instruction set that an operand of `Bot` type is never duplicated on the stack. This would change if the language were extended with stack instructions like `dup`. Under such an extension, the above algorithm would need to be refined by replacing the `Bot` type with proper _type variables_ to ensure that all uses are consistent.

### Custom Sections and Annotations[](#custom-sections-and-annotations①)

This appendix defines dedicated [custom sections](#binary-customsec) for WebAssembly’s [binary format](#binary) and [annotations](#text-annot) for the text format. Such sections or annotations do not contribute to, or otherwise affect, the WebAssembly semantics, and may be ignored by an implementation. However, they provide useful meta data that implementations can make use of to improve user experience or take compilation hints.

#### Name Section[](#name-section①)

The _name section_ is a [custom section](#binary-customsec) whose name string is itself ‘name’. The name section should appear only once in a module, and only after the [data section](#binary-datasec).

The purpose of this section is to attach printable names to definitions in a module, which e.g. can be used by a debugger or when parts of the module are to be rendered in [text form](#text).

Note

All [names](#binary-name) are represented in [\[UNICODE\]](#biblio-unicode "The Unicode Standard") encoded in UTF-8. Names need not be unique.

##### Subsections[](#subsections①)

The [data](#binary-customsec) of a name section consists of a sequence of _subsections_. Each subsection consists of a

*   a one-byte subsection _id_,
    
*   the [u32](#syntax-int) _size_ of the contents, in bytes,
    
*   the actual _contents_, whose structure is dependent on the subsection id.
    

​[namesec](#binary-namesubsection)[namedata](#binary-namesubsection)[namesubsection](#binary-namesubsection)N​(B)​::=::=::=​[section](#binary-section)0​([namedata](#binary-namesubsection))n:[name](#binary-name)[modulenamesubsec](#binary-modulenamesec)?[funcnamesubsec](#binary-funcnamesec)?[localnamesubsec](#binary-localnamesec)?[typenamesubsec](#binary-typenamesec)?[fieldnamesubsec](#binary-fieldnamesec)?[tagnamesubsec](#binary-tagnamesec)?N:[byte](#binary-byte) size:[u32](#binary-int) B​(ifn\=‘name’)(ifsize\=∣∣B∣∣)​​

The following subsection ids are used:

Id

Subsection

0

[module name](#binary-modulenamesec)

1

[function names](#binary-funcnamesec)

2

[local names](#binary-localnamesec)

4

[type names](#binary-typenamesec)

10

[field names](#binary-fieldnamesec)

11

[tag names](#binary-tagnamesec)

Each subsection may occur at most once, and in order of increasing id.

##### Name Maps[](#name-maps①)

A _name map_ assigns [names](#syntax-name) to [indices](#syntax-index) in a given [index space](#syntax-index). It consists of a [list](#binary-list) of index/name pairs in order of increasing index value. Each index must be unique, but the assigned names need not be.

​[namemap](#binary-namemap)[nameassoc](#binary-namemap)​::=::=​[list](#binary-list)([nameassoc](#binary-namemap))[idx](#binary-index) [name](#binary-name)​​

An _indirect name map_ assigns [names](#syntax-name) to a two-dimensional [index space](#syntax-index), where secondary indices are _grouped_ by primary indices. It consists of a list of primary index/name map pairs in order of increasing index value, where each name map in turn maps secondary indices to names. Each primary index must be unique, and likewise each secondary index per individual name map.

​[indirectnamemap](#binary-indirectnamemap)[indirectnameassoc](#binary-indirectnamemap)​::=::=​[list](#binary-list)([indirectnameassoc](#binary-indirectnamemap))[idx](#binary-index) [namemap](#binary-namemap)​​

##### Module Names[](#module-names①)

The _module name subsection_ has the id 0. It simply consists of a single [name](#binary-name) that is assigned to the module itself.

​[modulenamesubsec](#binary-modulenamesec)​::=​[namesubsection](#binary-namesubsection)0​([name](#binary-name))​​

##### Function Names[](#function-names①)

The _function name subsection_ has the id 1. It consists of a [name map](#binary-namemap) assigning function names to [function indices](#syntax-funcidx).

​[funcnamesubsec](#binary-funcnamesec)​::=​[namesubsection](#binary-namesubsection)1​([namemap](#binary-namemap))​​

##### Local Names[](#local-names①)

The _local name subsection_ has the id 2. It consists of an [indirect name map](#binary-indirectnamemap) assigning local names to [local indices](#syntax-localidx) grouped by [function indices](#syntax-funcidx).

​[localnamesubsec](#binary-localnamesec)​::=​[namesubsection](#binary-namesubsection)2​([indirectnamemap](#binary-indirectnamemap))​​

##### Type Names[](#type-names①)

The _type name subsection_ has the id 4. It consists of a [name map](#binary-namemap) assigning type names to [type indices](#syntax-typeidx).

​[typenamesubsec](#binary-typenamesec)​::=​[namesubsection](#binary-namesubsection)4​([namemap](#binary-namemap))​​

##### Field Names[](#field-names①)

The _field name subsection_ has the id 10. It consists of an [indirect name map](#binary-indirectnamemap) assigning field names to [field indices](#syntax-fieldidx) grouped by the [type indices](#syntax-typeidx) of their respective [structure types](#syntax-structtype).

​[fieldnamesubsec](#binary-fieldnamesec)​::=​[namesubsection](#binary-namesubsection)10​([indirectnamemap](#binary-indirectnamemap))​​

##### Tag Names[](#tag-names①)

The _tag name subsection_ has the id 11. It consists of a [name map](#binary-namemap) assigning tag names to [tag indices](#syntax-tagidx).

​[tagnamesubsec](#binary-tagnamesec)​::=​[namesubsection](#binary-namesubsection)11​([namemap](#binary-namemap))​​

#### Name Annotations[](#name-annotations①)

_Name annotations_ are the textual analogue to the [name section](#binary-namesec) and provide a textual representation for it. Consequently, their id is @name.

Analogous to the name section, name annotations are allowed on [modules](#text-module), [functions](#text-func), and [locals](#text-local) (including [parameters](#text-param)). They can be placed where the text format allows binding occurrences of respective [identifiers](#text-id). If both an identifier and a name annotation are given, the annotation is expected _after_ the identifier. In that case, the annotation takes precedence over the identifier as a textual representation of the binding’s name. At most one name annotation may be given per binding.

All name annotations have the following format:

​[nameannot](#text-nameannot)​::=​‘(@name’ [string](#text-string) ‘)’​​

Note

All name annotations can be arbitrary UTF-8 [strings](#text-string). Names need not be unique.

##### Module Names[](#module-names②)

A _module name annotation_ must be placed on a [module](#text-module) definition, directly after the ‘module’ keyword, or if present, after the following module [identifier](#text-id).

​[modulenameannot](#text-modulenameannot)​::=​[nameannot](#text-nameannot)​​

##### Function Names[](#function-names②)

A _function name annotation_ must be placed on a [function](#text-func) definition or function [import](#text-import), directly after the ‘func’ keyword, or if present, after the following function [identifier](#text-id) or.

​[funcnameannot](#text-funcnameannot)​::=​[nameannot](#text-nameannot)​​

##### Parameter Names[](#parameter-names①)

A _parameter name annotation_ must be placed on a [parameter](#text-param) declaration, directly after the ‘param’ keyword, or if present, after the following parameter [identifier](#text-id). It may only be placed on a declaration that declares exactly one parameter.

​[paramnameannot](#text-paramnameannot)​::=​[nameannot](#text-nameannot)​​

##### Local Names[](#local-names②)

A _local name annotation_ must be placed on a [local](#text-param) declaration, directly after the ‘local’ keyword, or if present, after the following local [identifier](#text-id). It may only be placed on a declaration that declares exactly one local.

​[localnameannot](#text-localnameannot)​::=​[nameannot](#text-nameannot)​​

##### Type Names[](#type-names②)

A _type name annotation_ must be placed on a [type](#text-type) declaration, directly after the ‘type’ keyword, or if present, after the following type [identifier](#text-id).

​[typenameannot](#text-typenameannot)​::=​[nameannot](#text-nameannot)​​

##### Field Names[](#field-names②)

A _field name annotation_ must be placed on the field of a [structure type](#text-structtype), directly after the ‘field’ keyword, or if present, after the following field [identifier](#text-id). It may only be placed on a declaration that declares exactly one field.

​[fieldnameannot](#text-fieldnameannot)​::=​[nameannot](#text-nameannot)​​

##### Tag Names[](#tag-names②)

A _tag name annotation_ must be placed on a [tag declaration](#text-tag) or tag [import](#text-import), directly after the ‘tag’ keyword, or if present, after the following tag [identifier](#text-id).

​[tagnameannot](#text-tagnameannot)​::=​[nameannot](#text-nameannot)​​

#### Custom Annotations[](#custom-annotations①)

_Custom annotations_ are a generic textual representation for any [custom section](#binary-customsec). Their id is @custom. By generating custom annotations, tools converting between [binary format](#binary) and [text format](#text) can maintain and round-trip the content of custom sections even when they do not recognize them.

Custom annotations must be placed inside a [module](#text-module) definition. They must occur anywhere after the ‘module’ keyword, or if present, after the following module [identifier](#text-id). They must not be nested into other constructs.

​[customannot](#text-customannot)[customplace](#text-customannot)[sec](#text-customannot)​::=::=∣∣∣::=∣∣∣∣∣∣∣∣∣∣∣​‘(@custom’ [string](#text-string) [customplace](#text-customannot)? [datastring](#text-datastring) ‘)’‘(’ ‘before’ ‘first’ ‘)’‘(’ ‘before’ [sec](#text-customannot) ‘)’‘(’ ‘after’ [sec](#text-customannot) ‘)’‘(’ ‘after’ ‘last’ ‘)’‘type’‘import’‘func’‘table’‘memory’‘global’‘export’‘start’‘elem’‘code’‘data’‘datacount’​​

The first [string](#text-string) in a custom annotation denotes the name of the custom section it represents. The remaining strings collectively represent the section’s payload data, written as a [data string](#text-datastring), which can be split up into a possibly empty sequence of individual string literals (similar to [data segments](#text-data)).

An arbitrary number of custom annotations (even of the same name) may occur in a module, each defining a separate custom section when converting to [binary format](#binary). Placement of the sections in the binary can be customized via explicit _placement_ directives, that position them either directly before or directly after a known section. That section must exist and be non-empty in the binary encoding of the annotated module. The placements (before first) and (after last) denote virtual sections before the first and after the last known section, respectively. When the placement directive is omitted, it defaults to (after last).

If multiple placement directives appear for the same position, then the sections are all placed there, in order of their appearance in the text. For this purpose, the position after a section is considered different from the position before the consecutive section, and the former occurs before the latter.

Note

Future versions of WebAssembly may introduce additional sections between others or at the beginning or end of a module. Using first and last guarantees that placement will still go before or after any future section, respectively.

If a custom section with a specific section id is given as well as annotations representing the same custom section (e.g., @name [annotations](#text-nameannot) as well as a @custom annotation for a name [section](#binary-namesec)), then two sections are assumed to be created. Their relative placement will depend on the placement directive given for the @custom annotation as well as the implicit placement requirements of the custom section, which are applied to the other annotation.

Note

For example, the following module,

(module
  (@custom "A" "aaa")
  (type $t (func))
  (@custom "B" (after func) "bbb")
  (@custom "C" (before func) "ccc")
  (@custom "D" (after last) "ddd")
  (table 10 funcref)
  (func (type $t))
  (@custom "E" (after import) "eee")
  (@custom "F" (before type) "fff")
  (@custom "G" (after data) "ggg")
  (@custom "H" (after code) "hhh")
  (@custom "I" (after func) "iii")
  (@custom "J" (before func) "jjj")
  (@custom "K" (before first) "kkk")
)

will result in the following section ordering:

custom section "K"
custom section "F"
type section
custom section "E"
custom section "C"
custom section "J"
function section
custom section "B"
custom section "I"
table section
code section
custom section "H"
custom section "G"
custom section "A"
custom section "D"

### A.8 Change History[](#a8-change-history)

Since the original release 1.0 of the WebAssembly specification, a number of proposals for extensions have been integrated. The following sections provide an overview of what has changed.

All present and future versions of WebAssembly are intended to be _backwards-compatible_ with all previous versions. Concretely:

1.  All syntactically well-formed (in [binary](#binary) or [text](#text) format) and [valid](#valid) modules remain well-formed and valid with an equivalent [module type](#syntax-moduletype) (or a subtype).
    

> Note
> 
> This allows previously malformed or invalid modules to become legal, e.g., by adding new features or by relaxing typing rules.
> 
> It also allows reclassifying previously malformed modules as well-formed but invalid, or vice versa.
> 
> And it allows refining the typing of [imports](#syntax-import) and [exports](#syntax-export), such that previously unlinkable modules become linkable.
> 
> Historically, minor breaking changes to the _text format_ have been allowed that turned previously possible valid modules invalid, as long as they were unlikely to occur in practice.

2.  All non-[trapping](#trap) [executions](#exec) of a valid program retain their behaviour with an equivalent set of possible [results](#syntax-result) (or a non-empty subset).
    

> Note
> 
> This allows previously malformed or invalid programs to become executable.
> 
> It also allows program executions that previously trapped to execute successfully, although the intention is to only exercise this where the possibility of such an extension has been previously noted.
> 
> And it allows reducing the set of observable behaviours of a program execution, e.g., by reducing non-determinism.
> 
> In a program linking prior modules with modules using new features, a prior module may encounter new behaviours, e.g., new forms of control flow or side effects when calling into a latter module.

In addition, future versions of WebAssembly will not allocate the [opcode](#binary-instr) 0xFF to represent an instruction or instruction prefix.

#### Release 2.0[](#release-20)

##### Sign Extension Instructions[](#sign-extension-instructions①)

Added new numeric instructions for performing sign extension within integer representations. [\[1\]](#proposal-signext)

*   New [numeric instructions](#syntax-instr-numeric):
    
    *   inn.[extend](#syntax-instr-numeric)N\_s
        

##### Non-trapping Float-to-Int Conversions[](#non-trapping-float-to-int-conversions①)

Added new conversion instructions that avoid trapping when converting a floating-point number to an integer. [\[2\]](#proposal-cvtsat)

*   New [numeric instructions](#syntax-instr-numeric):
    
    *   inn.[trunc](#syntax-instr-numeric)\_sat\_fmm\_[sx](#syntax-sx)
        

##### Multiple Values[](#multiple-values①)

Generalized the result type of blocks and functions to allow for multiple values; in addition, introduced the ability to have block parameters. [\[3\]](#proposal-multivalue)

*   [Function types](#syntax-functype) allow more than one result
    
*   [Block types](#syntax-blocktype) can be arbitrary function types
    

##### Reference Types[](#reference-types①①)

Added [funcref](#syntax-reftype) and [externref](#syntax-reftype) as new value types and respective instructions. [\[4\]](#proposal-reftype)

*   New [reference](#syntax-reftype) [value types](#syntax-valtype):
    
    *   [funcref](#syntax-reftype)
        
    *   [externref](#syntax-reftype)
        
*   New [reference instructions](#syntax-instr-ref):
    
    *   [ref.null](#syntax-instr-ref)
        
    *   [ref.func](#syntax-instr-ref)
        
    *   [ref.is\_null](#syntax-instr-ref)
        
*   Extended [parametric instruction](#syntax-instr-parametric):
    
    *   [select](#syntax-instr-parametric) with optional type immediate
        
*   New [declarative](#syntax-elemmode) form of [element segment](#syntax-elem)
    

##### Table Instructions[](#table-instructions①①)

Added instructions to directly access and modify tables. [\[4\]](#proposal-reftype)

*   [Table types](#syntax-tabletype) allow any [reference type](#syntax-reftype) as element type
    
*   New [table instructions](#syntax-instr-table):
    
    *   [table.get](#syntax-instr-table)
        
    *   [table.set](#syntax-instr-table)
        
    *   [table.size](#syntax-instr-table)
        
    *   [table.grow](#syntax-instr-table)
        

##### Multiple Tables[](#multiple-tables①)

Added the ability to use multiple tables per module. [\[4\]](#proposal-reftype)

*   [Modules](#syntax-module) may
    
    *   [define](#syntax-table) multiple tables
        
    *   [import](#syntax-import) multiple tables
        
    *   [export](#syntax-export) multiple tables
        
*   [Table instructions](#syntax-instr-table) take a [table index](#syntax-tableidx) immediate:
    
    *   [table.get](#syntax-instr-table)
        
    *   [table.set](#syntax-instr-table)
        
    *   [table.size](#syntax-instr-table)
        
    *   [table.grow](#syntax-instr-table)
        
    *   [call\_indirect](#syntax-instr-control)
        
*   [Element segments](#syntax-elem) take a [table index](#syntax-tableidx)
    

##### Bulk Memory and Table Instructions[](#bulk-memory-and-table-instructions①)

Added instructions that modify ranges of memory or table entries. [\[4\]](#proposal-reftype) [\[5\]](#proposal-bulk)

*   New [memory instructions](#syntax-instr-memory):
    
    *   [memory.fill](#syntax-instr-memory)
        
    *   [memory.init](#syntax-instr-memory)
        
    *   [memory.copy](#syntax-instr-memory)
        
    *   [data.drop](#syntax-instr-memory)
        
*   New [table instructions](#syntax-instr-table):
    
    *   [table.fill](#syntax-instr-table)
        
    *   [table.init](#syntax-instr-table)
        
    *   [table.copy](#syntax-instr-table)
        
    *   [elem.drop](#syntax-instr-table)
        
*   New [passive](#syntax-datamode) form of [data segment](#syntax-data)
    
*   New [passive](#syntax-elemmode) form of [element segment](#syntax-elem)
    
*   New [data count section](#binary-datacntsec) in binary format
    
*   Active data and element segments boundaries are no longer checked at compile time but may trap instead
    

##### Vector Instructions[](#vector-instructions①①)

Added vector type and instructions that manipulate multiple numeric values in parallel (also known as _SIMD_, single instruction multiple data) [\[6\]](#proposal-vectype)

*   New [value type](#syntax-valtype):
    
    *   [v128](#syntax-vectype)
        
*   New [memory instructions](#syntax-instr-memory):
    
    *   v128.[load](#syntax-instr-memory)
        
    *   v128.[load](#syntax-instr-memory)NxM\_[sx](#syntax-sx)
        
    *   v128.[load](#syntax-instr-memory)N\_zero
        
    *   v128.[load](#syntax-instr-memory)N\_splat
        
    *   v128.[load](#syntax-instr-memory)N\_lane
        
    *   v128.[store](#syntax-instr-memory)
        
    *   v128.[store](#syntax-instr-memory)N\_lane
        
*   New constant [vector instruction](#syntax-instr-vec):
    
    *   v128.[const](#syntax-instr-vec)
        
*   New unary [vector instructions](#syntax-instr-vec):
    
    *   v128.not
        
    *   iNxM.abs
        
    *   iNxM.neg
        
    *   i8x16.popcnt
        
    *   fNxM.abs
        
    *   fNxM.neg
        
    *   fNxM.sqrt
        
    *   fNxM.ceil
        
    *   fNxM.floor
        
    *   fNxM.trunc
        
    *   fNxM.nearest
        
*   New binary [vector instructions](#syntax-instr-vec):
    
    *   v128.and
        
    *   v128.andnot
        
    *   v128.or
        
    *   v128.xor
        
    *   iNxM.add
        
    *   iNxM.sub
        
    *   iNxM.mul
        
    *   iNxM.add\_sat\_[sx](#syntax-sx)
        
    *   iNxM.sub\_sat\_[sx](#syntax-sx)
        
    *   iNxM.min\_[sx](#syntax-sx)
        
    *   iNxM.max\_[sx](#syntax-sx)
        
    *   iNxM.shl
        
    *   iNxM.shr\_[sx](#syntax-sx)
        
    *   fNxM.add
        
    *   fNxM.sub
        
    *   fNxM.mul
        
    *   fNxM.div
        
    *   i16x8.extadd\_pairwise\_i8x16\_[sx](#syntax-sx)
        
    *   i32x4.extadd\_pairwise\_i16x8\_[sx](#syntax-sx)
        
    *   iNxM.extmul\_[half](#syntax-half)\_iN′xM′\_[sx](#syntax-sx)
        
    *   i16x8.q15mulr\_sat\_s
        
    *   i32x4.dot\_i16x8\_s
        
    *   i8x16.avgr\_u
        
    *   i16x8.avgr\_u
        
    *   fNxM.min
        
    *   fNxM.max
        
    *   fNxM.pmin
        
    *   fNxM.pmax
        
*   New ternary [vector instruction](#syntax-instr-vec):
    
    *   v128.bitselect
        
*   New test [vector instructions](#syntax-instr-vec):
    
    *   v128.any\_true
        
    *   iNxM.all\_true
        
*   New relational [vector instructions](#syntax-instr-vec):
    
    *   iNxM.eq
        
    *   iNxM.ne
        
    *   iNxM.lt\_[sx](#syntax-sx)
        
    *   iNxM.gt\_[sx](#syntax-sx)
        
    *   iNxM.le\_[sx](#syntax-sx)
        
    *   iNxM.ge\_[sx](#syntax-sx)
        
    *   fNxM.eq
        
    *   fNxM.ne
        
    *   fNxM.lt
        
    *   fNxM.gt
        
    *   fNxM.le
        
    *   fNxM.ge
        
*   New conversion [vector instructions](#syntax-instr-vec):
    
    *   i32x4.trunc\_sat\_f32x4\_[sx](#syntax-sx)
        
    *   i32x4.trunc\_sat\_f64x2\_[sx](#syntax-sx)\_zero
        
    *   f32x4.convert\_i32x4\_[sx](#syntax-sx)
        
    *   f32x4.demote\_f64x2\_zero
        
    *   f64x2.convert\_low\_i32x4\_[sx](#syntax-sx)
        
    *   f64x2.promote\_low\_f32x4
        
*   New lane access [vector instructions](#syntax-instr-vec):
    
    *   iNxM.extract\_lane\_[sx](#syntax-sx)?
        
    *   iNxM.replace\_lane
        
    *   fNxM.extract\_lane
        
    *   fNxM.replace\_lane
        
*   New lane splitting/combining [vector instructions](#syntax-instr-vec):
    
    *   iNxM.extend\_[half](#syntax-half)\_iN′xM′\_[sx](#syntax-sx)
        
    *   i8x16.narrow\_i16x8\_[sx](#syntax-sx)
        
    *   i16x8.narrow\_i32x4\_[sx](#syntax-sx)
        
*   New byte reordering [vector instructions](#syntax-instr-vec):
    
    *   i8x16.shuffle
        
    *   i8x16.swizzle
        
*   New injection/projection [vector instructions](#syntax-instr-vec):
    
    *   iNxM.splat
        
    *   fNxM.splat
        
    *   iNxM.bitmask
        

\[[1](#id1)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/sign-extension-ops/](https://github.com/WebAssembly/spec/tree/main/proposals/sign-extension-ops/)

\[[2](#id2)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/nontrapping-float-to-int-conversion/](https://github.com/WebAssembly/spec/tree/main/proposals/nontrapping-float-to-int-conversion/)

\[[3](#id3)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/multi-value/](https://github.com/WebAssembly/spec/tree/main/proposals/multi-value/)

\[4\] ([1](#id4),[2](#id5),[3](#id6),[4](#id7))

[https://github.com/WebAssembly/spec/tree/main/proposals/reference-types/](https://github.com/WebAssembly/spec/tree/main/proposals/reference-types/)

\[[5](#id8)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/bulk-memory-operations/](https://github.com/WebAssembly/spec/tree/main/proposals/bulk-memory-operations/)

\[[6](#id9)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/simd/](https://github.com/WebAssembly/spec/tree/main/proposals/simd/)

#### Release 3.0[](#release-30)

##### Extended Constant Expressions[](#extended-constant-expressions①)

Allowed basic numeric computations in constant expressions. [\[7\]](#proposal-extconst)

*   Extended set of [constant instructions](#valid-const) with:
    
    *   inn.add
        
    *   inn.sub
        
    *   inn.mul
        
    *   [global.get](#syntax-instr-variable) for any previously declared immutable [global](#syntax-global)
        

Note

The [garbage collection](#extension-gc) extension added further constant instructions.

##### Tail Calls[](#tail-calls①)

Added instructions to perform tail calls. [\[8\]](#proposal-tailcall)

*   New [control instructions](#syntax-instr-control):
    
    *   [return\_call](#syntax-instr-control)
        
    *   [return\_call\_indirect](#syntax-instr-control)
        

##### Exception Handling[](#exception-handling③)

Added tag definitions, imports, and exports, and instructions to throw and catch exceptions. [\[9\]](#proposal-exn)

*   [Modules](#syntax-module) may
    
    *   [define](#syntax-tag) tags
        
    *   [import](#syntax-import) tags
        
    *   [export](#syntax-export) tags
        
*   New [heap types](#syntax-heaptype):
    
    *   [exn](#syntax-heaptype)
        
    *   [noexn](#syntax-heaptype)
        
*   New [reference type](#syntax-reftype) short-hands:
    
    *   [exnref](#syntax-reftype)
        
    *   [nullexnref](#syntax-reftype)
        
*   New [control instructions](#syntax-instr-control):
    
    *   [throw](#syntax-instr-control)
        
    *   [throw\_ref](#syntax-instr-control)
        
    *   [try\_table](#syntax-instr-control)
        
*   New [tag section](#binary-tagsec) in binary format.
    

##### Multiple Memories[](#multiple-memories①)

Added the ability to use multiple memories per module. [\[10\]](#proposal-multimem)

*   [Modules](#syntax-module) may
    
    *   [define](#syntax-mem) multiple memories
        
    *   [import](#syntax-import) multiple memories
        
    *   [export](#syntax-export) multiple memories
        
*   [Memory instructions](#syntax-instr-memory) take a [memory index](#syntax-memidx) immediate:
    
    *   [memory.size](#syntax-instr-memory)
        
    *   [memory.grow](#syntax-instr-memory)
        
    *   [memory.fill](#syntax-instr-memory)
        
    *   [memory.copy](#syntax-instr-memory)
        
    *   [memory.init](#syntax-instr-memory)
        
    *   t.load
        
    *   t.store
        
    *   t.loadN\_[sx](#syntax-sx)
        
    *   t.storeN
        
    *   v128.loadNxM\_[sx](#syntax-sx)
        
    *   v128.loadN\_zero
        
    *   v128.loadN\_splat
        
    *   v128.loadN\_lane
        
    *   v128.storeN\_lane
        
*   [Data segments](#syntax-elem) take a [memory index](#syntax-memidx)
    

##### 64-bit Address Space[](#64-bit-address-space)

Added the ability to declare an [i64](#syntax-numtype) [address type](#syntax-addrtype) for [tables](#syntax-tabletype) and [memories](#syntax-memtype). [\[11\]](#proposal-addr64)

*   [Address types](#syntax-addrtype) denote a subset of the integral [number types](#syntax-numtype)
    
*   [Table types](#syntax-tabletype) include an [address type](#syntax-addrtype)
    
*   [Memory types](#syntax-memtype) include an [address type](#syntax-addrtype)
    
*   Operand types of [table](#syntax-instr-table) and [memory](#syntax-instr-memory) instructions now depend on the subject’s declared address type:
    
    *   [table.get](#syntax-instr-table)
        
    *   [table.set](#syntax-instr-table)
        
    *   [table.size](#syntax-instr-table)
        
    *   [table.grow](#syntax-instr-table)
        
    *   [table.fill](#syntax-instr-table)
        
    *   [table.copy](#syntax-instr-table)
        
    *   [table.init](#syntax-instr-table)
        
    *   [memory.size](#syntax-instr-memory)
        
    *   [memory.grow](#syntax-instr-memory)
        
    *   [memory.fill](#syntax-instr-memory)
        
    *   [memory.copy](#syntax-instr-memory)
        
    *   [memory.init](#syntax-instr-memory)
        
    *   t.load
        
    *   t.store
        
    *   t.loadN\_[sx](#syntax-sx)
        
    *   t.storeN
        
    *   v128.loadNxM\_[sx](#syntax-sx)
        
    *   v128.loadN\_zero
        
    *   v128.loadN\_splat
        
    *   v128.loadN\_lane
        
    *   v128.storeN\_lane
        

##### Typeful References[](#typeful-references①)

Added more precise types for references. [\[12\]](#proposal-typedref)

*   New generalised form of [reference types](#syntax-reftype):
    
    *   ([ref](#syntax-reftype) [null](#syntax-reftype)? [heaptype](#syntax-heaptype))
        
*   New class of [heap types](#syntax-heaptype):
    
    *   [func](#syntax-func)
        
    *   [extern](#syntax-heaptype)
        
    *   [typeidx](#syntax-typeidx)
        
*   Basic [subtyping](#match) on [reference](#match-reftype) and [value](#match-valtype) types
    
*   New [reference instructions](#syntax-instr-ref):
    
    *   [ref.as\_non\_null](#syntax-instr-ref)
        
    *   [br\_on\_null](#syntax-instr-control)
        
    *   [br\_on\_non\_null](#syntax-instr-control)
        
*   New [control instruction](#syntax-instr-control):
    
    *   [call\_ref](#syntax-instr-control)
        
*   Refined typing of [reference instruction](#syntax-instr-ref):
    
    *   [ref.func](#syntax-instr-ref) with more precise result type
        
*   Refined typing of [local instructions](#valid-instr-variable) and [instruction sequences](#valid-instrs) to track the [initialization status](#syntax-init) of [locals](#syntax-local) with non-defaultable type
    
*   Refined decoding of [active](#syntax-elemmode) [element segments](#binary-elem) with implicit element type and plain function indices (opcode 0) to produce [non-null](#syntax-null) [reference type](#syntax-reftype)
    
*   Extended [table definitions](#syntax-table) with optional initializer expression
    

##### Garbage Collection[](#garbage-collection①)

Added managed reference types. [\[13\]](#proposal-gc)

*   New forms of [heap types](#syntax-heaptype):
    
    *   [any](#syntax-heaptype)
        
    *   [eq](#syntax-heaptype)
        
    *   [i31](#syntax-heaptype)
        
    *   [struct](#syntax-heaptype)
        
    *   [array](#syntax-heaptype)
        
    *   [none](#syntax-heaptype)
        
    *   [nofunc](#syntax-heaptype)
        
    *   [noextern](#syntax-heaptype)
        
*   New [reference type](#syntax-reftype) short-hands:
    
    *   [anyref](#syntax-reftype)
        
    *   [eqref](#syntax-reftype)
        
    *   [i31ref](#syntax-reftype)
        
    *   [structref](#syntax-reftype)
        
    *   [arrayref](#syntax-reftype)
        
    *   [nullref](#syntax-reftype)
        
    *   [nullfuncref](#syntax-reftype)
        
    *   [nullexternref](#syntax-reftype)
        
*   New forms of type definitions:
    
    *   [structure](#syntax-structtype)
        
    *   [array types](#syntax-arraytype)
        
    *   [sub types](#syntax-subtype)
        
    *   [recursive types](#syntax-rectype)
        
*   Enriched [subtyping](#match) based on explicitly declared [sub types](#syntax-subtype) and the new heap types
    
*   New generic [reference instructions](#syntax-instr-ref):
    
    *   [ref.eq](#syntax-instr-ref)
        
    *   [ref.test](#syntax-instr-ref)
        
    *   [ref.cast](#syntax-instr-ref)
        
    *   [br\_on\_cast](#syntax-instr-control)
        
    *   [br\_on\_cast\_fail](#syntax-instr-control)
        
*   New [reference instructions](#syntax-instr-ref) for [unboxed scalars](#syntax-i31):
    
    *   [ref.i31](#syntax-instr-i31)
        
    *   [i31.get](#syntax-instr-i31)\_[sx](#syntax-sx)
        
*   New [reference instructions](#syntax-instr-ref) for [structure types](#syntax-structtype):
    
    *   [struct.new](#syntax-instr-struct)
        
    *   [struct.new\_default](#syntax-instr-struct)
        
    *   [struct.get](#syntax-instr-struct)\_[sx](#syntax-sx)?
        
    *   [struct.set](#syntax-instr-struct)
        
*   New [reference instructions](#syntax-instr-ref) for [array types](#syntax-structtype):
    
    *   [array.new](#syntax-instr-array)
        
    *   [array.new\_default](#syntax-instr-array)
        
    *   [array.new\_fixed](#syntax-instr-array)
        
    *   [array.new\_data](#syntax-instr-array)
        
    *   [array.new\_elem](#syntax-instr-array)
        
    *   [array.get](#syntax-instr-array)\_[sx](#syntax-sx)?
        
    *   [array.set](#syntax-instr-array)
        
    *   [array.len](#syntax-instr-array)
        
    *   [array.fill](#syntax-instr-array)
        
    *   [array.copy](#syntax-instr-array)
        
    *   [array.init\_data](#syntax-instr-array)
        
    *   [array.init\_elem](#syntax-instr-array)
        
*   New [reference instructions](#syntax-instr-ref) for converting [external types](#syntax-externtype):
    
    *   [any.convert\_extern](#syntax-instr-extern)
        
    *   [extern.convert\_any](#syntax-instr-extern)
        
*   Extended set of [constant instructions](#valid-const) with:
    
    *   [ref.i31](#syntax-instr-i31)
        
    *   [struct.new](#syntax-instr-struct)
        
    *   [struct.new\_default](#syntax-instr-struct)
        
    *   [array.new](#syntax-instr-array)
        
    *   [array.new\_default](#syntax-instr-array)
        
    *   [array.new\_fixed](#syntax-instr-array)
        
    *   [any.convert\_extern](#syntax-instr-extern)
        
    *   [extern.convert\_any](#syntax-instr-extern)
        

##### Relaxed Vector Instructions[](#relaxed-vector-instructions①)

Added new _relaxed_ vector instructions, whose behaviour is non-deterministic and implementation-dependent. [\[14\]](#proposal-relaxed)

*   New binary [vector instruction](#syntax-instr-vec-relaxed):
    
    *   fNxM.relaxed\_min
        
    *   fNxM.relaxed\_max
        
    *   i16x8.relaxed\_q15mulr\_s
        
    *   i16x8.relaxed\_dot\_i8x16\_i7x16\_s
        
*   New ternary [vector instruction](#syntax-instr-vec-relaxed):
    
    *   fNxM.relaxed\_madd
        
    *   fNxM.relaxed\_nmadd
        
    *   iNxM.relaxed\_laneselect
        
    *   i32x4.relaxed\_dot\_i8x16\_i7x16\_add\_s
        
*   New conversion [vector instructions](#syntax-instr-vec-relaxed):
    
    *   i32x4.relaxed\_trunc\_f32x4\_[sx](#syntax-sx)
        
    *   i32x4.relaxed\_trunc\_f64x2\_[sx](#syntax-sx)\_zero
        
*   New byte reordering [vector instruction](#syntax-instr-vec-relaxed):
    
    *   i8x16.relaxed\_swizzle
        

##### Profiles[](#profiles②)

Introduced the concept of [profile](#profiles) for specifying language subsets.

*   A new profile defining a [deterministic](#profile-deterministic) mode of execution.
    

##### Custom Annotations[](#custom-annotations③)

Added generic syntax for custom annotations in the text format, mirroring the role of custom sections in the binary format. [\[15\]](#proposal-annot)

*   [Annotations](#text-annot) of the form ‘(@id …)’ are allowed anywhere in the [text format](#text)
    
*   [Identifiers](#text-id) can be escaped as ‘@"…"’ with arbitrary [names](#text-name)
    
*   Defined [name annotations](#text-nameannot) ‘(@name "…")’ for:
    
    *   [module names](#text-modulenameannot)
        
    *   [type names](#text-typenameannot)
        
    *   [function names](#text-funcnameannot)
        
    *   [local names](#text-localnameannot)
        
    *   [field names](#text-fieldnameannot)
        
*   Defined [custom annotation](#text-customannot) ‘(@custom "…")’ to represent arbitrary [custom sections](#binary-customsec) in the text format
    

\[[7](#id10)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/extended-const/](https://github.com/WebAssembly/spec/tree/main/proposals/extended-const/)

\[[8](#id11)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/tail-call/](https://github.com/WebAssembly/spec/tree/main/proposals/tail-call/)

\[[9](#id12)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/exception-handling/](https://github.com/WebAssembly/spec/tree/main/proposals/exception-handling/)

\[[10](#id13)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/multi-memory/](https://github.com/WebAssembly/spec/tree/main/proposals/multi-memory/)

\[[11](#id14)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/memory64/](https://github.com/WebAssembly/spec/tree/main/proposals/memory64/)

\[[12](#id15)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/function-references/](https://github.com/WebAssembly/spec/tree/main/proposals/function-references/)

\[[13](#id16)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/gc/](https://github.com/WebAssembly/spec/tree/main/proposals/gc/)

\[[14](#id17)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/relaxed-simd/](https://github.com/WebAssembly/spec/tree/main/proposals/relaxed-simd/)

\[[15](#id18)\]

[https://github.com/WebAssembly/spec/tree/main/proposals/annotations/](https://github.com/WebAssembly/spec/tree/main/proposals/annotations/)

### A.9 Index of Types[](#a9-index-of-types)

Category

Constructor

Binary Opcode

[Type index](#syntax-typeidx)

x

(positive number as [s32](#binary-int) or [u32](#binary-int))

[Number type](#syntax-numtype)

[i32](#syntax-numtype)

0x7F (-1 as [s7](#binary-int))

[Number type](#syntax-numtype)

[i64](#syntax-numtype)

0x7E (-2 as [s7](#binary-int))

[Number type](#syntax-numtype)

[f32](#syntax-numtype)

0x7D (-3 as [s7](#binary-int))

[Number type](#syntax-numtype)

[f64](#syntax-numtype)

0x7C (-4 as [s7](#binary-int))

[Vector type](#syntax-vectype)

[v128](#syntax-vectype)

0x7B (-5 as [s7](#binary-int))

(reserved)

0x7A .. 0x79

[Packed type](#syntax-packtype)

[i8](#syntax-storagetype)

0x78 (-8 as [s7](#binary-int))

[Packed type](#syntax-packtype)

[i16](#syntax-storagetype)

0x77 (-9 as [s7](#binary-int))

(reserved)

0x78 .. 0x75

[Heap type](#syntax-heaptype)

[noexn](#syntax-heaptype)

0x74 (-12 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[nofunc](#syntax-heaptype)

0x73 (-13 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[noextern](#syntax-heaptype)

0x72 (-14 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[none](#syntax-heaptype)

0x71 (-15 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[func](#syntax-func)

0x70 (-16 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[extern](#syntax-heaptype)

0x6F (-17 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[any](#syntax-heaptype)

0x6E (-18 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[eq](#syntax-heaptype)

0x6D (-19 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[i31](#syntax-heaptype)

0x6C (-20 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[struct](#syntax-heaptype)

0x6B (-21 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[array](#syntax-heaptype)

0x6A (-22 as [s7](#binary-int))

[Heap type](#syntax-heaptype)

[exn](#syntax-heaptype)

0x69 (-23 as [s7](#binary-int))

(reserved)

0x68 .. 0x65

[Reference type](#syntax-reftype)

[ref](#syntax-reftype)

0x64 (-28 as [s7](#binary-int))

[Reference type](#syntax-reftype)

[ref](#syntax-reftype) [null](#syntax-reftype)

0x63 (-29 as [s7](#binary-int))

(reserved)

0x62 .. 0x61

[Composite type](#syntax-comptype)

[func](#syntax-comptype) \[[valtype](#syntax-valtype)∗\][→](#syntax-comptype)\[[valtype](#syntax-valtype)∗\]

0x60 (-32 as [s7](#binary-int))

[Composite type](#syntax-comptype)

[struct](#syntax-comptype) [fieldtype](#syntax-fieldtype)∗

0x5F (-33 as [s7](#binary-int))

[Composite type](#syntax-comptype)

[array](#syntax-comptype) [fieldtype](#syntax-fieldtype)

0x5E (-34 as [s7](#binary-int))

(reserved)

0x5D .. 0x51

[Sub type](#syntax-subtype)

[sub](#syntax-subtype) [typeidx](#syntax-typeidx)∗ [comptype](#syntax-comptype)

0x50 (-48 as [s7](#binary-int))

[Sub type](#syntax-subtype)

[sub](#syntax-subtype) [final](#syntax-subtype) [typeidx](#syntax-typeidx)∗ [comptype](#syntax-comptype)

0x4F (-49 as [s7](#binary-int))

[Recursive type](#syntax-rectype)

[rec](#syntax-rectype) [subtype](#syntax-subtype)∗

0x4E (-50 as [s7](#binary-int))

(reserved)

0x4D .. 0x41

[Result type](#syntax-resulttype)

\[ϵ\]

0x40 (-64 as [s7](#binary-int))

[Tag type](#syntax-tagtype)

[typeuse](#syntax-typeuse)

(none)

[Global type](#syntax-globaltype)

[mut](#syntax-mut) [valtype](#syntax-valtype)

(none)

[Memory type](#syntax-memtype)

[addrtype](#syntax-addrtype) [limits](#syntax-limits)

(none)

[Table type](#syntax-tabletype)

[addrtype](#syntax-addrtype) [limits](#syntax-limits) [reftype](#syntax-reftype)

(none)

### A.10 Index of Instructions[](#a10-index-of-instructions)

Instruction

Binary Opcode

Type

Validation

Execution

[unreachable](#syntax-instr-control)

0x00

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-unreachable)

[execution](#exec-unreachable)

[nop](#syntax-instr-control)

0x01

\[\][→](#syntax-instrtype)\[\]

[validation](#valid-nop)

[execution](#exec-nop)

[block](#syntax-instr-control) bt

0x02

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-block)

[execution](#exec-block)

[loop](#syntax-instr-control) bt

0x03

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-loop)

[execution](#exec-loop)

[if](#syntax-instr-control) bt

0x04

\[t1∗​ [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-if)

[execution](#exec-if)

[else](#syntax-instr-control)

0x05

(reserved)

0x06

(reserved)

0x07

[throw](#syntax-instr-control) x

0x08

\[t1∗​ tx∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-throw)

[execution](#exec-throw)

(reserved)

0x09

[throw\_ref](#syntax-instr-control)

0x0A

\[t1∗​ [exnref](#syntax-reftype)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-throw-ref)

[execution](#exec-throw-ref)

[end](#syntax-instr-control)

0x0B

[br](#syntax-instr-control) l

0x0C

\[t1∗​ t∗\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-br)

[execution](#exec-br)

[br\_if](#syntax-instr-control) l

0x0D

\[t∗ [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t∗\]

[validation](#valid-br-if)

[execution](#exec-br-if)

[br\_table](#syntax-instr-control) l∗ l

0x0E

\[t1∗​ t∗ [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-br-table)

[execution](#exec-br-table)

[return](#syntax-instr-control)

0x0F

\[t1∗​ t∗\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-return)

[execution](#exec-return)

[call](#syntax-instr-control) x

0x10

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-call)

[execution](#exec-call)

[call\_indirect](#syntax-instr-control) x y

0x11

\[t1∗​ [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-call-indirect)

[execution](#exec-call-indirect)

[return\_call](#syntax-instr-control) x

0x12

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-return-call)

[execution](#exec-return-call)

[return\_call\_indirect](#syntax-instr-control) x y

0x13

\[t1∗​ [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-return-call-indirect)

[execution](#exec-return-call-indirect)

[call\_ref](#syntax-instr-control) x

0x14

\[t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-call-ref)

[execution](#exec-call-ref)

[return\_call\_ref](#syntax-instr-control) x

0x15

\[t1∗​ ([ref](#syntax-reftype) [null](#syntax-reftype) x)\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-return-call-ref)

[execution](#exec-return-call-ref)

(reserved)

0x16

(reserved)

0x17

(reserved)

0x18

(reserved)

0x19

[drop](#syntax-instr-parametric)

0x1A

\[t\][→](#syntax-instrtype)\[\]

[validation](#valid-drop)

[execution](#exec-drop)

[select](#syntax-instr-parametric)

0x1B

\[t t [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t\]

[validation](#valid-select)

[execution](#exec-select)

[select](#syntax-instr-parametric) t

0x1C

\[t t [i32](#syntax-numtype)\][→](#syntax-instrtype)\[t\]

[validation](#valid-select)

[execution](#exec-select)

(reserved)

0x1D

(reserved)

0x1E

[try\_table](#syntax-instr-control) bt

0x1F

\[t1∗​\][→](#syntax-instrtype)\[t2∗​\]

[validation](#valid-try-table)

[execution](#exec-try-table)

[local.get](#syntax-instr-variable) x

0x20

\[\][→](#syntax-instrtype)\[t\]

[validation](#valid-local-get)

[execution](#exec-local-get)

[local.set](#syntax-instr-variable) x

0x21

\[t\][→](#syntax-instrtype)\[\]

[validation](#valid-local-set)

[execution](#exec-local-set)

[local.tee](#syntax-instr-variable) x

0x22

\[t\][→](#syntax-instrtype)\[t\]

[validation](#valid-local-tee)

[execution](#exec-local-tee)

[global.get](#syntax-instr-variable) x

0x23

\[\][→](#syntax-instrtype)\[t\]

[validation](#valid-global-get)

[execution](#exec-global-get)

[global.set](#syntax-instr-variable) x

0x24

\[t\][→](#syntax-instrtype)\[\]

[validation](#valid-global-set)

[execution](#exec-global-set)

[table.get](#syntax-instr-table) x

0x25

\[at\][→](#syntax-instrtype)\[t\]